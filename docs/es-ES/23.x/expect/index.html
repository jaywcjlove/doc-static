<!DOCTYPE html><html lang="es-ES"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Expect · Jest</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="When you&#x27;re writing tests, you often need to check that values meet certain conditions. `expect` gives you access to a number of &quot;matchers&quot; that let you validate different things."/><meta name="docsearch:version" content="23.x"/><meta name="docsearch:language" content="es-ES"/><meta property="og:title" content="Expect · Jest"/><meta property="og:type" content="website"/><meta property="og:url" content="https://jestjs.io/"/><meta property="og:description" content="When you&#x27;re writing tests, you often need to check that values meet certain conditions. `expect` gives you access to a number of &quot;matchers&quot; that let you validate different things."/><meta property="og:image" content="https://jestjs.io/img/opengraph.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://jestjs.io/img/jest.png"/><link rel="shortcut icon" href="/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://jestjs.io/blog/atom.xml" title="Jest Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://jestjs.io/blog/feed.xml" title="Jest Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-17', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/es-ES"><img class="logo" src="/img/jest.svg" alt="Jest"/><h2 class="headerTitleWithLogo">Jest</h2></a><a href="/es-ES/versions"><h3>23.x</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/es-ES/23.x/getting-started" target="_self">Documentación</a></li><li class="siteNavGroupActive"><a href="/docs/es-ES/23.x/api" target="_self">API</a></li><li class=""><a href="/es-ES/help" target="_self">Ayuda</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Español</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/23.x/expect">English</a></li><li><a href="/docs/ja/23.x/expect">日本語</a></li><li><a href="/docs/pt-BR/23.x/expect">Português (Brasil)</a></li><li><a href="/docs/ro/23.x/expect">Română</a></li><li><a href="/docs/ru/23.x/expect">Русский</a></li><li><a href="/docs/uk/23.x/expect">Українська</a></li><li><a href="/docs/zh-Hans/23.x/expect">简体中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/jest" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>API Reference</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/getting-started">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/using-matchers">Using Matchers</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/asynchronous">Testing Asynchronous Code</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/setup-teardown">Setup and Teardown</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/mock-functions">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/jest-platform">Jest Platform</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/jest-community">Jest Community</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/more-resources">More Resources</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/snapshot-testing">Snapshot Testing</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/tutorial-async">An Async Example</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/timer-mocks">Timer Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/manual-mocks">Manual Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/es6-class-mocks">ES6 Class Mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/bypassing-module-mocks">Bypassing module mocks</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/webpack">Using with webpack</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/puppeteer">Using with puppeteer</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/mongodb">Using with MongoDB</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/tutorial-jquery">DOM Manipulation</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/watch-plugins">Watch Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/migration-guide">Migrating to Jest</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/troubleshooting">Troubleshooting</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Framework Guides</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/tutorial-react">Testing React Apps</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/tutorial-react-native">Testing React Native Apps</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/testing-frameworks">Testing Web Frameworks</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">API Reference</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/api">Globals</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/es-ES/23.x/expect">Expect</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/mock-function-api">Mock Functions</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/jest-object">The Jest Object</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/configuration">Configuring Jest</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/23.x/cli">Jest CLI Options</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/facebook/jest/edit/master/docs/ExpectAPI.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Expect</h1></header><article><div><span><p>When you're writing tests, you often need to check that values meet certain conditions. <code>expect</code> gives you access to a number of &quot;matchers&quot; that let you validate different things.</p>
<p>For additional Jest matchers maintained by the Jest Community check out <a href="https://github.com/jest-community/jest-extended"><code>jest-extended</code></a>.</p>
<h2><a class="anchor" aria-hidden="true" id="métodos"></a><a href="#métodos" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Métodos</h2>
<ul>
<li><a href="#expectvalue"><code>expect(value)</code></a></li>
<li><a href="#expectextendmatchers"><code>expect.extend(matchers)</code></a></li>
<li><a href="#expectanything"><code>expect.anything()</code></a></li>
<li><a href="#expectanyconstructor"><code>expect.any(constructor)</code></a></li>
<li><a href="#expectarraycontainingarray"><code>expect.arrayContaining(array)</code></a></li>
<li><a href="#expectassertionsnumber"><code>expect.assertions(number)</code></a></li>
<li><a href="#expecthasassertions"><code>expect.hasAssertions()</code></a></li>
<li><a href="#expectnotarraycontainingarray"><code>expect.not.arrayContaining(array)</code></a></li>
<li><a href="#expectnotobjectcontainingobject"><code>expect.not.objectContaining(object)</code></a></li>
<li><a href="#expectnotstringcontainingstring"><code>expect.not.stringContaining(string)</code></a></li>
<li><a href="#expectnotstringmatchingstring--regexp"><code>expect.not.stringMatching(string | regexp)</code></a></li>
<li><a href="#expectobjectcontainingobject"><code>expect.objectContaining(object)</code></a></li>
<li><a href="#expectstringcontainingstring"><code>expect.stringContaining(string)</code></a></li>
<li><a href="#expectstringmatchingstring--regexp"><code>expect.stringMatching(string | regexp)</code></a></li>
<li><a href="#expectaddsnapshotserializerserializer"><code>expect.addSnapshotSerializer(serializer)</code></a></li>
<li><a href="#not"><code>.not</code></a></li>
<li><a href="#resolves"><code>.resolves</code></a></li>
<li><a href="#rejects"><code>.rejects</code></a></li>
<li><a href="#tobevalue"><code>.toBe(value)</code></a></li>
<li><a href="#tohavebeencalled"><code>.toHaveBeenCalled()</code></a></li>
<li><a href="#tohavebeencalledtimesnumber"><code>.toHaveBeenCalledTimes(number)</code></a></li>
<li><a href="#tohavebeencalledwitharg1-arg2-"><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code></a></li>
<li><a href="#tohavebeenlastcalledwitharg1-arg2-"><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code></a></li>
<li><a href="#tohavebeennthcalledwithnthcall-arg1-arg2-"><code>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)</code></a></li>
<li><a href="#tohavereturned"><code>.toHaveReturned()</code></a></li>
<li><a href="#tohavereturnedtimesnumber"><code>.toHaveReturnedTimes(number)</code></a></li>
<li><a href="#tohavereturnedwithvalue"><code>.toHaveReturnedWith(value)</code></a></li>
<li><a href="#tohavelastreturnedwithvalue"><code>.toHaveLastReturnedWith(value)</code></a></li>
<li><a href="#tohaventhreturnedwithnthcall-value"><code>.toHaveNthReturnedWith(nthCall, value)</code></a></li>
<li><a href="#tohavelengthnumber"><code>.toHaveLength(number)</code></a></li>
<li><a href="#tohavepropertypathllave-valor"><code>.toHaveProperty(pathLlave, valor)</code></a></li>
<li><a href="#tobeclosetonúmero-númerodigitos"><code>.toBeCloseTo(número, númeroDigitos)</code></a></li>
<li><a href="#tobedefined"><code>.toBeDefined()</code></a></li>
<li><a href="#tobefalsy"><code>.toBeFalsy()</code></a></li>
<li><a href="#tobegreaterthannúmero"><code>.toBeGreaterThan(número)</code></a></li>
<li><a href="#tobegreaterthanorequalnúmero"><code>.toBeGreaterThanOrEqual(número)</code></a></li>
<li><a href="#tobelessthannúmero"><code>.toBeLessThan(número)</code></a></li>
<li><a href="#tobelessthanorequalnúmero"><code>.toBeLessThanOrEqual(número)</code></a></li>
<li><a href="#tobeinstanceofclass"><code>.toBeInstanceOf(Class)</code></a></li>
<li><a href="#tobenull"><code>.toBeNull()</code></a></li>
<li><a href="#tobetruthy"><code>.toBeTruthy()</code></a></li>
<li><a href="#tobeundefined"><code>.toBeUndefined()</code></a></li>
<li><a href="#tobenan"><code>.toBeNaN()</code></a></li>
<li><a href="#tocontainitem"><code>.toContain(item)</code></a></li>
<li><a href="#tocontainequalitem"><code>.toContainEqual(item)</code></a></li>
<li><a href="#toequalvalue"><code>.toEqual(value)</code></a></li>
<li><a href="#tomatchregexporstring"><code>.toMatch(regexpOrString)</code></a></li>
<li><a href="#tomatchobjectobject"><code>.toMatchObject(object)</code></a></li>
<li><a href="#tomatchsnapshotpropertymatchers-snapshotname"><code>.toMatchSnapshot(propertyMatchers, snapshotName)</code></a></li>
<li><a href="#tomatchinlinesnapshotpropertymatchers-inlinesnapshot"><code>.toMatchInlineSnapshot(propertyMatchers, inlineSnapshot)</code></a></li>
<li><a href="#tostrictequalvalue"><code>.toStrictEqual(value)</code></a></li>
<li><a href="#tothrowerror"><code>.toThrow(error)</code></a></li>
<li><a href="#tothrowerrormatchingsnapshot"><code>.toThrowErrorMatchingSnapshot()</code></a></li>
<li><a href="#tothrowerrormatchinginlinesnapshot"><code>.toThrowErrorMatchingInlineSnapshot()</code></a></li>
</ul>
<hr>
<h2><a class="anchor" aria-hidden="true" id="referencia"></a><a href="#referencia" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Referencia</h2>
<h3><a class="anchor" aria-hidden="true" id="expectvalue"></a><a href="#expectvalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect(value)</code></h3>
<p>La función <code>expect</code> se utiliza cada vez que desea testear un valor. Rara vez se utiliza <code>expect</code> por sí mismo. En su lugar, utilizarás <code>expect</code> junto a una función de &quot;comparación&quot; para afirmar algo sobre un valor.</p>
<p>Es más fácil entenderlo con este ejemplo. Digamos que tenemos un método <code>mejorSabor()</code> que se supone que devuelve el texto <code>'grapefruit'</code>. Así es cómo sería el test:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'el mejor sabor es de melocotón'</span>, () =&gt; {
  expect(mejorSabor()).toBe(<span class="hljs-string">'melocotón'</span>);
});
</code></pre>
<p>In this case, <code>toBe</code> is the matcher function. There are a lot of different matcher functions, documented below, to help you test different things.</p>
<p>El argumento <code>expect</code> debe ser el valor que produce tu código, y cualquier argumento de comparación debe ser el valor correcto. Si los mezclas, tus test problablemente seguiran funcionando, pero los mensajes de error seran confusos.</p>
<h3><a class="anchor" aria-hidden="true" id="expectextendmatchers"></a><a href="#expectextendmatchers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.extend(matchers)</code></h3>
<p>Puedes utilizar <code>expect.extend</code> para añadir tus propios comparadores a Jest. For example, let's say that you're testing a number utility library and you're frequently asserting that numbers appear within particular ranges of other numbers. You could abstract that into a <code>toBeWithinRange</code> matcher:</p>
<pre><code class="hljs css language-js">expect.extend({
  toBeWithinRange(received, floor, ceiling) {
    <span class="hljs-keyword">const</span> pass = received &gt;= floor &amp;&amp; received &lt;= ceiling;
    <span class="hljs-keyword">if</span> (pass) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> not to be within range <span class="hljs-subst">${floor}</span> - <span class="hljs-subst">${ceiling}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> to be within range <span class="hljs-subst">${floor}</span> - <span class="hljs-subst">${ceiling}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
      };
    }
  },
});

test(<span class="hljs-string">'numeric ranges'</span>, () =&gt; {
  expect(<span class="hljs-number">100</span>).toBeWithinRange(<span class="hljs-number">90</span>, <span class="hljs-number">110</span>);
  expect(<span class="hljs-number">101</span>).not.toBeWithinRange(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>);
  expect({<span class="hljs-attr">apples</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">bananas</span>: <span class="hljs-number">3</span>}).toEqual({
    <span class="hljs-attr">apples</span>: expect.toBeWithinRange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>),
    <span class="hljs-attr">bananas</span>: expect.not.toBeWithinRange(<span class="hljs-number">11</span>, <span class="hljs-number">20</span>),
  });
});
</code></pre>
<p><em>Note</em>: In TypeScript, when using <code>@types/jest</code> for example, you can declare the new <code>toBeWithinRange</code> matcher like this:</p>
<pre><code class="hljs css language-ts"><span class="hljs-keyword">declare</span> global {
  <span class="hljs-keyword">namespace</span> jest {
    <span class="hljs-keyword">interface</span> Matchers&lt;R&gt; {
      toBeWithinRange(a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span>): R;
    }
  }
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="async-matchers"></a><a href="#async-matchers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Async Matchers</h4>
<p><code>expect.extend</code> also supports async matchers. Async matchers return a Promise so you will need to await the returned value. Let's use an example matcher to illustrate the usage of them. We are going to implement a matcher called <code>toBeDivisibleByExternalValue</code>, where the divisible number is going to be pulled from an external source.</p>
<pre><code class="hljs css language-js">expect.extend({
  <span class="hljs-keyword">async</span> toBeDivisibleByExternalValue(received) {
    <span class="hljs-keyword">const</span> externalValue = <span class="hljs-keyword">await</span> getExternalValueFromRemoteSource();
    <span class="hljs-keyword">const</span> pass = received % externalValue == <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (pass) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> not to be divisible by <span class="hljs-subst">${externalValue}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-string">`expected <span class="hljs-subst">${received}</span> to be divisible by <span class="hljs-subst">${externalValue}</span>`</span>,
        <span class="hljs-attr">pass</span>: <span class="hljs-literal">false</span>,
      };
    }
  },
});

test(<span class="hljs-string">'is divisible by external value'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-number">100</span>).toBeDivisibleByExternalValue();
  <span class="hljs-keyword">await</span> expect(<span class="hljs-number">101</span>).not.toBeDivisibleByExternalValue();
});
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="custom-matchers-api"></a><a href="#custom-matchers-api" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom Matchers API</h4>
<p>Matchers should return an object (or a Promise of an object) with two keys. <code>pass</code> indica si hubo un acierto o no, y <code>message</code> proporciona una función sin argumentos que devuelve un mensaje de error en caso de fallo. Así, cuando <code>pass</code> es falso, <code>message</code> debe devolver el mensaje de error para cuando <code>expect(x).tuComparador()</code>. Y cuando <code>pass</code> es 'true', <code>message</code> debe devolver el mensaje de error para cuando <code>expect(x).not.tuComparador()</code>.</p>
<p>Matchers are called with the argument passed to <code>expect(x)</code> followed by the arguments passed to <code>.yourMatcher(y, z)</code>:</p>
<pre><code class="hljs css language-js">expect.extend({
  yourMatcher(x, y, z) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">pass</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">message</span>: <span class="hljs-string">''</span>,
    };
  },
});
</code></pre>
<p>These helper functions and properties can be found on <code>this</code> inside a custom matcher:</p>
<h4><a class="anchor" aria-hidden="true" id="thisisnot"></a><a href="#thisisnot" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.isNot</code></h4>
<p>Un boleano te permite conocer si un comparador fue llamado con el modificador de negación <code>.not</code>, permitiendo negar la afirmación.</p>
<h4><a class="anchor" aria-hidden="true" id="thisequalsa-b"></a><a href="#thisequalsa-b" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.equals(a, b)</code></h4>
<p>Esta es una función de igualdad profunda que regresará <code>true</code> si dos objetos tienen los mismos valores (recursivamente).</p>
<h4><a class="anchor" aria-hidden="true" id="thisexpand"></a><a href="#thisexpand" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.expand</code></h4>
<p>A boolean to let you know this matcher was called with an <code>expand</code> option. When Jest is called with the <code>--expand</code> flag, <code>this.expand</code> can be used to determine if Jest is expected to show full diffs and errors.</p>
<h4><a class="anchor" aria-hidden="true" id="thisutils"></a><a href="#thisutils" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>this.utils</code></h4>
<p>Hay un número de herramientas de utilidad reveladas en <code>this.utils</code> que consisten en las funciones de <a href="https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils"><code>jest-matcher-utils</code></a>.</p>
<p>Las más útiles son <code>matcherHint</code>, <code>printExpected</code> y <code>printReceived</code> para dar formato mas agradable a los mensajes de error. Por ejemplo, echa un vistazo en la implementación para el comparador <code>toBe</code>:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> diff = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-diff'</span>);
expect.extend({
  toBe(received, expected) {
    <span class="hljs-keyword">const</span> pass = <span class="hljs-built_in">Object</span>.is(received, expected);

    <span class="hljs-keyword">const</span> message = pass
      ? <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
          <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.not.toBe'</span>) +
          <span class="hljs-string">'\n\n'</span> +
          <span class="hljs-string">`Expected value to not be (using Object.is):\n`</span> +
          <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
          <span class="hljs-string">`Received:\n`</span> +
          <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span>
      : <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
          <span class="hljs-keyword">const</span> diffString = diff(expected, received, {
            <span class="hljs-attr">expand</span>: <span class="hljs-keyword">this</span>.expand,
          });
          <span class="hljs-keyword">return</span> (
            <span class="hljs-keyword">this</span>.utils.matcherHint(<span class="hljs-string">'.toBe'</span>) +
            <span class="hljs-string">'\n\n'</span> +
            <span class="hljs-string">`Expected value to be (using Object.is):\n`</span> +
            <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printExpected(expected)}</span>\n`</span> +
            <span class="hljs-string">`Received:\n`</span> +
            <span class="hljs-string">`  <span class="hljs-subst">${<span class="hljs-keyword">this</span>.utils.printReceived(received)}</span>`</span> +
            (diffString ? <span class="hljs-string">`\n\nDifference:\n\n<span class="hljs-subst">${diffString}</span>`</span> : <span class="hljs-string">''</span>)
          );
        };

    <span class="hljs-keyword">return</span> {<span class="hljs-attr">actual</span>: received, message, pass};
  },
});
</code></pre>
<p>Esto mostrará algo así:</p>
<pre><code class="hljs css language-bash">  expect(received).toBe(expected)

    Expected value to be (using Object.is):
      <span class="hljs-string">"banana"</span>
    Received:
      <span class="hljs-string">"apple"</span>
</code></pre>
<p>Cuando una afirmación falla, el mensaje de error debería dar las señales necesarias para que el usuario pueda resolver sus problemas rápidamente. Deberías crear mensajes de errores precisos para que los usuarios de tus afirmaciones personalizadas se sientan cómodos usándolas.</p>
<h4><a class="anchor" aria-hidden="true" id="custom-snapshot-matchers"></a><a href="#custom-snapshot-matchers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Custom snapshot matchers</h4>
<p>To use snapshot testing inside of your custom matcher you can import <code>jest-snapshot</code> and use it from within your matcher.</p>
<p>Here's a snapshot matcher that trims a string to store for a given length, <code>.toMatchTrimmedSnapshot(length)</code>:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> {toMatchSnapshot} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jest-snapshot'</span>);

expect.extend({
  toMatchTrimmedSnapshot(received, length) {
    <span class="hljs-keyword">return</span> toMatchSnapshot.call(
      <span class="hljs-keyword">this</span>,
      received.substring(<span class="hljs-number">0</span>, length),
      <span class="hljs-string">'toMatchTrimmedSnapshot'</span>,
    );
  },
});

it(<span class="hljs-string">'stores only 10 characters'</span>, () =&gt; {
  expect(<span class="hljs-string">'extra long string oh my gerd'</span>).toMatchTrimmedSnapshot(<span class="hljs-number">10</span>);
});

<span class="hljs-comment">/*
Stored snapshot will look like:

exports[`stores only 10 characters: toMatchTrimmedSnapshot 1`] = `"extra long"`;
*/</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectanything"></a><a href="#expectanything" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.anything()</code></h3>
<p><code>expect.anything()</code> aprobará cualquier cosa excepto <code>null</code> o <code>undefined</code>. Pedes usarlo dentro de <code>toEqual</code> o <code>toBeCalledWith</code> en vez de usar un valor literal. Por ejemplo, si quieres asegurarte de que un mock ha sido llamado con un argumento que no sea null:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'map calls its argument with a non-null argument'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  [<span class="hljs-number">1</span>].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> mock(x));
  expect(mock).toBeCalledWith(expect.anything());
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectanyconstructor"></a><a href="#expectanyconstructor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.any(constructor)</code></h3>
<p><code>expect.any(constructor)</code> aprueba cualquier cosa que sea creada con el constructor recibido. Pedes usarlo dentro de <code>toEqual</code> o <code>toBeCalledWith</code> en vez de usar un valor literal. Por ejemplo, si quieres asegurarte de que un mock ha sido llamado con un número:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randocall</span>(<span class="hljs-params">fn</span>) </span>{
  <span class="hljs-keyword">return</span> fn(<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">6</span> + <span class="hljs-number">1</span>));
}

test(<span class="hljs-string">'randocall calls its callback with a number'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> mock = jest.fn();
  randocall(mock);
  expect(mock).toBeCalledWith(expect.any(<span class="hljs-built_in">Number</span>));
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectarraycontainingarray"></a><a href="#expectarraycontainingarray" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.arrayContaining(array)</code></h3>
<p><code>expect.arrayContaining(array)</code> aprueba que la matriz recibida contiene todos los elementos de la matriz esperada. Eso significa que la matriz esperada es un <strong>subconjunto</strong> de la matriz recibida. Por tanto, aprueba una matriz recibida que contenga elementos que <strong>no</strong> estén en la matriz esperada.</p>
<p>Puedes utilizarla en vez de usar un valor literal:</p>
<ul>
<li>en <code>toEqual</code> o <code>toBeCalledWith</code></li>
<li>para aprobar una propiedad en <code>objectContaining</code> o <code>toMatchObject</code></li>
</ul>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(expect.arrayContaining(expected));
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).not.toEqual(expect.arrayContaining(expected));
  });
});
</code></pre>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'Beware of a misunderstanding! A sequence of dice rolls'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
  it(<span class="hljs-string">'matches even with an unexpected number 7'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it(<span class="hljs-string">'does not match without an expected number 2'</span>, () =&gt; {
    expect([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectassertionsnumber"></a><a href="#expectassertionsnumber" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.assertions(number)</code></h3>
<p><code>expect.assertions(number)</code> verifica que un cierto número de afirmaciones han sido realizadas durante un test. Esto es útil a la hora de probar código asíncrono para asegurarnos de que las afirmaciones de un callback fueron llamadas.</p>
<p>Por ejemplo, supongamos que tenemos una función <code>doAsync</code> que recibe dos devoluciones de llamada <code>callback1</code> y <code>callback2</code>, asincrónicamente se llamará a ambas en un orden desconocido. Podemos comprobarlo con:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'doAsync llama a ambos callbacks'</span>, () =&gt; {
  expect.assertions(<span class="hljs-number">2</span>);
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">data</span>) </span>{
    expect(data).toBeTruthy();
  }

  doAsync(callback1, callback2);
});
</code></pre>
<p>La llamada de <code>expect.assertions(2)</code> asegura que ambas devoluciones de llamada son efectivamente ejecutadas.</p>
<h3><a class="anchor" aria-hidden="true" id="expecthasassertions"></a><a href="#expecthasassertions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.hasAssertions()</code></h3>
<p><code>expect.hasAssertions()</code> verifica que al menos una verificación es llamada durante un test. Esto es útil a la hora de probar código asíncrono para asegurarnos de que las afirmaciones de un callback fueron llamadas.</p>
<p>Por ejemplo, digamos que tenemos unas pocas funciones y todas tratan con un estado. <code>prepareState</code> llama a una devolución de llamada con un objeto de estado, <code>validateState</code> se ejecuta en este objeto de estado, y <code>waitOnState</code> devuelve una promesa que espera hasta que las devoluciones de llamada de <code>prepareState</code> completen. Podemos comprobarlo con:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'prepareState prepara un estado valido'</span>, () =&gt; {
  expect.hasAssertions();
  prepareState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> {
    expect(validateState(estado)).toBeTruthy();
  });
  <span class="hljs-keyword">return</span> waitOnState();
});
</code></pre>
<p>La llamada de <code>expect.hasAssertions()</code> asegura que ambas devoluciones de llamada de <code>prepareState</code> son efectivamente ejecutadas.</p>
<h3><a class="anchor" aria-hidden="true" id="expectnotarraycontainingarray"></a><a href="#expectnotarraycontainingarray" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.not.arrayContaining(array)</code></h3>
<p><code>expect.not.arrayContaining(array)</code> matches a received array which does not contain all of the elements in the expected array. That is, the expected array <strong>is not a subset</strong> of the received array.</p>
<p>It is the inverse of <code>expect.arrayContaining</code>.</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'not.arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [<span class="hljs-string">'Samantha'</span>];

  it(<span class="hljs-string">'matches if the actual array does not contain the expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Eve'</span>]).toEqual(
      expect.not.arrayContaining(expected),
    );
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectnotobjectcontainingobject"></a><a href="#expectnotobjectcontainingobject" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.not.objectContaining(object)</code></h3>
<p><code>expect.not.objectContaining(object)</code> matches any received object that does not recursively match the expected properties. That is, the expected object <strong>is not a subset</strong> of the received object. De tal manera que, hace match con un objeto que contiene propiedades que <strong>no</strong> se encuentran en el objeto esperado.</p>
<p>It is the inverse of <code>expect.objectContaining</code>.</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'not.objectContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = {<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>};

  it(<span class="hljs-string">'matches if the actual object does not contain expected key: value pairs'</span>, () =&gt; {
    expect({<span class="hljs-attr">bar</span>: <span class="hljs-string">'baz'</span>}).toEqual(expect.not.objectContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectnotstringcontainingstring"></a><a href="#expectnotstringcontainingstring" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.not.stringContaining(string)</code></h3>
<p><code>expect.not.stringContaining(string)</code> matches the received string that does not contain the exact expected string.</p>
<p>It is the inverse of <code>expect.stringContaining</code>.</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'not.stringContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = <span class="hljs-string">'Hello world!'</span>;

  it(<span class="hljs-string">'matches if the actual string does not contain the expected substring'</span>, () =&gt; {
    expect(<span class="hljs-string">'How are you?'</span>).toEqual(expect.not.stringContaining(expected));
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectnotstringmatchingstring--regexp"></a><a href="#expectnotstringmatchingstring--regexp" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.not.stringMatching(string | regexp)</code></h3>
<p><code>expect.not.stringMatching(string | regexp)</code> matches the received string that does not match the expected regexp.</p>
<p>It is the inverse of <code>expect.stringMatching</code>.</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'not.stringMatching'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = <span class="hljs-regexp">/Hello world!/</span>;

  it(<span class="hljs-string">'matches if the actual string does not match the expected regex'</span>, () =&gt; {
    expect(<span class="hljs-string">'How are you?'</span>).toEqual(expect.not.stringMatching(expected));
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectobjectcontainingobject"></a><a href="#expectobjectcontainingobject" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.objectContaining(object)</code></h3>
<p><code>expect.objectContaining(object)</code> compara recursivamente con cualquier objeto recibido que cumpla con las propiedades esperadas. Es decir, el objeto esperado es un <strong>subconjunto</strong> del objeto recibido. Therefore, it matches a received object which contains properties that <strong>are present</strong> in the expected object.</p>
<p>En lugar de verificar los valores de propiedades en el objeto esperado, se pueden ocupar matchers, como <code>expect.anything()</code>, entre otros.</p>
<p>Por ejemplo, si se espera que la función <code>onPress</code> sea llamada con el objeto <code>Event</code>, y solo se necesita verificar que el evento tiene las propiedades <code>event.x</code> y <code>event.y</code>. Puedes hacer esto con:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'onPress gets called with the right thing'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> onPress = jest.fn();
  simulatePresses(onPress);
  expect(onPress).toBeCalledWith(
    expect.objectContaining({
      <span class="hljs-attr">x</span>: expect.any(<span class="hljs-built_in">Number</span>),
      <span class="hljs-attr">y</span>: expect.any(<span class="hljs-built_in">Number</span>),
    }),
  );
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectstringcontainingstring"></a><a href="#expectstringcontainingstring" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.stringContaining(string)</code></h3>
<p><code>expect.stringContaining(string)</code> matches the received string that contains the exact expected string.</p>
<h3><a class="anchor" aria-hidden="true" id="expectstringmatchingstring--regexp"></a><a href="#expectstringmatchingstring--regexp" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.stringMatching(string | regexp)</code></h3>
<p><code>expect.stringMatching(string | regexp)</code> matches the received string that matches the expected regexp.</p>
<p>Puedes utilizarla en vez de usar un valor literal:</p>
<ul>
<li>en <code>toEqual</code> o <code>toBeCalledWith</code></li>
<li>para que coincida con un elemento en <code>arrayContaining</code></li>
<li>para aprobar una propiedad en <code>objectContaining</code> o <code>toMatchObject</code></li>
</ul>
<p>Este ejemplo también muestra cómo se pueden anidar múltiples marcadores de comparación asimétricas, con <code>expect.stringMatching</code> dentro de <code>expect.arrayContaining</code>.</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'stringMatching in arrayContaining'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> expected = [
    expect.stringMatching(<span class="hljs-regexp">/^Alic/</span>),
    expect.stringMatching(<span class="hljs-regexp">/^[BR]ob/</span>),
  ];
  it(<span class="hljs-string">'matches even if received contains additional elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Alicia'</span>, <span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>]).toEqual(
      expect.arrayContaining(expected),
    );
  });
  it(<span class="hljs-string">'does not match if received does not contain expected elements'</span>, () =&gt; {
    expect([<span class="hljs-string">'Roberto'</span>, <span class="hljs-string">'Evelina'</span>]).not.toEqual(
      expect.arrayContaining(expected),
    );
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="expectaddsnapshotserializerserializer"></a><a href="#expectaddsnapshotserializerserializer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>expect.addSnapshotSerializer(serializer)</code></h3>
<p>Puedes llamar a <code>expect.addSnapshotSerializer</code> para agregar un módulo que formatee estructuras de datos específicas de la aplicación.</p>
<p>Para un archivo de test individual, un módulo añadido precede a los módulos de <code>snapshotSerializers</code> en la configuración, que preceden los serializadores de instantánea predeterminados para tipos de JavaScript integrados y elementos de React. El último módulo añadido, es el primero módulo testeado.</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">import</span> serializer <span class="hljs-keyword">from</span> <span class="hljs-string">'my-serializer-module'</span>;
expect.addSnapshotSerializer(serializer);

<span class="hljs-comment">// afecta a las afirmaciones expect(value).toMatchSnapshot() en el archivo de test</span>
</code></pre>
<p>Si añades un serializador de instantánea en los archivos de test individuales en vez de a agregarlo a la configuración de <code>snapshotSerializers</code>:</p>
<ul>
<li>Haces la dependencia explícita en lugar de implícita.</li>
<li>Evitas límites de la configuración que podría causarte expulsar desde <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>.</li>
</ul>
<p>Véase <a href="/docs/es-ES/23.x/configuration#snapshotserializers-arraystring">configurando Jest</a> para más información.</p>
<h3><a class="anchor" aria-hidden="true" id="not"></a><a href="#not" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.not</code></h3>
<p>If you know how to test something, <code>.not</code> lets you test its opposite. For example, this code tests that the best La Croix flavor is not coconut:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'el mejor sabor no es coco'</span>, () =&gt; {
  expect(mejorSaborLaCroix()).not.toBe(<span class="hljs-string">'coco'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="resolves"></a><a href="#resolves" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.resolves</code></h3>
<p>Use <code>resolves</code> to unwrap the value of a fulfilled promise so any other matcher can be chained. If the promise is rejected the assertion fails.</p>
<p>Por ejemplo, este código testea que la promesa resuelve y que el valor resultando es <code>'limon'</code>:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'resuelve a limon'</span>, () =&gt; {
  <span class="hljs-comment">// Es esencial que se agregue un statement de return</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'limon'</span>)).resolves.toBe(<span class="hljs-string">'limon'</span>);
});
</code></pre>
<p>Tenga en cuenta que, dado que todavía esta probando promesas, la prueba sigue siendo asincronica. Hence, you will need to <a href="/docs/es-ES/23.x/asynchronous#promises">tell Jest to wait</a> by returning the unwrapped assertion.</p>
<p>Alternativamente, se puede usar <code>async/await</code> en combinación con <code>.resolves</code>:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'resuelve a limon'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'limon'</span>)).resolves.toBe(<span class="hljs-string">'limon'</span>);
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'limon'</span>)).resolves.not.toBe(<span class="hljs-string">'pulpo'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="rejects"></a><a href="#rejects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.rejects</code></h3>
<p>Use <code>.rejects</code> to unwrap the reason of a rejected promise so any other matcher can be chained. If the promise is fulfilled the assertion fails.</p>
<p>Por ejemplo, este código prueba que la promesa rechaza con la razón <code>'octopus'</code>:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'rejects to octopus'</span>, () =&gt; {
  <span class="hljs-comment">// make sure to add a return statement</span>
  <span class="hljs-keyword">return</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'octopus'</span>))).rejects.toThrow(
    <span class="hljs-string">'octopus'</span>,
  );
});
</code></pre>
<p>Tenga en cuenta que, dado que todavía esta probando promesas, la prueba sigue siendo asincronica. Hence, you will need to <a href="/docs/es-ES/23.x/asynchronous#promises">tell Jest to wait</a> by returning the unwrapped assertion.</p>
<p>Alternativamente, puede utilizar <code>async/await</code> combinado con <code>.rejects</code>.</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'rejects to octopus'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> expect(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'octopus'</span>))).rejects.toThrow(<span class="hljs-string">'octopus'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobevalue"></a><a href="#tobevalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBe(value)</code></h3>
<p>Use <code>.toBe</code> to compare primitive values or to check referential identity of object instances. It calls <code>Object.is</code> to compare values, which is even better for testing than <code>===</code> strict equality operator.</p>
<p>Por ejemplo, el código a continuación valida algunas propiedades del objeto <code>lata</code>:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> lata = {
  <span class="hljs-attr">nombre</span>: <span class="hljs-string">'pomelo'</span>,
  <span class="hljs-attr">onzas</span> : <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'la lata'</span>, () =&gt; {
  test(<span class="hljs-string">'tiene 12 onzas'</span>, () =&gt; {
    expect(lata.onzas).toBe(<span class="hljs-number">12</span>);
  });

  test(<span class="hljs-string">'tiene un nombre sofisticado'</span>, () =&gt; {
    expect(lata.nombre).toBe(<span class="hljs-string">'pomelo'</span>);
  });
});
</code></pre>
<p>Don't use <code>.toBe</code> with floating-point numbers. Por ejemplo, debido al redondeo, en JavaScript <code>0,2 + 0,1</code> no es estrictamente igual a <code>0,3</code>. Si tienes números de punto flotante, prueba <code>.toBeCloseTo</code> en su lugar.</p>
<p>Although the <code>.toBe</code> matcher <strong>checks</strong> referential identity, it <strong>reports</strong> a deep comparison of values if the assertion fails. If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the <code>expect</code> function. For example, to assert whether or not elements are the same instance:</p>
<ul>
<li>rewrite <code>expect(received).toBe(expected)</code> as <code>expect(Object.is(received, expected)).toBe(true)</code></li>
<li>rewrite <code>expect(received).not.toBe(expected)</code> as <code>expect(Object.is(received, expected)).toBe(false)</code></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="tohavebeencalled"></a><a href="#tohavebeencalled" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalled()</code></h3>
<p>También bajo el alias: <code>.toBeCalled()</code></p>
<p>Usa <code>.toHaveBeenCalled</code> para asegurar que una función &quot;mock&quot; fue llamada.</p>
<p>For example, let's say you have a <code>drinkAll(drink, flavour)</code> function that takes a <code>drink</code> function and applies it to all available beverages. You might want to check that <code>drink</code> gets called for <code>'lemon'</code>, but not for <code>'octopus'</code>, because <code>'octopus'</code> flavour is really weird and why would anything be octopus-flavoured? Puedes hacerlo con esta serie de tests:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkAll</span>(<span class="hljs-params">callback, flavour</span>) </span>{
  <span class="hljs-keyword">if</span> (flavour !== <span class="hljs-string">'octopus'</span>) {
    callback(flavour);
  }
}

describe(<span class="hljs-string">'drinkAll'</span>, () =&gt; {
  test(<span class="hljs-string">'drinks something lemon-flavoured'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'lemon'</span>);
    expect(drink).toHaveBeenCalled();
  });

  test(<span class="hljs-string">'does not drink something octopus-flavoured'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> drink = jest.fn();
    drinkAll(drink, <span class="hljs-string">'octopus'</span>);
    expect(drink).not.toHaveBeenCalled();
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavebeencalledtimesnumber"></a><a href="#tohavebeencalledtimesnumber" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalledTimes(number)</code></h3>
<p>Also under the alias: <code>.toBeCalledTimes(number)</code></p>
<p>Usa <code>.toHaveBeenCalledTimes</code> para asegurar que una función &quot;mock&quot; se llamo un número de veces exacto.</p>
<p>Por ejemplo, digamos que tienes una función <code>beberCada(beber, Array&lt;sabor&gt;)</code> que toma una función <code>beber</code> y la aplica a un arreglo de bebidas. Puede que quieras comprobar que la función beber se llamó un numero exacto de veces. Puedes hacerlo con esta serie de tests:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'beberCada bebe cada bebida'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beber = jest.fn();
  beberCada(beber, [<span class="hljs-string">'limon'</span>, <span class="hljs-string">'pulpo'</span>]);
  expect(beber).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavebeencalledwitharg1-arg2-"></a><a href="#tohavebeencalledwitharg1-arg2-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code></h3>
<p>También bajo el alias: <code>.toBeCalledWith()</code></p>
<p>Usa <code>.toHaveBeenCalledWith</code> para asegurar que una función mock haya sido llamada con argumentos específicos.</p>
<p>Por ejemplo, digamos que tienes una bebida con una función <code>registrar</code>, y <code>aplicarATodo(f)</code> que aplica la función <code>f</code> a todas las bebidas registradas. Para asegurarte que funciona, puedes escribir:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'registro aplicado correctamente a La Croix naranja'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> bebida = <span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'naranja'</span>);
  registrar(bebida);
  <span class="hljs-keyword">const</span> f = jest.fn();
  aplicarATodo(f);
  expect(f).toHaveBeenCalledWith(bebida);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavebeenlastcalledwitharg1-arg2-"></a><a href="#tohavebeenlastcalledwitharg1-arg2-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code></h3>
<p>También bajo el alias: <code>.lastCalledWith(arg1, arg2, ...)</code></p>
<p>Si tienes una función mock, puedes usar <code>.toHaveBeenLastCalledWith</code> para ver los argumentos con los que fue llamada la ultima vez. Por ejemplo digamos que tienes una función <code>aplicarATodosLosSabores(f)</code> que aplica la función <code>f</code> a diversos sabores, y quieres asegurarte que la ultima vez que se llama a esta función el último sabor al que se le aplica la función es <code>'mango'</code>. Puedes escribir:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'aplicarATodosLosSabores deja el mango para el final'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> bebida = jest.fn();
  aplicarATodosLosSabores(bebida);
  expect(bebida).toHaveBeenLastCalledWith(<span class="hljs-string">'mango'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavebeennthcalledwithnthcall-arg1-arg2-"></a><a href="#tohavebeennthcalledwithnthcall-arg1-arg2-" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)</code></h3>
<p>Also under the alias: <code>.nthCalledWith(nthCall, arg1, arg2, ...)</code></p>
<p>If you have a mock function, you can use <code>.toHaveBeenNthCalledWith</code> to test what arguments it was nth called with. For example, let's say you have a <code>drinkEach(drink, Array&lt;flavor&gt;)</code> function that applies <code>f</code> to a bunch of flavors, and you want to ensure that when you call it, the first flavor it operates on is <code>'lemon'</code> and the second one is <code>'octopus'</code>. Puedes escribir:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drinkEach drinks each drink'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn();
  drinkEach(drink, [<span class="hljs-string">'lemon'</span>, <span class="hljs-string">'octopus'</span>]);
  expect(drink).toHaveBeenNthCalledWith(<span class="hljs-number">1</span>, <span class="hljs-string">'lemon'</span>);
  expect(drink).toHaveBeenNthCalledWith(<span class="hljs-number">2</span>, <span class="hljs-string">'octopus'</span>);
});
</code></pre>
<p>Note: the nth argument must be positive integer starting from 1.</p>
<h3><a class="anchor" aria-hidden="true" id="tohavereturned"></a><a href="#tohavereturned" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveReturned()</code></h3>
<p>Also under the alias: <code>.toReturn()</code></p>
<p>If you have a mock function, you can use <code>.toHaveReturned</code> to test that the mock function successfully returned (i.e., did not throw an error) at least one time. For example, let's say you have a mock <code>drink</code> that returns <code>true</code>. Puedes escribir:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drinks returns'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-literal">true</span>);

  drink();

  expect(drink).toHaveReturned();
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavereturnedtimesnumber"></a><a href="#tohavereturnedtimesnumber" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveReturnedTimes(number)</code></h3>
<p>Also under the alias: <code>.toReturnTimes(number)</code></p>
<p>Use <code>.toHaveReturnedTimes</code> to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times. Any calls to the mock function that throw an error are not counted toward the number of times the function returned.</p>
<p>For example, let's say you have a mock <code>drink</code> that returns <code>true</code>. Puedes escribir:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drink returns twice'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> drink = jest.fn(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-literal">true</span>);

  drink();
  drink();

  expect(drink).toHaveReturnedTimes(<span class="hljs-number">2</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavereturnedwithvalue"></a><a href="#tohavereturnedwithvalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveReturnedWith(value)</code></h3>
<p>Also under the alias: <code>.toReturnWith(value)</code></p>
<p>Use <code>.toHaveReturnedWith</code> to ensure that a mock function returned a specific value.</p>
<p>For example, let's say you have a mock <code>drink</code> that returns the name of the beverage that was consumed. Puedes escribir:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drink returns La Croix'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beverage = {<span class="hljs-attr">name</span>: <span class="hljs-string">'La Croix'</span>};
  <span class="hljs-keyword">const</span> drink = jest.fn(<span class="hljs-function"><span class="hljs-params">beverage</span> =&gt;</span> beverage.name);

  drink(beverage);

  expect(drink).toHaveReturnedWith(<span class="hljs-string">'La Croix'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavelastreturnedwithvalue"></a><a href="#tohavelastreturnedwithvalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveLastReturnedWith(value)</code></h3>
<p>Also under the alias: <code>.lastReturnedWith(value)</code></p>
<p>Use <code>.toHaveLastReturnedWith</code> to test the specific value that a mock function last returned. If the last call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</p>
<p>For example, let's say you have a mock <code>drink</code> that returns the name of the beverage that was consumed. Puedes escribir:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drink returns La Croix (Orange) last'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beverage1 = {<span class="hljs-attr">name</span>: <span class="hljs-string">'La Croix (Lemon)'</span>};
  <span class="hljs-keyword">const</span> beverage2 = {<span class="hljs-attr">name</span>: <span class="hljs-string">'La Croix (Orange)'</span>};
  <span class="hljs-keyword">const</span> drink = jest.fn(<span class="hljs-function"><span class="hljs-params">beverage</span> =&gt;</span> beverage.name);

  drink(beverage1);
  drink(beverage2);

  expect(drink).toHaveLastReturnedWith(<span class="hljs-string">'La Croix (Orange)'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohaventhreturnedwithnthcall-value"></a><a href="#tohaventhreturnedwithnthcall-value" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveNthReturnedWith(nthCall, value)</code></h3>
<p>Also under the alias: <code>.nthReturnedWith(nthCall, value)</code></p>
<p>Use <code>.toHaveNthReturnedWith</code> to test the specific value that a mock function returned for the nth call. If the nth call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</p>
<p>For example, let's say you have a mock <code>drink</code> that returns the name of the beverage that was consumed. Puedes escribir:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'drink returns expected nth calls'</span>, () =&gt; {
  <span class="hljs-keyword">const</span> beverage1 = {<span class="hljs-attr">name</span>: <span class="hljs-string">'La Croix (Lemon)'</span>};
  <span class="hljs-keyword">const</span> beverage2 = {<span class="hljs-attr">name</span>: <span class="hljs-string">'La Croix (Orange)'</span>};
  <span class="hljs-keyword">const</span> drink = jest.fn(<span class="hljs-function"><span class="hljs-params">beverage</span> =&gt;</span> beverage.name);

  drink(beverage1);
  drink(beverage2);

  expect(drink).toHaveNthReturnedWith(<span class="hljs-number">1</span>, <span class="hljs-string">'La Croix (Lemon)'</span>);
  expect(drink).toHaveNthReturnedWith(<span class="hljs-number">2</span>, <span class="hljs-string">'La Croix (Orange)'</span>);
});
</code></pre>
<p>Note: the nth argument must be positive integer starting from 1.</p>
<h3><a class="anchor" aria-hidden="true" id="tohavelengthnumber"></a><a href="#tohavelengthnumber" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveLength(number)</code></h3>
<p>Utilice <code>.toHaveLength</code> para verificar que un objeto tenga longitud de <code>.length</code> y tenga cierto valor numérico.</p>
<p>Es especialmente útil para verificar el tamaño de cadenas o arreglos.</p>
<pre><code class="hljs css language-js">expect([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">'abc'</span>).toHaveLength(<span class="hljs-number">3</span>);
expect(<span class="hljs-string">''</span>).not.toHaveLength(<span class="hljs-number">5</span>);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tohavepropertypathllave-valor"></a><a href="#tohavepropertypathllave-valor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toHaveProperty(pathLlave, valor)</code></h3>
<p>Utilice <code>.toHaveProperty</code> para verificar si la propiedad en la referencia de <code>pathLlave</code> existe para un objeto dado. For checking deeply nested properties in an object you may use <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors">dot notation</a> or an array containing the keyPath for deep references.</p>
<p>Opcionalmente, se puede proveer un <code>valor</code> para verificar si está presente en el <code>pathLlave</code> del objeto objetivo. Este método utiliza 'igualdad profunda' (cómo <code>toEqual()</code>) y compara por igualdad a todos los campos de forma recursiva.</p>
<p>El siguiente ejemplo contiene un objeto <code>casaEnVenta</code> con propiedades anidadas. We are using <code>toHaveProperty</code> to check for the existence and values of various properties in the object.</p>
<pre><code class="hljs css language-js"><span class="hljs-comment">// Object containing house features to be tested</span>
<span class="hljs-keyword">const</span> houseForSale = {
  <span class="hljs-attr">bath</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">bedrooms</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">kitchen</span>: {
    <span class="hljs-attr">amenities</span>: [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">wallColor</span>: <span class="hljs-string">'white'</span>,
    <span class="hljs-string">'nice.oven'</span>: <span class="hljs-literal">true</span>,
  },
  <span class="hljs-string">'ceiling.height'</span>: <span class="hljs-number">2</span>,
};

test(<span class="hljs-string">'this house has my desired features'</span>, () =&gt; {
  <span class="hljs-comment">// Example Referencing</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bath'</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'bedrooms'</span>, <span class="hljs-number">4</span>);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'pool'</span>);

  <span class="hljs-comment">// Deep referencing using dot notation</span>
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.area'</span>, <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(<span class="hljs-string">'kitchen.amenities'</span>, [
    <span class="hljs-string">'oven'</span>,
    <span class="hljs-string">'stove'</span>,
    <span class="hljs-string">'washer'</span>,
  ]);

  expect(houseForSale).not.toHaveProperty(<span class="hljs-string">'kitchen.open'</span>);

  <span class="hljs-comment">// Deep referencing using an array containing the keyPath</span>
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'area'</span>], <span class="hljs-number">20</span>);
  expect(houseForSale).toHaveProperty(
    [<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'amenities'</span>],
    [<span class="hljs-string">'oven'</span>, <span class="hljs-string">'stove'</span>, <span class="hljs-string">'washer'</span>],
  );
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'amenities'</span>, <span class="hljs-number">0</span>], <span class="hljs-string">'oven'</span>);
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'nice.oven'</span>]);
  expect(houseForSale).not.toHaveProperty([<span class="hljs-string">'kitchen'</span>, <span class="hljs-string">'open'</span>]);

  <span class="hljs-comment">// Referencing keys with dot in the key itself</span>
  expect(houseForSale).toHaveProperty([<span class="hljs-string">'ceiling.height'</span>], <span class="hljs-string">'tall'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobeclosetonúmero-númerodigitos"></a><a href="#tobeclosetonúmero-númerodigitos" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeCloseTo(número, númeroDigitos)</code></h3>
<p>Using exact equality with floating point numbers is a bad idea. Rounding means that intuitive things fail. For example, this test fails:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'adding works sanely with decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBe(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// Fails!</span>
});
</code></pre>
<p>It fails because in JavaScript, <code>0.2 + 0.1</code> is actually <code>0.30000000000000004</code>. Sorry.</p>
<p>En su lugar, usa <code>.toBeCloseTo</code>. Utiliza <code>numDigits</code> para controlar cuántos dígitos después del punto decimal se deben verificar. Por ejemplo, si quieres estar seguro que <code>0.2 + 0.1</code> es igual a <code>0.3</code> con una precisión de 5 dígitos decimales, puedes ocupar esta prueba:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'adding works sanely with decimals'</span>, () =&gt; {
  expect(<span class="hljs-number">0.2</span> + <span class="hljs-number">0.1</span>).toBeCloseTo(<span class="hljs-number">0.3</span>, <span class="hljs-number">5</span>);
});
</code></pre>
<p>El valor por defecto para <code>númeroDigitos</code> es 2, el cual ha demostrado ser un buen valor por defecto para la mayoría de los casos.</p>
<h3><a class="anchor" aria-hidden="true" id="tobedefined"></a><a href="#tobedefined" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeDefined()</code></h3>
<p>Usa <code>.toBeDefined</code> para verificar que una variable no sea undefined. For example, if you want to check that a function <code>fetchNewFlavorIdea()</code> returns <em>something</em>, you can write:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'hay una nueva idea de sabor'</span>, () =&gt; {
  expect(conseguirNuevaIdeaSabor()).toBeDefined();
});
</code></pre>
<p>Puedes escribir <code>expect(conseguirNuevaIdeaSabor()).not.toBe(undefined)</code>, pero es buena practica omitir el uso de <code>undefined</code> directamente en el código.</p>
<h3><a class="anchor" aria-hidden="true" id="tobefalsy"></a><a href="#tobefalsy" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeFalsy()</code></h3>
<p>Use <code>.toBeFalsy</code> when you don't care what a value is and you want to ensure a value is false in a boolean context. For example, let's say you have some application code that looks like:</p>
<pre><code class="hljs css language-js">beberPocoLaCroix();
<span class="hljs-keyword">if</span> (!conseguirErrores()) {
  beberMasLaCroix();
}
</code></pre>
<p>Puede que no te importe el valor que <code>conseguirErrores</code> regrese, específicamente - podría regresar <code>false</code>, <code>null</code>, o <code>0</code>, y el código funcionaría correctamente. Si quieres probar que no hay errores después de tomar algo de La Croix, podrías escribir:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'beber LaCroix no provoca errores'</span>, () =&gt; {
  beberPocoLaCroix();
  expect(conseguirErrores()).toBeFalsy();
});
</code></pre>
<p>In JavaScript, there are six falsy values: <code>false</code>, <code>0</code>, <code>''</code>, <code>null</code>, <code>undefined</code>, and <code>NaN</code>. Everything else is truthy.</p>
<h3><a class="anchor" aria-hidden="true" id="tobegreaterthannúmero"></a><a href="#tobegreaterthannúmero" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeGreaterThan(número)</code></h3>
<p>To compare floating point numbers, you can use <code>toBeGreaterThan</code>. For example, if you want to test that <code>ouncesPerCan()</code> returns a value of more than 10 ounces, write:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'onzas por lata es mayor a 10'</span>, () =&gt; {
  expect(onzasPorLata()).toBeGreaterThan(<span class="hljs-number">10</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobegreaterthanorequalnúmero"></a><a href="#tobegreaterthanorequalnúmero" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeGreaterThanOrEqual(número)</code></h3>
<p>To compare floating point numbers, you can use <code>toBeGreaterThanOrEqual</code>. For example, if you want to test that <code>ouncesPerCan()</code> returns a value of at least 12 ounces, write:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'onzas por lata es por lo menos 12'</span>, () =&gt; {
  expect(onzasPorLata()).toBeGreaterThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobelessthannúmero"></a><a href="#tobelessthannúmero" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeLessThan(número)</code></h3>
<p>To compare floating point numbers, you can use <code>toBeLessThan</code>. For example, if you want to test that <code>ouncesPerCan()</code> returns a value of less than 20 ounces, write:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'onzas por lata es menor a 20'</span>, () =&gt; {
  expect(onzasPorLata()).toBeLessThan(<span class="hljs-number">20</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobelessthanorequalnúmero"></a><a href="#tobelessthanorequalnúmero" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeLessThanOrEqual(número)</code></h3>
<p>To compare floating point numbers, you can use <code>toBeLessThanOrEqual</code>. For example, if you want to test that <code>ouncesPerCan()</code> returns a value of at most 12 ounces, write:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'onzas por lata es a lo mucho 12'</span>, () =&gt; {
  expect(onzasPorLata()).toBeLessThanOrEqual(<span class="hljs-number">12</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobeinstanceofclass"></a><a href="#tobeinstanceofclass" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeInstanceOf(Class)</code></h3>
<p>Use <code>.toBeInstanceOf(Class)</code> to check that an object is an instance of a class. This matcher uses <code>instanceof</code> underneath.</p>
<pre><code class="hljs css language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{}

expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(A);
expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {}).toBeInstanceOf(<span class="hljs-built_in">Function</span>);
expect(<span class="hljs-keyword">new</span> A()).toBeInstanceOf(<span class="hljs-built_in">Function</span>); <span class="hljs-comment">// avienta error</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobenull"></a><a href="#tobenull" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeNull()</code></h3>
<p><code>.toBeNull()</code> is the same as <code>.toBe(null)</code> but the error messages are a bit nicer. So use <code>.toBeNull()</code> when you want to check that something is null.</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bloop</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

test(<span class="hljs-string">'bloop regresa null'</span>, () =&gt; {
  expect(bloop()).toBeNull();
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tobetruthy"></a><a href="#tobetruthy" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeTruthy()</code></h3>
<p>Use <code>.toBeTruthy</code> when you don't care what a value is and you want to ensure a value is true in a boolean context. For example, let's say you have some application code that looks like:</p>
<pre><code class="hljs css language-js">beberPocoLaCroix();
<span class="hljs-keyword">if</span> (infoSed()) {
  beberMasLaCroix();
}
</code></pre>
<p>Puede que no te importe el valor que <code>infoSed</code> regrese, específicamente - podría regresar <code>true</code>o un objeto complejo, y el código funcionaría correctamente. So if you want to test that <code>thirstInfo</code> will be truthy after drinking some La Croix, you could write:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'beber La Croix lleva a conseguir info de sed'</span>, () =&gt; {
  beberPocoLaCroix();
  expect(infoSed()).toBeTruthy();
});
</code></pre>
<p>In JavaScript, there are six falsy values: <code>false</code>, <code>0</code>, <code>''</code>, <code>null</code>, <code>undefined</code>, and <code>NaN</code>. Everything else is truthy.</p>
<h3><a class="anchor" aria-hidden="true" id="tobeundefined"></a><a href="#tobeundefined" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeUndefined()</code></h3>
<p>Usa <code>.toBeDefined</code> para verificar que una variable es undefined. Por ejemplo, si quieres verificar que la función <code>mejorBebidaPorSabor(sabor)</code> regresa <code>undefined</code> para el sabor <code>'pulpo'</code>, porque no existe ninguna bebida con sabor a pulpo que sepa bien:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'la mejor bebida con sabor a pulpo es undefined'</span>, () =&gt; {
  expect(mejorBebidaPorSabor(<span class="hljs-string">'pulpo'</span>)).toBeUndefined();
});
</code></pre>
<p>Podría escribir <code>expect(mejorBebidaPorSabor('pulpo')).toBe(undefined)</code>, pero es buena practica omitir el uso de <code>undefined</code> directamente en el código.</p>
<h3><a class="anchor" aria-hidden="true" id="tobenan"></a><a href="#tobenan" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toBeNaN()</code></h3>
<p>Use <code>.toBeNaN</code> when checking a value is <code>NaN</code>.</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'passes when value is NaN'</span>, () =&gt; {
  expect(<span class="hljs-literal">NaN</span>).toBeNaN();
  expect(<span class="hljs-number">1</span>).not.toBeNaN();
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tocontainitem"></a><a href="#tocontainitem" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toContain(item)</code></h3>
<p>Use <code>.toContain</code> when you want to check that an item is in an array. For testing the items in the array, this uses <code>===</code>, a strict equality check. <code>.toContain</code> can also check whether a string is a substring of another string.</p>
<p>For example, if <code>getAllFlavors()</code> returns an array of flavors and you want to be sure that <code>lime</code> is in there, you can write:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'la lista de sabores contiene lima'</span>, () =&gt; {
  expect(conseguirTodosSabores()).toContain(<span class="hljs-string">'lima'</span>);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tocontainequalitem"></a><a href="#tocontainequalitem" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toContainEqual(item)</code></h3>
<p>Use <code>.toContainEqual</code> when you want to check that an item with a specific structure and values is contained in an array. For testing the items in the array, this matcher recursively checks the equality of all fields, rather than checking for object identity.</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'mi bebida'</span>, () =&gt; {
  test(<span class="hljs-string">'es deliciosa y no es agría'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> miBebida = {<span class="hljs-attr">deliciosa</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">agria</span>: <span class="hljs-literal">false</span>};
    expect(misBebidas()).toContainEqual(miBebida);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="toequalvalue"></a><a href="#toequalvalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toEqual(value)</code></h3>
<p>Use <code>.toEqual</code> to compare recursively all properties of object instances (also known as &quot;deep&quot; equality). It calls <code>Object.is</code> to compare primitive values, which is even better for testing than <code>===</code> strict equality operator.</p>
<p>For example, <code>.toEqual</code> and <code>.toBe</code> behave differently in this test suite, so all the tests pass:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> lata1 = {
  <span class="hljs-attr">sabor</span>: <span class="hljs-string">'toronja'</span>,
  <span class="hljs-attr">onzas</span>: <span class="hljs-number">12</span>,
};
<span class="hljs-keyword">const</span> lata2 = {
  <span class="hljs-attr">sabor</span>: <span class="hljs-string">'toronja'</span>,
  <span class="hljs-attr">onzas</span>: <span class="hljs-number">12</span>,
};

describe(<span class="hljs-string">'las latas de La Croix en mi escritorio'</span>, () =&gt; {
  test(<span class="hljs-string">'tienen las mismas propiedades'</span>, () =&gt; {
    expect(lata1).toEqual(lata2);
  });
  test(<span class="hljs-string">'no son la misma lata'</span>, () =&gt; {
    expect(lata1).not.toBe(lata2);
  });
});
</code></pre>
<blockquote>
<p>Nota: <code>.toEqual</code> no realizara una verificación de <em>igualdad profunda</em> para dos errores. Sólo la propiedad <code>message</code> de un error se verifica para comparar igualdad. Se recomienda utilizar el método <code>.toThrow</code> para probar errores.</p>
</blockquote>
<p>If differences between properties do not help you to understand why a test fails, especially if the report is large, then you might move the comparison into the <code>expect</code> function. For example, use <code>equals</code> method of <code>Buffer</code> class to assert whether or not buffers contain the same content:</p>
<ul>
<li>rewrite <code>expect(received).toEqual(expected)</code> as <code>expect(received.equals(expected)).toBe(true)</code></li>
<li>rewrite <code>expect(received).not.toEqual(expected)</code> as <code>expect(received.equals(expected)).toBe(false)</code></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="tomatchregexporstring"></a><a href="#tomatchregexporstring" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatch(regexpOrString)</code></h3>
<p>Utilice <code>.toMatch</code> para verificar que la cadena coincida con una expresión regular (Regex).</p>
<p>Por ejemplo, puede que no sepas el valor exacto que <code>ensayoSobreElMejorSabor()</code> regresa, pero sabes que es una cadena muy larga, y que la cadena <code>toronja</code> es parte del contenido. Podemos probarlo con:</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'un ensayo sobre el mejor sabor'</span>, () =&gt; {
  test(<span class="hljs-string">'menciona toronja'</span>, () =&gt; {
    expect(ensayoSobreElMejorSabor()).toMatch(<span class="hljs-regexp">/toronja/</span>);
    expect(ensayoSobreElMejorSabor()).toMatch(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'toronja'</span>));
  });
});
</code></pre>
<p>Este método acepta también una cadena, con la que va a intentar coincidir:</p>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'las toronjas son saludables'</span>, () =&gt; {
  test(<span class="hljs-string">'las toronjas son frutas'</span>, () =&gt; {
    expect(<span class="hljs-string">'toronjas'</span>).toMatch(<span class="hljs-string">'fruta'</span>);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tomatchobjectobject"></a><a href="#tomatchobjectobject" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatchObject(object)</code></h3>
<p>Usa <code>.toMatchObject</code> para comprobar que un objeto de JavaScript coincide con un subconjunto de las propiedades de un objeto. Hará match de objetos recibidos cuyas propiedades <strong>no</strong> están en el objeto esperado.</p>
<p>También se puede pasar un arreglo de objetos, en cuyo caso el método regresara true solo si cada objeto en el arreglo hace match (como descrito en <code>toMatchObject</code> anteriormente) con el objeto correspondiente en el arreglo esperado. Esto es útil si se desea verificar que dos arreglos coinciden en el número de sus elementos, opuesto a <code>arrayContaining</code>, lo cual permite que el arreglo recibido contenga elementos adicionales.</p>
<p>Se puede hacer match de propiedades a través de sus valores o con matchers.</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">const</span> casaEnVenta = {
  bañera: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">habitaciones</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">cocina</span>: {
    <span class="hljs-attr">amenidades</span>: [<span class="hljs-string">'horno'</span>, <span class="hljs-string">'estufa'</span>, <span class="hljs-string">'lavadora'</span>],
    <span class="hljs-attr">area</span>: <span class="hljs-number">20</span>,
    <span class="hljs-attr">colorPared</span>: <span class="hljs-string">'blanco'</span>,
  },
};
<span class="hljs-keyword">const</span> casaDeseada = {
  bañera: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">cocina</span>: {
    <span class="hljs-attr">amenidades</span>: [<span class="hljs-string">'horno'</span>, <span class="hljs-string">'estufa'</span>, <span class="hljs-string">'lavadora'</span>],
    <span class="hljs-attr">colorPared</span>: expect.stringMatching(<span class="hljs-regexp">/blanco|amarillo/</span>),
  },
};

test(<span class="hljs-string">'la casa tiene las propiedades deseadas'</span>, () =&gt; {
  expect(casaEnVenta).toMatchObject(casaDeseada);
});
</code></pre>
<pre><code class="hljs css language-js">describe(<span class="hljs-string">'toMatchObject applied to arrays'</span>, () =&gt; {
  test(<span class="hljs-string">'the number of elements must match exactly'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]).toMatchObject([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]);
  });

  <span class="hljs-comment">// .arrayContaining "matches a received array which contains elements that</span>
  <span class="hljs-comment">// are *not* in the expected array"</span>
  test(<span class="hljs-string">'.toMatchObject does not allow extra elements'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>}]).toMatchObject([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}]);
  });

  test(<span class="hljs-string">'.toMatchObject is called for each elements, so extra object properties are okay'</span>, () =&gt; {
    expect([{<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>}, {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">extra</span>: <span class="hljs-string">'quux'</span>}]).toMatchObject([
      {<span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span>},
      {<span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>},
    ]);
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tomatchsnapshotpropertymatchers-snapshotname"></a><a href="#tomatchsnapshotpropertymatchers-snapshotname" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatchSnapshot(propertyMatchers, snapshotName)</code></h3>
<p>This ensures that a value matches the most recent snapshot. Check out <a href="/docs/es-ES/23.x/snapshot-testing">the Snapshot Testing guide</a> for more information.</p>
<p>The optional <code>propertyMatchers</code> argument allows you to specify asymmetric matchers which are verified instead of the exact values. Any value will be matched exactly if not provided as a matcher.</p>
<p>The last argument allows you option to specify a snapshot name. Otherwise, the name is inferred from the test.</p>
<h3><a class="anchor" aria-hidden="true" id="tomatchinlinesnapshotpropertymatchers-inlinesnapshot"></a><a href="#tomatchinlinesnapshotpropertymatchers-inlinesnapshot" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toMatchInlineSnapshot(propertyMatchers, inlineSnapshot)</code></h3>
<p>Ensures that a value matches the most recent snapshot. Unlike <a href="#tomatchsnapshotpropertymatchers-snapshotname"><code>.toMatchSnapshot()</code></a>, the snapshots will be written to the current source file, inline.</p>
<p>Check out the section on <a href="/docs/es-ES/23.x/snapshot-testing#inline-snapshots">Inline Snapshots</a> for more info.</p>
<h3><a class="anchor" aria-hidden="true" id="tostrictequalvalue"></a><a href="#tostrictequalvalue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toStrictEqual(value)</code></h3>
<p>Use <code>.toStrictEqual</code> to test that objects have the same types as well as structure.</p>
<p>Differences from <code>.toEqual</code>:</p>
<ul>
<li>Keys with <code>undefined</code> properties are checked. e.g. <code>{a: undefined, b: 2}</code> does not match <code>{b: 2}</code> when using <code>.toStrictEqual</code>.</li>
<li>Object types are checked to be equal. e.g. A class instance with fields <code>a</code> and <code>b</code> will not equal a literal object with fields <code>a</code> and <code>b</code>.</li>
</ul>
<pre><code class="hljs css language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaCroix</span> </span>{
  <span class="hljs-keyword">constructor</span>(flavor) {
    <span class="hljs-keyword">this</span>.flavor = flavor;
  }
}

describe(<span class="hljs-string">'the La Croix cans on my desk'</span>, () =&gt; {
  test(<span class="hljs-string">'are not semantically the same'</span>, () =&gt; {
    expect(<span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'lemon'</span>)).toEqual({<span class="hljs-attr">flavor</span>: <span class="hljs-string">'lemon'</span>});
    expect(<span class="hljs-keyword">new</span> LaCroix(<span class="hljs-string">'lemon'</span>)).not.toStrictEqual({<span class="hljs-attr">flavor</span>: <span class="hljs-string">'lemon'</span>});
  });
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tothrowerror"></a><a href="#tothrowerror" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toThrow(error)</code></h3>
<p>También bajo el alias: <code>.toThrowError(error)</code></p>
<p>Utilice <code>.toThrow</code> en una prueba para verificar que una función arroja un error cuando se llama. Por ejemplo, si deseamos probar que <code>beberSabor('pulpo')</code> arroja un error, porque el sabor a pulpo es demasiado repugnante para beber, podemos escribir:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'arroja error en pulpo'</span>, () =&gt; {
  expect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    beberSabor(<span class="hljs-string">'pulpo'</span>);
  }).toThrow();
});
</code></pre>
<blockquote>
<p>Note: You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail.</p>
</blockquote>
<p>Si deseas verificar que se arroja cierto error en especifico, se le puede proveer un argumento a <code>toThrow</code>. The argument can be a string that should be contained in the error message, a class for the error, or a regex that should match the error message. Por ejemplo, digamos que el código de <code>beberSabor</code> es el siguiente:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberSabor</span>(<span class="hljs-params">sabor</span>) </span>{
  <span class="hljs-keyword">if</span> (sabor == <span class="hljs-string">'pulpo'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ErrorSaborRepugnante(<span class="hljs-string">'guac! sabor a pulpo'</span>);
  }
  <span class="hljs-comment">// Funcionalidad extra</span>
}
</code></pre>
<p>Podríamos probar que este error lanza una excepción de varias formas:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'throws on octopus'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drinkOctopus</span>(<span class="hljs-params"></span>) </span>{
    drinkFlavor(<span class="hljs-string">'octopus'</span>);
  }

  <span class="hljs-comment">// Test that the error message says "yuck" somewhere: these are equivalent</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-regexp">/yuck/</span>);
  expect(drinkOctopus).toThrowError(<span class="hljs-string">'yuck'</span>);

  <span class="hljs-comment">// Test the exact error message</span>
  expect(drinkOctopus).toThrowError(<span class="hljs-regexp">/^yuck, octopus flavor$/</span>);

  <span class="hljs-comment">// Test that we get a DisgustingFlavorError</span>
  expect(drinkOctopus).toThrowError(DisgustingFlavorError);
});
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="tothrowerrormatchingsnapshot"></a><a href="#tothrowerrormatchingsnapshot" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toThrowErrorMatchingSnapshot()</code></h3>
<p>Utilice <code>.toThrowErrorMatchingSnapshot</code> para probar que una función arroja un error igual al snapshot más reciente cuando es llamada. Por ejemplo, digamos que tienes una función <code>beberSabor</code> que arroja un error cuando el sabor es <code>'pulpo'</code>, y su código es el siguiente:</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberSabor</span>(<span class="hljs-params">sabor</span>) </span>{
  <span class="hljs-keyword">if</span> (sabor == <span class="hljs-string">'pulpo'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ErrorSaborRepugnante(<span class="hljs-string">'guac! sabor a pulpo'</span>);
  }
  <span class="hljs-comment">// Funcionalidad extra</span>
}
</code></pre>
<p>El test para esta función se verá así:</p>
<pre><code class="hljs css language-js">test(<span class="hljs-string">'arroja error en pulpo'</span>, () =&gt; {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">beberPulpo</span>(<span class="hljs-params"></span>) </span>{
    beberSabor(<span class="hljs-string">'pulpo'</span>);
  }

  expect(beberPulpo).toThrowErrorMatchingSnapshot();
});
</code></pre>
<p>Y generará el siguiente snapshot:</p>
<pre><code class="hljs css language-js">exports[<span class="hljs-string">`drinking flavors throws on octopus 1`</span>] = <span class="hljs-string">`"yuck, octopus flavor"`</span>;
</code></pre>
<p>Echa un ojo a <a href="https://jestjs.io/blog/2016/07/27/jest-14.html">React Tree Snapshot Testing</a> para más información sobre tests de instantánea.</p>
<h3><a class="anchor" aria-hidden="true" id="tothrowerrormatchinginlinesnapshot"></a><a href="#tothrowerrormatchinginlinesnapshot" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>.toThrowErrorMatchingInlineSnapshot()</code></h3>
<p>This matcher is much like <a href="#tothrowerrormatchingsnapshot"><code>.toThrowErrorMatchingSnapshot</code></a>, except instead of writing the snapshot value to a <code>.snap</code> file, it will be written into the source code automatically.</p>
<p>Check out the section on <a href="/docs/es-ES/23.x/snapshot-testing#inline-snapshots">Inline Snapshots</a> for more info.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/es-ES/23.x/api"><span class="arrow-prev">← </span><span>Globals</span></a><a class="docs-next button" href="/docs/es-ES/23.x/mock-function-api"><span>Mock Functions</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#métodos">Métodos</a></li><li><a href="#referencia">Referencia</a><ul class="toc-headings"><li><a href="#expectvalue"><code>expect(value)</code></a></li><li><a href="#expectextendmatchers"><code>expect.extend(matchers)</code></a></li><li><a href="#expectanything"><code>expect.anything()</code></a></li><li><a href="#expectanyconstructor"><code>expect.any(constructor)</code></a></li><li><a href="#expectarraycontainingarray"><code>expect.arrayContaining(array)</code></a></li><li><a href="#expectassertionsnumber"><code>expect.assertions(number)</code></a></li><li><a href="#expecthasassertions"><code>expect.hasAssertions()</code></a></li><li><a href="#expectnotarraycontainingarray"><code>expect.not.arrayContaining(array)</code></a></li><li><a href="#expectnotobjectcontainingobject"><code>expect.not.objectContaining(object)</code></a></li><li><a href="#expectnotstringcontainingstring"><code>expect.not.stringContaining(string)</code></a></li><li><a href="#expectnotstringmatchingstring--regexp"><code>expect.not.stringMatching(string | regexp)</code></a></li><li><a href="#expectobjectcontainingobject"><code>expect.objectContaining(object)</code></a></li><li><a href="#expectstringcontainingstring"><code>expect.stringContaining(string)</code></a></li><li><a href="#expectstringmatchingstring--regexp"><code>expect.stringMatching(string | regexp)</code></a></li><li><a href="#expectaddsnapshotserializerserializer"><code>expect.addSnapshotSerializer(serializer)</code></a></li><li><a href="#not"><code>.not</code></a></li><li><a href="#resolves"><code>.resolves</code></a></li><li><a href="#rejects"><code>.rejects</code></a></li><li><a href="#tobevalue"><code>.toBe(value)</code></a></li><li><a href="#tohavebeencalled"><code>.toHaveBeenCalled()</code></a></li><li><a href="#tohavebeencalledtimesnumber"><code>.toHaveBeenCalledTimes(number)</code></a></li><li><a href="#tohavebeencalledwitharg1-arg2-"><code>.toHaveBeenCalledWith(arg1, arg2, ...)</code></a></li><li><a href="#tohavebeenlastcalledwitharg1-arg2-"><code>.toHaveBeenLastCalledWith(arg1, arg2, ...)</code></a></li><li><a href="#tohavebeennthcalledwithnthcall-arg1-arg2-"><code>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ....)</code></a></li><li><a href="#tohavereturned"><code>.toHaveReturned()</code></a></li><li><a href="#tohavereturnedtimesnumber"><code>.toHaveReturnedTimes(number)</code></a></li><li><a href="#tohavereturnedwithvalue"><code>.toHaveReturnedWith(value)</code></a></li><li><a href="#tohavelastreturnedwithvalue"><code>.toHaveLastReturnedWith(value)</code></a></li><li><a href="#tohaventhreturnedwithnthcall-value"><code>.toHaveNthReturnedWith(nthCall, value)</code></a></li><li><a href="#tohavelengthnumber"><code>.toHaveLength(number)</code></a></li><li><a href="#tohavepropertypathllave-valor"><code>.toHaveProperty(pathLlave, valor)</code></a></li><li><a href="#tobeclosetonúmero-númerodigitos"><code>.toBeCloseTo(número, númeroDigitos)</code></a></li><li><a href="#tobedefined"><code>.toBeDefined()</code></a></li><li><a href="#tobefalsy"><code>.toBeFalsy()</code></a></li><li><a href="#tobegreaterthannúmero"><code>.toBeGreaterThan(número)</code></a></li><li><a href="#tobegreaterthanorequalnúmero"><code>.toBeGreaterThanOrEqual(número)</code></a></li><li><a href="#tobelessthannúmero"><code>.toBeLessThan(número)</code></a></li><li><a href="#tobelessthanorequalnúmero"><code>.toBeLessThanOrEqual(número)</code></a></li><li><a href="#tobeinstanceofclass"><code>.toBeInstanceOf(Class)</code></a></li><li><a href="#tobenull"><code>.toBeNull()</code></a></li><li><a href="#tobetruthy"><code>.toBeTruthy()</code></a></li><li><a href="#tobeundefined"><code>.toBeUndefined()</code></a></li><li><a href="#tobenan"><code>.toBeNaN()</code></a></li><li><a href="#tocontainitem"><code>.toContain(item)</code></a></li><li><a href="#tocontainequalitem"><code>.toContainEqual(item)</code></a></li><li><a href="#toequalvalue"><code>.toEqual(value)</code></a></li><li><a href="#tomatchregexporstring"><code>.toMatch(regexpOrString)</code></a></li><li><a href="#tomatchobjectobject"><code>.toMatchObject(object)</code></a></li><li><a href="#tomatchsnapshotpropertymatchers-snapshotname"><code>.toMatchSnapshot(propertyMatchers, snapshotName)</code></a></li><li><a href="#tomatchinlinesnapshotpropertymatchers-inlinesnapshot"><code>.toMatchInlineSnapshot(propertyMatchers, inlineSnapshot)</code></a></li><li><a href="#tostrictequalvalue"><code>.toStrictEqual(value)</code></a></li><li><a href="#tothrowerror"><code>.toThrow(error)</code></a></li><li><a href="#tothrowerrormatchingsnapshot"><code>.toThrowErrorMatchingSnapshot()</code></a></li><li><a href="#tothrowerrormatchinginlinesnapshot"><code>.toThrowErrorMatchingInlineSnapshot()</code></a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/jest-outline.svg" alt="Jest" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/es-ES/getting-started.html">Getting Started</a><a href="/docs/es-ES/snapshot-testing.html">Guides</a><a href="/docs/es-ES/api.html">API Reference</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/jestjs" target="_blank">Stack Overflow</a><a href="https://www.reactiflux.com/">Reactiflux</a><a href="https://twitter.com/fbjest" target="_blank">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/facebook/jest">GitHub</a><a class="github-button" href="https://github.com/facebook/jest" data-icon="octicon-star" data-count-href="/facebook/jest/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star facebook/jest on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2020 Facebook Inc.</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '833906d7486e4059359fa58823c4ef56',
                indexName: 'jest',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:es-ES","version:23.x"]}
              });
            </script></body></html>