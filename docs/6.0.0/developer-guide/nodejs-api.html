<!doctype html><html lang="en" class="no-js"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="JavaScript, Linter, Linting, Pluggable, Configurable, Code Quality"><meta name="description" content="A pluggable and configurable linter tool for identifying and reporting on patterns in JavaScript. Maintain your code quality with ease."><meta name="theme-color" content="#463fd4"><meta property="og:locale" content="en_US"><meta property="og:site_name" content="ESLint - Pluggable JavaScript linter"><meta property="og:title" content="Node.js API"><meta property="og:url" content="/docs/6.0.0/developer-guide/nodejs-api"><meta property="og:image" content="https://eslint.org/assets/img/favicon.512x512.png"><meta name="twitter:site" content="@geteslint"><meta name="twitter:title" content="Node.js API"><meta name="twitter:description" content="A pluggable and configurable linter tool for identifying and reporting on patterns in JavaScript. Maintain your code quality with ease."><meta name="twitter:url" content="/docs/6.0.0/developer-guide/nodejs-api"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://eslint.org/assets/img/favicon.512x512.png"><title>Node.js API - ESLint - Pluggable JavaScript linter</title><link rel="preconnect" href="https://www.google-analytics.com"><link rel="canonical" href="/docs/6.0.0/developer-guide/nodejs-api"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600"><link rel="stylesheet" href="/assets/styles/main.css"><link rel="manifest" href="/manifest.json"><link rel="icon" href="/assets/img/favicon.512x512.png"><link rel="alternate" type="application/rss+xml" title="ESLint - Pluggable JavaScript linter" href="/feed.xml"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"></head><body><input type="checkbox" id="eslint-toggle-search" class="eslint-toggle-search-checkbox"><header class="navbar navbar-default navbar-demo navbar-fixed-top eslint-nav" id="top" role="banner"><div class="container"><a href="/" class="navbar-brand"><img alt="ESLint" src="/assets/img/logo.svg" itemprop="image">ESLint</a><div class="eslint-navbar-toggles"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#eslint-navbar" aria-controls="eslint-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button> <label for="eslint-toggle-search" class="navbar-toggle eslint-toggle-search-open"><span class="sr-only">Open search</span> <span class="glyphicon glyphicon-search" aria-hidden="true"></span></label></div><nav id="eslint-navbar" class="collapse navbar-collapse eslint-navbar"><ul class="nav navbar-nav navbar-right"><li class="dropdown"><a href="/docs/user-guide" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">User guide<span class="caret"></span></a><ul class="dropdown-menu" role="menu"><li><a href="/docs/user-guide/getting-started">Getting Started</a></li><li><a href="/docs/user-guide/configuring">Configuring ESLint</a></li><li><a href="/docs/user-guide/command-line-interface">Command Line Interface</a></li><li><a href="/docs/rules">Rules</a></li><li><a href="/docs/user-guide/formatters">Formatters</a></li><li><a href="/docs/user-guide/integrations">Integrations</a></li><li class="divider"></li><li><a href="/docs/user-guide/migrating-to-7.0.0">Migrating to v7.0.0</a></li><li><a href="/docs/user-guide/migrating-to-6.0.0">Migrating to v6.0.0</a></li><li><a href="/docs/user-guide/migrating-to-5.0.0">Migrating to v5.0.0</a></li><li><a href="/docs/user-guide/migrating-to-4.0.0">Migrating to v4.0.0</a></li><li><a href="/docs/user-guide/migrating-to-3.0.0">Migrating to v3.0.0</a></li><li><a href="/docs/user-guide/migrating-to-2.0.0">Migrating to v2.0.0</a></li><li><a href="/docs/user-guide/migrating-to-1.0.0">Migrating to v1.0.0</a></li><li><a href="/docs/user-guide/migrating-from-jscs">Migrating from JSCS</a></li></ul></li><li class="dropdown"><a href="/docs/developer-guide" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Developer guide<span class="caret"></span></a><ul class="dropdown-menu" role="menu"><li><a href="/docs/developer-guide/architecture">Architecture</a></li><li><a href="/docs/developer-guide/contributing">Contributing</a></li><li><a href="/docs/developer-guide/source-code">Get the Source Code</a></li><li><a href="/docs/developer-guide/development-environment">Set up a Development Environment</a></li><li><a href="/docs/developer-guide/unit-tests">Run the Unit Tests</a></li><li><a href="/docs/developer-guide/working-with-rules">Working with Rules</a></li><li><a href="/docs/developer-guide/working-with-plugins">Working with Plugins</a></li><li><a href="/docs/developer-guide/working-with-custom-formatters">Working with Custom Formatters</a></li><li><a href="/docs/developer-guide/working-with-custom-parsers">Working with Custom Parsers</a></li><li><a href="/docs/developer-guide/shareable-configs">Shareable Configs</a></li><li><a href="/docs/developer-guide/nodejs-api">Node.js API</a></li><li><a href="/docs/maintainer-guide">Maintainer guide</a></li></ul></li><li><a href="/blog">Blog</a></li><li><a href="/demo">Demo</a></li><li class="dropdown"><a href="/docs/about" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">About<span class="caret"></span></a><ul class="dropdown-menu" role="menu"><li><a href="/users">Who's Using ESLint?</a></li><li><a href="/team">About the Team</a></li><li><a href="/docs/about">About ESLint</a></li></ul></li></ul><label for="eslint-toggle-search" class="navbar-toggle eslint-toggle-search-open"><span class="sr-only">Open search</span> <span class="glyphicon glyphicon-search" aria-hidden="true"></span></label><div class="navbar-form navbar-right eslint-search" role="search"><div class="input-group"><label class="sr-only" aria-label="Search" for="eslint-search-input">Search</label><div class="eslint-search-input-wrapper"><input type="text" class="form-control" id="eslint-search-input" accesskey="s" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search the docs..."> <label for="eslint-toggle-search" class="eslint-toggle-search-close"><span class="sr-only">Close search</span> <span class="glyphicon glyphicon-remove-circle" aria-hidden="true"></span></label></div></div></div></nav></div></header><main class="doc"><article class="container"><h1>Node.js API</h1><p>While ESLint is designed to be run on the command line, it's possible to use ESLint programmatically through the Node.js API. The purpose of the Node.js API is to allow plugin and tool authors to use the ESLint functionality directly, without going through the command line interface.</p><p><strong>Note:</strong> Use undocumented parts of the API at your own risk. Only those parts that are specifically mentioned in this document are approved for use and will remain stable and reliable. Anything left undocumented is unstable and may change or be removed at any point.</p><h2>Table of Contents</h2><ul><li><a href="#sourcecode">SourceCode</a><ul><li><a href="#sourcecodesplitlines">splitLines()</a></li></ul></li><li><a href="#linter">Linter</a><ul><li><a href="#linterverify">verify()</a></li><li><a href="#linterverifyandfix">verifyAndFix()</a></li><li><a href="#linterdefinerule">defineRule()</a></li><li><a href="#linterdefinerules">defineRules()</a></li><li><a href="#lintergetrules">getRules()</a></li><li><a href="#linterdefineparser">defineParser()</a></li><li><a href="#linterversion">version</a></li></ul></li><li><a href="#linter-1">linter (deprecated)</a></li><li><a href="#cliengine">CLIEngine</a><ul><li><a href="#cliengineexecuteonfiles">executeOnFiles()</a></li><li><a href="#cliengineresolvefileglobpatterns">resolveFileGlobPatterns()</a></li><li><a href="#clienginegetconfigforfile">getConfigForFile()</a></li><li><a href="#cliengineexecuteontext">executeOnText()</a></li><li><a href="#cliengineaddplugin">addPlugin()</a></li><li><a href="#cliengineispathignored">isPathIgnored()</a></li><li><a href="#clienginegetformatter">getFormatter()</a></li><li><a href="#clienginegeterrorresults">getErrorResults()</a></li><li><a href="#cliengineoutputfixes">outputFixes()</a></li><li><a href="#clienginegetrules">getRules()</a></li><li><a href="#cliengineversion">version</a></li></ul></li><li><a href="#ruletester">RuleTester</a><ul><li><a href="#customizing-ruletester">Customizing RuleTester</a></li></ul></li><li><a href="#deprecated-apis">Deprecated APIs</a></li></ul><h2>SourceCode</h2><p>The <code>SourceCode</code> type represents the parsed source code that ESLint executes on. It's used internally in ESLint and is also available so that already-parsed code can be used. You can create a new instance of <code>SourceCode</code> by passing in the text string representing the code and an abstract syntax tree (AST) in <a href="https://github.com/estree/estree">ESTree</a> format (including location information, range information, comments, and tokens):</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> SourceCode = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).SourceCode;

<span class="hljs-keyword">const</span> code = <span class="hljs-keyword">new</span> SourceCode(<span class="hljs-string">"var foo = bar;"</span>, ast);
</code></pre><p>The <code>SourceCode</code> constructor throws an error if the AST is missing any of the required information.</p><p>The <code>SourceCode</code> constructor strips Unicode BOM. Please note the AST also should be parsed from stripped text.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> SourceCode = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).SourceCode;

<span class="hljs-keyword">const</span> code = <span class="hljs-keyword">new</span> SourceCode(<span class="hljs-string">"\uFEFFvar foo = bar;"</span>, ast);

assert(code.hasBOM === <span class="hljs-literal">true</span>);
assert(code.text === <span class="hljs-string">"var foo = bar;"</span>);
</code></pre><h3>SourceCode#splitLines()</h3><p>This is a static function on <code>SourceCode</code> that is used to split the source code text into an array of lines.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> SourceCode = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).SourceCode;

<span class="hljs-keyword">const</span> code = <span class="hljs-string">"var a = 1;\nvar b = 2;"</span>

<span class="hljs-comment">// split code into an array</span>
<span class="hljs-keyword">const</span> codeLines = SourceCode.splitLines(code);

<span class="hljs-comment">/*
    Value of codeLines will be
    [
        "var a = 1;",
        "var b = 2;"
    ]
 */</span>
</code></pre><h2>Linter</h2><p>The <code>Linter</code> object does the actual evaluation of the JavaScript code. It doesn't do any filesystem operations, it simply parses and reports on the code. In particular, the <code>Linter</code> object does not process configuration objects or files. The <code>Linter</code> is a constructor, and you can create a new instance by passing in the options you want to use. The available options are:</p><ul><li><code>cwd</code> - Path to a directory that should be considered as the current working directory. It is accessible to rules by calling <code>context.getCwd()</code> (see <a href="./working-with-rules#The-Context-Object">The Context Object</a>). If <code>cwd</code> is <code>undefined</code>, it will be normalized to <code>process.cwd()</code> if the global <code>process</code> object is defined (for example, in the Node.js runtime) , or <code>undefined</code> otherwise.</li></ul><p>For example:</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> Linter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).Linter;
<span class="hljs-keyword">const</span> linter1 = <span class="hljs-keyword">new</span> Linter({ <span class="hljs-attr">cwd</span>: <span class="hljs-string">'path/to/project'</span> });
<span class="hljs-keyword">const</span> linter2 = <span class="hljs-keyword">new</span> Linter();
</code></pre><p>In this example, rules run on <code>linter1</code> will get <code>path/to/project</code> when calling <code>context.getCwd()</code>. Those run on <code>linter2</code> will get <code>process.cwd()</code> if the global <code>process</code> object is defined or <code>undefined</code> otherwise (e.g. on the browser https://eslint.org/demo).</p><h3>Linter#verify</h3><p>The most important method on <code>Linter</code> is <code>verify()</code>, which initiates linting of the given text. This method accepts three arguments:</p><ul><li><code>code</code> - the source code to lint (a string or instance of <code>SourceCode</code>).</li><li><code>config</code> - a configuration object that has been processed and normalized by CLIEngine using eslintrc files and/or other configuration arguments.<ul><li><strong>Note</strong>: If you want to lint text and have your configuration be read and processed, use CLIEngine's <a href="#cliengineexecuteonfiles"><code>executeOnFiles</code></a> or <a href="#cliengineexecuteontext"><code>executeOnText</code></a> instead.</li></ul></li><li><code>options</code> - (optional) Additional options for this run.<ul><li><code>filename</code> - (optional) the filename to associate with the source code.</li><li><code>preprocess</code> - (optional) A function that <a href="/docs/developer-guide/working-with-plugins#processors-in-plugins">Processors in Plugins</a> documentation describes as the <code>preprocess</code> method.</li><li><code>postprocess</code> - (optional) A function that <a href="/docs/developer-guide/working-with-plugins#processors-in-plugins">Processors in Plugins</a> documentation describes as the <code>postprocess</code> method.</li><li><code>filterCodeBlock</code> - (optional) A function that decides which code blocks the linter should adopt. The function receives two arguments. The first argument is the virtual filename of a code block. The second argument is the text of the code block. If the function returned <code>true</code> then the linter adopts the code block. If the function was omitted, the linter adopts only <code>*.js</code> code blocks. If you provided a <code>filterCodeBlock</code> function, it overrides this default behavior, so the linter doesn't adopt <code>*.js</code> code blocks automatically.</li><li><code>disableFixes</code> - (optional) when set to <code>true</code>, the linter doesn't make either the <code>fix</code> or <code>suggestions</code> property of the lint result.</li><li><code>allowInlineConfig</code> - (optional) set to <code>false</code> to disable inline comments from changing ESLint rules.</li><li><code>reportUnusedDisableDirectives</code> - (optional) when set to <code>true</code>, adds reported errors for unused <code>eslint-disable</code> directives when no problems would be reported in the disabled area anyway.</li></ul></li></ul><p>If the third argument is a string, it is interpreted as the <code>filename</code>.</p><p>You can call <code>verify()</code> like this:</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> Linter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).Linter;
<span class="hljs-keyword">const</span> linter = <span class="hljs-keyword">new</span> Linter();

<span class="hljs-keyword">const</span> messages = linter.verify(<span class="hljs-string">"var foo;"</span>, {
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>
    }
}, { <span class="hljs-attr">filename</span>: <span class="hljs-string">"foo.js"</span> });

<span class="hljs-comment">// or using SourceCode</span>

<span class="hljs-keyword">const</span> Linter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).Linter,
    linter = <span class="hljs-keyword">new</span> Linter(),
    SourceCode = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).SourceCode;

<span class="hljs-keyword">const</span> code = <span class="hljs-keyword">new</span> SourceCode(<span class="hljs-string">"var foo = bar;"</span>, ast);

<span class="hljs-keyword">const</span> messages = linter.verify(code, {
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>
    }
}, { <span class="hljs-attr">filename</span>: <span class="hljs-string">"foo.js"</span> });
</code></pre><p>The <code>verify()</code> method returns an array of objects containing information about the linting warnings and errors. Here's an example:</p><pre class="hljs highlight-js"><code>{
    <span class="hljs-attr">fatal</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">ruleId</span>: <span class="hljs-string">"semi"</span>,
    <span class="hljs-attr">severity</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">column</span>: <span class="hljs-number">23</span>,
    <span class="hljs-attr">message</span>: <span class="hljs-string">"Expected a semicolon."</span>,
    <span class="hljs-attr">fix</span>: {
        <span class="hljs-attr">range</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">15</span>],
        <span class="hljs-attr">text</span>: <span class="hljs-string">";"</span>
    }
}
</code></pre><p>The information available for each linting message is:</p><ul><li><code>column</code> - the column on which the error occurred.</li><li><code>fatal</code> - usually omitted, but will be set to true if there's a parsing error (not related to a rule).</li><li><code>line</code> - the line on which the error occurred.</li><li><code>message</code> - the message that should be output.</li><li><code>nodeType</code> - the node or token type that was reported with the problem.</li><li><code>ruleId</code> - the ID of the rule that triggered the messages (or null if <code>fatal</code> is true).</li><li><code>severity</code> - either 1 or 2, depending on your configuration.</li><li><code>endColumn</code> - the end column of the range on which the error occurred (this property is omitted if it's not range).</li><li><code>endLine</code> - the end line of the range on which the error occurred (this property is omitted if it's not range).</li><li><code>fix</code> - an object describing the fix for the problem (this property is omitted if no fix is available).</li><li><code>suggestions</code> - an array of objects describing possible lint fixes for editors to programmatically enable (see details in the <a href="./working-with-rules#providing-suggestions">Working with Rules docs</a>).</li></ul><p>Linting message objects have a deprecated <code>source</code> property. This property <strong>will be removed</strong> from linting messages in an upcoming breaking release. If you depend on this property, you should now use the <code>SourceCode</code> instance provided by the linter.</p><p>You can also get an instance of the <code>SourceCode</code> object used inside of <code>linter</code> by using the <code>getSourceCode()</code> method:</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> Linter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).Linter;
<span class="hljs-keyword">const</span> linter = <span class="hljs-keyword">new</span> Linter();

<span class="hljs-keyword">const</span> messages = linter.verify(<span class="hljs-string">"var foo = bar;"</span>, {
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>
    }
}, { <span class="hljs-attr">filename</span>: <span class="hljs-string">"foo.js"</span> });

<span class="hljs-keyword">const</span> code = linter.getSourceCode();

<span class="hljs-built_in">console</span>.log(code.text);     <span class="hljs-comment">// "var foo = bar;"</span>
</code></pre><p>In this way, you can retrieve the text and AST used for the last run of <code>linter.verify()</code>.</p><h3>Linter#verifyAndFix()</h3><p>This method is similar to verify except that it also runs autofixing logic, similar to the <code>--fix</code> flag on the command line. The result object will contain the autofixed code, along with any remaining linting messages for the code that were not autofixed.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> Linter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).Linter;
<span class="hljs-keyword">const</span> linter = <span class="hljs-keyword">new</span> Linter();

<span class="hljs-keyword">const</span> messages = linter.verifyAndFix(<span class="hljs-string">"var foo"</span>, {
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>
    }
});
</code></pre><p>Output object from this method:</p><pre class="hljs highlight-js"><code>{
    <span class="hljs-attr">fixed</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">output</span>: <span class="hljs-string">"var foo;"</span>,
    <span class="hljs-attr">messages</span>: []
}
</code></pre><p>The information available is:</p><ul><li><code>fixed</code> - True, if the code was fixed.</li><li><code>output</code> - Fixed code text (might be the same as input if no fixes were applied).</li><li><code>messages</code> - Collection of all messages for the given code (It has the same information as explained above under <code>verify</code> block).</li></ul><h3>Linter#defineRule</h3><p>Each <code>Linter</code> instance holds a map of rule names to loaded rule objects. By default, all ESLint core rules are loaded. If you want to use <code>Linter</code> with custom rules, you should use the <code>defineRule</code> method to register your rules by ID.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> Linter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).Linter;
<span class="hljs-keyword">const</span> linter = <span class="hljs-keyword">new</span> Linter();

linter.defineRule(<span class="hljs-string">"my-custom-rule"</span>, {
    <span class="hljs-comment">// (an ESLint rule)</span>

    create(context) {
        <span class="hljs-comment">// ...</span>
    }
});

<span class="hljs-keyword">const</span> results = linter.verify(<span class="hljs-string">"// some source text"</span>, { <span class="hljs-attr">rules</span>: { <span class="hljs-string">"my-custom-rule"</span>: <span class="hljs-string">"error"</span> } });
</code></pre><h3>Linter#defineRules</h3><p>This is a convenience method similar to <code>Linter#defineRule</code>, except that it allows you to define many rules at once using an object.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> Linter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).Linter;
<span class="hljs-keyword">const</span> linter = <span class="hljs-keyword">new</span> Linter();

linter.defineRules({
    <span class="hljs-string">"my-custom-rule"</span>: { <span class="hljs-comment">/* an ESLint rule */</span> create() {} },
    <span class="hljs-string">"another-custom-rule"</span>: { <span class="hljs-comment">/* an ESLint rule */</span> create() {} }
});

<span class="hljs-keyword">const</span> results = linter.verify(<span class="hljs-string">"// some source text"</span>, {
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-string">"my-custom-rule"</span>: <span class="hljs-string">"error"</span>,
        <span class="hljs-string">"another-custom-rule"</span>: <span class="hljs-string">"warn"</span>
    }
});
</code></pre><h3>Linter#getRules</h3><p>This method returns a map of all loaded rules.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> Linter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).Linter;
<span class="hljs-keyword">const</span> linter = <span class="hljs-keyword">new</span> Linter();

linter.getRules();

<span class="hljs-comment">/*
Map {
  'accessor-pairs' =&gt; { meta: { docs: [Object], schema: [Array] }, create: [Function: create] },
  'array-bracket-newline' =&gt; { meta: { docs: [Object], schema: [Array] }, create: [Function: create] },
  ...
}
*/</span>
</code></pre><h3>Linter#defineParser</h3><p>Each instance of <code>Linter</code> holds a map of custom parsers. If you want to define a parser programmatically, you can add this function with the name of the parser as first argument and the <a href="/docs/developer-guide/working-with-plugins#working-with-custom-parsers">parser object</a> as second argument. The default <code>&quot;espree&quot;</code> parser will already be loaded for every <code>Linter</code> instance.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> Linter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).Linter;
<span class="hljs-keyword">const</span> linter = <span class="hljs-keyword">new</span> Linter();

linter.defineParser(<span class="hljs-string">"my-custom-parser"</span>, {
    parse(code, options) {
        <span class="hljs-comment">// ...</span>
    }
});

<span class="hljs-keyword">const</span> results = linter.verify(<span class="hljs-string">"// some source text"</span>, { <span class="hljs-attr">parser</span>: <span class="hljs-string">"my-custom-parser"</span> });
</code></pre><h3>Linter#version/Linter.version</h3><p>Each instance of <code>Linter</code> has a <code>version</code> property containing the semantic version number of ESLint that the <code>Linter</code> instance is from.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> Linter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).Linter;
<span class="hljs-keyword">const</span> linter = <span class="hljs-keyword">new</span> Linter();

linter.version; <span class="hljs-comment">// =&gt; '4.5.0'</span>
</code></pre><p>There is also a <code>Linter.version</code> property that you can read without instantiating <code>Linter</code>:</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> Linter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).Linter;

Linter.version; <span class="hljs-comment">// =&gt; '4.5.0'</span>
</code></pre><h2>linter</h2><p>The <code>eslint.linter</code> object (deprecated) is an instance of the <code>Linter</code> class as defined <a href="#linter">above</a>. <code>eslint.linter</code> exists for backwards compatibility, but we do not recommend using it because any mutations to it are shared among every module that uses <code>eslint</code>. Instead, please create your own instance of <code>eslint.Linter</code>.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> linter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).linter;

<span class="hljs-keyword">const</span> messages = linter.verify(<span class="hljs-string">"var foo;"</span>, {
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>
    }
}, { <span class="hljs-attr">filename</span>: <span class="hljs-string">"foo.js"</span> });
</code></pre><p>Note: This API is deprecated as of 4.0.0.</p><h2>CLIEngine</h2><p>The primary Node.js API is <code>CLIEngine</code>, which is the underlying utility that runs the ESLint command line interface. This object will read the filesystem for configuration and file information but will not output any results. Instead, it allows you direct access to the important information so you can deal with the output yourself.</p><p>You can get a reference to the <code>CLIEngine</code> by doing the following:</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine;
</code></pre><p>The <code>CLIEngine</code> is a constructor, and you can create a new instance by passing in the options you want to use. The available options are:</p><ul><li><code>allowInlineConfig</code> - Set to <code>false</code> to disable the use of configuration comments (such as <code>/*eslint-disable*/</code>). Corresponds to <code>--no-inline-config</code>.</li><li><code>baseConfig</code> - Can optionally be set to a config object that has the same schema as <code>.eslintrc.*</code>. This will used as a default config, and will be merged with any configuration defined in <code>.eslintrc.*</code> files, with the <code>.eslintrc.*</code> files having precedence.</li><li><code>cache</code> - Operate only on changed files (default: <code>false</code>). Corresponds to <code>--cache</code>.</li><li><code>cacheFile</code> - Name of the file where the cache will be stored (default: <code>.eslintcache</code>). Corresponds to <code>--cache-file</code>. Deprecated: use <code>cacheLocation</code> instead.</li><li><code>cacheLocation</code> - Name of the file or directory where the cache will be stored (default: <code>.eslintcache</code>). Corresponds to <code>--cache-location</code>.</li><li><code>configFile</code> - The configuration file to use (default: null). If <code>useEslintrc</code> is true or not specified, this configuration will be merged with any configuration defined in <code>.eslintrc.*</code> files, with options in this configuration having precedence. Corresponds to <code>-c</code>.</li><li><code>cwd</code> - Path to a directory that should be considered as the current working directory.</li><li><code>envs</code> - An array of environments to load (default: empty array). Corresponds to <code>--env</code>. Note: This differs from <code>.eslintrc.*</code> / <code>baseConfig</code>, where instead the option is called <code>env</code> and is an object.</li><li><code>extensions</code> - An array of filename extensions that should be checked for code. The default is an array containing just <code>&quot;.js&quot;</code>. Corresponds to <code>--ext</code>. It is only used in conjunction with directories, not with filenames, glob patterns or when using <code>executeOnText()</code>.</li><li><code>fix</code> - A boolean or a function (default: <code>false</code>). If a function, it will be passed each linting message and should return a boolean indicating whether the fix should be included with the output report (errors and warnings will not be listed if fixed). Files on disk are never changed regardless of the value of <code>fix</code>. To persist changes to disk, call <a href="#cliengineoutputfixes"><code>outputFixes()</code></a>.</li><li><code>fixTypes</code> - An array of rule types for which fixes should be applied (default: <code>null</code>). This array acts like a filter, only allowing rules of the given types to apply fixes. Possible array values are <code>&quot;problem&quot;</code>, <code>&quot;suggestion&quot;</code>, and <code>&quot;layout&quot;</code>.</li><li><code>globals</code> - An array of global variables to declare (default: empty array). Corresponds to <code>--global</code>, and similarly supports passing <code>'name:true'</code> to denote a writeable global. Note: This differs from <code>.eslintrc.*</code> / <code>baseConfig</code>, where <code>globals</code> is an object.</li><li><code>ignore</code> - False disables use of <code>.eslintignore</code>, <code>ignorePath</code> and <code>ignorePattern</code> (default: true). Corresponds to <code>--no-ignore</code>.</li><li><code>ignorePath</code> - The ignore file to use instead of <code>.eslintignore</code> (default: null). Corresponds to <code>--ignore-path</code>.</li><li><code>ignorePattern</code> - Glob patterns for paths to ignore. String or array of strings.</li><li><code>parser</code> - Specify the parser to be used (default: <code>espree</code>). Corresponds to <code>--parser</code>.</li><li><code>parserOptions</code> - An object containing parser options (default: empty object). Corresponds to <code>--parser-options</code>.</li><li><code>plugins</code> - An array of plugins to load (default: empty array). Corresponds to <code>--plugin</code>.</li><li><code>reportUnusedDisableDirectives</code> - When set to <code>true</code>, adds reported errors for unused <code>eslint-disable</code> directives when no problems would be reported in the disabled area anyway (default: false). Corresponds to <code>--report-unused-disable-directives</code>.</li><li><code>resolvePluginsRelativeTo</code> - Determines the folder where plugins should be resolved from. Should be used when an integration installs plugins and uses those plugins to lint code on behalf of the end user. Corresponds to <code>--resolve-plugins-relative-to</code>.</li><li><code>rulePaths</code> - An array of directories to load custom rules from (default: empty array). Corresponds to <code>--rulesdir</code>.</li><li><code>rules</code> - An object of rules to use (default: null). Corresponds to <code>--rule</code>.</li><li><code>useEslintrc</code> - Set to false to disable use of <code>.eslintrc</code> files (default: true). Corresponds to <code>--no-eslintrc</code>.</li><li><code>globInputPaths</code> - Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.</li></ul><p>To programmatically set <code>.eslintrc.*</code> options not supported above (such as <code>extends</code>, <code>overrides</code> and <code>settings</code>), define them in a config object passed to <code>baseConfig</code> instead.</p><p>For example:</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine;

<span class="hljs-keyword">const</span> cli = <span class="hljs-keyword">new</span> CLIEngine({
    <span class="hljs-attr">baseConfig</span>: {
        <span class="hljs-attr">extends</span>: [<span class="hljs-string">"eslint-config-shared"</span>],
        <span class="hljs-attr">settings</span>: {
            <span class="hljs-attr">sharedData</span>: <span class="hljs-string">"Hello"</span>
        }
    },
    <span class="hljs-attr">envs</span>: [<span class="hljs-string">"browser"</span>, <span class="hljs-string">"mocha"</span>],
    <span class="hljs-attr">useEslintrc</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>
    }
});
</code></pre><p>In this example, a new <code>CLIEngine</code> instance is created that extends a configuration called <code>&quot;eslint-config-shared&quot;</code>, a setting named <code>&quot;sharedData&quot;</code> and two environments (<code>&quot;browser&quot;</code> and <code>&quot;mocha&quot;</code>) are defined, loading of <code>.eslintrc</code> and <code>package.json</code> files are disabled, and the <code>semi</code> rule enabled as an error. You can then call methods on <code>cli</code> and these options will be used to perform the correct action.</p><p>Note: Currently <code>CLIEngine</code> does not validate options passed to it, but may start doing so in the future.</p><h3>CLIEngine#executeOnFiles()</h3><p>If you want to lint one or more files, use the <code>executeOnFiles()</code> method. This method accepts a single argument, which is an array of files and/or directories to traverse for files. You can pass the same values as you would using the ESLint command line interface, such as <code>&quot;.&quot;</code> to search all JavaScript files in the current directory. Here's an example:</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine;

<span class="hljs-keyword">const</span> cli = <span class="hljs-keyword">new</span> CLIEngine({
    <span class="hljs-attr">envs</span>: [<span class="hljs-string">"browser"</span>, <span class="hljs-string">"mocha"</span>],
    <span class="hljs-attr">useEslintrc</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>
    }
});

<span class="hljs-comment">// lint myfile.js and all files in lib/</span>
<span class="hljs-keyword">const</span> report = cli.executeOnFiles([<span class="hljs-string">"myfile.js"</span>, <span class="hljs-string">"lib/"</span>]);
</code></pre><p>The return value is an object containing the results of the linting operation. Here's an example of a report object:</p><pre class="hljs highlight-js"><code>{
    <span class="hljs-attr">results</span>: [
        {
            <span class="hljs-attr">filePath</span>: <span class="hljs-string">"/Users/eslint/project/myfile.js"</span>,
            <span class="hljs-attr">messages</span>: [{
                <span class="hljs-attr">ruleId</span>: <span class="hljs-string">"semi"</span>,
                <span class="hljs-attr">severity</span>: <span class="hljs-number">2</span>,
                <span class="hljs-attr">message</span>: <span class="hljs-string">"Missing semicolon."</span>,
                <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">column</span>: <span class="hljs-number">13</span>,
                <span class="hljs-attr">nodeType</span>: <span class="hljs-string">"ExpressionStatement"</span>,
                <span class="hljs-attr">fix</span>: { <span class="hljs-attr">range</span>: [<span class="hljs-number">12</span>, <span class="hljs-number">12</span>], <span class="hljs-attr">text</span>: <span class="hljs-string">";"</span> }
            }, {
                <span class="hljs-attr">ruleId</span>: <span class="hljs-string">"no-useless-escape"</span>,
                <span class="hljs-attr">severity</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">message</span>: <span class="hljs-string">"disallow unnecessary escape characters"</span>,
                <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">column</span>: <span class="hljs-number">10</span>,
                <span class="hljs-attr">nodeType</span>: <span class="hljs-string">"ExpressionStatement"</span>,
                <span class="hljs-attr">suggestions</span>: [{
                    <span class="hljs-attr">desc</span>: <span class="hljs-string">"Remove unnecessary escape. This maintains the current functionality."</span>,
                    <span class="hljs-attr">fix</span>: { <span class="hljs-attr">range</span>: [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>], <span class="hljs-attr">text</span>: <span class="hljs-string">""</span> }
                }, {
                    <span class="hljs-attr">desc</span>: <span class="hljs-string">"Escape backslash to include it in the RegExp."</span>,
                    <span class="hljs-attr">fix</span>: { <span class="hljs-attr">range</span>: [<span class="hljs-number">9</span>, <span class="hljs-number">9</span>], <span class="hljs-attr">text</span>: <span class="hljs-string">"\\"</span> }
                }]
            }],
            <span class="hljs-attr">errorCount</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">warningCount</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">fixableErrorCount</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">fixableWarningCount</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">source</span>: <span class="hljs-string">"\"use strict\"\n"</span>
        }
    ],
    <span class="hljs-attr">errorCount</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">warningCount</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">fixableErrorCount</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">fixableWarningCount</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">usedDeprecatedRules</span>: []
}
</code></pre><p>You can also pass <code>fix: true</code> when instantiating the <code>CLIEngine</code> in order to have it figure out what fixes can be applied.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine;

<span class="hljs-keyword">const</span> cli = <span class="hljs-keyword">new</span> CLIEngine({
    <span class="hljs-attr">envs</span>: [<span class="hljs-string">"browser"</span>, <span class="hljs-string">"mocha"</span>],
    <span class="hljs-attr">fix</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// difference from last example</span>
    <span class="hljs-attr">useEslintrc</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">quotes</span>: [<span class="hljs-number">2</span>, <span class="hljs-string">"double"</span>]
    }
});

<span class="hljs-comment">// lint myfile.js and all files in lib/</span>
<span class="hljs-keyword">const</span> report = cli.executeOnFiles([<span class="hljs-string">"myfile.js"</span>, <span class="hljs-string">"lib/"</span>]);
</code></pre><pre class="hljs highlight-js"><code>{
    <span class="hljs-attr">results</span>: [
        {
            <span class="hljs-attr">filePath</span>: <span class="hljs-string">"/Users/eslint/project/myfile.js"</span>,
            <span class="hljs-attr">messages</span>: [
                {
                    <span class="hljs-attr">ruleId</span>: <span class="hljs-string">"semi"</span>,
                    <span class="hljs-attr">severity</span>: <span class="hljs-number">2</span>,
                    <span class="hljs-attr">message</span>: <span class="hljs-string">"Missing semicolon."</span>,
                    <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
                    <span class="hljs-attr">column</span>: <span class="hljs-number">13</span>,
                    <span class="hljs-attr">nodeType</span>: <span class="hljs-string">"ExpressionStatement"</span>,
                    <span class="hljs-attr">fix</span>: { <span class="hljs-attr">range</span>: [<span class="hljs-number">12</span>, <span class="hljs-number">12</span>], <span class="hljs-attr">text</span>: <span class="hljs-string">";"</span> }
                },
                {
                    <span class="hljs-attr">ruleId</span>: <span class="hljs-string">"func-name-matching"</span>,
                    <span class="hljs-attr">severity</span>: <span class="hljs-number">2</span>,
                    <span class="hljs-attr">message</span>: <span class="hljs-string">"Function name `bar` should match variable name `foo`"</span>,
                    <span class="hljs-attr">line</span>: <span class="hljs-number">2</span>,
                    <span class="hljs-attr">column</span>: <span class="hljs-number">5</span>,
                    <span class="hljs-attr">nodeType</span>: <span class="hljs-string">"VariableDeclarator"</span>
                }
            ],
            <span class="hljs-attr">errorCount</span>: <span class="hljs-number">2</span>,
            <span class="hljs-attr">warningCount</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">fixableErrorCount</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">fixableWarningCount</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">output</span>: <span class="hljs-string">"\"use strict\";\nvar foo = function bar() {};\nfoo();\n"</span>
        }
    ],
    <span class="hljs-attr">errorCount</span>: <span class="hljs-number">2</span>,
    <span class="hljs-attr">warningCount</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">fixableErrorCount</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">fixableWarningCount</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">usedDeprecatedRules</span>: []
}
</code></pre><p>If the operation ends with a parsing error, you will get a single message for this file, with <code>fatal: true</code> added as an extra property.</p><pre class="hljs highlight-js"><code>{
    <span class="hljs-attr">results</span>: [
        {
            <span class="hljs-attr">filePath</span>: <span class="hljs-string">"./myfile.js"</span>,
            <span class="hljs-attr">messages</span>: [
                {
                    <span class="hljs-attr">ruleId</span>: <span class="hljs-literal">null</span>,
                    <span class="hljs-attr">fatal</span>: <span class="hljs-literal">true</span>,
                    <span class="hljs-attr">severity</span>: <span class="hljs-number">2</span>,
                    <span class="hljs-attr">message</span>: <span class="hljs-string">"Parsing error: Unexpected token foo"</span>,
                    <span class="hljs-attr">line</span>: <span class="hljs-number">1</span>,
                    <span class="hljs-attr">column</span>: <span class="hljs-number">10</span>
                }
            ],
            <span class="hljs-attr">errorCount</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">warningCount</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">fixableErrorCount</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">fixableWarningCount</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">source</span>: <span class="hljs-string">"function foo() {}"</span>
        }
    ],
    <span class="hljs-attr">errorCount</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">warningCount</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">fixableErrorCount</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">fixableWarningCount</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">usedDeprecatedRules</span>: []
}
</code></pre><p>The top-level report object has a <code>results</code> array containing all linting results for files that had warnings or errors (any files that did not produce a warning or error are omitted). Each file result includes:</p><ul><li><code>filePath</code> - Path to the given file.</li><li><code>messages</code> - Array containing the result of calling <code>linter.verify()</code> on the given file.</li><li><code>errorCount</code> and <code>warningCount</code> - The exact number of errors and warnings respectively on the given file.</li><li><code>source</code> - The source code for the given file. This property is omitted if this file has no errors/warnings or if the <code>output</code> property is present.</li><li><code>output</code> - The source code for the given file with as many fixes applied as possible, so you can use that to rewrite the files if necessary. This property is omitted if no fix is available.</li></ul><p>The top-level report object also has <code>errorCount</code> and <code>warningCount</code> which give the exact number of errors and warnings respectively on all the files. Additionally, <code>usedDeprecatedRules</code> signals any deprecated rules used and their replacement (if available). Specifically, it is array of objects with properties like so:</p><ul><li><code>ruleId</code> - The name of the rule (e.g. <code>indent-legacy</code>).</li><li><code>replacedBy</code> - An array of rules that replace the deprecated rule (e.g. <code>[&quot;indent&quot;]</code>).</li></ul><p>Once you get a report object, it's up to you to determine how to output the results. Fixes will not be automatically applied to the files, even if you set <code>fix: true</code> when constructing the <code>CLIEngine</code> instance. To apply fixes to the files, call <a href="#cliengineoutputfixes"><code>outputFixes</code></a>.</p><h3>CLIEngine#resolveFileGlobPatterns()</h3><p>You can pass filesystem-style or glob patterns to ESLint and have it function properly. In order to achieve this, ESLint must resolve non-glob patterns into glob patterns before determining which files to execute on. The <code>resolveFileGlobPatterns()</code> methods uses the current settings from <code>CLIEngine</code> to resolve non-glob patterns into glob patterns. Pass an array of patterns that might be passed to the ESLint CLI and it will return an array of glob patterns that mean the same thing. Here's an example:</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine;

<span class="hljs-keyword">const</span> cli = <span class="hljs-keyword">new</span> CLIEngine({
});

<span class="hljs-comment">// pass an array of patterns</span>
<span class="hljs-keyword">const</span> globPatterns = cli.resolveFileGlobPatterns([<span class="hljs-string">"."</span>]);
<span class="hljs-built_in">console</span>.log(globPatterns[i]);       <span class="hljs-comment">// ["**/*.js"]</span>
</code></pre><h3>CLIEngine#getConfigForFile()</h3><p>If you want to retrieve a configuration object for a given file, use the <code>getConfigForFile()</code> method. This method accepts one argument, a file path, and returns an object represented the calculated configuration of the file. Here's an example:</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine;

<span class="hljs-keyword">const</span> cli = <span class="hljs-keyword">new</span> CLIEngine({
    <span class="hljs-attr">envs</span>: [<span class="hljs-string">"browser"</span>, <span class="hljs-string">"mocha"</span>],
    <span class="hljs-attr">useEslintrc</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>
    }
});

<span class="hljs-keyword">const</span> config = cli.getConfigForFile(<span class="hljs-string">"myfile.js"</span>);
</code></pre><p>Once you have the configuration information, you can pass it into the <code>linter</code> object:</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine,
    Linter = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).Linter;

<span class="hljs-keyword">const</span> linter = <span class="hljs-keyword">new</span> Linter();
<span class="hljs-keyword">const</span> cli = <span class="hljs-keyword">new</span> CLIEngine({
    <span class="hljs-attr">envs</span>: [<span class="hljs-string">"browser"</span>, <span class="hljs-string">"mocha"</span>],
    <span class="hljs-attr">useEslintrc</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>
    }
});

<span class="hljs-keyword">const</span> config = cli.getConfigForFile(<span class="hljs-string">"myfile.js"</span>);

<span class="hljs-keyword">const</span> messages = linter.verify(<span class="hljs-string">'var foo;'</span>, config);
</code></pre><h3>CLIEngine#executeOnText()</h3><p>If you already have some text to lint, then you can use the <code>executeOnText()</code> method to lint that text. The linter will assume that the text is a file in the current working directory, and so will still obey any <code>.eslintrc</code> and <code>.eslintignore</code> files that may be present. Here's an example:</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine;

<span class="hljs-keyword">const</span> cli = <span class="hljs-keyword">new</span> CLIEngine({
    <span class="hljs-attr">envs</span>: [<span class="hljs-string">"browser"</span>, <span class="hljs-string">"mocha"</span>],
    <span class="hljs-attr">useEslintrc</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>
    }
});

<span class="hljs-comment">// Lint the supplied text and optionally set a filename that is displayed in the report</span>
<span class="hljs-keyword">const</span> report = cli.executeOnText(<span class="hljs-string">"var foo = 'bar';"</span>, <span class="hljs-string">"foo.js"</span>);

<span class="hljs-comment">// In addition to the above, warn if the resolved file name is ignored.</span>
<span class="hljs-keyword">const</span> reportAndWarnOnIgnoredFile = cli.executeOnText(<span class="hljs-string">"var foo = 'bar';"</span>, <span class="hljs-string">"foo.js"</span>, <span class="hljs-literal">true</span>);
</code></pre><p>The <code>report</code> returned from <code>executeOnText()</code> is in the same format as from <code>executeOnFiles()</code>, but there is only ever one result in <code>report.results</code>.</p><p>If a filename in the optional second parameter matches a file that is configured to be ignored, then this function returns no errors or warnings. The method includes an additional optional boolean third parameter. When <code>true</code>, a resolved file name that is ignored will return a warning.</p><h3>CLIEngine#addPlugin()</h3><p>Loads a plugin from configuration object with specified name. Name can include plugin prefix (&quot;eslint-plugin-&quot;)</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine;
<span class="hljs-keyword">const</span> cli = <span class="hljs-keyword">new</span> CLIEngine({
    <span class="hljs-attr">ignore</span>: <span class="hljs-literal">true</span>
});
cli.addPlugin(<span class="hljs-string">"eslint-plugin-processor"</span>, {
    <span class="hljs-attr">processors</span>: {
        <span class="hljs-string">".txt"</span>: {
            <span class="hljs-attr">preprocess</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) </span>{
                <span class="hljs-keyword">return</span> [text];
            },
            <span class="hljs-attr">postprocess</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">messages</span>) </span>{
                <span class="hljs-keyword">return</span> messages[<span class="hljs-number">0</span>];
            }
        }
    }
});
</code></pre><h3>CLIEngine#isPathIgnored()</h3><p>Checks if a given path is ignored by ESLint.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine;

<span class="hljs-keyword">const</span> cli = <span class="hljs-keyword">new</span> CLIEngine({
    <span class="hljs-attr">ignore</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">ignorePath</span>: <span class="hljs-string">".customIgnoreFile"</span>
});

<span class="hljs-keyword">const</span> isIgnored = cli.isPathIgnored(<span class="hljs-string">"foo/bar.js"</span>);
</code></pre><h3>CLIEngine#getFormatter()</h3><p>Retrieves a formatter, which you can then use to format a report object. The argument is either the name of a built-in formatter:</p><ul><li>&quot;<a href="../user-guide/formatters#checkstyle">checkstyle</a>&quot;</li><li>&quot;<a href="../user-guide/formatters#codeframe">codeframe</a>&quot;</li><li>&quot;<a href="../user-guide/formatters#compact">compact</a>&quot;</li><li>&quot;<a href="../user-guide/formatters#html">html</a>&quot;</li><li>&quot;<a href="../user-guide/formatters#jslint-xml">jslint-xml</a>&quot;</li><li>&quot;<a href="../user-guide/formatters#json">json</a>&quot;</li><li>&quot;<a href="../user-guide/formatters#junit">junit</a>&quot;</li><li>&quot;<a href="../user-guide/formatters#stylish">stylish</a>&quot; (the default)</li><li>&quot;<a href="../user-guide/formatters#table">table</a>&quot;</li><li>&quot;<a href="../user-guide/formatters#tap">tap</a>&quot;</li><li>&quot;<a href="../user-guide/formatters#unix">unix</a>&quot;</li><li>&quot;<a href="../user-guide/formatters#visualstudio">visualstudio</a>&quot;</li></ul><p>or the full path to a JavaScript file containing a custom formatter. You can also omit the argument to retrieve the default formatter.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine;

<span class="hljs-keyword">const</span> cli = <span class="hljs-keyword">new</span> CLIEngine({
    <span class="hljs-attr">envs</span>: [<span class="hljs-string">"browser"</span>, <span class="hljs-string">"mocha"</span>],
    <span class="hljs-attr">useEslintrc</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>
    }
});

<span class="hljs-comment">// lint myfile.js and all files in lib/</span>
<span class="hljs-keyword">const</span> report = cli.executeOnFiles([<span class="hljs-string">"myfile.js"</span>, <span class="hljs-string">"lib/"</span>]);

<span class="hljs-comment">// get the default formatter</span>
<span class="hljs-keyword">const</span> formatter = cli.getFormatter();

<span class="hljs-comment">// Also could do...</span>
<span class="hljs-comment">// const formatter = cli.getFormatter("compact");</span>
<span class="hljs-comment">// const formatter = cli.getFormatter("./my/formatter.js");</span>

<span class="hljs-comment">// output to console</span>
<span class="hljs-built_in">console</span>.log(formatter(report.results));
</code></pre><p><strong>Note:</strong> Also available as a static function on <code>CLIEngine</code>.</p><pre class="hljs highlight-js"><code><span class="hljs-comment">// get the default formatter by calling the static function</span>
<span class="hljs-keyword">const</span> formatter = CLIEngine.getFormatter();
</code></pre><p><strong>Important:</strong> You must pass in the <code>results</code> property of the report. Passing in <code>report</code> directly will result in an error.</p><h3>CLIEngine#getErrorResults()</h3><p>This is a static function on <code>CLIEngine</code>. It can be used to filter out all the non error messages from the report object.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine;

<span class="hljs-keyword">const</span> cli = <span class="hljs-keyword">new</span> CLIEngine({
    <span class="hljs-attr">envs</span>: [<span class="hljs-string">"browser"</span>, <span class="hljs-string">"mocha"</span>],
    <span class="hljs-attr">useEslintrc</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>
    }
});

<span class="hljs-comment">// lint myfile.js and all files in lib/</span>
<span class="hljs-keyword">const</span> report = cli.executeOnFiles([<span class="hljs-string">"myfile.js"</span>, <span class="hljs-string">"lib/"</span>]);

<span class="hljs-comment">// only get the error messages</span>
<span class="hljs-keyword">const</span> errorReport = CLIEngine.getErrorResults(report.results)
</code></pre><p><strong>Important:</strong> You must pass in the <code>results</code> property of the report. Passing in <code>report</code> directly will result in an error.</p><h3>CLIEngine#outputFixes()</h3><p>This is a static function on <code>CLIEngine</code> that is used to output fixes from <code>report</code> to disk. It does by looking for files that have an <code>output</code> property in their results. Here's an example:</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine;

<span class="hljs-keyword">const</span> cli = <span class="hljs-keyword">new</span> CLIEngine({
    <span class="hljs-attr">envs</span>: [<span class="hljs-string">"browser"</span>, <span class="hljs-string">"mocha"</span>],
    <span class="hljs-attr">fix</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">useEslintrc</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">rules</span>: {
        <span class="hljs-attr">semi</span>: <span class="hljs-number">2</span>
    }
});

<span class="hljs-comment">// lint myfile.js and all files in lib/</span>
<span class="hljs-keyword">const</span> report = cli.executeOnFiles([<span class="hljs-string">"myfile.js"</span>, <span class="hljs-string">"lib/"</span>]);

<span class="hljs-comment">// output fixes to disk</span>
CLIEngine.outputFixes(report);
</code></pre><h3>CLIEngine#getRules()</h3><p>This method returns a map of all loaded rules. Under the hood, it calls <a href="#lintergetrules">Linter#getRules</a>.</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> CLIEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine;
<span class="hljs-keyword">const</span> cli = <span class="hljs-keyword">new</span> CLIEngine();

cli.getRules();

<span class="hljs-comment">/*
Map {
  'accessor-pairs' =&gt; { meta: { docs: [Object], schema: [Array] }, create: [Function: create] },
  'array-bracket-newline' =&gt; { meta: { docs: [Object], schema: [Array] }, create: [Function: create] },
  ...
}
*/</span>
</code></pre><h3>CLIEngine.version</h3><p><code>CLIEngine</code> has a static <code>version</code> property containing the semantic version number of ESLint that it comes from.</p><pre class="hljs highlight-js"><code><span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).CLIEngine.version; <span class="hljs-comment">// '4.5.0'</span>
</code></pre><h2>RuleTester</h2><p><code>eslint.RuleTester</code> is a utility to write tests for ESLint rules. It is used internally for the bundled rules that come with ESLint, and it can also be used by plugins.</p><p>Example usage:</p><pre class="hljs highlight-js"><code><span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">const</span> rule = <span class="hljs-built_in">require</span>(<span class="hljs-string">"../../../lib/rules/my-rule"</span>),
    RuleTester = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).RuleTester;

<span class="hljs-keyword">const</span> ruleTester = <span class="hljs-keyword">new</span> RuleTester();

ruleTester.run(<span class="hljs-string">"my-rule"</span>, rule, {
    <span class="hljs-attr">valid</span>: [
        {
            <span class="hljs-attr">code</span>: <span class="hljs-string">"var foo = true"</span>,
            <span class="hljs-attr">options</span>: [{ <span class="hljs-attr">allowFoo</span>: <span class="hljs-literal">true</span> }]
        }
    ],

    <span class="hljs-attr">invalid</span>: [
        {
            <span class="hljs-attr">code</span>: <span class="hljs-string">"var invalidVariable = true"</span>,
            <span class="hljs-attr">errors</span>: [{ <span class="hljs-attr">message</span>: <span class="hljs-string">"Unexpected invalid variable."</span> }]
        },
        {
            <span class="hljs-attr">code</span>: <span class="hljs-string">"var invalidVariable = true"</span>,
            <span class="hljs-attr">errors</span>: [{ <span class="hljs-attr">message</span>: <span class="hljs-regexp">/^Unexpected.+variable/</span> }]
        }
    ]
});
</code></pre><p>The <code>RuleTester</code> constructor accepts an optional object argument, which can be used to specify defaults for your test cases. For example, if all of your test cases use ES2015, you can set it as a default:</p><pre class="hljs highlight-js"><code><span class="hljs-keyword">const</span> ruleTester = <span class="hljs-keyword">new</span> RuleTester({ <span class="hljs-attr">parserOptions</span>: { <span class="hljs-attr">ecmaVersion</span>: <span class="hljs-number">2015</span> } });
</code></pre><p>The <code>RuleTester#run()</code> method is used to run the tests. It should be passed the following arguments:</p><ul><li>The name of the rule (string)</li><li>The rule object itself (see <a href="./working-with-rules">&quot;working with rules&quot;</a>)</li><li>An object containing <code>valid</code> and <code>invalid</code> properties, each of which is an array containing test cases.</li></ul><p>A test case is an object with the following properties:</p><ul><li><code>code</code> (string, required): The source code that the rule should be run on</li><li><code>options</code> (array, optional): The options passed to the rule. The rule severity should not be included in this list.</li><li><code>filename</code> (string, optional): The filename for the given case (useful for rules that make assertions about filenames).</li></ul><p>In addition to the properties above, invalid test cases can also have the following properties:</p><ul><li><p><code>errors</code> (number or array, required): Asserts some properties of the errors that the rule is expected to produce when run on this code. If this is a number, asserts the number of errors produced. Otherwise, this should be a list of objects, each containing information about a single reported error. The following properties can be used for an error (all are optional):</p><ul><li><code>message</code> (string/regexp): The message for the error</li><li><code>type</code> (string): The type of the reported AST node</li><li><code>line</code> (number): The 1-based line number of the reported location</li><li><code>column</code> (number): The 1-based column number of the reported location</li><li><code>endLine</code> (number): The 1-based line number of the end of the reported location</li><li><code>endColumn</code> (number): The 1-based column number of the end of the reported location</li><li><code>suggestions</code> (array): An array of objects with suggestion details to check. See <a href="#testing-suggestions">Testing Suggestions</a> for details</li></ul><p>If a string is provided as an error instead of an object, the string is used to assert the <code>message</code> of the error.</p></li><li><p><code>output</code> (string, optional): Asserts the output that will be produced when using this rule for a single pass of autofixing (e.g. with the <code>--fix</code> command line flag). If this is <code>null</code>, asserts that none of the reported problems suggest autofixes.</p></li></ul><p>Any additional properties of a test case will be passed directly to the linter as config options. For example, a test case can have a <code>parserOptions</code> property to configure parser behavior:</p><pre class="hljs highlight-js"><code>{
    <span class="hljs-attr">code</span>: <span class="hljs-string">"let foo;"</span>,
    <span class="hljs-attr">parserOptions</span>: { <span class="hljs-attr">ecmaVersion</span>: <span class="hljs-number">2015</span> }
}
</code></pre><p>If a valid test case only uses the <code>code</code> property, it can optionally be provided as a string containing the code, rather than an object with a <code>code</code> key.</p><h4>Testing Suggestions</h4><p>Suggestions can be tested by defining a <code>suggestions</code> key on an errors object. The options to check for the suggestions are the following (all are optional): * <code>desc</code> (string): The suggestion <code>desc</code> value * <code>messageId</code> (string): The suggestion <code>messageId</code> value for suggestions that use <code>messageId</code>s * <code>output</code> (string): A code string representing the result of applying the suggestion fix to the input code</p><p>Example:</p><pre class="hljs highlight-js"><code>ruleTester.run(<span class="hljs-string">"my-rule-for-no-foo"</span>, rule, {
    <span class="hljs-attr">valid</span>: [],
    <span class="hljs-attr">invalid</span>: [{
        <span class="hljs-attr">code</span>: <span class="hljs-string">"var foo;"</span>,
        <span class="hljs-attr">errors</span>: [{
            <span class="hljs-attr">suggestions</span>: [{
                <span class="hljs-attr">desc</span>: <span class="hljs-string">"Rename identifier 'foo' to 'bar'"</span>,
                <span class="hljs-attr">messageId</span>: <span class="hljs-string">"renameFoo"</span>,
                <span class="hljs-attr">output</span>: <span class="hljs-string">"var bar;"</span>
            }]
        }]
    }]
})
</code></pre><h3>Customizing RuleTester</h3><p><code>RuleTester</code> depends on two functions to run tests: <code>describe</code> and <code>it</code>. These functions can come from various places:</p><ol><li>If <code>RuleTester.describe</code> and <code>RuleTester.it</code> have been set to function values, <code>RuleTester</code> will use <code>RuleTester.describe</code> and <code>RuleTester.it</code> to run tests. You can use this to customize the behavior of <code>RuleTester</code> to match a test framework that you're using.</li><li>Otherwise, if <code>describe</code> and <code>it</code> are present as globals, <code>RuleTester</code> will use <code>global.describe</code> and <code>global.it</code> to run tests. This allows <code>RuleTester</code> to work when using frameworks like <a href="https://mochajs.org/">Mocha</a> without any additional configuration.</li><li>Otherwise, <code>RuleTester#run</code> will simply execute all of the tests in sequence, and will throw an error if one of them fails. This means you can simply execute a test file that calls <code>RuleTester.run</code> using <code>node</code>, without needing a testing framework.</li></ol><p><code>RuleTester#run</code> calls the <code>describe</code> function with two arguments: a string describing the rule, and a callback function. The callback calls the <code>it</code> function with a string describing the test case, and a test function. The test function will return successfully if the test passes, and throw an error if the test fails. (Note that this is the standard behavior for test suites when using frameworks like <a href="https://mochajs.org/">Mocha</a>; this information is only relevant if you plan to customize <code>RuleTester.it</code> and <code>RuleTester.describe</code>.)</p><p>Example of customizing <code>RuleTester</code>:</p><pre class="hljs highlight-js"><code><span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">const</span> RuleTester = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eslint"</span>).RuleTester,
    test = <span class="hljs-built_in">require</span>(<span class="hljs-string">"my-test-runner"</span>),
    myRule = <span class="hljs-built_in">require</span>(<span class="hljs-string">"../../../lib/rules/my-rule"</span>);

RuleTester.describe = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text, method</span>) </span>{
    RuleTester.it.title = text;
    <span class="hljs-keyword">return</span> method.call(<span class="hljs-keyword">this</span>);
};

RuleTester.it = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text, method</span>) </span>{
    test(RuleTester.it.title + <span class="hljs-string">": "</span> + text, method);
};

<span class="hljs-comment">// then use RuleTester as documented</span>

<span class="hljs-keyword">const</span> ruleTester = <span class="hljs-keyword">new</span> RuleTester();

ruleTester.run(<span class="hljs-string">"my-rule"</span>, myRule, {
    <span class="hljs-attr">valid</span>: [
        <span class="hljs-comment">// valid test cases</span>
    ],
    <span class="hljs-attr">invalid</span>: [
        <span class="hljs-comment">// invalid test cases</span>
    ]
})
</code></pre><h2>Deprecated APIs</h2><ul><li><code>cli</code> - the <code>cli</code> object has been deprecated in favor of <code>CLIEngine</code>. As of v1.0.0, <code>cli</code> is no longer exported and should not be used by external tools.</li><li><code>linter</code> - the <code>linter</code> object has been deprecated in favor of <code>Linter</code> as of v4.0.0.</li></ul></article></main><hr><div class="container"><footer><ul class="list-inline"><li><a href="https://github.com/eslint/eslint/edit/master/docs/developer-guide/nodejs-api.md">Edit this page</a></li><li><a href="https://groups.google.com/group/eslint">Mailing List</a></li><li><a href="https://github.com/eslint/eslint">GitHub</a></li><li><a href="https://twitter.com/geteslint">Twitter</a></li><li><a href="/chat">Chat Room</a></li><li>Copyright OpenJS Foundation and other contributors, <a href="https://openjsf.org/">https://openjsf.org/</a></li></ul></footer></div><script src="/assets/js/main.js"></script></body></html>