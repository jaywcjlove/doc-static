{
  "id": "guide/upgrade-performance",
  "title": "Upgrading for performance",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/upgrade-performance.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"upgrading-for-performance\" translation-result=\"on\">更关注性能的升级方式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#upgrading-for-performance\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"upgrading-for-performance\">Upgrading for performance<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#upgrading-for-performance\"><i class=\"material-icons\">link</i></a></h1>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">  <em>Angular</em> 是当前以及未来的 Angular 名称。<br>\n<em>AngularJS</em> 特指 Angular 的所有 1.x 版本。</p><p translation-origin=\"off\">  <em>Angular</em> is the name for the Angular of today and tomorrow.<br>\n<em>AngularJS</em> is the name for all 1.x versions of Angular.</p>\n\n</div>\n<p translation-result=\"on\">本指南介绍了一些用来将 AngularJS 项目高效地逐块迁移到 Angular 平台上的工具。\n本章和<a href=\"guide/upgrade\">从 AngularJS 升级</a>很像，但是这里会用辅助函数 <a href=\"api/upgrade/static/downgradeModule\">downgradeModule()</a> 取代 <a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a>。这会影响到应用如何启动，以及变更检测事件如何在两个框架之间传播。\n它能让你逐步升级，并提高混合式应用的运行速度，并让你能在升级过程中尽早用上 Angular 中的最新特性。</p><p translation-origin=\"off\">This guide describes some of the built-in tools for efficiently migrating AngularJS projects over to\nthe Angular platform, one piece at a time. It is very similar to\n<a href=\"guide/upgrade\">Upgrading from AngularJS</a> with the exception that this one uses the <a href=\"api/upgrade/static/downgradeModule\">downgradeModule()</a> helper function instead of the <a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a> class. This affects how the app is bootstrapped and how change detection is\npropagated between the two frameworks. It allows you to upgrade incrementally while improving the\nspeed of your hybrid apps and leveraging the latest of Angular in AngularJS apps early in the\nprocess of upgrading.</p>\n\n<h2 id=\"preparation\" translation-result=\"on\">准备工作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#preparation\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"preparation\">Preparation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#preparation\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在讨论你应该如何用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 来创建混合式应用之前，你可以先采取一些措施来简化升级过程，甚至在开始升级之前就可以做。\n无论你用哪种方式升级，这些步骤都是一样的，请参考<a href=\"guide/upgrade\">从 AngularJS 升级</a>的<a href=\"guide/upgrade#preparation\">准备工作</a>部分。</p><p translation-origin=\"off\">Before discussing how you can use <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> to create hybrid apps, there are things that\nyou can do to ease the upgrade process even before you begin upgrading. Because the steps are the\nsame regardless of how you upgrade, refer to the <a href=\"guide/upgrade#preparation\">Preparation</a> section of\n<a href=\"guide/upgrade\">Upgrading from AngularJS</a>.</p>\n\n<h2 id=\"upgrading-with-ngupgrade\" translation-result=\"on\">使用 <code>ngUpgrade</code> 升级<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#upgrading-with-ngupgrade\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"upgrading-with-ngupgrade\">Upgrading with <code>ngUpgrade</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#upgrading-with-ngupgrade\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">使用 Angular 中的 <code>ngUpgrade</code> 库，你可以通过构建混合式应用来逐步升级现有的 AngularJS 应用。在这些混合式应用中，你可以混用 AngularJS 和 Angular 的组件与服务，并让它们天衣无缝地进行互操作。\n这意味着你不用一次性完成迁移工作，因为在过渡阶段两个框架可以自然共存。</p><p translation-origin=\"off\">With the <code>ngUpgrade</code> library in Angular you can upgrade an existing AngularJS app incrementally by\nbuilding a hybrid app where you can run both frameworks side-by-side. In these hybrid apps you can\nmix and match AngularJS and Angular components and services and have them interoperate seamlessly.\nThat means you don't have to do the upgrade work all at once as there is a natural coexistence\nbetween the two frameworks during the transition period.</p>\n\n<h3 id=\"how-ngupgrade-works\" translation-result=\"on\"><code>ngUpgrade</code> 的工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#how-ngupgrade-works\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"how-ngupgrade-works\">How <code>ngUpgrade</code> Works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#how-ngupgrade-works\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">无论选择 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 还是 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，升级的基本原则都是一样的：无论是混合式应用背后的心智模型，还是 <a href=\"api/upgrade/static\">upgrade/static</a> 的用法。\n要了解更多，参见<a href=\"guide/upgrade\">从 AngularJS 升级</a>的 <a href=\"guide/upgrade#how-ngupgrade-works\"><code>ngUpgrade</code> 工作原理</a>部分。</p><p translation-origin=\"off\">Regardless of whether you choose <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> or <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>, the basic principles of\nupgrading, the mental model behind hybrid apps, and how you use the <a href=\"api/upgrade/static\">upgrade/static</a> utilities remain the same. For more information, see the\n<a href=\"guide/upgrade#how-ngupgrade-works\">How <code>ngUpgrade</code> Works</a> section of\n<a href=\"guide/upgrade\">Upgrading from AngularJS</a>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">  <a href=\"guide/upgrade\">从 AngularJS 升级</a>中的<a href=\"guide/upgrade#change-detection\">变更检测</a>部分仅仅适用于使用 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 的应用。\n虽然你处理变更检测的方式和 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>（本章的重点）不同，不过读一下<a href=\"guide/upgrade#change-detection\">变更检测</a>部分还是能为后续内容提供一些有用的上下文知识。</p><p translation-origin=\"off\">  The <a href=\"guide/upgrade#change-detection\">Change Detection</a> section of\n<a href=\"guide/upgrade\">Upgrading from AngularJS</a> only applies to apps that use <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>. Though\nyou handle change detection differently with <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>, which is the focus of this\nguide, reading the <a href=\"guide/upgrade#change-detection\">Change Detection</a> section provides helpful\ncontext for what follows.</p>\n\n</div>\n<h4 id=\"change-detection-with-downgrademodule\" translation-result=\"on\">使用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 进行变更检测<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#change-detection-with-downgrademodule\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"change-detection-with-downgrademodule\">Change Detection with <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#change-detection-with-downgrademodule\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">如前所述，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 和 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 之间的一个关键区别，就是如何进行变更检测，以及检测结果如何在两个框架之间传播。</p><p translation-origin=\"off\">As mentioned before, one of the key differences between <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> and <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> has\nto do with change detection and how it is propagated between the two frameworks.</p>\n\n<p translation-result=\"on\">使用 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，两套变更检测系统绑得更紧密一些。\n一旦应用中的 AngularJS 部分发生了某些变化，变更检测就会自动在 Angular 部分触发它，反之亦然。\n这很方便，因为它保证了任何一个框架都不会丢失重要的变更。不过，其实大多数情况下并不需要运行这些额外的变更检测。</p><p translation-origin=\"off\">With <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>, the two change detection systems are tied together more tightly. Whenever\nsomething happens in the AngularJS part of the app, change detection is automatically triggered on\nthe Angular part and vice versa. This is convenient as it ensures that neither framework misses an\nimportant change. Most of the time, though, these extra change detection runs are unnecessary.</p>\n\n<p translation-result=\"on\">而 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 会避免显式触发变更检测，除非它确信应用的其它部分对此感兴趣。\n比如，如果被降级的组件定义了 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>，当那个值发生变化时，应用就可能需要知道。\n因此，<code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 就会自动在该组件上触发变更检测。</p><p translation-origin=\"off\"><code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>, on the other side, avoids explicitly triggering change detection unless it\nknows the other part of the app is interested in the changes. For example, if a downgraded component\ndefines an <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, chances are that the app needs to be aware when that value changes. Thus,\n<code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> automatically triggers change detection on that component.</p>\n\n<p translation-result=\"on\">但是，大多数情况下，应用的其它地方并不会关心某个组件中进行的局部更改。\n比如，如果用户点击了某个表单的提交按钮，通常会由组件自行处理这个操作的结果。\n话虽如此，但在某些情况下，你可能希望把这些变化传播到应用中由另一个框架控制的部分。\n这时候，你就有责任通过手动触发变更检测来通知相关方。</p><p translation-origin=\"off\">In most cases, though, the changes made locally in a particular component are of no interest to the\nrest of the app. For example, if the user clicks a button that submits a form, the component usually\nhandles the result of this action. That being said, there <em>are</em> cases where you want to propagate\nchanges to some other part of the app that may be controlled by the other framework. In such cases,\nyou are responsible for notifying the interested parties by manually triggering change detection.</p>\n\n<p translation-result=\"on\">如果你希望某些代码片段在应用的 AngularJS 部分触发变更检测，就要把它包在 <a href=\"https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply\">scope.$apply()</a> 中。\n同样，要想在 Angular 中触发变更检测，就要调用 <a href=\"api/core/NgZone#run\">ngZone.run()</a>。</p><p translation-origin=\"off\">If you want a particular piece of code to trigger change detection in the AngularJS part of the app,\nyou need to wrap it in\n<a href=\"https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply\">scope.$apply()</a>. Similarly, for\ntriggering change detection in Angular you would use <a href=\"api/core/NgZone#run\">ngZone.run()</a>.</p>\n\n<p translation-result=\"on\">很多情况下，是否运行额外的变更检测可能并不重要。不过，在较大或变更检测较多的应用中，它们可能会产生显著地影响。\n通过让你更精细的控制变更检测的传播方式，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 可以让你的混合式应用达到更好地性能。</p><p translation-origin=\"off\">In many cases, a few extra change detection runs may not matter much. However, on larger or\nchange-detection-heavy apps they can have a noticeable impact. By giving you more fine-grained\ncontrol over the change detection propagation, <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> allows you to achieve better\nperformance for your hybrid apps.</p>\n\n<h2 id=\"using-downgrademodule\" translation-result=\"on\">使用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-downgrademodule\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"using-downgrademodule\">Using <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-downgrademodule\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">AngularJS 和 Angular 都有自己的模块概念，来帮你把应用按功能组织成内聚的代码块。</p><p translation-origin=\"off\">Both AngularJS and Angular have their own concept of modules to help organize an app into cohesive\nblocks of functionality.</p>\n\n<p translation-result=\"on\">它们在架构和实现方面的细节有很大不同。在 AngularJS 中，你可以用 <a href=\"https://docs.angularjs.org/api/ng/function/angular.module\">angular.module()</a> 指定名字和依赖，以创建一个模块。\n然后，你可以使用它的各种方法添加资产。在 Angular 中，你要创建一个带有 <a href=\"api/core/NgModule\">NgModule</a> 装饰器的类，靠这个装饰器的元数据来描述这些资产。</p><p translation-origin=\"off\">Their details are quite different in architecture and implementation. In AngularJS, you create a\nmodule by specifying its name and dependencies with\n<a href=\"https://docs.angularjs.org/api/ng/function/angular.module\">angular.module()</a>. Then you can add\nassets using its various methods. In Angular, you create a class adorned with an <a href=\"api/core/NgModule\">NgModule</a> decorator that describes assets in metadata.</p>\n\n<p translation-result=\"on\">在混合式应用中，你同时运行着两个框架。这意味着你至少需要一个来自 AngularJS 的模块和一个来自 Angular 的模块。</p><p translation-origin=\"off\">In a hybrid app you run both frameworks at the same time. This means that you need at least one\nmodule each from both AngularJS and Angular.</p>\n\n<p translation-result=\"on\">大多数情况下，你可以使用与常规应用程序相同的方式来指定模块。然后，使用 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 辅助函数来让两个框架了解对方使用的资产。这叫做\"升级（upgrading）\"和\"降级（downgrading）\"。</p><p translation-origin=\"off\">For the most part, you specify the modules in the same way you would for a regular app. Then, you\nuse the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> helpers to let the two frameworks know about assets they can use from each\nother. This is known as \"upgrading\" and \"downgrading\".</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">  <b>定义：</b></p><p translation-origin=\"off\">  <b>Definitions:</b></p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><em>升级</em>：让 AngularJS 中的资产，比如组件或服务，可用于应用中的 Angular 部分。</p><p translation-origin=\"off\"><em>Upgrading</em>: The act of making an AngularJS asset, such as a component or service, available to\nthe Angular part of the app.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><em>降级</em>：让 Angular 中的资产，比如组件或服务，可用于应用中的 AngularJS 部分</p><p translation-origin=\"off\"><em>Downgrading</em>: The act of making an Angular asset, such as a component or service, available to\nthe AngularJS part of the app.</p>\n\n</li>\n</ul>\n</div>\n<p translation-result=\"on\">依赖互联中最重要的部分之一是把两个主模块联结在一起。这就是 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 的用武之地。使用它来创建 AngularJS 模块（你可以在 AngularJS 主模块中把这个模块用作依赖项），该模块将引导你的 Angular 主模块，并启动混合式应用中的 Angular 部分。从某种意义上说，它把 NgModule \"降级\"成了 AngularJS 模块。</p><p translation-origin=\"off\">An important part of inter-linking dependencies is linking the two main modules together. This is\nwhere <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> comes in. Use it to create an AngularJS module—one that you can use\nas a dependency in your main AngularJS module—that will bootstrap your main Angular module and\nkick off the Angular part of the hybrid app. In a sense, it \"downgrades\" an Angular module to an\nAngularJS module.</p>\n\n<p translation-result=\"on\">有几点需要注意：</p><p translation-origin=\"off\">There are a few things to note, though:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">你不必把 Angular 模块直接传给 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>。<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 所需要的只是一个用来创建模块实例 \"配方\"（比如工厂函数）。</p><p translation-origin=\"off\">You don't pass the Angular module directly to <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>. All <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> needs\nis a \"recipe\", for example, a factory function, to create an instance for your module.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">除非应用实际用到了，否则不会初始化这个 Angular 模块。</p><p translation-origin=\"off\">The Angular module is not instantiated until the app actually needs it.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">下面是如何使用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 来联结两个模块的例子。</p><p translation-origin=\"off\">The following is an example of how you can use <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> to link the two modules.</p>\n\n<code-example language=\"ts\">\n// Import `<a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()`.\nimport { <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n// Use it to downgrade the Angular module to an AngularJS module.\nconst downgradedModule = <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>(MainAngularModuleFactory);\n\n// Use the downgraded module as a dependency to the main AngularJS module.\nangular.module('mainAngularJsModule', [\n  downgradedModule\n]);\n</code-example>\n<h4 id=\"specifying-a-factory-for-the-angular-module\" translation-result=\"on\">为 Angular 模块指定一个工厂<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#specifying-a-factory-for-the-angular-module\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"specifying-a-factory-for-the-angular-module\">Specifying a factory for the Angular module<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#specifying-a-factory-for-the-angular-module\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">如前所述，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 需要知道如何实例化 Angular 模块。你可以通过提供可以创建 Angular 模块实例的工厂函数来定义该配方。\n<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 接受两种类型的工厂函数：</p><p translation-origin=\"off\">As mentioned earlier, <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> needs to know how to instantiate the Angular module. It\nneeds a recipe. You define that recipe by providing a factory function that can create an instance\nof the Angular module. <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> accepts two types of factory functions:</p>\n\n<ol>\n<li><code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code></li>\n<li><code>(extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) => Promise&#x3C;<a href=\"api/core/NgModuleRef\" class=\"code-anchor\">NgModuleRef</a>></code></li>\n</ol>\n<p translation-result=\"on\">当传入 <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code> 时，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 会把它传给 <a href=\"api/platform-browser/platformBrowser\">platformBrowser</a> 的 <a href=\"api/core/PlatformRef#bootstrapModuleFactory\">bootstrapModuleFactory()</a> 来实例化模块。它与预先（AOT）编译模式兼容。\n预先编译能让你的应用加载更快。要了解预先编译的更多知识，以及如何创建 <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code>，参见 <a href=\"guide/aot-compiler\">预先编译</a> 章。</p><p translation-origin=\"off\">When you pass an <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code>, <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> uses it to instantiate the module using\n<a href=\"api/platform-browser/platformBrowser\">platformBrowser</a>'s <a href=\"api/core/PlatformRef#bootstrapModuleFactory\">bootstrapModuleFactory()</a>, which is compatible with ahead-of-time (AOT) compilation. AOT compilation\nhelps make your apps load faster. For more about AOT and how to create an <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code>, see the\n<a href=\"guide/aot-compiler\">Ahead-of-Time Compilation</a> guide.</p>\n\n<p translation-result=\"on\">另外，你还可以传入一个普通函数，它要返回一个解析为 <a href=\"api/core/NgModuleRef\">NgModuleRef</a>（比如你的 Angular 模块） 的 Promise。该函数接收一个额外 <a href=\"api/core/StaticProvider\">Providers</a> 的数组，这个数组可以在所返回 <code><a href=\"api/core/NgModuleRef\" class=\"code-anchor\">NgModuleRef</a></code> 的 <a href=\"api/core/Injector\">Injector</a> 中可用。\n例如，如果你在使用 <a href=\"api/platform-browser/platformBrowser\">platformBrowser</a> 或 <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\">platformBrowserDynamic</a>，就可以把 <code>extraProviders</code> 数组传给它们：</p><p translation-origin=\"off\">Alternatively, you can pass a plain function, which is expected to return a promise resolving to an\n<a href=\"api/core/NgModuleRef\">NgModuleRef</a> (i.e. an instance of your Angular module). The function is called\nwith an array of extra <a href=\"api/core/StaticProvider\">Providers</a> that are expected to be available on the\nreturned <code><a href=\"api/core/NgModuleRef\" class=\"code-anchor\">NgModuleRef</a></code>'s <a href=\"api/core/Injector\">Injector</a>. For example, if you are using <a href=\"api/platform-browser/platformBrowser\">platformBrowser</a> or <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\">platformBrowserDynamic</a>, you can\npass the <code>extraProviders</code> array to them:</p>\n\n<code-example language=\"ts\">\nconst bootstrapFn = (extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) => {\n  const platformRef = <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>(extraProviders);\n  return platformRef.bootstrapModule(MainAngularModule);\n};\n// or\nconst bootstrapFn = (extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) => {\n  const platformRef = <a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>(extraProviders);\n  return platformRef.bootstrapModuleFactory(MainAngularModuleFactory);\n};\n</code-example>\n<p translation-result=\"on\">使用 <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code> 需要更少的样板代码，并且是一个很好的默认选项，因为它支持 AOT 开箱即用。\n使用自定义函数需要稍多的代码，但是给你提供了更大的灵活性。</p><p translation-origin=\"off\">Using an <code><a href=\"api/core/NgModuleFactory\" class=\"code-anchor\">NgModuleFactory</a></code> requires less boilerplate and is a good default option as it supports AOT\nout-of-the-box. Using a custom function requires slightly more code, but gives you greater\nflexibility.</p>\n\n<h4 id=\"instantiating-the-angular-module-on-demand\" translation-result=\"on\">按需实例化 Angular 模块<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#instantiating-the-angular-module-on-demand\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"instantiating-the-angular-module-on-demand\">Instantiating the Angular module on-demand<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#instantiating-the-angular-module-on-demand\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\"><code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 和 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 之间的另一个关键区别，就是后者要求你预先实例化 AngularJS 和 Angular 的模块。\n这意味着你必须为实例化应用中的 Angular 而付出代价 —— 即使你以后不会用到任何 Angular 资产。\n<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 则不那么激进。它只会在第一次用到时才实例化 Angular 部分，也就是说，当它需要实例化一个降级后的组件时。</p><p translation-origin=\"off\">Another key difference between <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> and <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> is that the latter requires\nyou to instantiate both the AngularJS and Angular modules up-front. This means that you have to pay\nthe cost of instantiating the Angular part of the app, even if you don't use any Angular assets\nuntil later. <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> is again less aggressive. It will only instantiate the Angular part\nwhen it is required for the first time; that is, as soon as it needs to create a downgraded\ncomponent.</p>\n\n<p translation-result=\"on\">你还可以更进一步，甚至不必将应用程序中 Angular 部分的代码下载到用户的浏览器中 —— 直到需要它的那一刻。\n当不需要初始渲染或用户尚未访问到混合式应用中的 Angular 部分时，这特别有用。</p><p translation-origin=\"off\">You could go a step further and not even download the code for the Angular part of the app to the\nuser's browser until it is needed. This is especially useful when you use Angular on parts of the\nhybrid app that are not necessary for the initial rendering or that the user doesn't reach.</p>\n\n<p translation-result=\"on\">举一些例子：</p><p translation-origin=\"off\">A few examples are:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">你只想在特定的路由上使用 Angular，除非用户访问此路由，否则你不需要它。</p><p translation-origin=\"off\">You use Angular on specific routes only and you don't need it until/if a user visits such a route.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你可以将 Angular 用于仅对特定类型的用户可见的特性，比如：登录用户、管理员或 VIP 成员。这样在用户通过了身份验证之前，你都无需加载 Angular。</p><p translation-origin=\"off\">You use Angular for features that are only visible to specific types of users; for example,\nlogged-in users, administrators, or VIP members. You don't need to load Angular until a user is\nauthenticated.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你可以把 Angular 用于应用中那些在初始渲染时不太重要的特性，并且愿意为了更好地初始加载性能，而忍受加载该特性时的一点延迟。</p><p translation-origin=\"off\">You use Angular for a feature that is not critical for the initial rendering of the app and you\ncan afford a small delay in favor of better initial load performance.</p>\n\n</li>\n</ul>\n<h3 id=\"bootstrapping-with-downgrademodule\" translation-result=\"on\">通过 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 启动<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#bootstrapping-with-downgrademodule\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"bootstrapping-with-downgrademodule\">Bootstrapping with <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#bootstrapping-with-downgrademodule\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">你可能已经猜到了，你不需要修改引导现有 AngularJS 应用的方式。<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 需要一些额外的步骤，但 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 能自行引导 Angular 模块，你只要为它提供配方即可。</p><p translation-origin=\"off\">As you might have guessed, you don't need to change anything in the way you bootstrap your existing\nAngularJS app. Unlike <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>—which requires some extra steps—\n<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> is able to take care of bootstrapping the Angular module, as long as you provide\nthe recipe.</p>\n\n<p translation-result=\"on\">要开始使用任何 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> API，你仍然要像在普通 Angular 应用中一样加载 Angular 框架。要想用 SystemJS 做到这一点，你可以遵循<a href=\"guide/upgrade-setup\" title=\"Setup for Upgrading from AngularJS\">升级的准备工作</a>中的指导，有选择的从<a href=\"https://github.com/angular/quickstart\">快速上手项目的 Github 仓库</a>中复制代码。</p><p translation-origin=\"off\">In order to start using any <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> APIs, you still need to load the Angular framework as\nyou would in a normal Angular app. You can see how this can be done with SystemJS by following the\ninstructions in the <a href=\"guide/upgrade-setup\" title=\"Setup for Upgrading from AngularJS\">Upgrade Setup</a> guide, selectively copying code from the\n<a href=\"https://github.com/angular/quickstart\">QuickStart github repository</a>.</p>\n\n<p translation-result=\"on\">你还需要用 <code>npm install @angular/upgrade --save</code> 安装 <code>@angular/upgrade</code> 包，并添加一个指向 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 包的映射：</p><p translation-origin=\"off\">You also need to install the <code>@angular/upgrade</code> package via <code>npm install @angular/upgrade --save</code>\nand add a mapping for the <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> package:</p>\n\n<code-example header=\"system.config.js\">\n'@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/bundles/upgrade-static.umd.js',\n</code-example>\n<p translation-result=\"on\">接下来，创建一个 <code>app.module.ts</code> 文件，并添加如下 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 类：</p><p translation-origin=\"off\">Next, create an <code>app.module.ts</code> file and add the following <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> class:</p>\n\n<code-example header=\"app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>\n  ]\n})\nexport class MainAngularModule {\n  // Empty placeholder method to satisfy the `<a href=\"api/core/Compiler\" class=\"code-anchor\">Compiler</a>`.\n  ngDoBootstrap() {}\n}\n</code-example>\n<p translation-result=\"on\">这个最小的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 导入了 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>，Angular 每个基于浏览器的应用都会导入该模块。\n它还定义了一个空的 <code>ngDoBootstrap()</code> 方法，来防止 <a href=\"api/core/Compiler\">Compiler</a> 返回错误。\n在这里它是必要的，因为 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 装饰器上还没有声明 <code>bootstrap</code>。</p><p translation-origin=\"off\">This bare minimum <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> imports <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>, the module every Angular browser-based app\nmust have. It also defines an empty <code>ngDoBootstrap()</code> method, to prevent the <a href=\"api/core/Compiler\">Compiler</a> from returning errors. This is necessary because the module will not have a <code>bootstrap</code>\ndeclaration on its <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator.</p>\n\n<div class=\"alert is-important\">\n<p translation-result=\"on\">  你不用把 <code>bootstrap</code> 声明加到 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 装饰器上，因为 AngularJS 拥有应用的根组件，并且 <code>ngUpgrade</code> 会负责启动必要的组件。</p><p translation-origin=\"off\">  You do not add a <code>bootstrap</code> declaration to the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator since AngularJS owns the root\ntemplate of the app and <code>ngUpgrade</code> bootstraps the necessary components.</p>\n\n</div>\n<p translation-result=\"on\">现在你可以用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 把 AngularJS 和 Angular 的模块联结在一起。</p><p translation-origin=\"off\">You can now link the AngularJS and Angular modules together using <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code>.</p>\n\n<code-example header=\"app.module.ts\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\nimport { <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nconst bootstrapFn = (extraProviders: <a href=\"api/core/StaticProvider\" class=\"code-anchor\">StaticProvider</a>[]) => {\n  const platformRef = <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>(extraProviders);\n  return platformRef.bootstrapModule(MainAngularModule);\n};\nconst downgradedModule = <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>(bootstrapFn);\n\nangular.module('mainAngularJsModule', [\n  downgradedModule\n]);\n</code-example>\n<p translation-result=\"on\">现有的 AngularJS 代码仍然在和以前一样正常工作，但你已经可以开始添加新的 Angular 代码了。</p><p translation-origin=\"off\">The existing AngularJS code works as before <em>and</em> you are ready to start adding Angular code.</p>\n\n<h3 id=\"using-components-and-injectables\" translation-result=\"on\">使用组件与可注入对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-components-and-injectables\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"using-components-and-injectables\">Using Components and Injectables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-components-and-injectables\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 和 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 之间的区别就是这些。\n其余的 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> API 和概念的工作方式在不同的混合式应用中都完全一样了。\n欲知详情，参见<a href=\"guide/upgrade\">从 AngularJS 升级</a>。</p><p translation-origin=\"off\">The differences between <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> and <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> end here. The rest of the\n<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> APIs and concepts work in the exact same way for both types of hybrid apps.\nSee <a href=\"guide/upgrade\">Upgrading from AngularJS</a> to learn about:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"guide/upgrade#using-angular-components-from-angularjs-code\">从 AngularJS 代码中使用 Angular 组件</a>。<br>\n<em>注意：如果你要降级多个模块，就要在调用 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 时为每个组件所属的降级后模块指定一个模块名。</em></p><p translation-origin=\"off\"><a href=\"guide/upgrade#using-angular-components-from-angularjs-code\">Using Angular Components from AngularJS Code</a>.<br>\n<em>NOTE: If you are downgrading multiple modules, you need to specify the name of the downgraded\nmodule each component belongs to, when calling <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code>.</em></p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/upgrade#using-angularjs-component-directives-from-angular-code\">如何从 Angular 代码中使用 AngularJS 组件和指令</a></p><p translation-origin=\"off\"><a href=\"guide/upgrade#using-angularjs-component-directives-from-angular-code\">Using AngularJS Component Directives from Angular Code</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/upgrade#projecting-angularjs-content-into-angular-components\">把 AngularJS 的内容投影进 Angular 组件中</a>。</p><p translation-origin=\"off\"><a href=\"guide/upgrade#projecting-angularjs-content-into-angular-components\">Projecting AngularJS Content into Angular Components</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\">把 Angular 的内容透传进 AngularJS 组件和指令中</a>。</p><p translation-origin=\"off\"><a href=\"guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\">Transcluding Angular Content into AngularJS Component Directives</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">让 AngularJS 的依赖可注入到 Angular 中</a>。</p><p translation-origin=\"off\"><a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">Making AngularJS Dependencies Injectable to Angular</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/upgrade#making-angular-dependencies-injectable-to-angularjs\">让 Angular 的依赖可注入到 AngularJS 中</a>。\n<em>注意：如果你正在降级多个模块，就要在调用 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> 时为每个包含可注入对象的模块指定降级后的模块名。</em></p><p translation-origin=\"off\"><a href=\"guide/upgrade#making-angular-dependencies-injectable-to-angularjs\">Making Angular Dependencies Injectable to AngularJS</a>.<br>\n<em>NOTE: If you are downgrading multiple modules, you need to specify the name of the downgraded\nmodule each injectable belongs to, when calling <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code>.</em></p>\n\n</li>\n</ul>\n<div class=\"alert is-important\">\n<p translation-result=\"on\">  虽然可以降级可注入对象，但在实例化 Angular 模块之前，无法使用降级后的可注入对象。\n安全起见，你需要确保降级后的可注入对象不会用于应用中<em>不受</em> Angular 控制的任何地方。</p><p translation-origin=\"off\">  While it is possible to downgrade injectables, downgraded injectables will not be available until\nthe Angular module that provides them is instantiated. In order to be safe, you need to ensure\nthat the downgraded injectables are not used anywhere <em>outside</em> the part of the app where it is\nguaranteed that their module has been instantiated.</p>\n\n<p translation-result=\"on\">  比如，在只使用 Angular 组件的已升级组件中<em>可以</em>使用降级后的服务，但是，<em>不能</em>在那些不依赖 Angular 的 AngularJS 组件中使用它，也不能从其它模块中使用降级过的 Angular 组件。</p><p translation-origin=\"off\">  For example, it is <em>OK</em> to use a downgraded service in an upgraded component that is only used\nfrom a downgraded Angular component provided by the same Angular module as the injectable, but it\nis <em>not OK</em> to use it in an AngularJS component that may be used independently of Angular or use\nit in a downgraded Angular component from a different module.</p>\n\n</div>\n<h2 id=\"using-ahead-of-time-compilation-with-hybrid-apps\" translation-result=\"on\">使用混合式应用进行预先编译<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-ahead-of-time-compilation-with-hybrid-apps\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"using-ahead-of-time-compilation-with-hybrid-apps\">Using ahead-of-time compilation with hybrid apps<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#using-ahead-of-time-compilation-with-hybrid-apps\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你可以像在任何其它 Angular 应用中一样，利用混合式应用的预先（AOT）编译功能。\n混合式应用的设置与<a href=\"guide/aot-compiler\">预先（AOT）编译</a>一章所讲的大致相同，但 <code>index.html</code> 和 <code>main-aot.ts</code> 略有差异。</p><p translation-origin=\"off\">You can take advantage of ahead-of-time (AOT) compilation in hybrid apps just like in any other\nAngular app. The setup for a hybrid app is mostly the same as described in the\n<a href=\"guide/aot-compiler\">Ahead-of-Time Compilation</a> guide save for differences in <code>index.html</code> and\n<code>main-aot.ts</code>.</p>\n\n<p translation-result=\"on\">AOT 需要在 AngularJS 的 <code>index.html</code> 中的 <code>&#x3C;script></code> 标签中加载所有 AngularJS 文件。</p><p translation-origin=\"off\">AOT needs to load any AngularJS files that are in the <code>&#x3C;script></code> tags in the AngularJS <code>index.html</code>.\nAn easy way to copy them is to add each to the <code>copy-dist-files.js</code> file.</p>\n\n<p translation-result=\"on\">你还要将所生成的 <code>MainAngularModuleFactory</code> 传给 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 函数，而不是自定义引导函数。</p><p translation-origin=\"off\">You also need to pass the generated <code>MainAngularModuleFactory</code> to <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> instead of the\ncustom bootstrap function:</p>\n\n<code-example header=\"app/main-aot.ts\">\nimport { <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\nimport { MainAngularModuleNgFactory } from '../aot/app/app.module.ngfactory';\n\nconst downgradedModule = <a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>(MainAngularModuleNgFactory);\n\nangular.module('mainAngularJsModule', [\n  downgradedModule\n]);\n</code-example>\n<p translation-result=\"on\">这就是当你想让混合式应用受益于 AOT 时所要做的一切。</p><p translation-origin=\"off\">And that is all you need to do to get the full benefit of AOT for hybrid Angular apps.</p>\n\n<h2 id=\"conclusion\" translation-result=\"on\">总结<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#conclusion\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"conclusion\">Conclusion<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade-performance#conclusion\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">该页面介绍了如何借助 <a href=\"api/upgrade/static\">upgrade/static</a> 包，来按照你自己的节奏逐步升级现有的 AngularJS 应用。并且升级过程中不会方案此应用的进一步开发。</p><p translation-origin=\"off\">This page covered how to use the <a href=\"api/upgrade/static\">upgrade/static</a> package to incrementally\nupgrade existing AngularJS apps at your own pace and without impeding further development of the app\nfor the duration of the upgrade process.</p>\n\n<p translation-result=\"on\">具体来说，本章介绍了如何使用 <a href=\"api/upgrade/static/downgradeModule\">downgradeModule()</a> 来代替 <a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a>，为混合式应用提供更好的性能和更大的灵活性。</p><p translation-origin=\"off\">Specifically, this guide showed how you can achieve better performance and greater flexibility in\nyour hybrid apps by using <a href=\"api/upgrade/static/downgradeModule\">downgradeModule()</a> instead of <a href=\"api/upgrade/static/UpgradeModule\">UpgradeModule</a>.</p>\n\n<p translation-result=\"on\">总结，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 中的关键差异性因素是：</p><p translation-origin=\"off\">To summarize, the key differentiating factors of <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> are:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">它允许实例化甚至惰性加载 Angular 部分，这能改善初始加载时间。某些情况下，这可能会完全免除启动第二个框架的成本。</p><p translation-origin=\"off\">It allows instantiating or even loading the Angular part lazily, which improves the initial\nloading time. In some cases this may waive the cost of running a second framework altogether.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">通过避免运行不必要的变更检测，它提高了性能，给开发人员提供了更大的自定义能力。</p><p translation-origin=\"off\">It improves performance by avoiding unnecessary change detection runs while giving the developer\ngreater ability to customize.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">它不需要你更改引导 AngularJS 应用的方式。</p><p translation-origin=\"off\">It does not require you to change how you bootstrap your AngularJS app.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">当你希望混合式应用的 AngularJS 部分和 Angular 部分保持松耦合时，使用 <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 是个很好的选择。\n你仍然可以混用并匹配两个框架中的组件和服务。作为回报，<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> 为你提供了更大的控制权和更好的性能。</p><p translation-origin=\"off\">Using <code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> is a good option for hybrid apps when you want to keep the AngularJS and\nAngular parts less coupled. You can still mix and match components and services from both\nframeworks, but you might need to manually propagate change detection. In return,\n<code><a href=\"api/upgrade/static/downgradeModule\" class=\"code-anchor\">downgradeModule</a>()</code> offers more control and better performance.</p>\n\n\n</div>\n\n<!-- links to this doc:\n - api/upgrade/static/downgradeModule\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/core/Compiler\n - api/core/Injector\n - api/core/Input\n - api/core/NgModule\n - api/core/NgModuleFactory\n - api/core/NgModuleRef\n - api/core/NgZone#run\n - api/core/PlatformRef#bootstrapModuleFactory\n - api/core/StaticProvider\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/BrowserModule\n - api/platform-browser/platformBrowser\n - api/upgrade/static\n - api/upgrade/static/UpgradeModule\n - api/upgrade/static/downgradeComponent\n - api/upgrade/static/downgradeInjectable\n - api/upgrade/static/downgradeModule\n - guide/aot-compiler\n - guide/upgrade\n - guide/upgrade#change-detection\n - guide/upgrade#how-ngupgrade-works\n - guide/upgrade#making-angular-dependencies-injectable-to-angularjs\n - guide/upgrade#making-angularjs-dependencies-injectable-to-angular\n - guide/upgrade#preparation\n - guide/upgrade#projecting-angularjs-content-into-angular-components\n - guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\n - guide/upgrade#using-angular-components-from-angularjs-code\n - guide/upgrade#using-angularjs-component-directives-from-angular-code\n - guide/upgrade-performance#bootstrapping-with-downgrademodule\n - guide/upgrade-performance#change-detection-with-downgrademodule\n - guide/upgrade-performance#conclusion\n - guide/upgrade-performance#how-ngupgrade-works\n - guide/upgrade-performance#instantiating-the-angular-module-on-demand\n - guide/upgrade-performance#preparation\n - guide/upgrade-performance#specifying-a-factory-for-the-angular-module\n - guide/upgrade-performance#upgrading-for-performance\n - guide/upgrade-performance#upgrading-with-ngupgrade\n - guide/upgrade-performance#using-ahead-of-time-compilation-with-hybrid-apps\n - guide/upgrade-performance#using-components-and-injectables\n - guide/upgrade-performance#using-downgrademodule\n - guide/upgrade-setup\n - https://docs.angularjs.org/api/ng/function/angular.module\n - https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/upgrade-performance.md?message=docs%3A%20请简述你的修改...\n - https://github.com/angular/quickstart\n-->"
}