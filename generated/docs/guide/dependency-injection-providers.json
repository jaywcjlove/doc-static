{
  "id": "guide/dependency-injection-providers",
  "title": "Dependency providers",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/dependency-injection-providers.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"dependency-providers\" translation-result=\"on\">依赖提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#dependency-providers\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"dependency-providers\">Dependency providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#dependency-providers\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">依赖<a href=\"guide/glossary#provider\">提供者</a>会使用 <a href=\"guide/glossary#di-token\">DI 令牌</a>来配置注入器，注入器会用它来提供这个依赖值的具体的、运行时版本。\n注入器依靠 \"提供者配置\" 来创建依赖的实例，并把该实例注入到组件、指令、管道和其它服务中。</p><p translation-origin=\"off\">A dependency <a href=\"guide/glossary#provider\">provider</a> configures an injector\nwith a <a href=\"guide/glossary#di-token\">DI token</a>,\nwhich that injector uses to provide the concrete, runtime version of a dependency value.\nThe injector relies on the provider configuration to create instances of the dependencies\nthat it injects into components, directives, pipes, and other services.</p>\n\n<p translation-result=\"on\">你必须使用提供者来配置注入器，否则注入器就无法知道如何创建此依赖。\n注入器创建服务实例的最简单方法，就是用这个服务类本身来创建它。\n如果你把服务类作为此服务的 DI 令牌，注入器的默认行为就是 <code>new</code> 出这个类实例。</p><p translation-origin=\"off\">You must configure an injector with a provider, or it won't know how to create the dependency.\nThe most obvious way for an injector to create an instance of a service class is with the class itself.\nIf you specify the service class itself as the provider token, the default behavior is for the injector to instantiate that class with <code>new</code>.</p>\n\n<p translation-result=\"on\">在下面这个典型的例子中，<code>Logger</code> 类自身提供了 <code>Logger</code> 的实例。</p><p translation-origin=\"off\">In the following typical example, the <code>Logger</code> class itself provides a <code>Logger</code> instance.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<p translation-result=\"on\">不过，你也可以用一个替代提供者来配置注入器，这样就可以指定另一些同样能提供日志功能的对象。\n比如：</p><p translation-origin=\"off\">You can, however, configure an injector with an alternative provider,\nin order to deliver some other object that provides the needed logging functionality.\nFor instance:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">你可以提供一个替代类。</p><p translation-origin=\"off\">You can provide a substitute class.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你可以提供一个类似于 Logger 的对象。</p><p translation-origin=\"off\">You can provide a logger-like object.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">你的提供者可以调用一个工厂函数来创建 logger。</p><p translation-origin=\"off\">Your provider can call a logger factory function.</p>\n\n</li>\n</ul>\n<a id=\"provide\"></a>\n<h2 id=\"the-provider-object-literal\" translation-result=\"on\"><code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code> 对象字面量<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#the-provider-object-literal\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"the-provider-object-literal\">The <code><a href=\"api/core/Provider\" class=\"code-anchor\">Provider</a></code> object literal<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#the-provider-object-literal\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">类提供者的语法实际上是一种简写形式，它会扩展成一个由 <a href=\"api/core/Provider\"><code>Provider</code> 接口</a>定义的提供者配置对象。\n下面的代码片段展示了 <code>providers</code> 中给出的类会如何扩展成完整的提供者配置对象。</p><p translation-origin=\"off\">The class-provider syntax is a shorthand expression that expands\ninto a provider configuration, defined by the <a href=\"api/core/Provider\"><code>Provider</code> interface</a>.\nThe following code snippets shows how a class that is given as the <code>providers</code> value is expanded into a full provider object.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-3\">\n[{ provide: Logger, useClass: Logger }]\n\n</code-example>\n<p translation-result=\"on\">扩展的提供者配置是一个具有两个属性的对象字面量。</p><p translation-origin=\"off\">The expanded provider configuration is an object literal with two properties.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">  <code>provide</code> 属性存有<a href=\"guide/dependency-injection#token\">令牌</a>，它作为一个 key，在定位依赖值和配置注入器时使用。</p><p translation-origin=\"off\">The <code>provide</code> property holds the <a href=\"guide/dependency-injection#token\">token</a>\nthat serves as the key for both locating a dependency value and configuring the injector.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  第二个属性是一个提供者定义对象，它告诉注入器要如何创建依赖值。\n提供者定义对象中的 key 可以是 <code>useClass</code> —— 就像这个例子中一样。\n也可以是 <code>useExisting</code>、<code>useValue</code> 或 <code>useFactory</code>。\n每一个 key 都用于提供一种不同类型的依赖，我们稍后会讨论。</p><p translation-origin=\"off\">The second property is a provider definition object, which tells the injector how to create the dependency value.\nThe provider-definition key can be <code>useClass</code>, as in the example.\nIt can also be <code>useExisting</code>, <code>useValue</code>, or <code>useFactory</code>.\nEach of these keys provides a different type of dependency, as discussed below.</p>\n\n</li>\n</ul>\n<a id=\"class-provider\"></a>\n<h2 id=\"alternative-class-providers\" translation-result=\"on\">替代类提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#alternative-class-providers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"alternative-class-providers\">Alternative class providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#alternative-class-providers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">不同的类都可用于提供相同的服务。\n比如，下面的代码告诉注入器，当组件使用 <code>Logger</code> 令牌请求日志对象时，给它返回一个 <code>BetterLogger</code> 实例。</p><p translation-origin=\"off\">Different classes can provide the same service.\nFor example, the following code tells the injector\nto return a <code>BetterLogger</code> instance when the component asks for a logger\nusing the <code>Logger</code> token.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-4\">\n[{ provide: Logger, useClass: BetterLogger }]\n\n</code-example>\n<a id=\"class-provider-dependencies\"></a>\n<h3 id=\"class-providers-with-dependencies\" translation-result=\"on\">带依赖的类提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#class-providers-with-dependencies\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"class-providers-with-dependencies\">Class providers with dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#class-providers-with-dependencies\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">另一个类 <code>EvenBetterLogger</code> 可能要在日志信息里显示用户名。\n这个 logger 要从注入的 <code>UserService</code> 实例中来获取该用户。</p><p translation-origin=\"off\">Another class, <code>EvenBetterLogger</code>, might display the user name in the log message.\nThis logger gets the user from an injected <code>UserService</code> instance.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"EvenBetterLogger\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class EvenBetterLogger extends Logger {\n  constructor(private userService: UserService) { super(); }\n\n  log(message: string) {\n    let name = this.userService.user.name;\n    super.log(`Message to ${name}: ${message}`);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">注入器需要提供这个新的日志服务以及该服务所依赖的 <code>UserService</code> 对象。\n使用 <code>useClass</code> 作为提供者定义对象的 key，来配置一个 logger 的替代品，比如 <code>BetterLogger</code>。\n下面的数组同时在父模块和组件的 <code>providers</code> 元数据选项中指定了这些提供者。</p><p translation-origin=\"off\">The injector needs providers for both this new logging service and its dependent <code>UserService</code>. Configure this alternative logger with the <code>useClass</code> provider-definition key, like <code>BetterLogger</code>. The following array specifies both providers in the <code>providers</code> metadata option of the parent module or component.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-5\">\n[ UserService,\n  { provide: Logger, useClass: EvenBetterLogger }]\n\n</code-example>\n<a id=\"aliased-class-providers\"></a>\n<h3 id=\"aliased-class-providers\" translation-result=\"on\">别名类提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#aliased-class-providers\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"aliased-class-providers\">Aliased class providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#aliased-class-providers\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">假设老的组件依赖于 <code>OldLogger</code> 类。<code>OldLogger</code> 和 <code>NewLogger</code> 的接口相同，但是由于某种原因，我们没法修改老的组件来使用 <code>NewLogger</code>。</p><p translation-origin=\"off\">Suppose an old component depends upon the <code>OldLogger</code> class.\n<code>OldLogger</code> has the same interface as <code>NewLogger</code>, but for some reason\nyou can't update the old component to use it.</p>\n\n<p translation-result=\"on\">当老的组件要使用 <code>OldLogger</code> 记录信息时，你可能希望改用 <code>NewLogger</code> 的单例来处理它。\n在这种情况下，无论某个组件请求老的 logger 还是新的 logger，依赖注入器都应该注入这个 <code>NewLogger</code> 的单例。\n也就是说 <code>OldLogger</code> 应该是 <code>NewLogger</code> 的<em>别名</em>。</p><p translation-origin=\"off\">When the old component logs a message with <code>OldLogger</code>,\nyou want the singleton instance of <code>NewLogger</code> to handle it instead.\nIn this case, the dependency injector should inject that singleton instance\nwhen a component asks for either the new or the old logger.\n<code>OldLogger</code> should be an <em>alias</em> for <code>NewLogger</code>.</p>\n\n<p translation-result=\"on\">如果你试图用 <code>useClass</code> 为 <code>OldLogger</code> 指定一个别名 <code>NewLogger</code>，就会在应用中得到 <code>NewLogger</code> 的两个不同的实例。</p><p translation-origin=\"off\">If you try to alias <code>OldLogger</code> to <code>NewLogger</code> with <code>useClass</code>, you end up with two different <code>NewLogger</code> instances in your app.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6a\">\n[ NewLogger,\n  // Not aliased! Creates two instances of `NewLogger`\n  { provide: OldLogger, useClass: NewLogger}]\n\n</code-example>\n<p translation-result=\"on\">要确保只有一个 <code>NewLogger</code> 实例，就要用 <code>useExisting</code> 来为 <code>OldLogger</code> 指定别名。</p><p translation-origin=\"off\">To make sure there is only one instance of <code>NewLogger</code>, alias <code>OldLogger</code> with the <code>useExisting</code> option.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6b\">\n[ NewLogger,\n  // Alias OldLogger w/ reference to NewLogger\n  { provide: OldLogger, useExisting: NewLogger}]\n\n</code-example>\n<a id=\"value-provider\"></a>\n<h2 id=\"value-providers\" translation-result=\"on\">值提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#value-providers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"value-providers\">Value providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#value-providers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">有时候，提供一个现成的对象会比要求注入器从类去创建更简单一些。\n如果要注入一个你已经创建过的对象，请使用 <code>useValue</code> 选项来配置该注入器。</p><p translation-origin=\"off\">Sometimes it's easier to provide a ready-made object rather than ask the injector to create it from a class.\nTo inject an object you have already created,\nconfigure the injector with the <code>useValue</code> option</p>\n\n<p translation-result=\"on\">下面的代码定义了一个变量，用来创建这样一个能扮演 logger 角色的对象。</p><p translation-origin=\"off\">The following code defines a variable that creates such an object to play the logger role.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"silent-logger\">\n// An object in the shape of the logger service\nfunction silentLoggerFn() {}\n\nexport const SilentLogger = {\n  logs: ['Silent logger says \"Shhhhh!\". Provided via \"useValue\"'],\n  log: silentLoggerFn\n};\n\n</code-example>\n<p translation-result=\"on\">下面的提供者定义对象使用 <code>useValue</code> 作为 key 来把该变量与 <code>Logger</code> 令牌关联起来。</p><p translation-origin=\"off\">The following provider object uses the <code>useValue</code> key to associate the variable with the <code>Logger</code> token.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-7\">\n[{ provide: Logger, useValue: SilentLogger }]\n\n</code-example>\n<a id=\"non-class-dependencies\"></a>\n<h3 id=\"non-class-dependencies\" translation-result=\"on\">非类依赖<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#non-class-dependencies\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"non-class-dependencies\">Non-class dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#non-class-dependencies\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">并非所有的依赖都是类。\n有时候你会希望注入字符串、函数或对象。</p><p translation-origin=\"off\">Not all dependencies are classes.\nSometimes you want to inject a string, function, or object.</p>\n\n<p translation-result=\"on\">应用通常会用大量的小型参数来定义配置对象，比如应用的标题或 Web API 端点的地址。\n这些配置对象不一定总是类的实例。\n它们还可能是对象字面量，如下例所示。</p><p translation-origin=\"off\">Apps often define configuration objects with lots of small facts,\nlike the title of the application or the address of a web API endpoint.\nThese configuration objects aren't always instances of a class.\nThey can be object literals, as shown in the following example.</p>\n\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"config\" header=\"src/app/app.config.ts (excerpt)\">\nexport const HERO_DI_CONFIG: AppConfig = {\n  apiEndpoint: 'api.heroes.com',\n  title: 'Dependency Injection'\n};\n\n\n</code-example>\n<a id=\"interface-not-valid-token\"></a>\n<p translation-result=\"on\"><strong>TypeScript 接口不是有效的令牌</strong></p><p translation-origin=\"off\"><strong>TypeScript interfaces are not valid tokens</strong></p>\n\n<p translation-result=\"on\"><code>HERO_DI_CONFIG</code> 常量满足 <code>AppConfig</code> 接口的要求。\n不幸的是，你不能用 TypeScript 的接口作为令牌。\n在 TypeScript 中，接口是一个设计期的概念，无法用作 DI 框架在运行期所需的令牌。</p><p translation-origin=\"off\">The <code>HERO_DI_CONFIG</code> constant conforms to the <code>AppConfig</code> interface.\nUnfortunately, you cannot use a TypeScript interface as a token.\nIn TypeScript, an interface is a design-time artifact, and doesn't have a runtime representation (token) that the DI framework can use.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9-interface\">\n// FAIL! Can't use interface as provider token\n[{ provide: AppConfig, useValue: HERO_DI_CONFIG })]\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-9-ctor-interface\">\n// FAIL! Can't inject using the interface as the parameter type\nconstructor(private config: AppConfig){ }\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">如果你曾经在强类型语言中使用过依赖注入功能，这一点可能看起来有点奇怪，那些语言都优先使用接口作为查找依赖的 key。\n不过，JavaScript 没有接口，所以，当 TypeScript 转译成 JavaScript 时，接口也就消失了。\n在运行期间，没有留下任何可供 Angular 进行查找的接口类型信息。</p><p translation-origin=\"off\">This might seem strange if you're used to dependency injection in strongly typed languages where an interface is the preferred dependency lookup key.\nHowever, JavaScript, doesn't have interfaces, so when TypeScript is transpiled to JavaScript, the interface disappears.\nThere is no interface type information left for Angular to find at runtime.</p>\n\n</div>\n<p translation-result=\"on\">替代方案之一是以类似于 <code>AppModule</code> 的方式，在 NgModule 中提供并注入这个配置对象。</p><p translation-origin=\"off\">One alternative is to provide and inject the configuration object in an NgModule like <code>AppModule</code>.</p>\n\n<code-example path=\"dependency-injection/src/app/app.module.ts\" region=\"providers\" header=\"src/app/app.module.ts (providers)\">\nproviders: [\n  UserService,\n  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n],\n\n</code-example>\n<p translation-result=\"on\">另一个为非类依赖选择提供者令牌的解决方案是定义并使用 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 对象。\n下面的例子展示了如何定义那样一个令牌。</p><p translation-origin=\"off\">Another solution to choosing a provider token for non-class dependencies is\nto define and use an <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> object.\nThe following example shows how to define such a token.</p>\n\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"token\" header=\"src/app/app.config.ts\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const APP_CONFIG = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&#x3C;AppConfig>('app.config');\n\n</code-example>\n<p translation-result=\"on\">虽然类型参数在这里是可选的，不过还是能把此依赖的类型信息传达给开发人员和开发工具。\n这个令牌的描述则是开发人员的另一个助力。</p><p translation-origin=\"off\">The type parameter, while optional, conveys the dependency's type to developers and tooling.\nThe token description is another developer aid.</p>\n\n<p translation-result=\"on\">使用 <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 对象注册依赖提供者：</p><p translation-origin=\"off\">Register the dependency provider using the <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> object:</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9\">\nproviders: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }]\n\n</code-example>\n<p translation-result=\"on\">现在，借助参数装饰器 <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>()</code>，你可以把这个配置对象注入到任何需要它的构造函数中。</p><p translation-origin=\"off\">Now you can inject the configuration object into any constructor that needs it, with\nthe help of an <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>()</code> parameter decorator.</p>\n\n<code-example path=\"dependency-injection/src/app/app.component.2.ts\" region=\"ctor\" header=\"src/app/app.component.ts\">\nconstructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(APP_CONFIG) config: AppConfig) {\n  this.title = config.title;\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">虽然 <code>AppConfig</code> 接口在依赖注入时没有任何作用，但它可以为该组件类中的这个配置对象指定类型信息。</p><p translation-origin=\"off\">Although the <code>AppConfig</code> interface plays no role in dependency injection,\nit supports typing of the configuration object within the class.</p>\n\n</div>\n<a id=\"factory-provider\"></a>\n<a id=\"factory-providers\"></a>\n<h2 id=\"factory-providers\" translation-result=\"on\">工厂提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#factory-providers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"factory-providers\">Factory providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#factory-providers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">有时候你需要动态创建依赖值，创建时需要的信息你要等运行期间才能拿到。\n比如，你可能需要某个在浏览器会话过程中会被反复修改的信息，而且这个可注入服务还不能独立访问这个信息的源头。</p><p translation-origin=\"off\">Sometimes you need to create a dependent value dynamically,\nbased on information you won't have until run time.\nFor example, you might need information that changes repeatedly in the course of the browser session.\nAlso, your injectable service might not have independent access to the source of the information.</p>\n\n<p translation-result=\"on\">这种情况下，你可以使用<em>工厂提供者</em>。\n当需要从第三方库创建依赖项实例时，工厂提供者也很有用，因为第三方库不是为 DI 而设计的。</p><p translation-origin=\"off\">In cases like this you can use a <em>factory provider</em>.\nFactory providers can also be useful when creating an instance of a dependency from a third-party library that wasn't designed to work with DI.</p>\n\n<p translation-result=\"on\">比如，假设 <code>HeroService</code> 必须对普通用户隐藏<em>秘密</em>英雄，只有得到授权的用户才能看到他们。</p><p translation-origin=\"off\">For example, suppose <code>HeroService</code> must hide <em>secret</em> heroes from normal users.\nOnly authorized users should see secret heroes.</p>\n\n<p translation-result=\"on\">像 <code>EvenBetterLogger</code> 一样，<code>HeroService</code> 需要知道该用户是否有权查看秘密英雄。\n而认证信息可能会在应用的单个会话中发生变化，比如你改用另一个用户登录。</p><p translation-origin=\"off\">Like  <code>EvenBetterLogger</code>, <code>HeroService</code> needs to know if the user is authorized to see secret heroes.\nThat authorization can change during the course of a single application session,\nas when you log in a different user.</p>\n\n<p translation-result=\"on\">假设你不希望直接把 <code>UserService</code> 注入到 <code>HeroService</code> 中，因为你不希望把这个服务与那些高度敏感的信息牵扯到一起。\n这样 <code>HeroService</code> 就无法直接访问到用户信息，来决定谁有权访问，谁没有。</p><p translation-origin=\"off\">Let's say you don't want to inject <code>UserService</code> directly into <code>HeroService</code>, because you don't want to complicate that service with security-sensitive information.\n<code>HeroService</code> won't have direct access to the user information to decide\nwho is authorized and who isn't.</p>\n\n<p translation-result=\"on\">要解决这个问题，我们给 <code>HeroService</code> 的构造函数一个逻辑型标志，以控制是否显示秘密英雄。</p><p translation-origin=\"off\">To resolve this, we give the <code>HeroService</code> constructor a boolean flag to control display of secret heroes.</p>\n\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.ts\" region=\"internals\" header=\"src/app/heroes/hero.service.ts (excerpt)\">\nconstructor(\n  private logger: Logger,\n  private isAuthorized: boolean) { }\n\ngetHeroes() {\n  let auth = this.isAuthorized ? 'authorized ' : 'unauthorized';\n  this.logger.log(`Getting heroes for ${auth} user.`);\n  return HEROES.filter(hero => this.isAuthorized || !hero.isSecret);\n}\n\n</code-example>\n<p translation-result=\"on\">你可以注入 <code>Logger</code> 但是不能注入 <code>isAuthorized</code> 标志。不过你可以改用工厂提供者来为 <code>HeroService</code> 创建一个新的 logger 实例。</p><p translation-origin=\"off\">You can inject <code>Logger</code>, but you can't inject the  <code>isAuthorized</code> flag. Instead, you can use a factory provider to create a new logger instance for <code>HeroService</code>.</p>\n\n<p translation-result=\"on\">工厂提供者需要一个工厂函数。</p><p translation-origin=\"off\">A factory provider needs a factory function.</p>\n\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"factory\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\">\nlet heroServiceFactory = (logger: Logger, userService: UserService) => {\n  return new HeroService(logger, userService.user.isAuthorized);\n};\n\n</code-example>\n<p translation-result=\"on\">虽然 <code>HeroService</code> 不能访问 <code>UserService</code>，但是工厂函数可以。\n你把 <code>Logger</code> 和 <code>UserService</code> 注入到了工厂提供者中，并让注入器把它们传给这个工厂函数。</p><p translation-origin=\"off\">Although <code>HeroService</code> has no access to <code>UserService</code>, the factory function does.\nYou inject both <code>Logger</code> and <code>UserService</code> into the factory provider\nand let the injector pass them along to the factory function.</p>\n\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"provider\" header=\"src/app/heroes/hero.service.provider.ts (excerpt)\">\nexport let heroServiceProvider =\n  { provide: HeroService,\n    useFactory: heroServiceFactory,\n    deps: [Logger, UserService]\n  };\n\n</code-example>\n<ul>\n<li>\n<p translation-result=\"on\"><code>useFactory</code> 字段告诉 Angular 该提供者是一个工厂函数，该函数的实现代码是 <code>heroServiceFactory</code>。</p><p translation-origin=\"off\">The <code>useFactory</code> field tells Angular that the provider is a factory function whose implementation is <code>heroServiceFactory</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  <code>deps</code> 属性是一个<a href=\"guide/dependency-injection#token\">提供者令牌</a>数组。\n<code>Logger</code> 和 <code>UserService</code> 类作为它们自己的类提供者令牌使用。\n注入器解析这些令牌，并把与之对应的服务注入到相应的工厂函数参数表中。</p><p translation-origin=\"off\">The <code>deps</code> property is an array of <a href=\"guide/dependency-injection#token\">provider tokens</a>.\nThe <code>Logger</code> and <code>UserService</code> classes serve as tokens for their own class providers.\nThe injector resolves these tokens and injects the corresponding services into the matching factory function parameters.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">注意，你把这个工厂提供者保存到了一个导出的变量 <code>heroServiceProvider</code> 中。\n这个额外的步骤让工厂提供者可被复用。\n你可以在任何需要它的地方用这个变量来配置 <code>HeroService</code> 的提供者。\n在这个例子中，你只在 <code>HeroesComponent</code> 中用到了它。你在该组件元数据的 <code>providers</code> 数组中用 <code>heroServiceProvider</code> 替换了 <code>HeroService</code>。</p><p translation-origin=\"off\">Notice that you captured the factory provider in an exported variable, <code>heroServiceProvider</code>.\nThis extra step makes the factory provider reusable.\nYou can configure a provider of <code>HeroService</code> with this variable wherever you need it.\nIn this sample, you need it only in <code>HeroesComponent</code>,\nwhere <code>heroServiceProvider</code> replaces <code>HeroService</code> in the metadata <code>providers</code> array.</p>\n\n<p translation-result=\"on\">下面并列显示了新旧实现。</p><p translation-origin=\"off\">The following shows the new and the old implementations side-by-side.</p>\n\n<code-tabs>\n\n  <code-pane header=\"src/app/heroes/heroes.component (v3)\" path=\"dependency-injection/src/app/heroes/heroes.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }          from '@angular/core';\nimport { heroServiceProvider } from './hero.service.provider';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ heroServiceProvider ],\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/heroes.component (v2)\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ HeroService ],\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n</code-tabs>\n<h2 id=\"predefined-tokens-and-multiple-providers\" translation-result=\"on\">预定义令牌与多提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#predefined-tokens-and-multiple-providers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"predefined-tokens-and-multiple-providers\">Predefined tokens and multiple providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#predefined-tokens-and-multiple-providers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 提供了一些内置的注入令牌常量，你可以用它们来自定义系统的多种行为。</p><p translation-origin=\"off\">Angular provides a number of built-in injection-token constants that you can use to customize the behavior of\nvarious systems.</p>\n\n<p translation-result=\"on\">比如，你可以使用下列内置令牌来切入 Angular 框架的启动和初始化过程。\n提供者对象可以把任何一个注入令牌与一个或多个用来执行应用初始化操作的回调函数关联起来。</p><p translation-origin=\"off\">For example, you can use the following built-in tokens as hooks into the framework’s bootstrapping and initialization process.\nA provider object can associate any of these injection tokens with one or more callback functions that take app-specific initialization actions.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><a href=\"api/core/PLATFORM_INITIALIZER\">PLATFORM_INITIALIZER</a>：平台初始化之后调用的回调函数。</p><p translation-origin=\"off\"><a href=\"api/core/PLATFORM_INITIALIZER\">PLATFORM_INITIALIZER</a>: Callback is invoked when a platform is initialized.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"api/core/APP_BOOTSTRAP_LISTENER\">APP_BOOTSTRAP_LISTENER</a>：每个启动组件启动完成之后调用的回调函数。这个处理器函数会收到这个启动组件的 ComponentRef 实例。</p><p translation-origin=\"off\"><a href=\"api/core/APP_BOOTSTRAP_LISTENER\">APP_BOOTSTRAP_LISTENER</a>: Callback is invoked for each component that is bootstrapped. The handler function receives the ComponentRef instance of the bootstrapped component.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"api/core/APP_INITIALIZER\">APP_INITIALIZER</a>：应用初始化之前调用的回调函数。注册的所有初始化器都可以（可选地）返回一个 Promise。所有返回 Promise 的初始化函数都必须在应用启动之前解析完。如果任何一个初始化器失败了，该应用就不会继续启动。</p><p translation-origin=\"off\"><a href=\"api/core/APP_INITIALIZER\">APP_INITIALIZER</a>: Callback is invoked before an app is initialized. All registered initializers can optionally return a Promise. All initializer functions that return Promises must be resolved before the application is bootstrapped. If one of the initializers fails to resolves, the application is not bootstrapped.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">该提供者对象还有第三个选项 <code>multi: true</code>，把它和 <code><a href=\"api/core/APP_INITIALIZER\" class=\"code-anchor\">APP_INITIALIZER</a></code> 一起使用可以为特定的事件注册多个处理器。</p><p translation-origin=\"off\">The provider object can have a third option, <code>multi: true</code>, which you can use with <code><a href=\"api/core/APP_INITIALIZER\" class=\"code-anchor\">APP_INITIALIZER</a></code>\nto register multiple handlers for the provide event.</p>\n\n<p translation-result=\"on\">比如，当启动应用时，你可以使用同一个令牌注册多个初始化器。</p><p translation-origin=\"off\">For example, when bootstrapping an application, you can register many initializers using the same token.</p>\n\n<code-example>\nexport const APP_TOKENS = [\n { provide: <a href=\"api/core/PLATFORM_INITIALIZER\" class=\"code-anchor\">PLATFORM_INITIALIZER</a>, useFactory: platformInitialized, multi: true    },\n { provide: <a href=\"api/core/APP_INITIALIZER\" class=\"code-anchor\">APP_INITIALIZER</a>, useFactory: delayBootstrapping, multi: true },\n { provide: <a href=\"api/core/APP_BOOTSTRAP_LISTENER\" class=\"code-anchor\">APP_BOOTSTRAP_LISTENER</a>, useFactory: appBootstrapped, multi: true },\n];\n</code-example>\n<p translation-result=\"on\">在其它地方，多个提供者也同样可以和单个令牌关联起来。\n比如，你可以使用内置的 <a href=\"api/forms/NG_VALIDATORS\">NG_VALIDATORS</a> 令牌注册自定义表单验证器，还可以在提供者定义对象中使用 <code>multi: true</code> 属性来为指定的验证器令牌提供多个验证器实例。\nAngular 会把你的自定义验证器添加到现有验证器的集合中。</p><p translation-origin=\"off\">Multiple providers can be associated with a single token in other areas as well.\nFor example, you can register a custom form validator using the built-in <a href=\"api/forms/NG_VALIDATORS\">NG_VALIDATORS</a> token,\nand provide multiple instances of a given validator provider by using the <code>multi: true</code> property in the provider object.\nAngular adds your custom validators to the existing collection.</p>\n\n<p translation-result=\"on\">路由器也同样用多个提供者关联到了一个令牌。\n当你在单个模块中用 <a href=\"api/router/RouterModule#forroot\">RouterModule.forRoot</a> 和 <a href=\"api/router/RouterModule#forchild\">RouterModule.forChild</a> 提供了多组路由时，<a href=\"api/router/ROUTES\">ROUTES</a> 令牌会把这些不同的路由组都合并成一个单一值。</p><p translation-origin=\"off\">The Router also makes use of multiple providers associated with a single token.\nWhen you provide multiple sets of routes using <a href=\"api/router/RouterModule#forroot\">RouterModule.forRoot</a>\nand <a href=\"api/router/RouterModule#forchild\">RouterModule.forChild</a> in a single module,\nthe <a href=\"api/router/ROUTES\">ROUTES</a> token combines all the different provided sets of routes into a single value.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">搜索 <a href=\"api?type=const\">API 文档中的常量</a>以了解更多内置令牌。</p><p translation-origin=\"off\">Search for <a href=\"api?type=const\">Constants in API documentation</a> to find more built-in tokens.</p>\n\n</div>\n<a id=\"tree-shakable-provider\"></a>\n<a id=\"tree-shakable-providers\"></a>\n<h2 id=\"tree-shakable-providers\" translation-result=\"on\">可摇树优化的提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#tree-shakable-providers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"tree-shakable-providers\">Tree-shakable providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#tree-shakable-providers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">摇树优化是指一个编译器选项，意思是把应用中未引用过的代码从最终生成的包中移除。\n如果提供者是可摇树优化的，Angular 编译器就会从最终的输出内容中移除应用代码中从未用过的服务。\n这会显著减小你的打包体积。</p><p translation-origin=\"off\">Tree shaking refers to a compiler option that removes code from the final bundle if the app doesn't reference that code.\nWhen providers are tree-shakable, the Angular compiler removes the associated\nservices from the final output when it determines that your application doesn't use those services.\nThis significantly reduces the size of your bundles.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">理想情况下，如果应用没有注入服务，它就不应该包含在最终输出中。\n不过，Angular 要能在构建期间识别出该服务是否需要。\n由于还可能用 <code>injector.get(Service)</code> 的形式直接注入服务，所以 Angular 无法准确识别出代码中可能发生此注入的全部位置，因此为保险起见，只能把服务包含在注入器中。\n因此，在 NgModule 或 组件级别提供的服务是无法被摇树优化掉的。</p><p translation-origin=\"off\">Ideally, if an application isn't injecting a service, Angular shouldn't include it in the final output.\nHowever, Angular has to be able to identify at build time whether the app will require the service or not.\nBecause it's always possible to inject a service directly using <code>injector.get(Service)</code>,\nAngular can't identify all of the places in your code where this injection could happen,\nso it has no choice but to include the service in the injector.\nThus, services in the NgModule <code>providers</code> array or at component level are not tree-shakable.</p>\n\n</div>\n<p translation-result=\"on\">下面这个不可摇树优化的 Angular 提供者的例子为 NgModule 注入器配置了一个服务提供者。</p><p translation-origin=\"off\">The following example of non-tree-shakable providers in Angular configures a service provider for the injector of an NgModule.</p>\n\n<code-example path=\"dependency-injection/src/app/tree-shaking/service-and-module.ts\" header=\"src/app/tree-shaking/service-and-modules.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Service {\n  doSomething(): void {\n  }\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [Service],\n})\nexport class ServiceModule {\n}\n\n\n</code-example>\n<p translation-result=\"on\">你可以把该模块导入到你的应用模块中，以便该服务可注入到你的应用中，例子如下。</p><p translation-origin=\"off\">You can then import this module into your application module\nto make the service available for injection in your app,\nas in the following example.</p>\n\n<code-example path=\"dependency-injection/src/app/tree-shaking/app.module.ts\" header=\"src/app/tree-shaking/app.modules.ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    RouterModule.forRoot([]),\n    ServiceModule,\n  ],\n})\nexport class AppModule {\n}\n\n\n</code-example>\n<p translation-result=\"on\">当运行 <code>ngc</code> 时，它会把 <code>AppModule</code> 编译到模块工厂中，工厂包含该模块及其导入的所有模块中声明的所有提供者。在运行时，该工厂会变成负责实例化所有这些服务的注入器。</p><p translation-origin=\"off\">When <code>ngc</code> runs, it compiles <code>AppModule</code> into a module factory, which contains definitions for all the providers declared in all the modules it includes. At runtime, this factory becomes an injector that instantiates these services.</p>\n\n<p translation-result=\"on\">这里摇树优化不起作用，因为 Angular 无法根据是否用到了其它代码块（服务类），来决定是否能排除这块代码（模块工厂中的服务提供者定义）。要让服务可以被摇树优化，关于如何构建该服务实例的信息（即提供者定义），就应该是服务类本身的一部分。</p><p translation-origin=\"off\">Tree-shaking doesn't work here because Angular can't decide to exclude one chunk of code (the provider definition for the service within the module factory) based on whether another chunk of code (the service class) is used. To make services tree-shakable, the information about how to construct an instance of the service (the provider definition) needs to be a part of the service class itself.</p>\n\n<h3 id=\"creating-tree-shakable-providers\" translation-result=\"on\">创建可摇树优化的提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#creating-tree-shakable-providers\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"creating-tree-shakable-providers\">Creating tree-shakable providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-providers#creating-tree-shakable-providers\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">只要在服务本身的 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器中指定，而不是在依赖该服务的 NgModule 或组件的元数据中指定，你就可以制作一个可摇树优化的提供者。</p><p translation-origin=\"off\">You can make a provider tree-shakable by specifying it in the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator on the service itself, rather than in the metadata for the NgModule or component that depends on the service.</p>\n\n<p translation-result=\"on\">下面的例子展示了与上面的 <code>ServiceModule</code> 例子等价的可摇树优化的版本。</p><p translation-origin=\"off\">The following example shows the tree-shakable equivalent to the <code>ServiceModule</code> example above.</p>\n\n<code-example path=\"dependency-injection/src/app/tree-shaking/service.ts\" header=\"src/app/tree-shaking/service.ts\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class Service {\n}\n\n\n</code-example>\n<p translation-result=\"on\">该服务还可以通过配置工厂函数来实例化，如下例所示。</p><p translation-origin=\"off\">The service can be instantiated by configuring a factory function, as in the following example.</p>\n\n<code-example path=\"dependency-injection/src/app/tree-shaking/service.0.ts\" header=\"src/app/tree-shaking/service.0.ts\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n  useFactory: () => new Service('dependency'),\n})\nexport class Service {\n  constructor(private dep: string) {\n  }\n}\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">要想覆盖可摇树优化的提供者，请使用其它提供者来配置指定的 NgModule 或组件的注入器，只要使用 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 或 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器中的 <code>providers: []</code> 数组就可以了。</p><p translation-origin=\"off\">To override a tree-shakable provider, configure the injector of a specific NgModule or component with another provider, using the <code>providers: []</code> array syntax of the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator.</p>\n\n</div>\n\n</div>\n\n<!-- links to this doc:\n - api/core/Injector\n - api/core/StaticProvider\n - guide/creating-libraries\n - guide/dependency-injection\n - guide/dependency-injection-in-action\n - guide/hierarchical-dependency-injection\n - guide/lightweight-injection-tokens\n - guide/providers\n - guide/upgrade\n-->\n<!-- links from this doc:\n - api/core/APP_BOOTSTRAP_LISTENER\n - api/core/APP_INITIALIZER\n - api/core/Component\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/NgModule\n - api/core/PLATFORM_INITIALIZER\n - api/core/Provider\n - api/forms/NG_VALIDATORS\n - api/platform-browser/BrowserModule\n - api/router/ROUTES\n - api/router/RouterModule#forchild\n - api/router/RouterModule#forroot\n - api?type=const\n - guide/dependency-injection#token\n - guide/dependency-injection-providers#aliased-class-providers\n - guide/dependency-injection-providers#alternative-class-providers\n - guide/dependency-injection-providers#class-providers-with-dependencies\n - guide/dependency-injection-providers#creating-tree-shakable-providers\n - guide/dependency-injection-providers#dependency-providers\n - guide/dependency-injection-providers#factory-providers\n - guide/dependency-injection-providers#non-class-dependencies\n - guide/dependency-injection-providers#predefined-tokens-and-multiple-providers\n - guide/dependency-injection-providers#the-provider-object-literal\n - guide/dependency-injection-providers#tree-shakable-providers\n - guide/dependency-injection-providers#value-providers\n - guide/glossary#di-token\n - guide/glossary#provider\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/dependency-injection-providers.md?message=docs%3A%20请简述你的修改...\n-->"
}