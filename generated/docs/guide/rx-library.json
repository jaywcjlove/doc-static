{
  "id": "guide/rx-library",
  "title": "The RxJS library",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/rx-library.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"the-rxjs-library\" translation-result=\"on\">RxJS 库<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#the-rxjs-library\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"the-rxjs-library\">The RxJS library<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#the-rxjs-library\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">响应式编程是一种面向数据流和变更传播的异步编程范式（<a href=\"https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B\">Wikipedia</a>）。RxJS（响应式扩展的 JavaScript 版）是一个使用可观察对象进行响应式编程的库，它让组合异步代码和基于回调的代码变得更简单。参见 <a href=\"https://rxjs.dev/guide/overview\">RxJS 官方文档</a>。</p><p translation-origin=\"off\">Reactive programming is an asynchronous programming paradigm concerned with data streams and the propagation of change (<a href=\"https://en.wikipedia.org/wiki/Reactive_programming\">Wikipedia</a>). RxJS (Reactive Extensions for JavaScript) is a library for reactive programming using observables that makes it easier to compose asynchronous or callback-based code. See (<a href=\"https://rxjs.dev/guide/overview\">RxJS Docs</a>).</p>\n\n<p translation-result=\"on\">RxJS 提供了一种对 <code>Observable</code> 类型的实现，直到 <code>Observable</code> 成为了 JavaScript 语言的一部分并且浏览器支持它之前，它都是必要的。这个库还提供了一些工具函数，用于创建和使用可观察对象。这些工具函数可用于：</p><p translation-origin=\"off\">RxJS provides an implementation of the <code>Observable</code> type, which is needed until the type becomes part of the language and until browsers support it. The library also provides utility functions for creating and working with observables. These utility functions can be used for:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> 把现有的异步代码转换成可观察对象</p><p translation-origin=\"off\">Converting existing code for async operations into observables</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 迭代流中的各个值</p><p translation-origin=\"off\">Iterating through the values in a stream</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 把这些值映射成其它类型</p><p translation-origin=\"off\">Mapping values to different types</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 对流进行过滤</p><p translation-origin=\"off\">Filtering streams</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 组合多个流</p><p translation-origin=\"off\">Composing multiple streams</p>\n\n</li>\n</ul>\n<h2 id=\"observable-creation-functions\" translation-result=\"on\">创建可观察对象的函数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#observable-creation-functions\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"observable-creation-functions\">Observable creation functions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#observable-creation-functions\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">RxJS 提供了一些用来创建可观察对象的函数。这些函数可以简化根据某些东西创建可观察对象的过程，比如事件、定时器、承诺等等。比如：</p><p translation-origin=\"off\">RxJS offers a number of functions that can be used to create new observables. These functions can simplify the process of creating observables from things such as events, timers, promises, and so on. For example:</p>\n\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"promise\" header=\"Create an observable from a promise\">\n\nimport { from } from 'rxjs';\n\n// Create an Observable out of a promise\nconst data = from(fetch('/api/endpoint'));\n// Subscribe to begin listening for <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a> result\ndata.subscribe({\n  next(response) { console.log(response); },\n  error(err) { console.error('Error: ' + err); },\n  complete() { console.log('Completed'); }\n});\n\n\n</code-example>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"interval\" header=\"Create an observable from a counter\">\n\nimport { interval } from 'rxjs';\n\n// Create an Observable that will publish a value on an interval\nconst secondsCounter = interval(1000);\n// Subscribe to begin publishing values\nsecondsCounter.subscribe(n =>\n  console.log(`It's been ${n} seconds since subscribing!`));\n\n\n</code-example>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"event\" header=\"Create an observable from an event\">\n\nimport { fromEvent } from 'rxjs';\n\nconst el = document.getElementById('my-element');\n\n// Create an Observable that will publish mouse movements\nconst mouseMoves = fromEvent(el, 'mousemove');\n\n// Subscribe to start listening for mouse-move events\nconst subscription = mouseMoves.subscribe((evt: MouseEvent) => {\n  // Log coords of mouse movements\n  console.log(`Coords: ${evt.clientX} X ${evt.clientY}`);\n\n  // When the mouse is over the upper-left of the screen,\n  // unsubscribe to stop listening for mouse movements\n  if (evt.clientX &#x3C; 40 &#x26;&#x26; evt.clientY &#x3C; 40) {\n    subscription.unsubscribe();\n  }\n});\n\n\n</code-example>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"ajax\" header=\"Create an observable that creates an AJAX request\">\n\nimport { ajax } from 'rxjs/ajax';\n\n// Create an Observable that will create an AJAX request\nconst apiData = ajax('/api/data');\n// Subscribe to create the request\napiData.subscribe(res => console.log(res.status, res.response));\n\n\n</code-example>\n<h2 id=\"operators\" translation-result=\"on\">操作符<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#operators\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"operators\">Operators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#operators\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">操作符是基于可观察对象构建的一些对集合进行复杂操作的函数。RxJS 定义了一些操作符，比如 <code>map()</code>、<code>filter()</code>、<code>concat()</code> 和 <code>flatMap()</code>。</p><p translation-origin=\"off\">Operators are functions that build on the observables foundation to enable sophisticated manipulation of collections. For example, RxJS defines operators such as <code>map()</code>, <code>filter()</code>, <code>concat()</code>, and <code>flatMap()</code>.</p>\n\n<p translation-result=\"on\">操作符接受一些配置项，然后返回一个以来源可观察对象为参数的函数。当执行这个返回的函数时，这个操作符会观察来源可观察对象中发出的值，转换它们，并返回由转换后的值组成的新的可观察对象。下面是一个简单的例子：</p><p translation-origin=\"off\">Operators take configuration options, and they return a function that takes a source observable. When executing this returned function, the operator observes the source observable’s emitted values, transforms them, and returns a new observable of those transformed values. Here is a simple example:</p>\n\n<code-example path=\"rx-library/src/operators.ts\" header=\"Map operator\">\n\nimport { map } from 'rxjs/operators';\n\nconst nums = of(1, 2, 3);\n\nconst squareValues = map((val: number) => val * val);\nconst squaredNums = squareValues(nums);\n\nsquaredNums.subscribe(x => console.log(x));\n\n// Logs\n// 1\n// 4\n// 9\n\n\n</code-example>\n<p translation-result=\"on\">你可以使用<em>管道</em>来把这些操作符链接起来。管道让你可以把多个由操作符返回的函数组合成一个。<code>pipe()</code> 函数以你要组合的这些函数作为参数，并且返回一个新的函数，当执行这个新函数时，就会顺序执行那些被组合进去的函数。</p><p translation-origin=\"off\">You can use <em>pipes</em> to link operators together. Pipes let you combine multiple functions into a single function. The <code>pipe()</code> function takes as its arguments the functions you want to combine, and returns a new function that, when executed, runs the composed functions in sequence.</p>\n\n<p translation-result=\"on\">应用于某个可观察对象上的一组操作符就像一个处理流程 —— 也就是说，对你感兴趣的这些值进行处理的一组操作步骤。这个处理流程本身不会做任何事。你需要调用 <code>subscribe()</code> 来通过处理流程得出并生成一个结果。</p><p translation-origin=\"off\">A set of operators applied to an observable is a recipe—that is, a set of instructions for producing the values you’re interested in. By itself, the recipe doesn’t do anything. You need to call <code>subscribe()</code> to produce a result through the recipe.</p>\n\n<p translation-result=\"on\">例子如下：</p><p translation-origin=\"off\">Here’s an example:</p>\n\n<code-example path=\"rx-library/src/operators.1.ts\" header=\"Standalone pipe function\">\n\nimport { filter, map } from 'rxjs/operators';\n\nconst nums = of(1, 2, 3, 4, 5);\n\n// Create a function that accepts an Observable.\nconst squareOddVals = pipe(\n  filter((n: number) => n % 2 !== 0),\n  map(n => n * n)\n);\n\n// Create an Observable that will run the filter and map functions\nconst squareOdd = squareOddVals(nums);\n\n// Subscribe to run the combined functions\nsquareOdd.subscribe(x => console.log(x));\n\n\n</code-example>\n<p translation-result=\"on\"><code>pipe()</code> 函数也同时是 RxJS 的 <code>Observable</code> 上的一个方法，所以你可以用下列简写形式来达到同样的效果：</p><p translation-origin=\"off\">The <code>pipe()</code> function is also a method on the RxJS <code>Observable</code>, so you use this shorter form to define the same operation:</p>\n\n<code-example path=\"rx-library/src/operators.2.ts\" header=\"Observable.pipe function\">\n\nimport { filter, map } from 'rxjs/operators';\n\nconst squareOdd = of(1, 2, 3, 4, 5)\n  .pipe(\n    filter(n => n % 2 !== 0),\n    map(n => n * n)\n  );\n\n// Subscribe to get values\nsquareOdd.subscribe(x => console.log(x));\n\n\n</code-example>\n<h3 id=\"common-operators\" translation-result=\"on\">常用操作符<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#common-operators\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"common-operators\">Common operators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#common-operators\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">RxJS 提供了很多操作符，不过只有少数是常用的。\n下面是一个常用操作符的列表和用法范例，参见 <a href=\"https://rxjs.dev/api\">RxJS API 文档</a>。</p><p translation-origin=\"off\">RxJS provides many operators, but only a handful are used frequently. For a list of operators and usage samples, visit the <a href=\"https://rxjs.dev/api\">RxJS API Documentation</a>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">  注意，对于 Angular 应用来说，我们提倡使用管道来组合操作符，而不是使用链式写法。链式写法仍然在很多 RxJS 中使用着。</p><p translation-origin=\"off\">  Note that, for Angular apps, we prefer combining operators with pipes, rather than chaining. Chaining is used in many RxJS examples.</p>\n\n</div>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><p translation-result=\"on\">类别</p><p translation-origin=\"off\">Area</p></th>\n<th align=\"left\"><p translation-result=\"on\">操作</p><p translation-origin=\"off\">Operators</p></th>\n</tr>\n</thead>\n<tbody>\n\n<tr>\n<td align=\"left\"><p translation-result=\"on\">创建</p><p translation-origin=\"off\">Creation</p></td>\n<td align=\"left\"><p><code>from</code>,<code>fromEvent</code>, <code>of</code></p><p><code>from</code>, <code>fromPromise</code>,<code>fromEvent</code>, <code>of</code></p></td>\n</tr>\n\n<tr>\n<td align=\"left\"><p translation-result=\"on\">组合</p><p translation-origin=\"off\">Combination</p></td>\n<td align=\"left\"><code>combineLatest</code>, <code>concat</code>, <code>merge</code>, <code>startWith</code> , <code>withLatestFrom</code>, <code>zip</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><p translation-result=\"on\">过滤</p><p translation-origin=\"off\">Filtering</p></td>\n<td align=\"left\"><code>debounceTime</code>, <code>distinctUntilChanged</code>, <code>filter</code>, <code>take</code>, <code>takeUntil</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><p translation-result=\"on\">转换</p><p translation-origin=\"off\">Transformation</p></td>\n<td align=\"left\"><code>bufferTime</code>, <code>concatMap</code>, <code>map</code>, <code>mergeMap</code>, <code>scan</code>, <code>switchMap</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><p translation-result=\"on\">工具</p><p translation-origin=\"off\">Utility</p></td>\n<td align=\"left\"><code>tap</code></td>\n</tr>\n\n<tr>\n<td align=\"left\"><p translation-result=\"on\">多播</p><p translation-origin=\"off\">Multicasting</p></td>\n<td align=\"left\"><code>share</code></td>\n</tr>\n\n</tbody>\n</table>\n<h2 id=\"error-handling\" translation-result=\"on\">错误处理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#error-handling\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"error-handling\">Error handling<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#error-handling\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">除了可以在订阅时提供 <code>error()</code> 处理器外，RxJS 还提供了 <code>catchError</code> 操作符，它允许你在管道中处理已知错误。</p><p translation-origin=\"off\">In addition to the <code>error()</code> handler that you provide on subscription, RxJS provides the <code>catchError</code> operator that lets you handle known errors in the observable recipe.</p>\n\n<p translation-result=\"on\">假设你有一个可观察对象，它发起 API 请求，然后对服务器返回的响应进行映射。如果服务器返回了错误或值不存在，就会生成一个错误。如果你捕获这个错误并提供了一个默认值，流就会继续处理这些值，而不会报错。</p><p translation-origin=\"off\">For instance, suppose you have an observable that makes an API request and maps to the response from the server. If the server returns an error or the value doesn’t exist, an error is produced. If you catch this error and supply a default value, your stream continues to process values rather than erroring out.</p>\n\n<p translation-result=\"on\">下面是使用 <code>catchError</code> 操作符实现这种效果的例子：</p><p translation-origin=\"off\">Here's an example of using the <code>catchError</code> operator to do this:</p>\n\n<code-example path=\"rx-library/src/error-handling.ts\" header=\"catchError operator\">\n\nimport { ajax } from 'rxjs/ajax';\nimport { map, catchError } from 'rxjs/operators';\n// Return \"response\" from the API. If an error happens,\n// return an empty array.\nconst apiData = ajax('/api/data').pipe(\n  map(res => {\n    if (!res.response) {\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  catchError(err => of([]))\n);\n\napiData.subscribe({\n  next(x) { console.log('data: ', x); },\n  error(err) { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<h3 id=\"retry-failed-observable\" translation-result=\"on\">重试失败的可观察对象<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#retry-failed-observable\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"retry-failed-observable\">Retry failed observable<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#retry-failed-observable\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>catchError</code> 提供了一种简单的方式进行恢复，而 <code>retry</code> 操作符让你可以尝试失败的请求。</p><p translation-origin=\"off\">Where the <code>catchError</code> operator provides a simple path of recovery, the <code>retry</code> operator lets you retry a failed request.</p>\n\n<p translation-result=\"on\">可以在 <code>catchError</code> 之前使用 <code>retry</code> 操作符。它会订阅到原始的来源可观察对象，它可以重新运行导致结果出错的动作序列。如果其中包含 HTTP 请求，它就会重新发起那个 HTTP 请求。</p><p translation-origin=\"off\">Use the <code>retry</code> operator before the <code>catchError</code> operator. It resubscribes to the original source observable, which can then re-run the full sequence of actions that resulted in the error. If this includes an HTTP request, it will retry that HTTP request.</p>\n\n<p translation-result=\"on\">下列代码把前面的例子改成了在捕获错误之前重发请求：</p><p translation-origin=\"off\">The following converts the previous example to retry the request before catching the error:</p>\n\n<code-example path=\"rx-library/src/retry-on-error.ts\" header=\"retry operator\">\n\nimport { ajax } from 'rxjs/ajax';\nimport { map, retry, catchError } from 'rxjs/operators';\n\nconst apiData = ajax('/api/data').pipe(\n  retry(3), // Retry up to 3 times before failing\n  map(res => {\n    if (!res.response) {\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  catchError(err => of([]))\n);\n\napiData.subscribe({\n  next(x) { console.log('data: ', x); },\n  error(err) { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">   不要重试<strong>登录认证</strong>请求，这些请求只应该由用户操作触发。我们肯定不会希望自动重复发送登录请求导致用户的账号被锁定。</p><p translation-origin=\"off\">   Do not retry <strong>authentication</strong> requests, since these should only be initiated by user action. We don't want to lock out user accounts with repeated login requests that the user has not initiated.</p>\n\n</div>\n<h2 id=\"naming-conventions-for-observables\" translation-result=\"on\">可观察对象的命名约定<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#naming-conventions-for-observables\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"naming-conventions-for-observables\">Naming conventions for observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/rx-library#naming-conventions-for-observables\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">由于 Angular 的应用几乎都是用 TypeScript 写的，你通常会希望知道某个变量是否可观察对象。虽然 Angular 框架并没有针对可观察对象的强制性命名约定，不过你经常会看到可观察对象的名字以“$”符号结尾。</p><p translation-origin=\"off\">Because Angular applications are mostly written in TypeScript, you will typically know when a variable is an observable. Although the Angular framework does not enforce a naming convention for observables, you will often see observables named with a trailing “$” sign.</p>\n\n<p translation-result=\"on\">这在快速浏览代码并查找可观察对象值时会非常有用。同样的，如果你希望用某个属性来存储来自可观察对象的最近一个值，它的命名惯例是与可观察对象同名，但不带“$”后缀。</p><p translation-origin=\"off\">This can be useful when scanning through code and looking for observable values. Also, if you want a property to store the most recent value from an observable, it can be convenient to simply use the same name with or without the “$”.</p>\n\n<p translation-result=\"on\">比如：</p><p translation-origin=\"off\">For example:</p>\n\n<code-example path=\"rx-library/src/naming-convention.ts\" header=\"Naming observables\">\n\n\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-stopwatch',\n  templateUrl: './stopwatch.component.html'\n})\nexport class StopwatchComponent {\n\n  stopwatchValue: number;\n  stopwatchValue$: Observable&#x3C;number>;\n\n  start() {\n    this.stopwatchValue$.subscribe(num =>\n      this.stopwatchValue = num\n    );\n  }\n}\n\n\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - guide/http\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/testing/async\n - guide/rx-library#common-operators\n - guide/rx-library#error-handling\n - guide/rx-library#naming-conventions-for-observables\n - guide/rx-library#observable-creation-functions\n - guide/rx-library#operators\n - guide/rx-library#retry-failed-observable\n - guide/rx-library#the-rxjs-library\n - https://en.wikipedia.org/wiki/Reactive_programming\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/rx-library.md?message=docs%3A%20请简述你的修改...\n - https://rxjs.dev/api\n - https://rxjs.dev/guide/overview\n - https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B\n-->"
}