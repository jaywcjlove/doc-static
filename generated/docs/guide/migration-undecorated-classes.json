{
  "id": "guide/migration-undecorated-classes",
  "title": "Missing @Directive()/@Component() decorator migration",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/migration-undecorated-classes.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"missing-directivecomponent-decorator-migration\" translation-result=\"on\">缺少 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> / <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器的迁移<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#missing-directivecomponent-decorator-migration\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"missing-directivecomponent-decorator-migration\">Missing <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code>/<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator migration<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#missing-directivecomponent-decorator-migration\"><i class=\"material-icons\">link</i></a></h1>\n\n<h2 id=\"what-does-this-migration-do\" translation-result=\"on\">这个迁移是做什么的？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#what-does-this-migration-do\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"what-does-this-migration-do\">What does this migration do?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#what-does-this-migration-do\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">此迁移会把一个空的 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 装饰器添加到一些不带装饰器的基类中：</p><p translation-origin=\"off\">This migration adds an empty <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> decorator to undecorated\nbase classes that:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">使用了 Angular 的特性</p><p translation-origin=\"off\">use Angular features</p>\n\n</li>\n<li>\n<p translation-result=\"on\">被指令或组件继承（extend）</p><p translation-origin=\"off\">are extended by directives or components</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">例如，在下面的对比中，把一个 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 装饰器加到了 <code>BaseMenu</code> 上是因为 <code>BaseMenu</code> 使用了依赖性注入。</p><p translation-origin=\"off\">For example, in the diff below, a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> decorator is added to <code>BaseMenu</code> because <code>BaseMenu</code> uses dependency injection.</p>\n\n<p translation-result=\"on\">  <strong>之前:</strong></p><p translation-origin=\"off\">  <strong>Before:</strong></p>\n\n<code-example language=\"ts\">\nexport class BaseMenu {\n  constructor(private vcr: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) {}\n}\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[settingsMenu]'})\nexport class SettingsMenu extends BaseMenu {}\n</code-example>\n<p translation-result=\"on\">  <strong>之后:</strong></p><p translation-origin=\"off\">  <strong>After:</strong></p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()\nexport class BaseMenu {\n  constructor(private vcr: <a href=\"api/core/ViewContainerRef\" class=\"code-anchor\">ViewContainerRef</a>) {}\n}\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[settingsMenu]'})\nexport class SettingsMenu extends BaseMenu {}\n</code-example>\n<p translation-result=\"on\">如果指令或组件是在没有装饰器的情况下被类扩展的，那么该原理图就会把任何继承来的指令或组件元数据复制到派生类中。</p><p translation-origin=\"off\">In the event that a directive or component is extended by a class without a decorator, the schematic copies any inherited directive or component metadata to the derived class.</p>\n\n<p translation-result=\"on\"><strong>之前：</strong></p><p translation-origin=\"off\"><strong>Before:</strong></p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'base-menu',\n  template: '&#x3C;div>&#x3C;/div>'\n})\nclass BaseMenu {}\n\nexport class SettingsMenu extends BaseMenu {}\n</code-example>\n<p translation-result=\"on\"><strong>之后：</strong></p><p translation-origin=\"off\"><strong>After:</strong></p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'base-menu',\n  template: '&#x3C;div>&#x3C;/div>'\n})\nclass BaseMenu {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'base-menu',\n  template: '&#x3C;div>&#x3C;/div>'\n})\nexport class SettingsMenu extends BaseMenu {}\n</code-example>\n<p translation-result=\"on\">这个原理图还装饰了使用 Angular 字段装饰器的类，包括：</p><p translation-origin=\"off\">This schematic also decorates classes that use Angular field decorators, including:</p>\n\n<ul>\n<li><code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code></li>\n<li><code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code></li>\n<li><code>@<a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a>()</code></li>\n<li><code>@<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>()</code></li>\n<li><code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>()</code> / <code>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a>()</code></li>\n<li><code>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>()</code> / <code>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>()</code></li>\n</ul>\n<p translation-result=\"on\"><strong>之前：</strong></p><p translation-origin=\"off\"><strong>Before:</strong></p>\n\n<code-example language=\"ts\">\nclass Base {\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()\n  countChanged = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;number>();\n}\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[myDir]'\n})\nclass Dir extends Base {\n}\n</code-example>\n<p translation-result=\"on\"><strong>之后：</strong></p><p translation-origin=\"off\"><strong>After:</strong></p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>() // schematic adds @<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()\nclass Base {\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()\n  countChanged = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;number>();\n}\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[myDir]'\n})\nclass Dir extends Base {\n}\n</code-example>\n<h2 id=\"why-is-this-migration-necessary\" translation-result=\"on\">为何此迁移是必要的？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#why-is-this-migration-necessary\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"why-is-this-migration-necessary\">Why is this migration necessary?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#why-is-this-migration-necessary\"><i class=\"material-icons\">link</i></a></h2>\n\n<h3 id=\"migrating-classes-that-use-di\" translation-result=\"on\">迁移使用了 DI 的类<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#migrating-classes-that-use-di\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"migrating-classes-that-use-di\">Migrating classes that use DI<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#migrating-classes-that-use-di\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">当一个类有 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 或者 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器时，Angular 编译器会生成一些额外的代码来把这些依赖注入到构造函数中。当使用继承时，Ivy 既要让父类、也要让子类应用装饰器来生成正确的代码。</p><p translation-origin=\"off\">When a class has a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator, the Angular compiler generates extra code to inject dependencies into the constructor.\nWhen using inheritance, Ivy needs both the parent class and the child class to apply a decorator to generate the correct code.</p>\n\n<p translation-result=\"on\">你可以把这种变化看作两种情况：父类缺少装饰器，或者子类缺少装饰器。在这两种场景中，Angular 的运行时都需要得到来自编译器的额外信息。这些额外信息来自所添加的装饰器。</p><p translation-origin=\"off\">You can think of this change as two cases: a parent class is missing a\ndecorator or a child class is missing a decorator.\nIn both scenarios, Angular's runtime needs additional information from the compiler.\nThis additional information comes from adding decorators.</p>\n\n<h4 id=\"decorator-missing-from-parent-class\" translation-result=\"on\">父类缺少了装饰器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#decorator-missing-from-parent-class\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"decorator-missing-from-parent-class\">Decorator missing from parent class<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#decorator-missing-from-parent-class\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">当父类中缺少装饰器时，该子类会继承一个构造函数，而这个构造函数并没有为编译器生成特殊的构造函数信息（因为它没有指令装饰器）。当 Angular 尝试创建子类时，它没有正确的信息来创建它。</p><p translation-origin=\"off\">When the decorator is missing from the parent class, the subclass will inherit a constructor from a class for which the compiler did not generate special constructor info (because it was not decorated as a directive).\nWhen Angular then tries to create the subclass, it doesn't have the correct info to create it.</p>\n\n<p translation-result=\"on\">在 View Engine 中，编译器具有全局知识，可以查找丢失的数据。然而，Ivy 编译器只是孤立地处理每个指令。这意味着编译可以更快，但编译器无法自动推断出和以前一样的信息。添加 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 可以明确提供这些信息。</p><p translation-origin=\"off\">In View Engine, the compiler has global knowledge, so it can look up the missing data.\nHowever, the Ivy compiler only processes each directive in isolation.\nThis means that compilation can be faster, but the compiler can't automatically infer the same information as before.\nAdding the <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> explicitly provides this information.</p>\n\n<p translation-result=\"on\">未来，会把 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 添加到那些还没有装饰器而且被指令扩展的基类中。</p><p translation-origin=\"off\">In the future, add <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> to base classes that do not already have decorators and are extended by directives.</p>\n\n<h4 id=\"decorator-missing-from-child-class\" translation-result=\"on\">子类缺少装饰器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#decorator-missing-from-child-class\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"decorator-missing-from-child-class\">Decorator missing from child class<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#decorator-missing-from-child-class\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">当子类缺少装饰器时，子类继承自父类，但却没有自己的装饰器。如果没有装饰器，编译器就无法知道该类是 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 还是 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>，所以它无法为该指令生成正确的代码。</p><p translation-origin=\"off\">When the child class is missing the decorator, the child class inherits from the parent class yet has no decorators of its own.\nWithout a decorator, the compiler has no way of knowing that the class is a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>, so it doesn't generate the proper instructions for the directive.</p>\n\n<h3 id=\"migrating-classes-that-use-field-decorators\" translation-result=\"on\">迁移使用了字段装饰器的类<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#migrating-classes-that-use-field-decorators\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"migrating-classes-that-use-field-decorators\">Migrating classes that use field decorators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#migrating-classes-that-use-field-decorators\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在 ViewEngine 中，包含 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 等字段装饰器的基类在组件没有 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 或者 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器时也能正常工作。例如：</p><p translation-origin=\"off\">In ViewEngine, base classes with field decorators like <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> worked even when the class did not have a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator.\nFor example:</p>\n\n<code-example language=\"ts\">\nclass Base {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  foo: string;\n}\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>(...)\nclass Dir extends Base {\n  ngOnChanges(): void {\n    // notified when bindings to [foo] are updated\n  }\n}\n</code-example>\n<p translation-result=\"on\">但是，这个例子无法用 Ivy 编译，因为 <code>Base</code> 类<em>需要</em>一个 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 或者 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器来为输入、输出、查询和宿主绑定生成代码。</p><p translation-origin=\"off\">However, this example won't compile with Ivy because the <code>Base</code> class <em>requires</em> either a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator to generate code for inputs, outputs, queries, and host bindings.</p>\n\n<p translation-result=\"on\">所以始终都需要一个类装饰器，这会给 Angular 带来两大好处：</p><p translation-origin=\"off\">Always requiring a class decorator leads to two main benefits for Angular:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">以前的行为是不一致的。一些 Angular 特性需要装饰器（依赖注入），但其它的则不需要。现在，所有的 Angular 特性都需要一个类装饰器。</p><p translation-origin=\"off\">The previous behavior was inconsistent.\nSome Angular features required a decorator (dependency injection), but others did not.\nNow, all Angular features consistently require a class decorator.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">支持不带装饰器的类会增加 Angular 的代码大小和复杂性。如果总是要求类装饰器，对于所有用户来说框架都会变得更小、更简单。</p><p translation-origin=\"off\">Supporting undecorated classes increases the code size and complexity of Angular.\nAlways requiring class decorators allows the framework to become smaller and simpler for all users.</p>\n\n</li>\n</ol>\n<h2 id=\"what-does-it-mean-to-have-a-directive-decorator-with-no-metadata-inside-of-it\" translation-result=\"on\"><code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 装饰器里面没有元数据是怎么回事？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#what-does-it-mean-to-have-a-directive-decorator-with-no-metadata-inside-of-it\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"what-does-it-mean-to-have-a-directive-decorator-with-no-metadata-inside-of-it\">What does it mean to have a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> decorator with no metadata inside of it?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#what-does-it-mean-to-have-a-directive-decorator-with-no-metadata-inside-of-it\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 装饰器的出现让 Angular 为受其影响的类生成了额外的代码。如果该装饰器不包含任何属性（元数据），该指令就不会与任何元素匹配或者被直接实例化，但<em>扩展</em>该指令类的其它类也会继承这些生成的代码。你可以把它看作一个“抽象”的指令。</p><p translation-origin=\"off\">The presence of the <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> decorator causes Angular to generate extra code for the affected class.\nIf that decorator includes no properties (metadata), the directive won't be matched to elements or instantiated directly, but other classes that <em>extend</em> the directive class will inherit this generated code.\nYou can think of this as an \"abstract\" directive.</p>\n\n<p translation-result=\"on\">把一个抽象指令添加到 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中会导致错误。非抽象指令必须定义一个 <code>selector</code> 属性，才能匹配模板中的某些元素。</p><p translation-origin=\"off\">Adding an abstract directive to an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> will cause an error.\nA directive must have a <code>selector</code> property defined in order to match some element in a template.</p>\n\n<h2 id=\"when-do-i-need-a-directive-decorator-without-a-selector\" translation-result=\"on\">我什么时候需要一个没有选择器的 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 装饰器？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#when-do-i-need-a-directive-decorator-without-a-selector\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"when-do-i-need-a-directive-decorator-without-a-selector\">When do I need a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> decorator without a selector?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#when-do-i-need-a-directive-decorator-without-a-selector\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">如果你正在使用依赖注入或任何 Angular 特有的特性，比如 <code>@<a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a>()</code>，<code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>()</code> 或者 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>，你就需要一个 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 或者 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器。装饰器能让编译器知道如何生成正确的指令来创建该类以及那些扩展了它的类。如果你不想直接把那个基类用作指令，那就不写这个选择器。如果你确实希望它可以独立使用，那就像往常一样填写元数据。</p><p translation-origin=\"off\">If you're using dependency injection, or any Angular-specific feature, such as <code>@<a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a>()</code>, <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>()</code>, or <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>, you need a <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator.\nThe decorator lets the compiler know to generate the correct instructions to create that class and any classes that extend it.\nIf you don't want to use that base class as a directive directly, leave the selector blank.\nIf you do want it to be usable independently, fill in the metadata as usual.</p>\n\n<p translation-result=\"on\">那些没有使用 Angular 特性的类不需要 Angular 装饰器。</p><p translation-origin=\"off\">Classes that don't use Angular features don't need an Angular decorator.</p>\n\n<h2 id=\"im-a-library-author-should-i-add-the-directive-decorator-to-base-classes\" translation-result=\"on\">我是库作者。我应该把 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 装饰器添加到基类中吗？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#im-a-library-author-should-i-add-the-directive-decorator-to-base-classes\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"im-a-library-author-should-i-add-the-directive-decorator-to-base-classes\">I'm a library author. Should I add the <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> decorator to base classes?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#im-a-library-author-should-i-add-the-directive-decorator-to-base-classes\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">由于 Angular 9 中引入了对无选择器装饰器的支持，如果你想支持 Angular 8 及更早版本，就不应该添加一个无选择器的 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 装饰器。你可以添加带选择器的 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code>，或者把 Angular 特有的特性移动到受影响的子类中。</p><p translation-origin=\"off\">As support for selectorless decorators is introduced in Angular version 9, if you want to support Angular version 8 and earlier, you shouldn't add a selectorless <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> decorator.\nYou can either add <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> with a selector or move the Angular-specific features to affected subclasses.</p>\n\n<h2 id=\"what-about-applications-using-non-migrated-libraries\" translation-result=\"on\">那些使用未迁移库的应用呢？<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#what-about-applications-using-non-migrated-libraries\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"what-about-applications-using-non-migrated-libraries\">What about applications using non-migrated libraries?<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/migration-undecorated-classes#what-about-applications-using-non-migrated-libraries\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><a href=\"guide/glossary#ngcc\">Angular 兼容性编译器</a> （ <code>ngcc</code> ）应该会自动转换所有未迁移的库来生成合适的代码。</p><p translation-origin=\"off\">The <a href=\"guide/glossary#ngcc\">Angular compatibility compiler</a> (<code>ngcc</code>) should automatically transform any non-migrated libraries to generate the proper code.</p>\n\n\n</div>\n\n<!-- links to this doc:\n - guide/deprecations\n - guide/ivy-compatibility-examples\n - guide/updating-to-version-10\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Directive\n - api/core/EventEmitter\n - api/core/HostBinding\n - api/core/HostListener\n - api/core/Input\n - api/core/NgModule\n - api/core/Output\n - api/core/ViewChild\n - api/core/ViewChildren\n - api/core/ViewContainerRef\n - guide/glossary#ngcc\n - guide/migration-undecorated-classes#decorator-missing-from-child-class\n - guide/migration-undecorated-classes#decorator-missing-from-parent-class\n - guide/migration-undecorated-classes#im-a-library-author-should-i-add-the-directive-decorator-to-base-classes\n - guide/migration-undecorated-classes#migrating-classes-that-use-di\n - guide/migration-undecorated-classes#migrating-classes-that-use-field-decorators\n - guide/migration-undecorated-classes#missing-directivecomponent-decorator-migration\n - guide/migration-undecorated-classes#what-about-applications-using-non-migrated-libraries\n - guide/migration-undecorated-classes#what-does-it-mean-to-have-a-directive-decorator-with-no-metadata-inside-of-it\n - guide/migration-undecorated-classes#what-does-this-migration-do\n - guide/migration-undecorated-classes#when-do-i-need-a-directive-decorator-without-a-selector\n - guide/migration-undecorated-classes#why-is-this-migration-necessary\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/migration-undecorated-classes.md?message=docs%3A%20请简述你的修改...\n-->"
}