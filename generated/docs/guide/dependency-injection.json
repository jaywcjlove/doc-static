{
  "id": "guide/dependency-injection",
  "title": "Dependency injection in Angular",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/dependency-injection.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"dependency-injection-in-angular\" translation-result=\"on\">Angular 中的依赖注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#dependency-injection-in-angular\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"dependency-injection-in-angular\">Dependency injection in Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#dependency-injection-in-angular\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">依赖注入（DI）是一种重要的应用设计模式。\nAngular 有自己的 DI 框架，在设计应用时常会用到它，以提升它们的开发效率和模块化程度。</p><p translation-origin=\"off\">Dependency injection (DI), is an important application design pattern.\nAngular has its own DI framework, which is typically\nused in the design of Angular applications to increase their efficiency and modularity.</p>\n\n<p translation-result=\"on\">依赖，是当类需要执行其功能时，所需要的服务或对象。\nDI 是一种编码模式，其中的类会从外部源中请求获取依赖，而不是自己创建它们。</p><p translation-origin=\"off\">Dependencies are services or objects that a class needs to perform its function.\nDI is a coding pattern in which a class asks for dependencies from external sources rather than creating them itself.</p>\n\n<p translation-result=\"on\">在 Angular 中，DI 框架会在实例化该类时向其提供这个类所声明的依赖项。本指南介绍了 DI 在 Angular 中的工作原理，以及如何借助它来让你的应用更灵活、高效、健壮，以及可测试、可维护。</p><p translation-origin=\"off\">In Angular, the DI framework provides declared dependencies to a class when that class is instantiated. This guide explains how DI works in Angular, and how you use it to make your apps flexible, efficient, and robust, as well as testable and maintainable.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"> 你可以运行本章这个范例应用的<live-example></live-example>。</p><p translation-origin=\"off\"> You can run the <live-example></live-example> of the sample app that accompanies this guide.</p>\n\n</div>\n<p translation-result=\"on\">我们先看一下<a href=\"tutorial/\">英雄指南</a>中<em>英雄管理</em>特性的简化版。这个简化版不使用 DI，我们将逐步把它转换成使用 DI 的。</p><p translation-origin=\"off\">Start by reviewing this simplified version of the <em>heroes</em> feature\nfrom the <a href=\"tutorial/\">The Tour of Heroes</a>. This simple version doesn't use DI; we'll walk through converting it to do so.</p>\n\n<code-tabs>\n  <code-pane header=\"src/app/heroes/heroes.component.ts\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" region=\"v1\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/hero-list.component.ts\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { HEROES }      from './mock-heroes';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/hero.ts\" path=\"dependency-injection/src/app/heroes/hero.ts\">\nexport interface Hero {\n  id: number;\n  name: string;\n  isSecret: boolean;\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/mock-heroes.ts\" path=\"dependency-injection/src/app/heroes/mock-heroes.ts\">\nimport { Hero } from './hero';\n\nexport const HEROES: Hero[] = [\n  { id: 11, isSecret: false, name: 'Dr Nice' },\n  { id: 12, isSecret: false, name: 'Narco' },\n  { id: 13, isSecret: false, name: 'Bombasto' },\n  { id: 14, isSecret: false, name: 'Celeritas' },\n  { id: 15, isSecret: false, name: 'Magneta' },\n  { id: 16, isSecret: false, name: 'RubberMan' },\n  { id: 17, isSecret: false, name: 'Dynama' },\n  { id: 18, isSecret: true,  name: 'Dr IQ' },\n  { id: 19, isSecret: true,  name: 'Magma' },\n  { id: 20, isSecret: true,  name: 'Tornado' }\n];\n\n\n</code-pane>\n\n</code-tabs>\n<p translation-result=\"on\"><code>HeroesComponent</code> 是顶层英雄管理组件。\n它唯一的目的是显示 <code>HeroListComponent</code>，该组件会显示一个英雄名字的列表。</p><p translation-origin=\"off\"><code>HeroesComponent</code> is the top-level heroes component.\nIts only purpose is to display <code>HeroListComponent</code>, which displays a list of hero names.</p>\n\n<p translation-result=\"on\"><code>HeroListComponent</code> 的这个版本从 <code>HEROES</code> 数组（它在一个独立的 <code>mock-heroes</code> 文件中定义了一个内存集合）中获取英雄。</p><p translation-origin=\"off\">This version of the <code>HeroListComponent</code> gets heroes from the <code>HEROES</code> array, an in-memory collection\ndefined in a separate <code>mock-heroes</code> file.</p>\n\n<code-example header=\"src/app/heroes/hero-list.component.ts (class)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\" region=\"class\">\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n</code-example>\n<p translation-result=\"on\">这种方法在原型阶段有用，但是不够健壮、不利于维护。\n一旦你想要测试该组件或想从远程服务器获得英雄列表，就不得不修改 <code>HeroesListComponent</code> 的实现，并且替换每一处使用了 <code>HEROES</code> 模拟数据的地方。</p><p translation-origin=\"off\">This approach works for prototyping, but is not robust or maintainable.\nAs soon as you try to test this component or get heroes from a remote server,\nyou have to change the implementation of <code>HeroesListComponent</code> and\nreplace every use of the <code>HEROES</code> mock data.</p>\n\n<h2 id=\"create-and-register-an-injectable-service\" translation-result=\"on\">创建和注册可注入的服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#create-and-register-an-injectable-service\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"create-and-register-an-injectable-service\">Create and register an injectable service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#create-and-register-an-injectable-service\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">DI 框架让你能从一个可注入的<em>服务</em>类（独立文件）中为组件提供数据。为了演示，我们还会创建一个用来提供英雄列表的、可注入的服务类，并把它注册为该服务的提供者。</p><p translation-origin=\"off\">The DI framework lets you supply data to a component from an injectable <em>service</em> class, defined in its own file. To demonstrate, we'll create an injectable service class that provides a list of heroes, and register that class as a provider of that service.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">在同一个文件中放多个类容易让人困惑。我们通常建议你在单独的文件中定义组件和服务。</p><p translation-origin=\"off\">Having multiple classes in the same file can be confusing. We generally recommend that you define components and services in separate files.</p>\n\n<p translation-result=\"on\">如果你把组件和服务都放在同一个文件中，请务必先定义服务，然后再定义组件。如果在服务之前定义组件，则会在运行时收到一个空引用错误。</p><p translation-origin=\"off\">If you do combine a component and service in the same file,\nit is important to define the service first, and then the component. If you define the component before the service, you get a run-time null reference error.</p>\n\n<p translation-result=\"on\">也可以借助 <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> 方法来先定义组件，就像<a href=\"http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\">这个博客</a>中解释的那样。</p><p translation-origin=\"off\">It is possible to define the component first with the help of the <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> method as explained in this <a href=\"http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\">blog post</a>.</p>\n\n<p translation-result=\"on\">你还可以使用前向引用来打破循环依赖，参见 <a href=\"guide/dependency-injection-in-action#forwardref\">DI 一章</a>中的例子。</p><p translation-origin=\"off\">You can also use forward references to break circular dependencies.\nSee an example in the <a href=\"guide/dependency-injection-in-action#forwardref\">DI Cookbook</a>.</p>\n\n</div>\n<h3 id=\"create-an-injectable-service-class\" translation-result=\"on\">创建可注入的服务类<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#create-an-injectable-service-class\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"create-an-injectable-service-class\">Create an injectable service class<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#create-an-injectable-service-class\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><a href=\"cli\">Angular CLI</a> 可以用下列命令在 <code>src/app/heroes</code> 目录下生成一个新的 <code>HeroService</code> 类。</p><p translation-origin=\"off\">The <a href=\"cli\">Angular CLI</a> can generate a new <code>HeroService</code> class in the <code>src/app/heroes</code> folder with this command.</p>\n\n<code-example language=\"sh\" class=\"code-shell\">\nng generate service heroes/hero\n</code-example>\n<p translation-result=\"on\">下列命令会创建 <code>HeroService</code> 的骨架。</p><p translation-origin=\"off\">The command creates the following <code>HeroService</code> skeleton.</p>\n\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.0.ts\" header=\"src/app/heroes/hero.service.ts (CLI-generated)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class HeroService {\n  constructor() { }\n}\n\n\n</code-example>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 是每个 Angular 服务定义中的基本要素。该类的其余部分导出了一个 <code>getHeroes</code> 方法，它会返回像以前一样的模拟数据。（真实的应用可能会从远程服务器中异步获取这些数据，不过这里我们先忽略它，专心实现服务的注入机制。）</p><p translation-origin=\"off\">The <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> is an essential ingredient in every Angular service definition. The rest of the class has been written to expose a <code>getHeroes</code> method that returns the same mock data as before. (A real app would probably get its data asynchronously from a remote server, but we'll ignore that to focus on the mechanics of injecting the service.)</p>\n\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.3.ts\" header=\"src/app/heroes/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES } from './mock-heroes';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  // we declare that this service should be created\n  // by the root application injector.\n  providedIn: 'root',\n})\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-example>\n<a id=\"injector-config\"></a>\n<a id=\"bootstrap\"></a>\n<h3 id=\"configure-an-injector-with-a-service-provider\" translation-result=\"on\">用服务提供者配置注入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#configure-an-injector-with-a-service-provider\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"configure-an-injector-with-a-service-provider\">Configure an injector with a service provider<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#configure-an-injector-with-a-service-provider\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">我们创建的类提供了一个服务。<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器把它标记为可供注入的服务，不过在你使用该服务的 <a href=\"guide/glossary#provider\">provider</a> 提供者配置好 Angular 的<a href=\"guide/glossary#injector\">依赖注入器</a>之前，Angular 实际上无法将其注入到任何位置。</p><p translation-origin=\"off\">The class we have created provides a service. The <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator marks it as a service\nthat can be injected, but Angular can't actually inject it anywhere until you configure\nan Angular <a href=\"guide/glossary#injector\">dependency injector</a> with a <a href=\"guide/glossary#provider\">provider</a> of that service.</p>\n\n<p translation-result=\"on\">该注入器负责创建服务实例，并把它们注入到像 <code>HeroListComponent</code> 这样的类中。\n你很少需要自己创建 Angular 的注入器。Angular 会在执行应用时为你创建注入器，第一个注入器是<em>根注入器</em>，创建于<a href=\"guide/bootstrapping\">启动过程</a>中。</p><p translation-origin=\"off\">The injector is responsible for creating service instances and injecting them into classes like <code>HeroListComponent</code>.\nYou rarely create an Angular injector yourself. Angular creates injectors for you as it executes the app, starting with the <em>root injector</em> that it creates during the <a href=\"guide/bootstrapping\">bootstrap process</a>.</p>\n\n<p translation-result=\"on\">提供者会告诉注入器<em>如何创建该服务</em>。\n要想让注入器能够创建服务（或提供其它类型的依赖），你必须使用某个提供者配置好注入器。</p><p translation-origin=\"off\">A provider tells an injector <em>how to create the service</em>.\nYou must configure an injector with a provider before that injector can create a service (or provide any other kind of dependency).</p>\n\n<p translation-result=\"on\">提供者可以是服务类本身，因此注入器可以使用 <code>new</code> 来创建实例。\n你还可以定义多个类，以不同的方式提供同一个服务，并使用不同的提供者来配置不同的注入器。</p><p translation-origin=\"off\">A provider can be the service class itself, so that the injector can use <code>new</code> to create an instance.\nYou might also define more than one class to provide the same service in different ways,\nand configure different injectors with different providers.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">注入器是可继承的，这意味着如果指定的注入器无法解析某个依赖，它就会请求父注入器来解析它。\n组件可以从它自己的注入器来获取服务、从其祖先组件的注入器中获取、从其父 NgModule 的注入器中获取，或从 <code>root</code> 注入器中获取。</p><p translation-origin=\"off\">Injectors are inherited, which means that if a given injector can't resolve a dependency,\nit asks the parent injector to resolve it.\nA component can get services from its own injector,\nfrom the injectors of its component ancestors,\nfrom the injector of its parent NgModule, or from the <code>root</code> injector.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">更多知识，参见 <a href=\"guide/dependency-injection-providers\">提供者的不同类型</a>。</p><p translation-origin=\"off\">Learn more about the <a href=\"guide/dependency-injection-providers\">different kinds of providers</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">更多知识，参见<a href=\"guide/hierarchical-dependency-injection\">层次化注入器</a>的工作原理。</p><p translation-origin=\"off\">Learn more about how the <a href=\"guide/hierarchical-dependency-injection\">injector hierarchy</a> works.</p>\n\n</li>\n</ul>\n</div>\n<p translation-result=\"on\">你可以在三种位置之一设置元数据，以便在应用的不同层级使用提供者来配置注入器：</p><p translation-origin=\"off\">You can configure injectors with providers at different levels of your app, by setting a metadata value in one of three places:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">在服务本身的 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器中。</p><p translation-origin=\"off\">In the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator for the service itself.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在 NgModule 的 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 装饰器中。</p><p translation-origin=\"off\">In the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> decorator for an NgModule.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在组件的 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器中。</p><p translation-origin=\"off\">In the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator for a component.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器具有一个名叫 <code>providedIn</code> 的元数据选项，在那里你可以指定把被装饰类的提供者放到 <code>root</code> 注入器中，或某个特定 NgModule 的注入器中。</p><p translation-origin=\"off\">The <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator has the <code>providedIn</code> metadata option, where you can specify the provider of the decorated service class with the <code>root</code> injector, or with the injector for a specific NgModule.</p>\n\n<p translation-result=\"on\"><code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 和 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器都有用一个 <code>providers</code> 元数据选项，在那里你可以配置 NgModule 级或组件级的注入器。</p><p translation-origin=\"off\">The <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> and <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorators have the <code>providers</code> metadata option, where you can configure providers for NgModule-level or component-level injectors.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">所有组件都是指令，而 <code>providers</code> 选项是从 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 中继承来的。\n你也可以与组件一样的级别为指令、管道配置提供者。</p><p translation-origin=\"off\">Components are directives, and the <code>providers</code> option is inherited from <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code>. You can also configure providers for directives and pipes at the same level as the component.</p>\n\n<p translation-result=\"on\">欲知详情，参见<a href=\"guide/hierarchical-dependency-injection\">该在哪里配置提供者</a>。</p><p translation-origin=\"off\">Learn more about <a href=\"guide/hierarchical-dependency-injection\">where to configure providers</a>.</p>\n\n</div>\n<a id=\"injector-config\"></a>\n<a id=\"bootstrap\"></a>\n<h2 id=\"injecting-services\" translation-result=\"on\">注入服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#injecting-services\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"injecting-services\">Injecting services<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#injecting-services\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\"><code>HeroListComponent</code> 要想从 <code>HeroService</code> 中获取英雄列表，就得要求注入 <code>HeroService</code>，而不是自己使用 <code>new</code> 来创建自己的 <code>HeroService</code> 实例。</p><p translation-origin=\"off\">In order for <code>HeroListComponent</code> to get heroes from <code>HeroService</code>, it needs to ask for <code>HeroService</code> to be injected, rather than creating its own <code>HeroService</code> instance with <code>new</code>.</p>\n\n<p translation-result=\"on\">你可以通过制定<strong>带有依赖类型的构造函数参数</strong>来要求 Angular 在组件的构造函数中注入依赖项。下面的代码是 <code>HeroListComponent</code> 的构造函数，它要求注入 <code>HeroService</code>。</p><p translation-origin=\"off\">You can tell Angular to inject a dependency in a component's constructor by specifying a <strong>constructor parameter with the dependency type</strong>. Here's the <code>HeroListComponent</code> constructor, asking for the <code>HeroService</code> to be injected.</p>\n\n<code-example header=\"src/app/heroes/hero-list.component (constructor signature)\" path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p translation-result=\"on\">当然，<code>HeroListComponent</code> 还应该使用注入的这个 <code>HeroService</code> 做一些事情。\n这里是修改过的组件，它转而使用注入的服务。与前一版本并列显示，以便比较。</p><p translation-origin=\"off\">Of course, <code>HeroListComponent</code> should do something with the injected <code>HeroService</code>.\nHere's the revised component, making use of the injected service, side-by-side with the previous version for comparison.</p>\n\n<code-tabs>\n  <code-pane header=\"hero-list.component (with DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.2.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { Hero }        from './hero';\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes: Hero[];\n\n  constructor(heroService: HeroService) {\n    this.heroes = heroService.getHeroes();\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"hero-list.component (without DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { HEROES }      from './mock-heroes';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n</code-tabs>\n<p translation-result=\"on\">必须在某些父注入器中提供 <code>HeroService</code>。<code>HeroListComponent</code> 并不关心 <code>HeroService</code> 来自哪里。\n如果你决定在 <code>AppModule</code> 中提供 <code>HeroService</code>，也不必修改 <code>HeroListComponent</code>。</p><p translation-origin=\"off\"><code>HeroService</code> must be provided in some parent injector. The code in <code>HeroListComponent</code> doesn't depend on where <code>HeroService</code> comes from.\nIf you decided to provide <code>HeroService</code> in <code>AppModule</code>, <code>HeroListComponent</code> wouldn't change.</p>\n\n<a id=\"singleton-services\"></a>\n<a id=\"component-child-injectors\"></a>\n<h3 id=\"injector-hierarchy-and-service-instances\" translation-result=\"on\">注入器树与服务实例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#injector-hierarchy-and-service-instances\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"injector-hierarchy-and-service-instances\">Injector hierarchy and service instances<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#injector-hierarchy-and-service-instances\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><em>在某个注入器</em>的范围内，服务是单例的。也就是说，在指定的注入器中最多只有某个服务的最多一个实例。</p><p translation-origin=\"off\">Services are singletons <em>within the scope of an injector</em>. That is, there is at most one instance of a service in a given injector.</p>\n\n<p translation-result=\"on\">应用只有一个根注入器。在 <code>root</code> 或 <code>AppModule</code> 级提供 <code>UserService</code> 意味着它注册到了根注入器上。\n在整个应用中只有一个 <code>UserService</code> 实例，每个要求注入 <code>UserService</code> 的类都会得到这一个服务实例，<em>除非</em>你在<em>子注入器</em>中配置了另一个提供者。</p><p translation-origin=\"off\">There is only one root injector for an app. Providing <code>UserService</code> at the <code>root</code> or <code>AppModule</code> level means it is registered with the root injector. There is just one <code>UserService</code> instance in the entire app and every class that injects <code>UserService</code> gets this service instance <em>unless</em> you configure another provider with a <em>child injector</em>.</p>\n\n<p translation-result=\"on\">Angular DI 具有<a href=\"guide/hierarchical-dependency-injection\">分层注入体系</a>，这意味着下级注入器也可以创建它们自己的服务实例。\nAngular 会有规律的创建下级注入器。每当 Angular 创建一个在 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 中指定了 <code>providers</code> 的组件实例时，它也会为该实例创建一个新的<em>子注入器</em>。\n类似的，当在运行期间加载一个新的 NgModule 时，Angular 也可以为它创建一个拥有自己的提供者的注入器。</p><p translation-origin=\"off\">Angular DI has a <a href=\"guide/hierarchical-dependency-injection\">hierarchical injection system</a>, which means that nested injectors can create their own service instances.\nAngular regularly creates nested injectors. Whenever Angular creates a new instance of a component that has <code>providers</code> specified in <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code>, it also creates a new <em>child injector</em> for that instance.\nSimilarly, when a new NgModule is lazy-loaded at run time, Angular can create an injector for it with its own providers.</p>\n\n<p translation-result=\"on\">子模块和组件注入器彼此独立，并且会为所提供的服务分别创建自己的实例。当 Angular 销毁 NgModule 或组件实例时，也会销毁这些注入器以及注入器中的那些服务实例。</p><p translation-origin=\"off\">Child modules and component injectors are independent of each other, and create their own separate instances of the provided services. When Angular destroys an NgModule or component instance, it also destroys that injector and that injector's service instances.</p>\n\n<p translation-result=\"on\">借助<a href=\"guide/hierarchical-dependency-injection\">注入器继承机制</a>，你仍然可以把全应用级的服务注入到这些组件中。\n组件的注入器是其父组件注入器的子节点，它会继承所有的祖先注入器，其终点则是应用的<em>根</em>注入器。\nAngular 可以注入该继承谱系中任何一个注入器提供的服务。</p><p translation-origin=\"off\">Thanks to <a href=\"guide/hierarchical-dependency-injection\">injector inheritance</a>,\nyou can still inject application-wide services into these components.\nA component's injector is a child of its parent component's injector, and inherits from all ancestor injectors all the way back to the application's <em>root</em> injector. Angular can inject a service provided by any injector in that lineage.</p>\n\n<p translation-result=\"on\">比如，Angular 既可以把 <code>HeroComponent</code> 中提供的 <code>HeroService</code>  注入到 <code>HeroListComponent</code>，也可以注入 <code>AppModule</code> 中提供的 <code>UserService</code>。</p><p translation-origin=\"off\">For example, Angular can inject <code>HeroListComponent</code> with both the <code>HeroService</code> provided in <code>HeroComponent</code> and the <code>UserService</code> provided in <code>AppModule</code>.</p>\n\n<a id=\"testing-the-component\"></a>\n<h2 id=\"testing-components-with-dependencies\" translation-result=\"on\">测试带有依赖的组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#testing-components-with-dependencies\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"testing-components-with-dependencies\">Testing components with dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#testing-components-with-dependencies\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">基于依赖注入设计一个类，能让它更易于测试。\n要想高效的测试应用的各个部分，你所要做的一切就是把这些依赖列到构造函数的参数表中而已。</p><p translation-origin=\"off\">Designing a class with dependency injection makes the class easier to test.\nListing dependencies as constructor parameters may be all you need to test application parts effectively.</p>\n\n<p translation-result=\"on\">比如，你可以使用一个可在测试期间操纵的模拟服务来创建新的 <code>HeroListComponent</code>。</p><p translation-origin=\"off\">For example, you can create a new <code>HeroListComponent</code> with a mock service that you can manipulate\nunder test.</p>\n\n<code-example path=\"dependency-injection/src/app/test.component.ts\" region=\"spec\" header=\"src/app/test.component.ts\">\nconst expectedHeroes = [{name: 'A'}, {name: 'B'}]\nconst mockService = &#x3C;HeroService> {getHeroes: () => expectedHeroes }\n\nit('should have heroes when HeroListComponent created', () => {\n  // Pass the mock to the constructor as the Angular injector would\n  const component = new HeroListComponent(mockService);\n  expect(component.heroes.length).toEqual(expectedHeroes.length);\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">欲知详情，参见<a href=\"guide/testing\">测试</a>一章。</p><p translation-origin=\"off\">Learn more in the <a href=\"guide/testing\">Testing</a> guide.</p>\n\n</div>\n<a id=\"service-needs-service\"></a>\n<h2 id=\"services-that-need-other-services\" translation-result=\"on\">那些需要其它服务的服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#services-that-need-other-services\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"services-that-need-other-services\">Services that need other services<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#services-that-need-other-services\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">服务还可以具有自己的依赖。<code>HeroService</code> 非常简单，没有自己的依赖。不过，如果你希望通过日志服务来报告这些活动，那么就可以使用同样的<em>构造函数注入</em>模式，添加一个构造函数来接收一个 <code>Logger</code> 参数。</p><p translation-origin=\"off\">Services can have their own dependencies. <code>HeroService</code> is very simple and doesn't have any dependencies of its own. Suppose, however, that you want it to report its activities through a logging service. You can apply the same <em>constructor injection</em> pattern,\nadding a constructor that takes a <code>Logger</code> parameter.</p>\n\n<p translation-result=\"on\">这是修改后的 <code>HeroService</code>，它注入了 <code>Logger</code>，我们把它和前一个版本的服务放在一起进行对比。</p><p translation-origin=\"off\">Here is the revised <code>HeroService</code> that injects <code>Logger</code>, side by side with the previous service for comparison.</p>\n\n<code-tabs>\n\n  <code-pane header=\"src/app/heroes/hero.service (v2)\" path=\"dependency-injection/src/app/heroes/hero.service.2.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES }     from './mock-heroes';\nimport { Logger }     from '../logger.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class HeroService {\n\n  constructor(private logger: Logger) {  }\n\n  getHeroes() {\n    this.logger.log('Getting heroes ...');\n    return HEROES;\n  }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/heroes/hero.service (v1)\" path=\"dependency-injection/src/app/heroes/hero.service.1.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES }     from './mock-heroes';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-pane>\n\n  <code-pane header=\"src/app/logger.service\" path=\"dependency-injection/src/app/logger.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class Logger {\n  logs: string[] = []; // capture logs for testing\n\n  log(message: string) {\n    this.logs.push(message);\n    console.log(message);\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p translation-result=\"on\">该构造函数请求注入一个 <code>Logger</code> 的实例，并把它保存在一个名叫 <code>logger</code> 的私有字段中。\n当要求获取英雄列表时，<code>getHeroes()</code> 方法就会记录一条消息。</p><p translation-origin=\"off\">The constructor asks for an injected instance of <code>Logger</code> and stores it in a private field called <code>logger</code>. The <code>getHeroes()</code> method logs a message when asked to fetch heroes.</p>\n\n<p translation-result=\"on\">注意，虽然 <code>Logger</code> 服务没有自己的依赖项，但是它同样带有 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器。实际上，<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> <strong>对所有服务都是必须的</strong>。</p><p translation-origin=\"off\">Notice that the <code>Logger</code> service also has the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator, even though it might not need its own dependencies. In fact, the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator is <strong>required for all services</strong>.</p>\n\n<p translation-result=\"on\">当 Angular 创建一个构造函数中有参数的类时，它会查找有关这些参数的类型，和供注入使用的元数据，以便找到正确的服务。\n如果 Angular 无法找到参数信息，它就会抛出一个错误。\n<em>只有当类具有某种装饰器时</em>，Angular 才能找到参数信息。\n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器是所有服务类的标准装饰器。</p><p translation-origin=\"off\">When Angular creates a class whose constructor has parameters, it looks for type and injection metadata about those parameters so that it can inject the correct service.\nIf Angular can't find that parameter information, it throws an error.\nAngular can only find the parameter information <em>if the class has a decorator of some kind</em>.\nThe <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator is the standard decorator for service classes.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"> 装饰器是 TypeScript 强制要求的。当 TypeScript 把代码<a href=\"guide/glossary#transpile\">转译</a>成 JavaScript 时，一般会丢弃参数的类型信息。只有当类具有装饰器，并且 <code>tsconfig.json</code> 中的编译器选项 <code>emitDecoratorMetadata</code> 为 <code>true</code> 时，TypeScript 才会保留这些信息。CLI 所配置的 <code>tsconfig.json</code> 就带有 <code>emitDecoratorMetadata: true</code>。</p><p translation-origin=\"off\"> The decorator requirement is imposed by TypeScript. TypeScript normally discards parameter type information when it <a href=\"guide/glossary#transpile\">transpiles</a> the code to JavaScript. TypeScript preserves this information if the class has a decorator and the <code>emitDecoratorMetadata</code> compiler option is set <code>true</code> in TypeScript's <code>tsconfig.json</code> configuration file. The CLI configures <code>tsconfig.json</code> with <code>emitDecoratorMetadata: true</code>.</p>\n\n<p translation-result=\"on\"> 这意味着你有责任给所有服务类加上 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code>。</p><p translation-origin=\"off\"> This means you're responsible for putting <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> on your service classes.</p>\n\n</div>\n<a id=\"token\"></a>\n<a id=\"injection-token\"></a>\n<h3 id=\"dependency-injection-tokens\" translation-result=\"on\">依赖注入令牌<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#dependency-injection-tokens\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"dependency-injection-tokens\">Dependency injection tokens<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#dependency-injection-tokens\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">当使用提供者配置注入器时，就会把提供者和一个 <a href=\"guide/glossary#di-token\">DI 令牌</a>关联起来。\n注入器维护一个内部<em>令牌-提供者</em>的映射表，当请求一个依赖项时就会引用它。令牌就是这个映射表的键。</p><p translation-origin=\"off\">When you configure an injector with a provider, you associate that provider with a <a href=\"guide/glossary#di-token\">DI token</a>.\nThe injector maintains an internal <em>token-provider</em> map that it references when\nasked for a dependency. The token is the key to the map.</p>\n\n<p translation-result=\"on\">在简单的例子中，依赖项的值是一个<em>实例</em>，而类的<em>类型</em>则充当键来查阅它。\n通过把 <code>HeroService</code> 类型作为令牌，你可以直接从注入器中获得一个 <code>HeroService</code> 实例。</p><p translation-origin=\"off\">In simple examples, the dependency value is an <em>instance</em>, and\nthe class <em>type</em> serves as its own lookup key.\nHere you get a <code>HeroService</code> directly from the injector by supplying the <code>HeroService</code> type as the token:</p>\n\n<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"get-hero-service\" header=\"src/app/injector.component.ts\">\nheroService: HeroService;\n\n</code-example>\n<p translation-result=\"on\">当你编写的构造函数中需要注入基于类的依赖项时，其行为也类似。\n当你使用 <code>HeroService</code> 类的类型来定义构造函数参数时，Angular 就会知道要注入与 <code>HeroService</code> 类这个令牌相关的服务。</p><p translation-origin=\"off\">The behavior is similar when you write a constructor that requires an injected class-based dependency.\nWhen you define a constructor parameter with the <code>HeroService</code> class type,\nAngular knows to inject the service associated with that <code>HeroService</code> class token:</p>\n\n<code-example path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\" header=\"src/app/heroes/hero-list.component.ts\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p translation-result=\"on\">很多依赖项的值都是通过类来提供的，但不是全部。扩展的 <em>provide</em> 对象让你可以把多种不同种类的提供者和 DI 令牌关联起来。</p><p translation-origin=\"off\">Many dependency values are provided by classes, but not all. The expanded <em>provide</em> object lets you associate different kinds of providers with a DI token.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">欲知详情，参见<a href=\"guide/dependency-injection-providers\">不同种类的提供者</a>。</p><p translation-origin=\"off\">Learn more about <a href=\"guide/dependency-injection-providers\">different kinds of providers</a>.</p>\n\n</li>\n</ul>\n<a id=\"optional\"></a>\n<h3 id=\"optional-dependencies\" translation-result=\"on\">可选依赖<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#optional-dependencies\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"optional-dependencies\">Optional dependencies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#optional-dependencies\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>HeroService</code> <em>需要</em>一个记录器，但是如果找不到它会怎么样？</p><p translation-origin=\"off\"><code>HeroService</code> <em>requires</em> a logger, but what if it could get by without\none?</p>\n\n<p translation-result=\"on\">当组件或服务声明某个依赖项时，该类的构造函数会以参数的形式接收那个依赖项。\n通过给这个参数加上 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 注解，你可以告诉 Angular，该依赖是可选的。</p><p translation-origin=\"off\">When a component or service declares a dependency, the class constructor takes that dependency as a parameter.\nYou can tell Angular that the dependency is optional by annotating the\nconstructor parameter with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>.</p>\n\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"import-optional\">\nimport { <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a> } from '@angular/core';\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-10-ctor\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() private logger?: Logger) {\n  if (this.logger) {\n    this.logger.log(some_message);\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">当使用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 时，你的代码必须能正确处理 null 值。如果你没有在任何地方注册过 logger 提供者，那么注入器就会把 <code>logger</code> 的值设置为 null。</p><p translation-origin=\"off\">When using <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>, your code must be prepared for a null value. If you\ndon't register a logger provider anywhere, the injector sets the\nvalue of <code>logger</code> to null.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>()</code> 和 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 都是<em>参数装饰器</em>。它们通过在需要依赖项的类的构造函数上对参数进行注解，来改变 DI 框架提供依赖项的方式。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>()</code> and <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> are <em>parameter decorators</em>. They alter the way the DI framework provides a dependency, by annotating the dependency parameter on the constructor of the class that requires the dependency.</p>\n\n<p translation-result=\"on\">欲知详情，参见<a href=\"guide/hierarchical-dependency-injection\">多级注入器</a>。</p><p translation-origin=\"off\">Learn more about parameter decorators in <a href=\"guide/hierarchical-dependency-injection\">Hierarchical Dependency Injectors</a>.</p>\n\n</div>\n<h2 id=\"summary\" translation-result=\"on\">小结<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#summary\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"summary\">Summary<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#summary\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本页中你学到了 Angular 依赖注入的基础知识。\n你可以注册多种提供者，并且知道了如何通过为构造函数添加参数来请求所注入的对象（比如服务）。</p><p translation-origin=\"off\">You learned the basics of Angular dependency injection in this page.\nYou can register various kinds of providers,\nand you know how to ask for an injected object (such as a service) by\nadding a parameter to a constructor.</p>\n\n<p translation-result=\"on\">在以下页面中可以深入了解 Angular DI 体系的能力及高级特性：</p><p translation-origin=\"off\">Dive deeper into the capabilities and advanced feature of the Angular DI system in the following pages:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">  要深入了解嵌套注入器，参见<a href=\"guide/hierarchical-dependency-injection\">多级依赖注入</a></p><p translation-origin=\"off\">Learn more about nested injectors in\n<a href=\"guide/hierarchical-dependency-injection\">Hierarchical Dependency Injection</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">到 <a href=\"guide/dependency-injection-providers\">DI 令牌与提供者</a>中学习更多知识。</p><p translation-origin=\"off\">Learn more about <a href=\"guide/dependency-injection-providers\">DI tokens and providers</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"><a href=\"guide/dependency-injection-in-action\">依赖注入实战</a>中讲了一些你能用 DI 做的一些有意思的事。 </p><p translation-origin=\"off\"><a href=\"guide/dependency-injection-in-action\">Dependency Injection in Action</a> is a cookbook for some of the interesting things you can do with DI.</p>\n\n</li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - api/core/ClassProvider\n - api/core/ClassSansProvider\n - api/core/ConstructorProvider\n - api/core/ConstructorSansProvider\n - api/core/ExistingProvider\n - api/core/ExistingSansProvider\n - api/core/FactoryProvider\n - api/core/FactorySansProvider\n - api/core/Inject\n - api/core/Injectable\n - api/core/Optional\n - api/core/Provider\n - api/core/StaticClassProvider\n - api/core/TypeProvider\n - api/core/ValueProvider\n - guide/architecture-next-steps\n - guide/architecture-services\n - guide/attribute-directives\n - guide/dependency-injection-providers\n - guide/glossary\n - guide/http\n - guide/ngmodule-api\n - guide/router\n - guide/sharing-ngmodules\n - guide/testing\n - guide/upgrade\n - tutorial/toh-pt4\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/core/Component\n - api/core/Directive\n - api/core/Inject\n - api/core/Injectable\n - api/core/NgModule\n - api/core/Optional\n - api/core/forwardRef\n - cli\n - guide/bootstrapping\n - guide/dependency-injection#configure-an-injector-with-a-service-provider\n - guide/dependency-injection#create-an-injectable-service-class\n - guide/dependency-injection#create-and-register-an-injectable-service\n - guide/dependency-injection#dependency-injection-in-angular\n - guide/dependency-injection#dependency-injection-tokens\n - guide/dependency-injection#injecting-services\n - guide/dependency-injection#injector-hierarchy-and-service-instances\n - guide/dependency-injection#optional-dependencies\n - guide/dependency-injection#services-that-need-other-services\n - guide/dependency-injection#summary\n - guide/dependency-injection#testing-components-with-dependencies\n - guide/dependency-injection-in-action\n - guide/dependency-injection-in-action#forwardref\n - guide/dependency-injection-providers\n - guide/glossary#di-token\n - guide/glossary#injector\n - guide/glossary#provider\n - guide/glossary#transpile\n - guide/hierarchical-dependency-injection\n - guide/testing\n - tutorial/\n - http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/dependency-injection.md?message=docs%3A%20请简述你的修改...\n-->"
}