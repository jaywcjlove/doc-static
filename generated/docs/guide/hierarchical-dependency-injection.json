{
  "id": "guide/hierarchical-dependency-injection",
  "title": "Hierarchical injectors",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/hierarchical-dependency-injection.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"hierarchical-injectors\" translation-result=\"on\">多级注入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#hierarchical-injectors\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"hierarchical-injectors\">Hierarchical injectors<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#hierarchical-injectors\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">Angular 中的注入器有一些规则，你可以利用这些规则来在应用程序中获得所需的可注入对象可见性。通过了解这些规则，可以确定应在哪个 NgModule、组件或指令中声明服务提供者。</p><p translation-origin=\"off\">Injectors in Angular have rules that you can leverage to\nachieve the desired visibility of injectables in your apps.\nBy understanding these rules, you can determine in which\nNgModule, Component or Directive you should declare a provider.</p>\n\n<h2 id=\"two-injector-hierarchies\" translation-result=\"on\">两个注入器层次结构<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#two-injector-hierarchies\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"two-injector-hierarchies\">Two injector hierarchies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#two-injector-hierarchies\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">Angular 中有两个注入器层次结构：</p><p translation-origin=\"off\">There are two injector hierarchies in Angular:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">   <code>ModuleInjector</code> 层次结构 —— 使用 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 或 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 注解在此层次结构中配置 <code>ModuleInjector</code>。</p><p translation-origin=\"off\"><code>ModuleInjector</code> hierarchy—configure a <code>ModuleInjector</code>\nin this hierarchy using an <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> or <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> annotation.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">   <code>ElementInjector</code> 层次结构 —— 在每个 DOM 元素上隐式创建。除非你在 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 或 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 的 <code>providers</code> 属性中进行配置，否则默认情况下，<code>ElementInjector</code> 为空。</p><p translation-origin=\"off\"><code>ElementInjector</code> hierarchy—created implicitly at each\nDOM element. An <code>ElementInjector</code> is empty by default\nunless you configure it in the <code>providers</code> property on\n<code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> or <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code>.</p>\n\n</li>\n</ol>\n<a id=\"register-providers-injectable\"></a>\n<h3 id=\"moduleinjector\"><code>ModuleInjector</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#moduleinjector\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">可以通过以下两种方式之一配置 <code>ModuleInjector</code> ：</p><p translation-origin=\"off\">The <code>ModuleInjector</code> can be configured in one of two ways:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">  使用 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 的 <code>providedIn</code> 属性引用 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 或 <code>root</code>。</p><p translation-origin=\"off\">Using the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> <code>providedIn</code> property to\nrefer to <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code>, or <code>root</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 的 <code>providers</code> 数组。</p><p translation-origin=\"off\">Using the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> <code>providers</code> array.</p>\n\n</li>\n</ul>\n<div class=\"is-helpful alert\">\n<h4 id=\"tree-shaking-and-injectable\" translation-result=\"on\">摇树优化与 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#tree-shaking-and-injectable\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"tree-shaking-and-injectable\">Tree-shaking and <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#tree-shaking-and-injectable\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 的 <code>providedIn</code> 属性优于 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 的 <code>providers</code> 数组，因为使用 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 的 <code>providedIn</code> 时，优化工具可以进行摇树优化，从而删除你的应用程序中未使用的服务，以减小捆绑包尺寸。</p><p translation-origin=\"off\">Using the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> <code>providedIn</code> property is preferable\nto the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> <code>providers</code>\narray because with <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> <code>providedIn</code>, optimization\ntools can perform\ntree-shaking, which removes services that your app isn't\nusing and results in smaller bundle sizes.</p>\n\n<p translation-result=\"on\">摇树优化对于库特别有用，因为使用该库的应用程序不需要注入它。在 <a href=\"guide/dependency-injection-providers\">DI 提供者中</a>了解有关<a href=\"guide/dependency-injection-providers#tree-shakable-providers\">可摇树优化的提供者</a>的更多信息。</p><p translation-origin=\"off\">Tree-shaking is especially useful for a library\nbecause the application which uses the library may not have\na need to inject it. Read more\nabout <a href=\"guide/dependency-injection-providers#tree-shakable-providers\">tree-shakable providers</a>\nin <a href=\"guide/dependency-injection-providers\">DI Providers</a>.</p>\n\n</div>\n<p translation-result=\"on\"><code>ModuleInjector</code> 由 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 和 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code> 属性配置。<code>ModuleInjector</code> 是可以通过 <code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code> 递归找到的所有 providers 数组的扁平化。</p><p translation-origin=\"off\"><code>ModuleInjector</code> is configured by the <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> and\n<code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code> property. <code>ModuleInjector</code> is a flattening of\nall of the providers arrays which can be reached by following the\n<code><a href=\"api/core/NgModule#imports\" class=\"code-anchor\">NgModule.imports</a></code> recursively.</p>\n\n<p translation-result=\"on\">子 <code>ModuleInjector</code> 是在延迟加载其它 <code>@NgModules</code> 时创建的。</p><p translation-origin=\"off\">Child <code>ModuleInjector</code>s are created when lazy loading other <code>@NgModules</code>.</p>\n\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 的 <code>providedIn</code> 属性提供服务的方式如下：</p><p translation-origin=\"off\">Provide services with the <code>providedIn</code> property of <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> as follows:</p>\n\n<code-example language=\"ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'  // &#x3C;--provides this service in the root ModuleInjector\n})\nexport class ItemService {\n  name = 'telephone';\n}\n</code-example>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器标识服务类。该 <code>providedIn</code> 属性配置指定的 <code>ModuleInjector</code>，这里的 <code>root</code> 会把让该服务在 <code>root</code> <code>ModuleInjector</code> 上可用。</p><p translation-origin=\"off\">The <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator identifies a service class.\nThe <code>providedIn</code> property configures a specific <code>ModuleInjector</code>,\nhere <code>root</code>, which makes the service available in the <code>root</code> <code>ModuleInjector</code>.</p>\n\n<h4 id=\"platform-injector\" translation-result=\"on\">平台注入器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#platform-injector\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"platform-injector\">Platform injector<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#platform-injector\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">在 <code>root</code> 之上还有两个注入器，一个是额外的 <code>ModuleInjector</code>，一个是 <code>NullInjector()</code>。</p><p translation-origin=\"off\">There are two more injectors above <code>root</code>, an\nadditional <code>ModuleInjector</code> and <code>NullInjector()</code>.</p>\n\n<p translation-result=\"on\">思考下 Angular 要如何通过 <code>main.ts</code> 中的如下代码引导应用程序：</p><p translation-origin=\"off\">Consider how Angular bootstraps the app with the\nfollowing in <code>main.ts</code>:</p>\n\n<code-example language=\"javascript\">\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule).then(ref => {...})\n</code-example>\n<p translation-result=\"on\"><code>bootstrapModule()</code> 方法会创建一个由 <code>AppModule</code> 配置的注入器作为平台注入器的子注入器。也就是 <code>root</code> <code>ModuleInjector</code>。</p><p translation-origin=\"off\">The <code>bootstrapModule()</code> method creates a child injector of\nthe platform injector which is configured by the <code>AppModule</code>.\nThis is the <code>root</code> <code>ModuleInjector</code>.</p>\n\n<p translation-result=\"on\"><code><a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>()</code> 方法创建一个由 <code>PlatformModule</code> 配置的注入器，该注入器包含特定平台的依赖项。这允许多个应用共享同一套平台配置。例如，无论你运行多少个应用程序，浏览器都只有一个 URL 栏。你可以使用 <code><a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>()</code> 函数提供 <code>extraProviders</code>，从而在平台级别配置特定平台的额外提供者。</p><p translation-origin=\"off\">The <code><a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>()</code> method creates an injector\nconfigured by a <code>PlatformModule</code>, which contains platform-specific\ndependencies. This allows multiple apps to share a platform\nconfiguration.\nFor example, a browser has only one URL bar, no matter how\nmany apps you have running.\nYou can configure additional platform-specific providers at the\nplatform level by supplying <code>extraProviders</code> using the <code><a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>()</code> function.</p>\n\n<p translation-result=\"on\">层次结构中的下一个父注入器是 <code>NullInjector()</code>，它是树的顶部。如果你在树中向上走了很远，以至于要在 <code>NullInjector()</code> 中寻找服务，那么除非使用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>，否则将收到错误消息，因为最终所有东西都将以 <code>NullInjector()</code> 结束并返回错误，或者对于 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>，返回 <code>null</code>。有关 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 的更多信息，请参见本指南的 <a href=\"guide/hierarchical-dependency-injection#optional\"><code>@Optional()</code> 部分</a>。</p><p translation-origin=\"off\">The next parent injector in the hierarchy is the <code>NullInjector()</code>,\nwhich is the top of the tree. If you've gone so far up the tree\nthat you are looking for a service in the <code>NullInjector()</code>, you'll\nget an error unless you've used <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> because ultimately,\neverything ends at the <code>NullInjector()</code> and it returns an error or,\nin the case of <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>, <code>null</code>. For more information on\n<code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>, see the <a href=\"guide/hierarchical-dependency-injection#optional\"><code>@Optional()</code> section</a> of this guide.</p>\n\n<p translation-result=\"on\">下图展示了前面各段落描述的 <code>root</code> <code>ModuleInjector</code> 及其父注入器之间的关系。</p><p translation-origin=\"off\">The following diagram represents the relationship between the\n<code>root</code> <code>ModuleInjector</code> and its parent injectors as the\nprevious paragraphs describe.</p>\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/dependency-injection/injectors.svg\" alt=\"NullInjector, ModuleInjector, root injector\" width=\"600\" height=\"445\">\n</div>\n<p translation-result=\"on\">虽然 <code>root</code> 是一个特殊的别名，但其它 <code>ModuleInjector</code> 都没有别名。每当创建动态加载组件时，你还会创建 <code>ModuleInjector</code>，比如路由器，它还会创建子 <code>ModuleInjector</code>。</p><p translation-origin=\"off\">While the name <code>root</code> is a special alias, other <code>ModuleInjector</code>s\ndon't have aliases. You have the option to create <code>ModuleInjector</code>s\nwhenever a dynamically loaded component is created, such as with\nthe Router, which will create child <code>ModuleInjector</code>s.</p>\n\n<p translation-result=\"on\">无论是使用 <code>bootstrapModule()</code> 的方法配置它，还是将所有提供者都用 <code>root</code> 注册到其自己的服务中，所有请求最终都会转发到 <code>root</code> 注入器。</p><p translation-origin=\"off\">All requests forward up to the root injector, whether you configured it\nwith the <code>bootstrapModule()</code> method, or registered all providers\nwith <code>root</code> in their own services.</p>\n\n<div class=\"alert is-helpful\">\n<h4 id=\"injectable-vs-ngmodule\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> vs. <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#injectable-vs-ngmodule\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\">如果你在 <code>AppModule</code> 的 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 中配置应用级提供者，它就会覆盖一个在 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 的 <code>root</code> 元数据中配置的提供者。你可以用这种方式，来配置供多个应用共享的服务的非默认提供者。</p><p translation-origin=\"off\">If you configure an app-wide provider in the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> of\n<code>AppModule</code>, it overrides one configured for <code>root</code> in the\n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> metadata. You can do this to configure a\nnon-default provider of a service that is shared with multiple apps.</p>\n\n<p translation-result=\"on\">下面的例子中，通过把 <a href=\"guide/router#location-strategy\">location 策略</a> 的提供者添加到 <code>AppModule</code> 的 <code>providers</code> 列表中，为路由器配置了非默认的 <a href=\"guide/router#location-strategy\">location 策略</a>。</p><p translation-origin=\"off\">Here is an example of the case where the component router\nconfiguration includes\na non-default <a href=\"guide/router#location-strategy\">location strategy</a>\nby listing its provider\nin the <code>providers</code> list of the <code>AppModule</code>.</p>\n\n<code-example path=\"dependency-injection-in-action/src/app/app.module.ts\" region=\"providers\" header=\"src/app/app.module.ts (providers)\">\nproviders: [\n  { provide: <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a>, useClass: <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a> }\n]\n\n</code-example>\n</div>\n<h3 id=\"elementinjector\"><code>ElementInjector</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#elementinjector\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">Angular 会为每个 DOM 元素隐式创建 <code>ElementInjector</code>。</p><p translation-origin=\"off\">Angular creates <code>ElementInjector</code>s implicitly for each DOM element.</p>\n\n<p translation-result=\"on\">可以用 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器中的 <code>providers</code> 或 <code>viewProviders</code> 属性来配置 <code>ElementInjector</code> 以提供服务。例如，下面的 <code>TestComponent</code> 通过提供此服务来配置 <code>ElementInjector</code>：</p><p translation-origin=\"off\">Providing a service in the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator using\nits <code>providers</code> or <code>viewProviders</code>\nproperty configures an <code>ElementInjector</code>.\nFor example, the following <code>TestComponent</code> configures the <code>ElementInjector</code>\nby providing the service as follows:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{ provide: ItemService, useValue: { name: 'lamp' } }]\n})\nexport class TestComponent\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意：</strong>请参阅<a href=\"guide/hierarchical-dependency-injection#resolution-rules\">解析规则</a>部分，以了解 <code>ModuleInjector</code> 树和 <code>ElementInjector</code> 树之间的关系。</p><p translation-origin=\"off\"><strong>Note:</strong> Please see the\n<a href=\"guide/hierarchical-dependency-injection#resolution-rules\">resolution rules</a>\nsection to understand the relationship between the <code>ModuleInjector</code> tree and\nthe <code>ElementInjector</code> tree.</p>\n\n</div>\n<p translation-result=\"on\">在组件中提供服务时，可以通过 <code>ElementInjector</code> 在该组件实例处使用该服务。根据<a href=\"guide/hierarchical-dependency-injection#resolution-rules\">解析规则</a>部分描述的可见性规则，它也同样在子组件/指令处可见。</p><p translation-origin=\"off\">When you provide services in a component, that service is available via\nthe <code>ElementInjector</code> at that component instance.\nIt may also be visible at\nchild component/directives based on visibility rules described in the <a href=\"guide/hierarchical-dependency-injection#resolution-rules\">resolution rules</a> section.</p>\n\n<p translation-result=\"on\">当组件实例被销毁时，该服务实例也将被销毁。</p><p translation-origin=\"off\">When the component instance is destroyed, so is that service instance.</p>\n\n<h4 id=\"directive-and-component\" translation-result=\"on\"><code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 和 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#directive-and-component\"><i class=\"material-icons\">link</i></a></h4><h4 translation-origin=\"off\" id=\"directive-and-component\"><code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> and <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#directive-and-component\"><i class=\"material-icons\">link</i></a></h4>\n\n<p translation-result=\"on\">组件是一种特殊类型的指令，这意味着 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> 具有 <code>providers</code> 属性，<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 也同样如此。\n这意味着指令和组件都可以使用 <code>providers</code> 属性来配置提供者。当使用 <code>providers</code> 属性为组件或指令配置提供者时，该提供程商就属于该组件或指令的 <code>ElementInjector</code>。同一元素上的组件和指令共享同一个注入器。</p><p translation-origin=\"off\">A component is a special type of directive, which means that\njust as <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> has a <code>providers</code> property, <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> does too.\nThis means that directives as well as components can configure\nproviders, using the <code>providers</code> property.\nWhen you configure a provider for a component or directive\nusing the <code>providers</code> property,\nthat provider belongs to the <code>ElementInjector</code> of that component or\ndirective.\nComponents and directives on the same element share an injector.</p>\n\n<a id=\"resolution-rules\"></a>\n<h2 id=\"resolution-rules\" translation-result=\"on\">解析规则<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#resolution-rules\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"resolution-rules\">Resolution rules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#resolution-rules\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">当为组件/指令解析令牌时，Angular 分为两个阶段来解析它：</p><p translation-origin=\"off\">When resolving a token for a component/directive, Angular\nresolves it in two phases:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">针对 <code>ElementInjector</code> 层次结构（其父级）</p><p translation-origin=\"off\">Against the <code>ElementInjector</code> hierarchy (its parents)</p>\n\n</li>\n<li>\n<p translation-result=\"on\">针对 <code>ModuleInjector</code> 层次结构（其父级）</p><p translation-origin=\"off\">Against the <code>ModuleInjector</code> hierarchy (its parents)</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">当组件声明依赖项时，Angular 会尝试使用它自己的 <code>ElementInjector</code> 来满足该依赖。\n如果组件的注入器缺少提供者，它将把请求传给其父组件的 <code>ElementInjector</code>。</p><p translation-origin=\"off\">When a component declares a dependency, Angular tries to satisfy that\ndependency with its own <code>ElementInjector</code>.\nIf the component's injector lacks the provider, it passes the request\nup to its parent component's <code>ElementInjector</code>.</p>\n\n<p translation-result=\"on\">这些请求将继续转发，直到 Angular 找到可以处理该请求的注入器或用完祖先 <code>ElementInjector</code>。</p><p translation-origin=\"off\">The requests keep forwarding up until Angular finds an injector that can\nhandle the request or runs out of ancestor <code>ElementInjector</code>s.</p>\n\n<p translation-result=\"on\">如果 Angular 在任何 <code>ElementInjector</code> 中都找不到提供者，它将返回到发起请求的元素，并在 <code>ModuleInjector</code> 层次结构中进行查找。如果 Angular 仍然找不到提供者，它将引发错误。</p><p translation-origin=\"off\">If Angular doesn't find the provider in any <code>ElementInjector</code>s,\nit goes back to the element where the request originated and looks\nin the <code>ModuleInjector</code> hierarchy.\nIf Angular still doesn't find the provider, it throws an error.</p>\n\n<p translation-result=\"on\">如果你已在不同级别注册了相同 DI 令牌的提供者，则 Angular 会用遇到的第一个来解析该依赖。例如，如果提供者已经在需要此服务的组件中本地注册了，则 Angular 不会再寻找同一服务的其它提供者。</p><p translation-origin=\"off\">If you have registered a provider for the same DI token at\ndifferent levels, the first one Angular encounters is the one\nit uses to resolve the dependency. If, for example, a provider\nis registered locally in the component that needs a service,\nAngular doesn't look for another provider of the same service.</p>\n\n<h2 id=\"resolution-modifiers\" translation-result=\"on\">解析修饰符<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#resolution-modifiers\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"resolution-modifiers\">Resolution modifiers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#resolution-modifiers\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">可以使用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>，<code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code>，<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 和 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 来修饰 Angular 的解析行为。从 <code>@angular/core</code> 导入它们，并在注入服务时在组件类构造函数中使用它们。</p><p translation-origin=\"off\">Angular's resolution behavior can be modified with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>, <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code>,\n<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> and <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>. Import each of them from <code>@angular/core</code>\nand use each in the component class constructor when you inject your service.</p>\n\n<p translation-result=\"on\">有关展示本节介绍的解析修饰符的可运行应用，请参阅<live-example name=\"resolution-modifiers\">解析修饰符范例</live-example>。</p><p translation-origin=\"off\">For a working app showcasing the resolution modifiers that\nthis section covers, see the <live-example name=\"resolution-modifiers\">resolution modifiers example</live-example>.</p>\n\n<h3 id=\"types-of-modifiers\" translation-result=\"on\">修饰符的类型<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#types-of-modifiers\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"types-of-modifiers\">Types of modifiers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#types-of-modifiers\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">解析修饰符分为三类：</p><p translation-origin=\"off\">Resolution modifiers fall into three categories:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">   如果 Angular 找不到你要的东西该怎么办，用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code></p><p translation-origin=\"off\">What to do if Angular doesn't find what you're\nlooking for, that is <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">从哪里开始寻找，用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code></p><p translation-origin=\"off\">Where to start looking, that is <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code></p>\n\n</li>\n<li>\n<p translation-result=\"on\">到哪里停止寻找，用 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 和 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code></p><p translation-origin=\"off\">Where to stop looking, <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> and <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code></p>\n\n</li>\n</ol>\n<p translation-result=\"on\">默认情况下，Angular 始终从当前的 <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> 开始，并一直向上搜索。修饰符使你可以更改开始（默认是自己）或结束位置。</p><p translation-origin=\"off\">By default, Angular always starts at the current <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> and keeps\nsearching all the way up. Modifiers allow you to change the starting\n(self) or ending location.</p>\n\n<p translation-result=\"on\">另外，你可以组合除 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 和 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 之外的所有修饰符，当然还有 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 和 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code>。</p><p translation-origin=\"off\">Additionally, you can combine all of the modifiers except <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> and <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> and of course <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> and <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code>.</p>\n\n<a id=\"optional\"></a>\n<h3 id=\"optional\"><code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#optional\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 允许 Angular 将你注入的服务视为可选服务。这样，如果无法在运行时解析它，Angular 只会将服务解析为 <code>null</code>，而不会抛出错误。在下面的示例中，服务 <code>OptionalService</code> 没有在 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 或组件类中提供，所以它没有在应用中的任何地方。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> allows Angular to consider a service you inject to be optional.\nThis way, if it can't be resolved at runtime, Angular simply\nresolves the service as <code>null</code>, rather than throwing an error. In\nthe following example, the service, <code>OptionalService</code>, isn't provided in\nthe service, <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code>, or component class, so it isn't available\nanywhere in the app.</p>\n\n<code-example path=\"resolution-modifiers/src/app/optional/optional.component.ts\" header=\"resolution-modifiers/src/app/optional/optional.component.ts\" region=\"optional-component\">\nexport class OptionalComponent {\n  constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public optional?: OptionalService) {}\n}\n\n</code-example>\n<h3 id=\"self\"><code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#self\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 让 Angular 仅查看当前组件或指令的 <code>ElementInjector</code>。</p><p translation-origin=\"off\">Use <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> so that Angular will only look at the <code>ElementInjector</code> for the current component or directive.</p>\n\n<p translation-result=\"on\"><code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 的一个好例子是要注入某个服务，但只有当该服务在当前宿主元素上可用时才行。为了避免这种情况下出错，请将 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 与 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 结合使用。</p><p translation-origin=\"off\">A good use case for <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> is to inject a service but only if it is\navailable on the current host element. To avoid errors in this situation,\ncombine <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>.</p>\n\n<p translation-result=\"on\">例如，在下面的 <code>SelfComponent</code> 中。请注意在构造函数中注入的 <code>LeafService</code>。</p><p translation-origin=\"off\">For example, in the following <code>SelfComponent</code>, notice\nthe injected <code>LeafService</code> in\nthe constructor.</p>\n\n<code-example path=\"resolution-modifiers/src/app/self-no-data/self-no-data.component.ts\" header=\"resolution-modifiers/src/app/self-no-data/self-no-data.component.ts\" region=\"self-no-data-component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-self-no-data',\n  templateUrl: './self-no-data.component.html',\n  styleUrls: ['./self-no-data.component.css']\n})\nexport class SelfNoDataComponent {\n  constructor(@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public leaf?: LeafService) { }\n}\n\n\n</code-example>\n<p translation-result=\"on\">在这个例子中，有一个父提供者，注入服务将返回该值，但是，使用 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 和 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 注入的服务将返回 <code>null</code> 因为 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 告诉注入器在当前宿主元素上就要停止搜索。</p><p translation-origin=\"off\">In this example, there is a parent provider and injecting the\nservice will return the value, however, injecting the service\nwith <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> and <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> will return <code>null</code> because\n<code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> tells the injector to stop searching in the current\nhost element.</p>\n\n<p translation-result=\"on\">另一个示例显示了具有 <code>FlowerService</code> 提供者的组件类。在这个例子中，注入器没有超出当前 <code>ElementInjector</code> 就停止了，因为它已经找到了 <code>FlowerService</code> 并返回了黄色花朵🌼。</p><p translation-origin=\"off\">Another example shows the component class with a provider\nfor <code>FlowerService</code>. In this case, the injector looks no further\nthan the current <code>ElementInjector</code> because it finds the <code>FlowerService</code> and returns the yellow flower 🌼.</p>\n\n<code-example path=\"resolution-modifiers/src/app/self/self.component.ts\" header=\"resolution-modifiers/src/app/self/self.component.ts\" region=\"self-component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-self',\n  templateUrl: './self.component.html',\n  styleUrls: ['./self.component.css'],\n  providers: [{ provide: FlowerService, useValue: { emoji: '🌼' } }]\n\n})\nexport class SelfComponent {\n  constructor(@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>() public flower: FlowerService) {}\n}\n\n</code-example>\n<h3 id=\"skipself\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#skipself\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 与 <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 相反。使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>，Angular 在父 <code>ElementInjector</code> 中而不是当前 <code>ElementInjector</code> 中开始搜索服务。因此，如果父 <code>ElementInjector</code> 对 <code>emoji</code> 使用了值 <code>🌿</code>（蕨类），但组件的 <code>providers</code> 数组中有 <code>🍁</code>（枫叶），则 Angular 将忽略 <code>🍁</code>（枫叶），而使用 <code>🌿</code>（蕨类）。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> is the opposite of <code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code>. With <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>, Angular\nstarts its search for a service in the parent <code>ElementInjector</code>, rather than\nin the current one. So if the parent <code>ElementInjector</code> were using the value  <code>🌿</code>  (fern)\nfor <code>emoji</code> , but you had  <code>🍁</code>  (maple leaf) in the component's <code>providers</code> array,\nAngular would ignore  <code>🍁</code>  (maple leaf) and use  <code>🌿</code>  (fern).</p>\n\n<p translation-result=\"on\">要在代码中看到这一点，请先假定 <code>emoji</code> 的以下值就是父组件正在使用的值，如本服务所示：</p><p translation-origin=\"off\">To see this in code, assume that the following value for <code>emoji</code> is what the parent component were using, as in this service:</p>\n\n<code-example path=\"resolution-modifiers/src/app/leaf.service.ts\" header=\"resolution-modifiers/src/app/leaf.service.ts\" region=\"leafservice\">\nexport class LeafService {\n  emoji = '🌿';\n}\n\n</code-example>\n<p translation-result=\"on\">想象一下，在子组件中，你有一个不同的值 <code>🍁</code>（枫叶），但你想使用父项的值。你就要使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> ：</p><p translation-origin=\"off\">Imagine that in the child component, you had a different value, <code>🍁</code> (maple leaf) but you wanted to use the parent's value instead. This is when you'd use <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>:</p>\n\n<code-example path=\"resolution-modifiers/src/app/skipself/skipself.component.ts\" header=\"resolution-modifiers/src/app/skipself/skipself.component.ts\" region=\"skipself-component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-skipself',\n  templateUrl: './skipself.component.html',\n  styleUrls: ['./skipself.component.css'],\n  // Angular would ignore this LeafService instance\n  providers: [{ provide: LeafService, useValue: { emoji: '🍁' } }]\n})\nexport class SkipselfComponent {\n  // Use @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() in the constructor\n  constructor(@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() public leaf: LeafService) { }\n}\n\n</code-example>\n<p translation-result=\"on\">在这个例子中，你获得的 <code>emoji</code> 值将为 <code>🌿</code>（蕨类），而不是 <code>🍁</code>（枫叶）。</p><p translation-origin=\"off\">In this case, the value you'd get for <code>emoji</code> would be <code>🌿</code> (fern), not <code>🍁</code> (maple leaf).</p>\n\n<h4 id=\"skipself-with-optional\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#skipself-with-optional\"><i class=\"material-icons\">link</i></a></h4>\n<p translation-result=\"on\">如果值为 <code>null</code> 请同时使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 和 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 来防止错误。在下面的示例中，将 <code>Person</code> 服务注入到构造函数中。<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 告诉 Angular 跳过当前的注入器，如果 <code>Person</code> 服务为 <code>null</code>，则 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 将防止报错。</p><p translation-origin=\"off\">Use <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> to prevent an error if the value is <code>null</code>. In the following example, the <code>Person</code> service is injected in the constructor. <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> tells Angular to skip the current injector and <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> will prevent an error should the <code>Person</code> service be <code>null</code>.</p>\n\n<code-example language=\"ts\">\nclass Person {\n  constructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parent?: Person) {}\n}\n</code-example>\n<h3 id=\"host\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#host\"><i class=\"material-icons\">link</i></a></h3>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 使你可以在搜索提供者时将当前组件指定为注入器树的最后一站。即使树的更上级有一个服务实例，Angular 也不会继续寻找。使用 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 的例子如下：</p><p translation-origin=\"off\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> lets you designate a component as the last stop in the injector tree when searching for providers. Even if there is a service instance further up the tree, Angular won't continue looking. Use <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> as follows:</p>\n\n<code-example path=\"resolution-modifiers/src/app/host/host.component.ts\" header=\"resolution-modifiers/src/app/host/host.component.ts\" region=\"host-component\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-host',\n  templateUrl: './host.component.html',\n  styleUrls: ['./host.component.css'],\n  //  provide the service\n  providers: [{ provide: FlowerService, useValue: { emoji: '🌼' } }]\n})\nexport class HostComponent {\n  // use @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() in the constructor when injecting the service\n  constructor(@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public flower?: FlowerService) { }\n\n}\n\n</code-example>\n<p translation-result=\"on\">由于 <code>HostComponent</code> 在其构造函数中具有 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>，因此，无论 <code>HostComponent</code> 的父级是否可能有 <code>flower.emoji</code> 值，该 <code>HostComponent</code> 都将使用 <code>🌼</code>（黄色花朵）。</p><p translation-origin=\"off\">Since <code>HostComponent</code> has <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> in its constructor, no\nmatter what the parent of <code>HostComponent</code> might have as a\n<code>flower.emoji</code> value,\nthe <code>HostComponent</code> will use <code>🌼</code> (yellow flower).</p>\n\n<h2 id=\"logical-structure-of-the-template\" translation-result=\"on\">模板的逻辑结构<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#logical-structure-of-the-template\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"logical-structure-of-the-template\">Logical structure of the template<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#logical-structure-of-the-template\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在组件类中提供服务时，服务在 <code>ElementInjector</code> 树中的可见性是取决于你在何处以及如何提供这些服务。</p><p translation-origin=\"off\">When you provide services in the component class, services are\nvisible within the <code>ElementInjector</code> tree relative to where\nand how you provide those services.</p>\n\n<p translation-result=\"on\">了解 Angular 模板的基础逻辑结构将为你配置服务并进而控制其可见性奠定基础。</p><p translation-origin=\"off\">Understanding the underlying logical structure of the Angular\ntemplate will give you a foundation for configuring services\nand in turn control their visibility.</p>\n\n<p translation-result=\"on\">组件在模板中使用，如以下示例所示：</p><p translation-origin=\"off\">Components are used in your templates, as in the following example:</p>\n\n<code-example>\n&#x3C;app-root>\n    &#x3C;app-child>&#x3C;/app-child>\n&#x3C;/app-root>\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意：</strong>通常，你要在单独的文件中声明组件及其模板。为了理解注入系统的工作原理，从组合逻辑树的视角来看它们是很有帮助的。使用术语“逻辑”将其与渲染树（你的应用程序 DOM 树）区分开。为了标记组件模板的位置，本指南使用 <code>&#x3C;#VIEW></code> 伪元素，该元素实际上不存在于渲染树中，仅用于心智模型中。</p><p translation-origin=\"off\"><strong>Note:</strong> Usually, you declare the components and their\ntemplates in separate files. For the purposes of understanding\nhow the injection system works, it is useful to look at them\nfrom the point of view of a combined logical tree. The term\nlogical distinguishes it from the render tree (your application\nDOM tree). To mark the locations of where the component\ntemplates are located, this guide uses the <code>&#x3C;#VIEW></code>\npseudo element, which doesn't actually exist in the render tree\nand is present for mental model purposes only.</p>\n\n</div>\n<p translation-result=\"on\">下面是如何将 <code>&#x3C;app-root></code> 和 <code>&#x3C;app-child></code> 视图树组合为单个逻辑树的示例：</p><p translation-origin=\"off\">The following is an example of how the <code>&#x3C;app-root></code> and <code>&#x3C;app-child></code> view trees are combined into a single logical tree:</p>\n\n<code-example>\n&#x3C;app-root>\n  &#x3C;#VIEW>\n    &#x3C;app-child>\n     &#x3C;#VIEW>\n       ...content goes here...\n     &#x3C;/#VIEW>\n    &#x3C;/app-child>\n  &#x3C;#VIEW>\n&#x3C;/app-root>\n</code-example>\n<p translation-result=\"on\">当你在组件类中配置服务时，了解这种 <code>&#x3C;#VIEW></code> 划界的思想尤其重要。</p><p translation-origin=\"off\">Understanding the idea of the <code>&#x3C;#VIEW></code> demarcation is especially significant when you configure services in the component class.</p>\n\n<h2 id=\"providing-services-in-component\" translation-result=\"on\">在 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 中提供服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#providing-services-in-component\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"providing-services-in-component\">Providing services in <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#providing-services-in-component\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你如何通过 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> （或 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code> ）装饰器提供服务决定了它们的可见性。以下各节演示了 <code>providers</code> 和 <code>viewProviders</code> 以及使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 和 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 修改服务可见性的方法。</p><p translation-origin=\"off\">How you provide services via an <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> (or <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>()</code>)\ndecorator determines their visibility. The following sections\ndemonstrate <code>providers</code> and <code>viewProviders</code> along with ways to\nmodify service visibility with <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> and <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>.</p>\n\n<p translation-result=\"on\">组件类可以通过两种方式提供服务：</p><p translation-origin=\"off\">A component class can provide services in two ways:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">使用 <code>providers</code> 数组</p><p translation-origin=\"off\">with a <code>providers</code> array</p>\n\n</li>\n</ol>\n<code-example language=\"typescript=\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [\n    {provide: FlowerService, useValue: {emoji: '🌺'}}\n  ]\n})\n</code-example>\n<ol start=\"2\">\n<li>\n<p translation-result=\"on\">使用 <code>viewProviders</code> 数组</p><p translation-origin=\"off\">with a <code>viewProviders</code> array</p>\n\n</li>\n</ol>\n<code-example language=\"typescript=\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  viewProviders: [\n    {provide: AnimalService, useValue: {emoji: '🐶'}}\n  ]\n})\n</code-example>\n<p translation-result=\"on\">为了解 <code>providers</code> 和 <code>viewProviders</code> 对服务可见性的影响有何差异，以下各节将逐步构建一个 <live-example name=\"providers-viewproviders\"></live-example> 并在代码和逻辑树中比较 <code>providers</code> 和 <code>viewProviders</code> 的作用。</p><p translation-origin=\"off\">To understand how the <code>providers</code> and <code>viewProviders</code> influence service\nvisibility differently, the following sections build\na <live-example name=\"providers-viewproviders\"></live-example>\nstep-by-step and compare the use of <code>providers</code> and <code>viewProviders</code>\nin code and a logical tree.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意：</strong>在逻辑树中，你会看到 <code>@Provide</code>，<code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 和 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>，这些不是真正的 HTML 属性，只是为了在这里证明其幕后的原理。</p><p translation-origin=\"off\"><strong>NOTE:</strong> In the logical tree, you'll see <code>@Provide</code>, <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code>, and\n<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>, which are not real HTML attributes but are here to demonstrate\nwhat is going on under the hood.</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">  <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(Token)=>Value</code> 表示，如果要将 <code>Token</code> 注入逻辑树中的此位置，则它的值为 <code>Value</code>。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(Token)=>Value</code> demonstrates that if <code>Token</code> is injected at\nthis location in the logical tree its value would be <code>Value</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  <code>@Provide(Token=Value)</code> 表示，在逻辑树中的此位置存在一个值为 <code>Value</code> 的 <code>Token</code> 提供者的声明。</p><p translation-origin=\"off\"><code>@Provide(Token=Value)</code> demonstrates that there is a declaration of\n<code>Token</code> provider with value <code>Value</code> at this location in the logical tree.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(Token)</code> 表示，应在此位置使用后备的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 注入器。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(Token)</code> demonstrates that a fallback <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> injector\nshould be used at this location.</p>\n\n</li>\n</ul>\n</div>\n<h3 id=\"example-app-structure\" translation-result=\"on\">应用程序结构示例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#example-app-structure\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"example-app-structure\">Example app structure<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#example-app-structure\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">示例应用程序的 <code>root</code> 提供了 <code>FlowerService</code>，其 <code>emoji</code> 值为 <code>🌺</code>（红色芙蓉）。</p><p translation-origin=\"off\">The example app has a <code>FlowerService</code> provided in <code>root</code> with an <code>emoji</code>\nvalue of <code>🌺</code> (red hibiscus).</p>\n\n<code-example path=\"providers-viewproviders/src/app/flower.service.ts\" header=\"providers-viewproviders/src/app/flower.service.ts\" region=\"flowerservice\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class FlowerService {\n  emoji = '🌺';\n}\n\n</code-example>\n<p translation-result=\"on\">考虑一个只有 <code>AppComponent</code> 和 <code>ChildComponent</code> 的简单应用程序。最基本的渲染视图看起来就像嵌套的 HTML 元素，例如：</p><p translation-origin=\"off\">Consider a simple app with only an <code>AppComponent</code> and a <code>ChildComponent</code>.\nThe most basic rendered view would look like nested HTML elements such as\nthe following:</p>\n\n<code-example>\n&#x3C;app-root> &#x3C;!-- AppComponent selector -->\n    &#x3C;app-child> &#x3C;!-- ChildComponent selector -->\n    &#x3C;/app-child>\n&#x3C;/app-root>\n</code-example>\n<p translation-result=\"on\">但是，在幕后，Angular 在解析注入请求时使用如下逻辑视图表示形式：</p><p translation-origin=\"off\">However, behind the scenes, Angular uses a logical view\nrepresentation as follows when resolving injection requests:</p>\n\n<code-example>\n&#x3C;app-root> &#x3C;!-- AppComponent selector -->\n    &#x3C;#VIEW>\n        &#x3C;app-child> &#x3C;!-- ChildComponent selector -->\n            &#x3C;#VIEW>\n            &#x3C;/#VIEW>\n        &#x3C;/app-child>\n    &#x3C;/#VIEW>\n&#x3C;/app-root>\n</code-example>\n<p translation-result=\"on\">此处的 <code>&#x3C;#VIEW></code> 表示模板的实例。请注意，每个组件都有自己的 <code>&#x3C;#VIEW></code>。</p><p translation-origin=\"off\">The <code>&#x3C;#VIEW></code> here represents an instance of a template.\nNotice that each component has its own <code>&#x3C;#VIEW></code>.</p>\n\n<p translation-result=\"on\">了解此结构可以告知你如何提供和注入服务，并完全控制服务的可见性。</p><p translation-origin=\"off\">Knowledge of this structure can inform how you provide and\ninject your services, and give you complete control of service visibility.</p>\n\n<p translation-result=\"on\">现在，考虑 <code>&#x3C;app-root></code> 只注入了 <code>FlowerService</code> ：</p><p translation-origin=\"off\">Now, consider that <code>&#x3C;app-root></code> simply injects the <code>FlowerService</code>:</p>\n\n<code-example path=\"providers-viewproviders/src/app/app.component.1.ts\" header=\"providers-viewproviders/src/app/app.component.ts\" region=\"injection\">\nexport class AppComponent  {\n  constructor(public flower: FlowerService) {}\n}\n\n</code-example>\n<p translation-result=\"on\">将绑定添加到 <code>&#x3C;app-root></code> 模板来将结果可视化：</p><p translation-origin=\"off\">Add a binding to the <code>&#x3C;app-root></code> template to visualize the result:</p>\n\n<code-example path=\"providers-viewproviders/src/app/app.component.html\" header=\"providers-viewproviders/src/app/app.component.html\" region=\"binding-flower\">\n&#x3C;p>Emoji from FlowerService: {{flower.emoji}}&#x3C;/p>\n\n</code-example>\n<p translation-result=\"on\">该视图中的输出为：</p><p translation-origin=\"off\">The output in the view would be:</p>\n\n<code-example>\nEmoji from FlowerService: 🌺\n</code-example>\n<p translation-result=\"on\">在逻辑树中，这可以表示成如下形式：</p><p translation-origin=\"off\">In the logical tree, this would be represented as follows:</p>\n\n<code-example>\n&#x3C;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n        @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService) flower=>\"🌺\">\n  &#x3C;#VIEW>\n\n    &#x3C;p>Emoji from FlowerService: {{flower.emoji}} (🌺)&#x3C;/p>\n\n    &#x3C;app-child>\n      &#x3C;#VIEW>\n      &#x3C;/#VIEW>\n     &#x3C;/app-child>\n  &#x3C;/#VIEW>\n&#x3C;/app-root>\n</code-example>\n<p translation-result=\"on\">当 <code>&#x3C;app-root></code> 请求 <code>FlowerService</code> 时，注入器的工作就是解析 <code>FlowerService</code> 令牌。令牌的解析分为两个阶段：</p><p translation-origin=\"off\">When <code>&#x3C;app-root></code> requests the <code>FlowerService</code>, it is the injector's job\nto resolve the <code>FlowerService</code> token. The resolution of the token happens\nin two phases:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">   注入器确定逻辑树中搜索的开始位置和结束位置。注入程序从起始位置开始，并在逻辑树的每个级别上查找令牌。如果找到令牌，则将其返回。</p><p translation-origin=\"off\">The injector determines the starting location in the logical tree and\nan ending location of the search. The injector begins with the starting\nlocation and looks for the token at each level in the logical tree. If\nthe token is found it is returned.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">   如果未找到令牌，则注入程序将寻找最接近的父 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> 委派该请求。</p><p translation-origin=\"off\">If the token is not found, the injector looks for the closest\nparent <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>()</code> to delegate the request to.</p>\n\n</li>\n</ol>\n<p translation-result=\"on\">在这个例子中，约束为：</p><p translation-origin=\"off\">In the example case, the constraints are:</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">从属于 <code>&#x3C;app-root></code> 的  <code>&#x3C;#VIEW></code> 开始，并结束于 <code>&#x3C;app-root></code>。</p><p translation-origin=\"off\">Start with <code>&#x3C;#VIEW></code> belonging to <code>&#x3C;app-root></code> and end with <code>&#x3C;app-root></code>.</p>\n\n</li>\n</ol>\n<ul>\n<li>\n<p translation-result=\"on\">  通常，搜索的起点就是注入点。但是，在这个例子中，<code>&#x3C;app-root></code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 的特殊之处在于它们还包括自己的 <code>viewProviders</code>，这就是为什么搜索从 <code>&#x3C;app-root></code> 的 <code>&#x3C;#VIEW></code> 开始的原因。（对于匹配同一位置的指令，情况却并非如此）。</p><p translation-origin=\"off\">Normally the starting point for search is at the point\nof injection. However, in this case <code>&#x3C;app-root></code>  <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>s\nare special in that they also include their own <code>viewProviders</code>,\nwhich is why the search starts at <code>&#x3C;#VIEW></code> belonging to <code>&#x3C;app-root></code>.\n(This would not be the case for a directive matched at the same location).</p>\n\n</li>\n<li>\n<p translation-result=\"on\">  结束位置恰好与组件本身相同，因为它就是此应用程序中最顶层的组件。</p><p translation-origin=\"off\">The ending location just happens to be the same as the component\nitself, because it is the topmost component in this application.</p>\n\n</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p translation-result=\"on\">   当在 <code>ElementInjector</code> 中找不到注入令牌时，就用 <code>AppModule</code> 充当后备注入器。</p><p translation-origin=\"off\">The <code>AppModule</code> acts as the fallback injector when the\ninjection token can't be found in the <code>ElementInjector</code>s.</p>\n\n</li>\n</ol>\n<h3 id=\"using-the-providers-array\" translation-result=\"on\">使用 <code>providers</code> 数组<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#using-the-providers-array\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"using-the-providers-array\">Using the <code>providers</code> array<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#using-the-providers-array\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">现在，在 <code>ChildComponent</code> 类中，为 <code>FlowerService</code> 添加一个提供者，以便在接下来的小节中演示更复杂的解析规则：</p><p translation-origin=\"off\">Now, in the <code>ChildComponent</code> class, add a provider for <code>FlowerService</code>\nto demonstrate more complex resolution rules in the upcoming sections:</p>\n\n<code-example path=\"providers-viewproviders/src/app/child/child.component.1.ts\" header=\"providers-viewproviders/src/app/child.component.ts\" region=\"flowerservice\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child',\n  templateUrl: './child.component.html',\n  styleUrls: ['./child.component.css'],\n  // use the providers array to provide a service\n  providers: [{ provide: FlowerService, useValue: { emoji: '🌻' } }]\n})\n\nexport class ChildComponent {\n  // inject the service\n  constructor( public flower: FlowerService) { }\n}\n\n\n</code-example>\n<p translation-result=\"on\">现在，在 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器中提供了 <code>FlowerService</code>，当 <code>&#x3C;app-child></code> 请求该服务时，注入器仅需要查找 <code>&#x3C;app-child></code> 自己的 <code>ElementInjector</code>。不必再通过注入器树继续搜索。</p><p translation-origin=\"off\">Now that the <code>FlowerService</code> is provided in the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator,\nwhen the <code>&#x3C;app-child></code> requests the service, the injector has only to look\nas far as the <code>&#x3C;app-child></code>'s own <code>ElementInjector</code>. It won't have to\ncontinue the search any further through the injector tree.</p>\n\n<p translation-result=\"on\">下一步是将绑定添加到 <code>ChildComponent</code> 模板。</p><p translation-origin=\"off\">The next step is to add a binding to the <code>ChildComponent</code> template.</p>\n\n<code-example path=\"providers-viewproviders/src/app/child/child.component.html\" header=\"providers-viewproviders/src/app/child.component.html\" region=\"flower-binding\">\n&#x3C;p>Emoji from FlowerService: {{flower.emoji}}&#x3C;/p>\n\n</code-example>\n<p translation-result=\"on\">要渲染新的值，请在 <code>AppComponent</code> 模板的底部添加 <code>&#x3C;app-child></code>，以便其视图也显示向日葵：</p><p translation-origin=\"off\">To render the new values, add <code>&#x3C;app-child></code> to the bottom of\nthe <code>AppComponent</code> template so the view also displays the sunflower:</p>\n\n<code-example>\nChild <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>\nEmoji from FlowerService: 🌻\n</code-example>\n<p translation-result=\"on\">在逻辑树中，可以把它表示成这样：</p><p translation-origin=\"off\">In the logical tree, this would be represented as follows:</p>\n\n<code-example>\n&#x3C;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n        @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService) flower=>\"🌺\">\n  &#x3C;#VIEW>\n\n    &#x3C;p>Emoji from FlowerService: {{flower.emoji}} (🌺)&#x3C;/p>\n\n    &#x3C;app-child @Provide(FlowerService=\"🌻\")\n               @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService)=>\"🌻\"> &#x3C;!-- search ends here -->\n      &#x3C;#VIEW> &#x3C;!-- search starts here -->\n\n        &#x3C;h2>Parent <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>&#x3C;/h2>\n\n        &#x3C;p>Emoji from FlowerService: {{flower.emoji}} (🌻)&#x3C;/p>\n\n      &#x3C;/#VIEW>\n     &#x3C;/app-child>\n  &#x3C;/#VIEW>\n&#x3C;/app-root>\n</code-example>\n<p translation-result=\"on\">当 <code>&#x3C;app-child></code> 请求 <code>FlowerService</code> 时，注入器从 <code>&#x3C;app-child></code> 的 <code>&#x3C;#VIEW></code> 开始搜索（包括 <code>&#x3C;#VIEW></code>，因为它是从 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 注入的），并到 <code>&#x3C;app-child></code> 结束。在这个例子中，<code>FlowerService</code> 在 <code>&#x3C;app-child></code> 的 <code>providers</code> 数组中解析为向日葵🌻。注入器不必在注入器树中进一步查找。一旦找到 <code>FlowerService</code>，它便停止运行，再也看不到🌺（红芙蓉）。</p><p translation-origin=\"off\">When <code>&#x3C;app-child></code> requests the <code>FlowerService</code>, the injector begins\nits search at the <code>&#x3C;#VIEW></code> belonging to <code>&#x3C;app-child></code> (<code>&#x3C;#VIEW></code> is\nincluded because it is injected from <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code>) and ends with\n<code>&#x3C;app-child></code>. In this case, the <code>FlowerService</code> is resolved in the\n<code>&#x3C;app-child></code>'s <code>providers</code> array with sunflower 🌻. The injector doesn't\nhave to look any further in the injector tree. It stops as soon as it\nfinds the <code>FlowerService</code> and never sees the 🌺 (red hibiscus).</p>\n\n<a id=\"use-view-providers\"></a>\n<h3 id=\"using-the-viewproviders-array\" translation-result=\"on\">使用 <code>viewProviders</code> 数组<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#using-the-viewproviders-array\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"using-the-viewproviders-array\">Using the <code>viewProviders</code> array<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#using-the-viewproviders-array\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">使用 <code>viewProviders</code> 数组是在 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器中提供服务的另一种方法。使用 <code>viewProviders</code> 使服务在 <code>&#x3C;#VIEW></code> 中可见。</p><p translation-origin=\"off\">Use the <code>viewProviders</code> array as another way to provide services in the\n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator. Using <code>viewProviders</code> makes services\nvisible in the <code>&#x3C;#VIEW></code>.</p>\n\n<div class=\"is-helpful alert\">\n<p translation-result=\"on\">除了使用 <code>viewProviders</code> 数组外，其它步骤与使用 <code>providers</code> 数组相同。</p><p translation-origin=\"off\">The steps are the same as using the <code>providers</code> array,\nwith the exception of using the <code>viewProviders</code> array instead.</p>\n\n<p translation-result=\"on\">有关这些步骤的说明，请继续本节。如果你可以自行设置，请跳至<a href=\"guide/hierarchical-dependency-injection#modify-visibility\">修改服务可用性</a> 一节。</p><p translation-origin=\"off\">For step-by-step instructions, continue with this section. If you can\nset it up on your own, skip ahead to <a href=\"guide/hierarchical-dependency-injection#modify-visibility\">Modifying service availability</a>.</p>\n\n</div>\n<p translation-result=\"on\">该示例应用程序具有第二个服务 <code>AnimalService</code> 来演示 <code>viewProviders</code>。</p><p translation-origin=\"off\">The example app features a second service, the <code>AnimalService</code> to\ndemonstrate <code>viewProviders</code>.</p>\n\n<p translation-result=\"on\">首先，创建一个 <code>AnimalService</code> 与 <code>emoji</code> 的🐳（鲸鱼）属性：</p><p translation-origin=\"off\">First, create an <code>AnimalService</code> with an <code>emoji</code> property of 🐳 (whale):</p>\n\n<code-example path=\"providers-viewproviders/src/app/animal.service.ts\" header=\"providers-viewproviders/src/app/animal.service.ts\" region=\"animal-service\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class AnimalService {\n  emoji = '🐳';\n}\n\n</code-example>\n<p translation-result=\"on\">遵循与 <code>FlowerService</code> 相同的模式，将 <code>AnimalService</code> 注入 <code>AppComponent</code> 类：</p><p translation-origin=\"off\">Following the same pattern as with the <code>FlowerService</code>, inject the\n<code>AnimalService</code> in the <code>AppComponent</code> class:</p>\n\n<code-example path=\"providers-viewproviders/src/app/app.component.ts\" header=\"providers-viewproviders/src/app/app.component.ts\" region=\"inject-animal-service\">\nexport class AppComponent  {\n  constructor(public flower: FlowerService, public animal: AnimalService) {}\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意：</strong>你可以保留所有与 <code>FlowerService</code> 相关的代码，因为它可以与 <code>AnimalService</code> 进行比较。</p><p translation-origin=\"off\"><strong>Note:</strong> You can leave all the <code>FlowerService</code> related code in place\nas it will allow a comparison with the <code>AnimalService</code>.</p>\n\n</div>\n<p translation-result=\"on\">添加一个 <code>viewProviders</code> 数组，并将 <code>AnimalService</code> 也注入到 <code>&#x3C;app-child></code> 类中，但是给 <code>emoji</code> 一个不同的值。在这里，它的值为🐶（小狗）。</p><p translation-origin=\"off\">Add a <code>viewProviders</code> array and inject the <code>AnimalService</code> in the\n<code>&#x3C;app-child></code> class, too, but give <code>emoji</code> a different value. Here,\nit has a value of 🐶 (puppy).</p>\n\n<code-example path=\"providers-viewproviders/src/app/child/child.component.ts\" header=\"providers-viewproviders/src/app/child.component.ts\" region=\"provide-animal-service\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child',\n  templateUrl: './child.component.html',\n  styleUrls: ['./child.component.css'],\n  // provide services\n  providers: [{ provide: FlowerService, useValue: { emoji: '🌻' } }],\n  viewProviders: [{ provide: AnimalService, useValue: { emoji: '🐶' } }]\n})\n\nexport class ChildComponent {\n  // inject service\n  constructor( public flower: FlowerService, public animal: AnimalService) { }\n}\n\n</code-example>\n<p translation-result=\"on\">将绑定添加到 <code>ChildComponent</code> 和 <code>AppComponent</code> 模板。在 <code>ChildComponent</code> 模板中，添加以下绑定：</p><p translation-origin=\"off\">Add bindings to the <code>ChildComponent</code> and the <code>AppComponent</code> templates.\nIn the <code>ChildComponent</code> template, add the following binding:</p>\n\n<code-example path=\"providers-viewproviders/src/app/child/child.component.html\" header=\"providers-viewproviders/src/app/child.component.html\" region=\"animal-binding\">\n&#x3C;p>Emoji from AnimalService: {{animal.emoji}}&#x3C;/p>\n\n</code-example>\n<p translation-result=\"on\">此外，将其添加到 <code>AppComponent</code> 模板：</p><p translation-origin=\"off\">Additionally, add the same to the <code>AppComponent</code> template:</p>\n\n<code-example path=\"providers-viewproviders/src/app/app.component.html\" header=\"providers-viewproviders/src/app/app.component.html\" region=\"binding-animal\">\n&#x3C;p>Emoji from AnimalService: {{animal.emoji}}&#x3C;/p>\n\n</code-example>\n<p translation-result=\"on\">现在，你应该在浏览器中看到两个值：</p><p translation-origin=\"off\">Now you should see both values in the browser:</p>\n\n<code-example>\nAppComponent\nEmoji from AnimalService: 🐳\n\nChild <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>\nEmoji from AnimalService: 🐶\n</code-example>\n<p translation-result=\"on\">此 <code>viewProviders</code> 示例的逻辑树如下：</p><p translation-origin=\"off\">The logic tree for this example of <code>viewProviders</code> is as follows:</p>\n\n<code-example>\n&#x3C;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n        @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService) animal=>\"🐳\">\n  &#x3C;#VIEW>\n    &#x3C;app-child>\n      &#x3C;#VIEW\n       @Provide(AnimalService=\"🐶\")\n       @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService=>\"🐶\")>\n\n       &#x3C;!-- ^^using viewProviders means AnimalService is available in &#x3C;#VIEW>-->\n\n       &#x3C;p>Emoji from AnimalService: {{animal.emoji}} (🐶)&#x3C;/p>\n\n      &#x3C;/#VIEW>\n     &#x3C;/app-child>\n  &#x3C;/#VIEW>\n&#x3C;/app-root>\n</code-example>\n<p translation-result=\"on\">与 <code>FlowerService</code> 示例一样，<code>&#x3C;app-child></code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 装饰器中提供了 <code>AnimalService</code>。这意味着，由于注入器首先在组件的 <code>ElementInjector</code> 中查找，因此它将找到 <code>AnimalService</code> 的值 🐶（小狗）。它不需要继续搜索 <code>ElementInjector</code> 树，也不需要搜索 <code>ModuleInjector</code>。</p><p translation-origin=\"off\">Just as with the <code>FlowerService</code> example, the <code>AnimalService</code> is provided\nin the <code>&#x3C;app-child></code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> decorator. This means that since the\ninjector first looks in the <code>ElementInjector</code> of the component, it finds the\n<code>AnimalService</code> value of 🐶 (puppy). It doesn't need to continue searching the\n<code>ElementInjector</code> tree, nor does it need to search the <code>ModuleInjector</code>.</p>\n\n<h3 id=\"providers-vs-viewproviders\" translation-result=\"on\"><code>providers</code> 与 <code>viewProviders</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#providers-vs-viewproviders\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"providers-vs-viewproviders\"><code>providers</code> vs. <code>viewProviders</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#providers-vs-viewproviders\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">为了看清 <code>providers</code> 和 <code>viewProviders</code> 的差异，请在示例中添加另一个组件，并将其命名为 <code>InspectorComponent</code>。<code>InspectorComponent</code> 将是 <code>ChildComponent</code> 的子 <code>ChildComponent</code>。在 <code>inspector.component.ts</code> 中，将 <code>FlowerService</code> 和 <code>AnimalService</code> 注入构造函数中：</p><p translation-origin=\"off\">To see the difference between using <code>providers</code> and <code>viewProviders</code>, add\nanother component to the example and call it <code>InspectorComponent</code>.\n<code>InspectorComponent</code> will be a child of the <code>ChildComponent</code>. In\n<code>inspector.component.ts</code>, inject the <code>FlowerService</code> and <code>AnimalService</code> in\nthe constructor:</p>\n\n<code-example path=\"providers-viewproviders/src/app/inspector/inspector.component.ts\" header=\"providers-viewproviders/src/app/inspector/inspector.component.ts\" region=\"injection\">\nexport class InspectorComponent {\n  constructor(public flower: FlowerService, public animal: AnimalService) { }\n}\n\n</code-example>\n<p translation-result=\"on\">你不需要 <code>providers</code> 或 <code>viewProviders</code> 数组。接下来，在 <code>inspector.component.html</code> 中，从以前的组件中添加相同的 html：</p><p translation-origin=\"off\">You do not need a <code>providers</code> or <code>viewProviders</code> array. Next, in\n<code>inspector.component.html</code>, add the same markup from previous components:</p>\n\n<code-example path=\"providers-viewproviders/src/app/inspector/inspector.component.html\" header=\"providers-viewproviders/src/app/inspector/inspector.component.html\" region=\"binding\">\n&#x3C;p>Emoji from FlowerService: {{flower.emoji}}&#x3C;/p>\n&#x3C;p>Emoji from AnimalService: {{animal.emoji}}&#x3C;/p>\n\n</code-example>\n<p translation-result=\"on\">别忘了将 <code>InspectorComponent</code> 添加到 <code>AppModule</code> <code>declarations</code> 数组。</p><p translation-origin=\"off\">Remember to add the <code>InspectorComponent</code> to the <code>AppModule</code> <code>declarations</code> array.</p>\n\n<code-example path=\"providers-viewproviders/src/app/app.module.ts\" header=\"providers-viewproviders/src/app/app.module.ts\" region=\"appmodule\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>, <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> ],\n  declarations: [ AppComponent, ChildComponent, InspectorComponent ],\n  bootstrap:    [ AppComponent ],\n  providers: []\n})\nexport class AppModule { }\n\n</code-example>\n<p translation-result=\"on\">接下来，确保你的 <code>child.component.html</code> 包含以下内容：</p><p translation-origin=\"off\">Next, make sure your <code>child.component.html</code> contains the following:</p>\n\n<code-example path=\"providers-viewproviders/src/app/child/child.component.html\" header=\"providers-viewproviders/src/app/child/child.component.html\" region=\"child-component\">\n&#x3C;p>Emoji from FlowerService: {{flower.emoji}}&#x3C;/p>\n&#x3C;p>Emoji from AnimalService: {{animal.emoji}}&#x3C;/p>\n\n&#x3C;div class=\"container\">\n  &#x3C;h3>Content projection&#x3C;/h3>\n\t&#x3C;ng-content>&#x3C;/ng-content>\n&#x3C;/div>\n\n&#x3C;h3>Inside the view&#x3C;/h3>\n&#x3C;app-inspector>&#x3C;/app-inspector>\n\n</code-example>\n<p translation-result=\"on\">前两行带有绑定，来自之前的步骤。新的部分是 <code>&#x3C;ng-content></code> 和 <code>&#x3C;app-inspector></code>。<code>&#x3C;ng-content></code> 允许你投影内容，<code>ChildComponent</code> 模板中的 <code>&#x3C;app-inspector></code> 使 <code>InspectorComponent</code> 成为 <code>ChildComponent</code> 的子组件。</p><p translation-origin=\"off\">The first two lines, with the bindings, are there from previous steps. The\nnew parts are  <code>&#x3C;ng-content></code> and <code>&#x3C;app-inspector></code>. <code>&#x3C;ng-content></code> allows\nyou to project content, and <code>&#x3C;app-inspector></code> inside the <code>ChildComponent</code>\ntemplate makes the <code>InspectorComponent</code> a child component of\n<code>ChildComponent</code>.</p>\n\n<p translation-result=\"on\">接下来，将以下内容添加到 <code>app.component.html</code> 中以利用内容投影的优势。</p><p translation-origin=\"off\">Next, add the following to <code>app.component.html</code> to take advantage of content projection.</p>\n\n<code-example path=\"providers-viewproviders/src/app/app.component.html\" header=\"providers-viewproviders/src/app/app.component.html\" region=\"content-projection\">\n&#x3C;app-child>&#x3C;app-inspector>&#x3C;/app-inspector>&#x3C;/app-child>\n\n</code-example>\n<p translation-result=\"on\">现在，浏览器将渲染以下内容，为简洁起见，省略了前面的示例：</p><p translation-origin=\"off\">The browser now renders the following, omitting the previous examples\nfor brevity:</p>\n\n<code-example>\n//...Omitting previous examples. The following applies to this section.\n\nContent projection: This is coming from content. Doesn't get to see\npuppy because the puppy is declared inside the view only.\n\nEmoji from FlowerService: 🌻\nEmoji from AnimalService: 🐳\n\nEmoji from FlowerService: 🌻\nEmoji from AnimalService: 🐶\n</code-example>\n<p translation-result=\"on\">这四个绑定说明了 <code>providers</code> 和 <code>viewProviders</code> 之间的区别。由于🐶（小狗）在&#x3C;#VIEW>中声明，因此投影内容不可见。投影的内容中会看到🐳（鲸鱼）。</p><p translation-origin=\"off\">These four bindings demonstrate the difference between <code>providers</code>\nand <code>viewProviders</code>. Since the 🐶 (puppy) is declared inside the &#x3C;#VIEW>,\nit isn't visible to the projected content. Instead, the projected\ncontent sees the 🐳 (whale).</p>\n\n<p translation-result=\"on\">但是下一部分，<code>InspectorComponent</code> 是 <code>ChildComponent</code> 的子组件，<code>InspectorComponent</code> 在 <code>&#x3C;#VIEW></code> 内部，因此当它请求 <code>AnimalService</code> 时，它会看到🐶（小狗）。</p><p translation-origin=\"off\">The next section though, where <code>InspectorComponent</code> is a child component\nof <code>ChildComponent</code>, <code>InspectorComponent</code> is inside the <code>&#x3C;#VIEW></code>, so\nwhen it asks for the <code>AnimalService</code>, it sees the 🐶 (puppy).</p>\n\n<p translation-result=\"on\">逻辑树中的 <code>AnimalService</code> 如下所示：</p><p translation-origin=\"off\">The <code>AnimalService</code> in the logical tree would look like this:</p>\n\n<code-example>\n&#x3C;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n        @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService) animal=>\"🐳\">\n  &#x3C;#VIEW>\n    &#x3C;app-child>\n      &#x3C;#VIEW\n       @Provide(AnimalService=\"🐶\")\n       @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService=>\"🐶\")>\n\n       &#x3C;!-- ^^using viewProviders means AnimalService is available in &#x3C;#VIEW>-->\n\n       &#x3C;p>Emoji from AnimalService: {{animal.emoji}} (🐶)&#x3C;/p>\n\n       &#x3C;app-inspector>\n\n        &#x3C;p>Emoji from AnimalService: {{animal.emoji}} (🐶)&#x3C;/p>\n\n       &#x3C;/app-inspector>\n      &#x3C;/#VIEW>\n      &#x3C;app-inspector>\n        &#x3C;#VIEW>\n\n          &#x3C;p>Emoji from AnimalService: {{animal.emoji}} (🐳)&#x3C;/p>\n\n        &#x3C;/#VIEW>\n      &#x3C;/app-inspector>\n     &#x3C;/app-child>\n  &#x3C;/#VIEW>\n&#x3C;/app-root>\n</code-example>\n<p translation-result=\"on\"><code>&#x3C;app-inspector></code> 的投影内容中看到了🐳（鲸鱼），而不是🐶（小狗），因为🐶（小狗）在 <code>&#x3C;app-child></code> 的 <code>&#x3C;#VIEW></code> 中。如果 <code>&#x3C;app-inspector></code> 也位于 <code>&#x3C;#VIEW></code> 则只能看到🐶（小狗）。</p><p translation-origin=\"off\">The projected content of <code>&#x3C;app-inspector></code> sees the 🐳 (whale), not\nthe 🐶 (puppy), because the\n🐶 (puppy) is inside the <code>&#x3C;app-child></code> <code>&#x3C;#VIEW></code>. The <code>&#x3C;app-inspector></code> can\nonly see the 🐶 (puppy)\nif it is also within the <code>&#x3C;#VIEW></code>.</p>\n\n<a id=\"modify-visibility\"></a>\n<h2 id=\"modifying-service-visibility\" translation-result=\"on\">修改服务可见性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#modifying-service-visibility\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"modifying-service-visibility\">Modifying service visibility<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#modifying-service-visibility\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">本节讲的是如何使用可见性修饰符 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>，<code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code> 和 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 来限制 <code>ElementInjector</code> 的开始和结束范围。</p><p translation-origin=\"off\">This section describes how to limit the scope of the beginning and\nending <code>ElementInjector</code> using the visibility decorators <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>,\n<code>@<a href=\"api/core/Self\" class=\"code-anchor\">Self</a>()</code>, and <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>.</p>\n\n<h3 id=\"visibility-of-provided-tokens\" translation-result=\"on\">提供者令牌的可见性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#visibility-of-provided-tokens\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"visibility-of-provided-tokens\">Visibility of provided tokens<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#visibility-of-provided-tokens\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">可见性装饰器影响搜索注入令牌时在逻辑树中开始和结束的位置。为此，要将可见性装饰器放置在注入点，即 <code>constructor()</code>，而不是在声明点。</p><p translation-origin=\"off\">Visibility decorators influence where the search for the injection\ntoken begins and ends in the logic tree. To do this, place\nvisibility decorators at the point of injection, that is, the\n<code>constructor()</code>, rather than at a point of declaration.</p>\n\n<p translation-result=\"on\">为了修改该注入器从哪里开始寻找 <code>FlowerService</code>，把 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 加到 <code>&#x3C;app-child></code> 的 <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 声明 <code>FlowerService</code> 中。该声明在 <code>&#x3C;app-child></code> 构造函数中，如 <code>child.component.ts</code> 所示：</p><p translation-origin=\"off\">To alter where the injector starts looking for <code>FlowerService</code>, add\n<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> to the <code>&#x3C;app-child></code> <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> declaration for the\n<code>FlowerService</code>. This declaration is in the <code>&#x3C;app-child></code> constructor\nas shown in <code>child.component.ts</code>:</p>\n\n<code-example language=\"typescript=\">\n  constructor(@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() public flower : FlowerService) { }\n</code-example>\n<p translation-result=\"on\">使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>，<code>&#x3C;app-child></code> 注入器不会寻找自身来获取 <code>FlowerService</code>。相反，喷射器开始在 <code>&#x3C;app-root></code> 的 <code>ElementInjector</code> 中寻找 <code>FlowerService</code>，在那里它什么也没找到。\n然后，它返回到 <code>&#x3C;app-child></code> 的 <code>ModuleInjector</code> 并找到🌺（红芙蓉）值，这是可用的，因为 <code>&#x3C;app-child></code> <code>ModuleInjector</code> 和 <code>&#x3C;app-root></code> <code>ModuleInjector</code> 被展开成了一个 <code>ModuleInjector</code>。因此，UI 将渲染以下内容：</p><p translation-origin=\"off\">With <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>, the <code>&#x3C;app-child></code> injector doesn't look to itself for\nthe <code>FlowerService</code>. Instead, the injector starts looking for the\n<code>FlowerService</code> at the <code>&#x3C;app-root></code>'s <code>ElementInjector</code>, where it finds\nnothing. Then, it goes back to the <code>&#x3C;app-child></code> <code>ModuleInjector</code> and finds\nthe 🌺 (red hibiscus) value, which is available because the <code>&#x3C;app-child></code>\n<code>ModuleInjector</code> and the <code>&#x3C;app-root></code> <code>ModuleInjector</code> are flattened into one\n<code>ModuleInjector</code>. Thus, the UI renders the following:</p>\n\n<code-example>\nEmoji from FlowerService: 🌺\n</code-example>\n<p translation-result=\"on\">在逻辑树中，这种情况可能如下所示：</p><p translation-origin=\"off\">In a logical tree, this same idea might look like this:</p>\n\n<code-example>\n&#x3C;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n        @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService) flower=>\"🌺\">\n  &#x3C;#VIEW>\n    &#x3C;app-child @Provide(FlowerService=\"🌻\")>\n      &#x3C;#VIEW @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>)=>\"🌺\">\n\n      &#x3C;!-- With <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>, the injector looks to the next injector up the tree -->\n\n      &#x3C;/#VIEW>\n      &#x3C;/app-child>\n  &#x3C;/#VIEW>\n&#x3C;/app-root>\n</code-example>\n<p translation-result=\"on\">尽管 <code>&#x3C;app-child></code> 提供了🌻（向日葵），但该应用程序渲染了🌺（红色芙蓉），因为 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 导致当前的注入器跳过了自身并寻找其父级。</p><p translation-origin=\"off\">Though <code>&#x3C;app-child></code> provides the 🌻 (sunflower), the app renders\nthe 🌺 (red hibiscus) because <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>  causes the current\ninjector to skip\nitself and look to its parent.</p>\n\n<p translation-result=\"on\">如果现在将 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>（以及 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> ）添加到了 <code>FlowerService</code> 的 <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code>，其结果将为 <code>null</code>。这是因为 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 将搜索的上限限制为 <code>&#x3C;#VIEW></code>。这是在逻辑树中的情况：</p><p translation-origin=\"off\">If you now add <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> (in addition to the <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>) to the\n<code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> of the <code>FlowerService</code>, the result will be <code>null</code>. This is\nbecause <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> limits the upper bound of the search to the\n<code>&#x3C;#VIEW></code>. Here's the idea in the logical tree:</p>\n\n<code-example>\n&#x3C;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n        @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService) flower=>\"🌺\">\n  &#x3C;#VIEW> &#x3C;!-- end search here with null-->\n    &#x3C;app-child @Provide(FlowerService=\"🌻\")> &#x3C;!-- start search here -->\n      &#x3C;#VIEW @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(FlowerService, @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>, @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>, @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>)=>null>\n      &#x3C;/#VIEW>\n      &#x3C;/app-parent>\n  &#x3C;/#VIEW>\n&#x3C;/app-root>\n</code-example>\n<p translation-result=\"on\">在这里，服务及其值是相同的，但是 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 阻止了注入器对 <code>FlowerService</code> 进行任何高于 <code>&#x3C;#VIEW></code> 的查找，因此找不到它并返回 <code>null</code>。</p><p translation-origin=\"off\">Here, the services and their values are the same, but <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>\nstops the injector from looking any further than the <code>&#x3C;#VIEW></code>\nfor <code>FlowerService</code>, so it doesn't find it and returns <code>null</code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意：</strong>示例应用程序使用 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 因此该应用程序不会引发错误，但是其原理是一样的。</p><p translation-origin=\"off\"><strong>Note:</strong> The example app uses <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> so the app does\nnot throw an error, but the principles are the same.</p>\n\n</div>\n<h3 id=\"skipself-and-viewproviders\" translation-result=\"on\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 和 <code>viewProviders</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#skipself-and-viewproviders\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"skipself-and-viewproviders\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> and <code>viewProviders</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#skipself-and-viewproviders\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">该 <code>&#x3C;app-child></code> 目前提供在 <code>viewProviders</code> 数组中提供了值为 🐶（小狗）的 <code>AnimalService</code>。由于注入器只需要查看 <code>&#x3C;app-child></code> 的 <code>ElementInjector</code> 中的 <code>AnimalService</code>，它就不会看到🐳（鲸鱼）。</p><p translation-origin=\"off\">The <code>&#x3C;app-child></code> currently provides the <code>AnimalService</code> in\nthe <code>viewProviders</code> array with the value of 🐶 (puppy). Because\nthe injector has only to look at the <code>&#x3C;app-child></code>'s <code>ElementInjector</code>\nfor the <code>AnimalService</code>, it never sees the 🐳 (whale).</p>\n\n<p translation-result=\"on\">就像在 <code>FlowerService</code> 示例中一样，如果将 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 添加到 <code>AnimalService</code> 的构造函数中，则注入器将不在 <code>AnimalService</code> 的当前 <code>&#x3C;app-child></code> 的 <code>ElementInjector</code> 中查找 <code>AnimalService</code>。</p><p translation-origin=\"off\">Just as in the <code>FlowerService</code> example, if you add <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>\nto the constructor for the <code>AnimalService</code>, the injector won't\nlook in the current <code>&#x3C;app-child></code>'s <code>ElementInjector</code> for the\n<code>AnimalService</code>.</p>\n\n<code-example language=\"typescript=\">\nexport class ChildComponent {\n\n// add @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()\n  constructor(@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() public animal : AnimalService) { }\n\n}\n</code-example>\n<p translation-result=\"on\">相反，注入器将从 <code>&#x3C;app-root></code> <code>ElementInjector</code> 开始找。请记住，<code>&#x3C;app-child></code> 类在 <code>viewProviders</code> 数组中 <code>AnimalService</code> 中提供了🐶（小狗）的值：</p><p translation-origin=\"off\">Instead, the injector will begin at the <code>&#x3C;app-root></code>\n<code>ElementInjector</code>. Remember that the <code>&#x3C;app-child></code> class\nprovides the <code>AnimalService</code> in the <code>viewProviders</code> array\nwith a value of 🐶 (puppy):</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child',\n  ...\n  viewProviders:\n  [{ provide: AnimalService, useValue: { emoji: '🐶' } }]\n})\n</code-example>\n<p translation-result=\"on\">在 <code>&#x3C;app-child></code> 中使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 的逻辑树是这样的：</p><p translation-origin=\"off\">The logical tree looks like this with <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> in <code>&#x3C;app-child></code>:</p>\n\n<code-example>\n  &#x3C;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n          @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService=>\"🐳\")>\n    &#x3C;#VIEW>&#x3C;!-- search begins here -->\n      &#x3C;app-child>\n        &#x3C;#VIEW\n         @Provide(AnimalService=\"🐶\")\n         @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>=>\"🐳\")>\n\n         &#x3C;!--Add @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> -->\n\n        &#x3C;/#VIEW>\n        &#x3C;/app-child>\n    &#x3C;/#VIEW>\n  &#x3C;/app-root>\n</code-example>\n<p translation-result=\"on\">在 <code>&#x3C;app-child></code> 中使用 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>，注入器就会在 <code>&#x3C;app-root></code> 的 <code>ElementInjector</code> 中找到 🐳（鲸）。</p><p translation-origin=\"off\">With <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> in the <code>&#x3C;app-child></code>, the injector begins its\nsearch for the <code>AnimalService</code> in the <code>&#x3C;app-root></code> <code>ElementInjector</code>\nand finds 🐳 (whale).</p>\n\n<h3 id=\"host-and-viewproviders\" translation-result=\"on\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 和 <code>viewProviders</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#host-and-viewproviders\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"host-and-viewproviders\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> and <code>viewProviders</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#host-and-viewproviders\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">如果把 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 添加到 <code>AnimalService</code> 的构造函数上，结果就是🐶（小狗），因为注入器会在 <code>&#x3C;app-child></code> 的 <code>&#x3C;#VIEW></code> 中查找 <code>AnimalService</code> 服务。这里是 <code>&#x3C;app-child></code> 类中的 <code>viewProviders</code> 数组和构造函数中的 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> ：</p><p translation-origin=\"off\">If you add <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> to the constructor for <code>AnimalService</code>, the\nresult is 🐶 (puppy) because the injector finds the <code>AnimalService</code>\nin the <code>&#x3C;app-child></code> <code>&#x3C;#VIEW></code>. Here is the <code>viewProviders</code> array\nin the <code>&#x3C;app-child></code> class and <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> in the constructor:</p>\n\n<code-example language=\"typescript=\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child',\n  ...\n  viewProviders:\n  [{ provide: AnimalService, useValue: { emoji: '🐶' } }]\n\n})\nexport class ChildComponent {\n  constructor(@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() public animal : AnimalService) { }\n}\n</code-example>\n<p translation-result=\"on\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 导致注入器开始查找，直到遇到 <code>&#x3C;#VIEW></code> 的边缘。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> causes the injector to look until it encounters the edge of the <code>&#x3C;#VIEW></code>.</p>\n\n<code-example>\n  &#x3C;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n          @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService=>\"🐳\")>\n    &#x3C;#VIEW>\n      &#x3C;app-child>\n        &#x3C;#VIEW\n         @Provide(AnimalService=\"🐶\")\n         @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService, @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>=>\"🐶\")> &#x3C;!-- @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a> stops search here -->\n        &#x3C;/#VIEW>\n        &#x3C;/app-child>\n    &#x3C;/#VIEW>\n  &#x3C;/app-root>\n</code-example>\n<p translation-result=\"on\">将带有第三个动物🦔（刺猬）的 <code>viewProviders</code> 数组添加到 <code>app.component.ts</code> 的 <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 元数据中：</p><p translation-origin=\"off\">Add a <code>viewProviders</code> array with a third animal, 🦔 (hedgehog), to the\n<code>app.component.ts</code> <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> metadata:</p>\n\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: [ './app.component.css' ],\n  viewProviders: [{ provide: AnimalService, useValue: { emoji: '🦔' } }]\n})\n</code-example>\n<p translation-result=\"on\">接下来，同时把 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 和 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 加在 <code>child.component.ts</code> 中 <code>AnimalService</code> 的构造函数中。这是 <code>&#x3C;app-child></code> 构造函数中的 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 和 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>：</p><p translation-origin=\"off\">Next, add <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> along with <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> to the constructor for the\n<code>Animal Service</code> in <code>child.component.ts</code>. Here are <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code>\nand <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> in the <code>&#x3C;app-child></code>\nconstructor :</p>\n\n<code-example language=\"ts\">\nexport class ChildComponent {\n\n  constructor(\n  @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() public animal : AnimalService) { }\n\n}\n</code-example>\n<p translation-result=\"on\">将 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 和 <code><a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 应用于 <code>providers</code> 数组中的 <code>FlowerService</code>，结果为 <code>null</code>，因为 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 会在 <code>&#x3C;app-child></code> 的注入器中开始搜索，但是 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 要求它在 <code>&#x3C;#VIEW></code> 停止搜索 —— 没有 <code>FlowerService</code>。在逻辑树中，你可以看到 <code>FlowerService</code> 在 <code>&#x3C;app-child></code> 中可见，而在 <code>&#x3C;#VIEW></code> 中不可见。</p><p translation-origin=\"off\">When <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> and <code><a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> were applied to the <code>FlowerService</code>,\nwhich is in the <code>providers</code> array, the result was <code>null</code> because\n<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> starts its search in the <code>&#x3C;app-child></code> injector, but\n<code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> stops searching at <code>&#x3C;#VIEW></code>—where there is no\n<code>FlowerService</code>. In the logical tree, you can see that the\n<code>FlowerService</code> is visible in <code>&#x3C;app-child></code>, not its <code>&#x3C;#VIEW></code>.</p>\n\n<p translation-result=\"on\">不过，提供在 <code>AppComponent</code> 的 <code>viewProviders</code> 数组中的 <code>AnimalService</code>，是可见的。</p><p translation-origin=\"off\">However, the <code>AnimalService</code>, which is provided in the\n<code>AppComponent</code> <code>viewProviders</code> array, is visible.</p>\n\n<p translation-result=\"on\">逻辑树表示法说明了为何如此：</p><p translation-origin=\"off\">The logical tree representation shows why this is:</p>\n\n<code-example language=\"html\">\n&#x3C;app-root @<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>(AppModule)\n        @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService=>\"🐳\")>\n  &#x3C;#VIEW @Provide(AnimalService=\"🦔\")\n         @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService, @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>, @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>, @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>)=>\"🦔\">\n\n    &#x3C;!-- ^^@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() starts here,  @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() stops here^^ -->\n\n    &#x3C;app-child>\n      &#x3C;#VIEW @Provide(AnimalService=\"🐶\")\n             @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(AnimalService, @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>, @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>, @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>)=>\"🐶\">\n\n               &#x3C;!-- Add @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> ^^-->\n\n      &#x3C;/#VIEW>\n      &#x3C;/app-child>\n  &#x3C;/#VIEW>\n&#x3C;/app-root>\n</code-example>\n<p translation-result=\"on\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 导致注入器从 <code>&#x3C;app-root></code> 而不是 <code>&#x3C;app-child></code> 处开始对 <code>AnimalService</code> 进行搜索，而 <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 会在 <code>&#x3C;app-root></code> 的 <code>&#x3C;#VIEW></code> 处停止搜索。\n由于 <code>AnimalService</code> 是通过 <code>viewProviders</code> 数组提供的，因此注入程序会在 <code>&#x3C;#VIEW></code> 找到🦔（刺猬）。</p><p translation-origin=\"off\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>, causes the injector to start its search for\nthe <code>AnimalService</code> at the <code>&#x3C;app-root></code>, not the <code>&#x3C;app-child></code>,\nwhere the request originates, and <code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> stops the search\nat the <code>&#x3C;app-root></code> <code>&#x3C;#VIEW></code>. Since <code>AnimalService</code> is\nprovided via the <code>viewProviders</code> array, the injector finds 🦔\n(hedgehog) in the <code>&#x3C;#VIEW></code>.</p>\n\n<a id=\"component-injectors\"></a>\n<h2 id=\"elementinjector-use-case-examples\" translation-result=\"on\"><code>ElementInjector</code> 用例示例<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#elementinjector-use-case-examples\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"elementinjector-use-case-examples\"><code>ElementInjector</code> use case examples<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#elementinjector-use-case-examples\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在不同级别配置一个或多个提供者的能力开辟了很有用的可能性。要查看正在运行的应用中的以下情况，请参阅<live-example>英雄示例</live-example>。</p><p translation-origin=\"off\">The ability to configure one or more providers at different levels\nopens up useful possibilities.\nFor a look at the following scenarios in a working app, see the <live-example>heroes use case examples</live-example>.</p>\n\n<h3 id=\"scenario-service-isolation\" translation-result=\"on\">场景：服务隔离<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-service-isolation\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"scenario-service-isolation\">Scenario: service isolation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-service-isolation\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">出于架构方面的考虑，可能会让你决定把一个服务限制到只能在它所属的那个应用域中访问。\n比如，这个例子中包括一个用于显示反派列表的 <code>VillainsListComponent</code>，它会从 <code>VillainsService</code> 中获得反派列表数据。</p><p translation-origin=\"off\">Architectural reasons may lead you to restrict access to a service to the application domain where it belongs.\nFor example, the guide sample includes a <code>VillainsListComponent</code> that displays a list of villains.\nIt gets those villains from a <code>VillainsService</code>.</p>\n\n<p translation-result=\"on\">如果你在根模块 <code>AppModule</code> 中（也就是你注册 <code>HeroesService</code> 的地方）提供 <code>VillainsService</code>，就会让应用中的任何地方都能访问到 <code>VillainsService</code>，包括针对英雄的工作流。如果你稍后修改了 <code>VillainsService</code>，就可能破坏了英雄组件中的某些地方。在根模块 <code>AppModule</code> 中提供该服务将会引入此风险。</p><p translation-origin=\"off\">If you provided <code>VillainsService</code> in the root <code>AppModule</code>\n(where you registered the <code>HeroesService</code>),\nthat would make the <code>VillainsService</code> visible everywhere in the\napplication, including the <em>Hero</em> workflows. If you later\nmodified the <code>VillainsService</code>, you could break something in a\nhero component somewhere.</p>\n\n<p translation-result=\"on\">该怎么做呢？你可以在 <code>VillainsListComponent</code> 的 <code>providers</code> 元数据中提供 <code>VillainsService</code>，就像这样：</p><p translation-origin=\"off\">Instead, you can provide the <code>VillainsService</code> in the <code>providers</code> metadata of the <code>VillainsListComponent</code> like this:</p>\n\n<code-example path=\"hierarchical-dependency-injection/src/app/villains-list.component.ts\" header=\"src/app/villains-list.component.ts (metadata)\" region=\"metadata\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-villains-list',\n  templateUrl: './villains-list.component.html',\n  providers: [ VillainsService ]\n})\n\n</code-example>\n<p translation-result=\"on\">在 <code>VillainsListComponent</code> 的元数据中而不是其它地方提供 <code>VillainsService</code> 服务，该服务就会只在 <code>VillainsListComponent</code> 及其子组件树中可用。</p><p translation-origin=\"off\">By providing <code>VillainsService</code> in the <code>VillainsListComponent</code> metadata and nowhere else,\nthe service becomes available only in the <code>VillainsListComponent</code> and its sub-component tree.</p>\n\n<p translation-result=\"on\"><code>VillainService</code> 对于 <code>VillainsListComponent</code> 来说是单例的，因为它就是在这里声明的。只要 <code>VillainsListComponent</code> 没有销毁，它就始终是 <code>VillainService</code> 的同一个实例。但是对于 <code>VillainsListComponent</code> 的多个实例，每个 <code>VillainsListComponent</code> 的实例都会有自己的 <code>VillainService</code> 实例。</p><p translation-origin=\"off\"><code>VillainService</code> is a singleton with respect to <code>VillainsListComponent</code>\nbecause that is where it is declared. As long as <code>VillainsListComponent</code>\ndoes not get destroyed it will be the same instance of <code>VillainService</code>\nbut if there are multilple instances of <code>VillainsListComponent</code>, then each\ninstance of <code>VillainsListComponent</code> will have its own instance of <code>VillainService</code>.</p>\n\n<h3 id=\"scenario-multiple-edit-sessions\" translation-result=\"on\">场景：多重编辑会话<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-multiple-edit-sessions\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"scenario-multiple-edit-sessions\">Scenario: multiple edit sessions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-multiple-edit-sessions\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">很多应用允许用户同时进行多个任务。\n比如，在纳税申报应用中，申报人可以打开多个报税单，随时可能从一个切换到另一个。</p><p translation-origin=\"off\">Many applications allow users to work on several open tasks at the same time.\nFor example, in a tax preparation application, the preparer could be working on several tax returns,\nswitching from one to the other throughout the day.</p>\n\n<p translation-result=\"on\">本章要示范的场景仍然是基于《英雄指南》的。\n想象一个外层的 <code>HeroListComponent</code>，它显示一个超级英雄的列表。</p><p translation-origin=\"off\">This guide demonstrates that scenario with an example in the Tour of Heroes theme.\nImagine an outer <code>HeroListComponent</code> that displays a list of super heroes.</p>\n\n<p translation-result=\"on\">要打开一个英雄的报税单，申报者点击英雄名，它就会打开一个组件来编辑那个申报单。\n每个选中的申报单都会在自己的组件中打开，并且可以同时打开多个申报单。</p><p translation-origin=\"off\">To open a hero's tax return, the preparer clicks on a hero name, which opens a component for editing that return.\nEach selected hero tax return opens in its own component and multiple returns can be open at the same time.</p>\n\n<p translation-result=\"on\">每个报税单组件都有下列特征：</p><p translation-origin=\"off\">Each tax return component has the following characteristics:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> 属于它自己的报税单会话。</p><p translation-origin=\"off\">Is its own tax return editing session.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 可以修改一个报税单，而不会影响另一个组件中的申报单。</p><p translation-origin=\"off\">Can change a tax return without affecting a return in another component.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> 能把所做的修改保存到它的报税单中，或者放弃它们。</p><p translation-origin=\"off\">Has the ability to save the changes to its tax return or cancel them.</p>\n\n</li>\n</ul>\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/dependency-injection/hid-heroes-anim.gif\" alt=\"Heroes in action\" width=\"500\" height=\"384\">\n</div>\n<p translation-result=\"on\">假设 <code>HeroTaxReturnComponent</code> 还有一些管理并还原这些更改的逻辑。\n这对于简单的报税单来说是很容易的。\n不过，在现实世界中，报税单的数据模型非常复杂，对这些修改的管理可能不得不投机取巧。\n你可以把这种管理任务委托给一个辅助服务，就像这个例子中所做的。</p><p translation-origin=\"off\">Suppose that the <code>HeroTaxReturnComponent</code> had logic to manage and restore changes.\nThat would be a pretty easy task for a simple hero tax return.\nIn the real world, with a rich tax return data model, the change management would be tricky.\nYou could delegate that management to a helper service, as this example does.</p>\n\n<p translation-result=\"on\">报税单服务 <code>HeroTaxReturnService</code> 缓存了单条 <code>HeroTaxReturn</code>，用于跟踪那个申报单的变更，并且可以保存或还原它。\n它还委托给了全应用级的单例服务 <code>HeroService</code>，它是通过依赖注入机制取得的。</p><p translation-origin=\"off\">The <code>HeroTaxReturnService</code> caches a single <code>HeroTaxReturn</code>, tracks changes to that return, and can save or restore it.\nIt also delegates to the application-wide singleton <code>HeroService</code>, which it gets by injection.</p>\n\n<code-example path=\"hierarchical-dependency-injection/src/app/hero-tax-return.service.ts\" header=\"src/app/hero-tax-return.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> }    from '@angular/core';\nimport { HeroTaxReturn } from './hero';\nimport { HeroesService } from './heroes.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroTaxReturnService {\n  private currentTaxReturn: HeroTaxReturn;\n  private originalTaxReturn: HeroTaxReturn;\n\n  constructor(private heroService: HeroesService) { }\n\n  set taxReturn (htr: HeroTaxReturn) {\n    this.originalTaxReturn = htr;\n    this.currentTaxReturn  = htr.clone();\n  }\n\n  get taxReturn (): HeroTaxReturn {\n    return this.currentTaxReturn;\n  }\n\n  restoreTaxReturn() {\n    this.taxReturn = this.originalTaxReturn;\n  }\n\n  saveTaxReturn() {\n    this.taxReturn = this.currentTaxReturn;\n    this.heroService.saveTaxReturn(this.currentTaxReturn).subscribe();\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">下面是正在使用 <code>HeroTaxReturnService</code> 的 <code>HeroTaxReturnComponent</code> 组件。</p><p translation-origin=\"off\">Here is the <code>HeroTaxReturnComponent</code> that makes use of <code>HeroTaxReturnService</code>.</p>\n\n<code-example path=\"hierarchical-dependency-injection/src/app/hero-tax-return.component.ts\" header=\"src/app/hero-tax-return.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\nimport { HeroTaxReturn }        from './hero';\nimport { HeroTaxReturnService } from './hero-tax-return.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-tax-return',\n  templateUrl: './hero-tax-return.component.html',\n  styleUrls: [ './hero-tax-return.component.css' ],\n  providers: [ HeroTaxReturnService ]\n})\nexport class HeroTaxReturnComponent {\n  message = '';\n\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() close = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;void>();\n\n  get taxReturn(): HeroTaxReturn {\n    return this.heroTaxReturnService.taxReturn;\n  }\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  set taxReturn (htr: HeroTaxReturn) {\n    this.heroTaxReturnService.taxReturn = htr;\n  }\n\n  constructor(private heroTaxReturnService: HeroTaxReturnService) { }\n\n  onCanceled()  {\n    this.flashMessage('Canceled');\n    this.heroTaxReturnService.restoreTaxReturn();\n  };\n\n  onClose()  { this.close.emit(); };\n\n  onSaved() {\n    this.flashMessage('Saved');\n    this.heroTaxReturnService.saveTaxReturn();\n  }\n\n  flashMessage(msg: string) {\n    this.message = msg;\n    setTimeout(() => this.message = '', 500);\n  }\n}\n\n\n</code-example>\n<p translation-result=\"on\">通过 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 属性可以得到<em>要编辑的报税单</em>，这个属性被实现成了读取器（getter）和设置器（setter）。\n设置器根据传进来的报税单初始化了组件自己的 <code>HeroTaxReturnService</code> 实例。\n读取器总是返回该服务所存英雄的当前状态。\n组件也会请求该服务来保存或还原这个报税单。</p><p translation-origin=\"off\">The <em>tax-return-to-edit</em> arrives via the <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> property, which is implemented with getters and setters.\nThe setter initializes the component's own instance of the <code>HeroTaxReturnService</code> with the incoming return.\nThe getter always returns what that service says is the current state of the hero.\nThe component also asks the service to save and restore this tax return.</p>\n\n<p translation-result=\"on\">但如果该服务是一个全应用范围的单例就不行了。\n每个组件就都会共享同一个服务实例，每个组件也都会覆盖属于其它英雄的报税单。</p><p translation-origin=\"off\">This won't work if the service is an application-wide singleton.\nEvery component would share the same service instance, and each component would overwrite the tax return that belonged to another hero.</p>\n\n<p translation-result=\"on\">要防止这一点，就要在 <code>HeroTaxReturnComponent</code> 元数据的 <code>providers</code> 属性中配置组件级的注入器，来提供该服务。</p><p translation-origin=\"off\">To prevent this, configure the component-level injector of <code>HeroTaxReturnComponent</code> to provide the service, using the  <code>providers</code> property in the component metadata.</p>\n\n<code-example path=\"hierarchical-dependency-injection/src/app/hero-tax-return.component.ts\" header=\"src/app/hero-tax-return.component.ts (providers)\" region=\"providers\">\nproviders: [ HeroTaxReturnService ]\n\n</code-example>\n<p translation-result=\"on\"><code>HeroTaxReturnComponent</code> 有它自己的 <code>HeroTaxReturnService</code> 提供者。\n回忆一下，每个组件的<em>实例</em>都有它自己的注入器。\n在组件级提供服务可以确保组件的<em>每个</em>实例都得到一个自己的、私有的服务实例，而报税单也不会再被意外覆盖了。</p><p translation-origin=\"off\">The <code>HeroTaxReturnComponent</code> has its own provider of the <code>HeroTaxReturnService</code>.\nRecall that every component <em>instance</em> has its own injector.\nProviding the service at the component level ensures that <em>every</em> instance of the component gets its own, private instance of the service, and no tax return gets overwritten.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\">该场景代码中的其它部分依赖另一些 Angular 的特性和技术，你将会在本文档的其它章节学到。\n你可以到<live-example></live-example>查看代码和下载它。</p><p translation-origin=\"off\">The rest of the scenario code relies on other Angular features and techniques that you can learn about elsewhere in the documentation.\nYou can review it and download it from the <live-example></live-example>.</p>\n\n</div>\n<h3 id=\"scenario-specialized-providers\" translation-result=\"on\">场景：专门的提供者<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-specialized-providers\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"scenario-specialized-providers\">Scenario: specialized providers<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#scenario-specialized-providers\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在其它层级重新提供服务的另一个理由，是在组件树的深层中把该服务替换为一个<em>更专门化的</em>实现。</p><p translation-origin=\"off\">Another reason to re-provide a service at another level is to substitute a <em>more specialized</em> implementation of that service, deeper in the component tree.</p>\n\n<p translation-result=\"on\">考虑一个依赖于一系列服务的 Car 组件。\n假设你在根注入器（代号 A）中配置了<em>通用的</em>提供者：<code>CarService</code>、<code>EngineService</code> 和 <code>TiresService</code>。</p><p translation-origin=\"off\">Consider a Car component that depends on several services.\nSuppose you configured the root injector (marked as A) with <em>generic</em> providers for\n<code>CarService</code>, <code>EngineService</code> and <code>TiresService</code>.</p>\n\n<p translation-result=\"on\">你创建了一个车辆组件（A），它显示一个从另外三个通用服务构造出的车辆。</p><p translation-origin=\"off\">You create a car component (A) that displays a car constructed from these three generic services.</p>\n\n<p translation-result=\"on\">然后，你创建一个子组件（B），它为 <code>CarService</code> 和 <code>EngineService</code> 定义了自己<em>特有的</em>提供者，它们具有适用于组件 B 的特有能力。</p><p translation-origin=\"off\">Then you create a child component (B) that defines its own, <em>specialized</em> providers for <code>CarService</code> and <code>EngineService</code>\nthat have special capabilities suitable for whatever is going on in component (B).</p>\n\n<p translation-result=\"on\">组件 B 是另一个组件 C 的父组件，而组件 C 又定义了自己的，<em>更特殊的</em><code>CarService</code> 提供者。</p><p translation-origin=\"off\">Component (B) is the parent of another component (C) that defines its own, even <em>more specialized</em> provider for <code>CarService</code>.</p>\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/dependency-injection/car-components.png\" alt=\"car components\" width=\"338\" height=\"201\">\n</div>\n<p translation-result=\"on\">在幕后，每个组件都有自己的注入器，这个注入器带有为组件本身准备的 0 个、1 个或多个提供者。</p><p translation-origin=\"off\">Behind the scenes, each component sets up its own injector with zero, one, or more providers defined for that component itself.</p>\n\n<p translation-result=\"on\">当你在最深层的组件 C 解析 <code>Car</code> 的实例时，它使用注入器 C 解析生成了一个 <code>Car</code> 的实例，使用注入器 B 解析了 <code>Engine</code>，而 <code>Tires</code> 则是由根注入器 A 解析的。</p><p translation-origin=\"off\">When you resolve an instance of <code>Car</code> at the deepest component (C),\nits injector produces an instance of <code>Car</code> resolved by injector (C) with an <code>Engine</code> resolved by injector (B) and\n<code>Tires</code> resolved by the root injector (A).</p>\n\n<div class=\"lightbox\">\n  <img src=\"generated/images/guide/dependency-injection/injector-tree.png\" alt=\"car injector tree\" width=\"600\" height=\"248\">\n</div>\n<hr>\n<h2 id=\"more-on-dependency-injection\" translation-result=\"on\">关于依赖注入的更多知识<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#more-on-dependency-injection\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"more-on-dependency-injection\">More on dependency injection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/hierarchical-dependency-injection#more-on-dependency-injection\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">要了解关于 Angular 依赖注入的更多信息，参见 <a href=\"guide/dependency-injection-providers\">DI 提供者</a>和 <a href=\"guide/dependency-injection-in-action\">DI 实战</a> 两章。</p><p translation-origin=\"off\">For more information on Angular dependency injection, see the <a href=\"guide/dependency-injection-providers\">DI Providers</a> and <a href=\"guide/dependency-injection-in-action\">DI in Action</a> guides.</p>\n\n\n</div>\n\n<!-- links to this doc:\n - guide/dependency-injection\n - guide/glossary\n - guide/upgrade\n-->\n<!-- links from this doc:\n - api/common/HashLocationStrategy\n - api/common/LocationStrategy\n - api/core/Component\n - api/core/Directive\n - api/core/EventEmitter\n - api/core/Host\n - api/core/Inject\n - api/core/Injectable\n - api/core/Injector\n - api/core/Input\n - api/core/NgModule\n - api/core/NgModule#imports\n - api/core/NgModule#providers\n - api/core/Optional\n - api/core/Output\n - api/core/Self\n - api/core/SkipSelf\n - api/forms/FormsModule\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/BrowserModule\n - api/platform-browser/platformBrowser\n - guide/dependency-injection-in-action\n - guide/dependency-injection-providers\n - guide/dependency-injection-providers#tree-shakable-providers\n - guide/hierarchical-dependency-injection#directive-and-component\n - guide/hierarchical-dependency-injection#elementinjector\n - guide/hierarchical-dependency-injection#elementinjector-use-case-examples\n - guide/hierarchical-dependency-injection#example-app-structure\n - guide/hierarchical-dependency-injection#hierarchical-injectors\n - guide/hierarchical-dependency-injection#host\n - guide/hierarchical-dependency-injection#host-and-viewproviders\n - guide/hierarchical-dependency-injection#injectable-vs-ngmodule\n - guide/hierarchical-dependency-injection#logical-structure-of-the-template\n - guide/hierarchical-dependency-injection#modify-visibility\n - guide/hierarchical-dependency-injection#modifying-service-visibility\n - guide/hierarchical-dependency-injection#moduleinjector\n - guide/hierarchical-dependency-injection#more-on-dependency-injection\n - guide/hierarchical-dependency-injection#optional\n - guide/hierarchical-dependency-injection#platform-injector\n - guide/hierarchical-dependency-injection#providers-vs-viewproviders\n - guide/hierarchical-dependency-injection#providing-services-in-component\n - guide/hierarchical-dependency-injection#resolution-modifiers\n - guide/hierarchical-dependency-injection#resolution-rules\n - guide/hierarchical-dependency-injection#scenario-multiple-edit-sessions\n - guide/hierarchical-dependency-injection#scenario-service-isolation\n - guide/hierarchical-dependency-injection#scenario-specialized-providers\n - guide/hierarchical-dependency-injection#self\n - guide/hierarchical-dependency-injection#skipself\n - guide/hierarchical-dependency-injection#skipself-and-viewproviders\n - guide/hierarchical-dependency-injection#skipself-with-optional\n - guide/hierarchical-dependency-injection#tree-shaking-and-injectable\n - guide/hierarchical-dependency-injection#two-injector-hierarchies\n - guide/hierarchical-dependency-injection#types-of-modifiers\n - guide/hierarchical-dependency-injection#using-the-providers-array\n - guide/hierarchical-dependency-injection#using-the-viewproviders-array\n - guide/hierarchical-dependency-injection#visibility-of-provided-tokens\n - guide/router#location-strategy\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/hierarchical-dependency-injection.md?message=docs%3A%20请简述你的修改...\n-->"
}