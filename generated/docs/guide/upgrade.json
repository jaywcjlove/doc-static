{
  "id": "guide/upgrade",
  "title": "从 AngularJS 升级到 Angular",
  "contents": "\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/cn/aio/content/guide/upgrade.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"upgrading-from-angularjs-to-angular\">Upgrading from AngularJS to Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-from-angularjs-to-angular\"><i class=\"material-icons\">link</i></a></h1>\n<h1 id=\"从-angularjs-升级到-angular\">从 AngularJS 升级到 Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#从-angularjs-升级到-angular\"><i class=\"material-icons\">link</i></a></h1>\n<p><em>Angular</em> is the name for the Angular of today and tomorrow.</p>\n<p><em>Angular</em>是现在和未来的 Angular 名称。</p>\n<p><em>AngularJS</em> is the name for all 1.x versions of Angular.</p>\n<p><em>AngularJS</em>是所有 1.x 版本的 Angular 的名称。</p>\n<p>AngularJS applications are great.\nAlways consider the business case before moving to Angular.\nAn important part of that case is the time and effort to get there.\nThis guide describes the built-in tools for efficiently migrating AngularJS projects over to the Angular platform, a piece at a time.</p>\n<p>有很多大型 AngularJS 应用。在迁移到 Angular 之前，请始终考虑其业务案例。该案例的一个重要部分是迁移的时间和精力。本指南描述了用于将 AngularJS 项目高效迁移到 Angular 平台的内置工具，一次一个。</p>\n<p>Some applications will be easier to upgrade than others, and there are many ways to make it easier for yourself.\nIt is possible to prepare and align AngularJS applications with Angular even before beginning the upgrade process.\nThese preparation steps are all about making the code more decoupled, more maintainable, and better aligned with modern development tools.\nThat means in addition to making the upgrade easier, you will also improve the existing AngularJS applications.</p>\n<p>有些应用可能比其它的升级起来简单，还有一些方法能让把这项工作变得更简单。即使在正式开始升级过程之前，可以提前准备 AngularJS 的程序，让它向 Angular 看齐。这些准备步骤几乎都是关于如何让代码更加松耦合、更有可维护性，以及用现代开发工具提高速度的。这意味着，这种准备工作不仅能让最终的升级变得更简单，而且还能提升 AngularJS 程序的质量。</p>\n<p>One of the keys to a successful upgrade is to do it incrementally, by running the two frameworks side by side in the same application, and porting AngularJS components to Angular one by one.\nThis makes it possible to upgrade even large and complex applications without disrupting other business, because the work can be done collaboratively and spread over a period of time.\nThe <code>upgrade</code> module in Angular has been designed to make incremental upgrading seamless.</p>\n<p>成功升级的关键之一是增量式的实现它，通过在同一个应用中一起运行这两个框架，并且逐个把 AngularJS 的组件迁移到 Angular 中。这意味着可以在不必打断其它业务的前提下，升级更大、更复杂的应用程序，因为这项工作可以多人协作完成，在一段时间内逐渐铺开。Angular <code>upgrade</code> 模块的设计目标就是让你渐进、无缝的完成升级。</p>\n<h2 id=\"preparation\">Preparation<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#preparation\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"准备工作\">准备工作<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#准备工作\"><i class=\"material-icons\">link</i></a></h2>\n<p>There are many ways to structure AngularJS applications.\nWhen you begin to upgrade these applications to Angular, some will turn out to be much easier to work with than others.\nThere are a few key techniques and patterns that you can apply to future-proof applications even before you begin the migration.</p>\n<p>AngularJS 应用程序的组织方式有很多种。当你想把它们升级到 Angular 的时候，有些做起来会比其它的更容易些。即使在开始升级之前，也有一些关键的技术和模式可以让你将来升级时更轻松。</p>\n<h3 id=\"follow-the-angularjs-style-guide\">Follow the AngularJS Style Guide<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#follow-the-angularjs-style-guide\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"遵循-angularjs-风格指南\">遵循 AngularJS 风格指南<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#遵循-angularjs-风格指南\"><i class=\"material-icons\">link</i></a></h3>\n<p>The <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\" title=\"Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">AngularJS Style Guide</a> collects patterns and practices that have been proven to result in cleaner and more maintainable AngularJS applications.\nIt contains a wealth of information about how to write and organize AngularJS code —and equally importantly— how <strong>not</strong> to write and organize AngularJS code.</p>\n<p><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\" title=\"Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">AngularJS 风格指南</a>收集了一些已证明能写出干净且可维护的 AngularJS 程序的模式与实践。\n它包含了很多关于如何书写和组织 AngularJS 代码的有价值信息，同样重要的是，<strong>不应该</strong>采用的书写和组织 AngularJS 代码的方式。</p>\n<p>Angular is a reimagined version of the best parts of AngularJS.\nIn that sense, its goals are the same as the Style Guide for AngularJS:\nTo preserve the good parts of AngularJS, and to avoid the bad parts.\nThere is a lot more to Angular than that of course, but this does mean that <em>following the style guide helps make your AngularJS application more closely aligned with Angular</em>.</p>\n<p>Angular 是一个基于 AngularJS 中最好的部分构思出来的版本。在这种意义上，它的目标和 AngularJS 风格指南是一样的：保留 AngularJS 中好的部分，去掉坏的部分。当然，Angular 还做了更多。说这些的意思是：<em>遵循这个风格指南可以让你写出更接近 Angular 程序的 AngularJS 程序</em>。</p>\n<p>There are a few rules in particular that will make it much easier to do <em>an incremental upgrade</em> using the Angular <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> module:</p>\n<p>有一些特别的规则可以让使用 Angular 的 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 模块进行<em>增量升级</em>变得更简单：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Rules</th>\n<th align=\"left\">Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">规则</td>\n<td align=\"left\">详情</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\" title=\"Single Responsibility - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Rule of 1</a></td>\n<td align=\"left\">There should be one component per file. This not only makes components easy to navigate and find, but will also allow us to migrate them between languages and frameworks one at a time. In this example application, each controller, component, service, and filter is in its own source file.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\" title=\"Single Responsibility - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">单一规则</a></td>\n<td align=\"left\">每个文件应该只放一个组件。这不仅让组件更容易浏览和查找，而且还让你能逐个迁移它们的语言和框架。在这个范例程序中，每个控制器、工厂和过滤器都位于各自的源文件中。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\" title=\"Folders-by-Feature Structure - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Folders-by-Feature Structure</a> <br> <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\" title=\"Modularity - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Modularity</a></td>\n<td align=\"left\">Define similar principles on a higher level of abstraction: Different parts of the application should reside in different directories and NgModules.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\" title=\"Folders-by-Feature Structure - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">按特性分目录的结构</a> <br> <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\" title=\"Modularity - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">模块化</a></td>\n<td align=\"left\">在较高的抽象层定义了一些相似的原则：应用程序中的不同部分应该被分到不同的目录和 NgModule 中。</td>\n</tr>\n</tbody>\n</table>\n<p>When an application is laid out feature per feature in this way, it can also be migrated one feature at a time.\nFor applications that don't already look like this, applying the rules in the AngularJS style guide is a highly recommended preparation step.\nAnd this is not just for the sake of the upgrade - it is just solid advice in general!</p>\n<p>如果应用程序能用这种方式把每个特性分到一个独立目录中，它也就能每次迁移一个特性。对于那些还没有这么做的程序，强烈建议把应用这条规则作为准备步骤。而且这也不仅仅对升级有价值，它还是一个通用的规则，可以让你的程序更“坚实”。</p>\n<h3 id=\"using-a-module-loader\">Using a Module Loader<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-a-module-loader\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"使用模块加载器\">使用模块加载器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#使用模块加载器\"><i class=\"material-icons\">link</i></a></h3>\n<p>When you break application code down into one component per file, you often end up with a project structure with a large number of relatively small files.\nThis is a much neater way to organize things than a small number of large files, but it doesn't work that well if you have to load all those files to the HTML page with <code>&#x3C;script></code> tags.\nEspecially when you also have to maintain those tags in the correct order.\nThat is why it is a good idea to start using a <em>module loader</em>.</p>\n<p>当你把应用代码分解到每个文件中只放一个组件的粒度后，通常会得到一个由大量相对较小的文件组成的项目结构。这比组织成少量大文件要整洁得多，但如果你不得不通过 <code>&#x3C;script></code> 标签在 HTML 页面中加载所有这些文件，那就不好玩了。尤其是当你不得不自己按正确的顺序维护这些标签时更是如此，就要开始使用<em>模块加载器</em>了。</p>\n<p>Using a module loader such as <a href=\"https://github.com/systemjs/systemjs\" title=\"systemjs/systemjs | GitHub\">SystemJS</a>, <a href=\"https://webpack.github.io\" title=\"webpack module bundler | GitHub\">Webpack</a>, or <a href=\"http://browserify.org\" title=\"Browserify\">Browserify</a> allows us to use the built-in module systems of TypeScript or ES2015.\nYou can use the <code>import</code> and <code>export</code> features that explicitly specify what code can and will be shared between different parts of the application.\nFor ES5 applications you can use CommonJS style <code>require</code> and <code>module.exports</code> features.\nIn both cases, the module loader will then take care of loading all the code the application needs in the correct order.</p>\n<p>使用模块加载器，比如<a href=\"https://github.com/systemjs/systemjs\" title=\"systemjs/systemjs | GitHub\">SystemJS</a>、\n<a href=\"https://webpack.github.io\" title=\"webpack module bundler | GitHub\">Webpack</a>或<a href=\"http://browserify.org\" title=\"Browserify\">Browserify</a>，\n可以让你在程序中使用 TypeScript 或 ES2015 语言内置的模块系统。\n你可以使用 <code>import</code> 和 <code>export</code> 特性来明确指定哪些代码应该以及将会被在程序的不同部分之间共享。\n对于 ES5 程序来说，可以改用 CommonJS 风格的 <code>require</code> 和 <code>module.exports</code> 特性代替。\n无是论哪种情况，模块加载器都会按正确的顺序加载程序中用到的所有代码。</p>\n<p>When moving applications into production, module loaders also make it easier to package them all up into production bundles with batteries included.</p>\n<p>当要把应用程序投入生产环境时，模块加载器也会让你把所有这些文件打成完整的产品包变得容易一些。</p>\n<h3 id=\"migrating-to-typescript\">Migrating to TypeScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#migrating-to-typescript\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"迁移到-typescript\">迁移到 TypeScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#迁移到-typescript\"><i class=\"material-icons\">link</i></a></h3>\n<p>If part of the Angular upgrade plan is to also take TypeScript into use, it makes sense to bring in the TypeScript compiler even before the upgrade itself begins.\nThis means there is one less thing to learn and think about during the actual upgrade.\nIt also means you can start using TypeScript features in your AngularJS code.</p>\n<p>Angular 升级计划的一部分是引入 TypeScript，即使在开始升级之前，引入 TypeScript 编译器也是有意义的。这意味着等真正升级的时候需要学习和思考的东西会更少，并且你可以在 AngularJS 代码中开始使用 TypeScript 的特性。</p>\n<p>Since TypeScript is a superset of ECMAScript 2015, which in turn is a superset of ECMAScript 5, \"switching\" to TypeScript doesn't necessarily require anything more than installing the TypeScript compiler and renaming files from <code>*.js</code> to <code>*.ts</code>.\nBut just doing that is not hugely useful or exciting, of course.\nAdditional steps like the following can give us much more bang for the buck:</p>\n<p>TypeScript 是 ECMAScript 2015 的超集，而 ES2015 又是 ECMAScript 5 的超集。这意味着除了安装一个 TypeScript 编译器，并把文件名都从 <code>*.js</code> 改成 <code>*.ts</code> 之外，其实什么都不用做。当然，如果仅仅这样做也没什么大用，也没什么有意思的地方。下面这些额外的步骤可以让你打起精神：</p>\n<ul>\n<li>\n<p>For applications that use a module loader, TypeScript imports and exports (which are really ECMAScript 2015 imports and exports) can be used to organize code into modules.</p>\n<p>对那些使用了模块加载器的程序，TypeScript 的导入和导出语法(实际上是 ECMAScript 2015 的导入和导出)可以把代码组织成模块。</p>\n</li>\n<li>\n<p>Type annotations can be gradually added to existing functions and variables to pin down their types and get benefits like build-time error checking, great autocompletion support and inline documentation.</p>\n<p>可以逐步把类型注解添加到现有函数和变量上，以固定它们的类型，并获得其优点：比如编译期错误检查、更好的支持自动完成，以及内联式文档等。</p>\n</li>\n<li>\n<p>JavaScript features new to ES2015, like arrow functions, <code>let</code>s and <code>const</code>s, default function parameters, and destructuring assignments can also be gradually added to make the code more expressive.</p>\n<p>那些 ES2015 中新增的特性，比如箭头函数、<code>let</code>、<code>const</code>、默认函数参数、解构赋值等也可以逐渐添加进来，让代码更有表现力。</p>\n</li>\n<li>\n<p>Services and controllers can be turned into <em>classes</em>.\nThat way they'll be a step closer to becoming Angular service and component classes, which will make life easier after the upgrade.</p>\n<p>服务和控制器可以转成<em>类</em>。这样它们就能一步步接近 Angular 的服务和组件类了，也会让升级变得简单一点。</p>\n</li>\n</ul>\n<h3 id=\"using-component-directives\">Using Component Directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-component-directives\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"使用组件型指令\">使用组件型指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#使用组件型指令\"><i class=\"material-icons\">link</i></a></h3>\n<p>In Angular, components are the main primitive from which user interfaces are built.\nYou define the different portions of the UI as components and compose them into a full user experience.</p>\n<p>在 Angular 中，组件是用来构建用户界面的主要元素。你把 UI 中的不同部分定义成组件，然后在模板中使用这些组件合成出最终的 UI。</p>\n<p>You can also do this in AngularJS, using <em>component directives</em>.\nThese are directives that define their own templates, controllers, and input/output bindings - the same things that Angular components define.\nApplications built with component directives are much easier to migrate to Angular than applications built with lower-level features like <code>ng-controller</code>,  <code>ng-include</code>, and scope inheritance.</p>\n<p>你在 AngularJS 中也能这么做。那就是一种定义了自己的模板、控制器和输入/输出绑定的指令 —— 跟 Angular 中对组件的定义是一样的。要迁移到 Angular，通过组件型指令构建的应用程序会比直接用 <code>ng-controller</code>、<code>ng-include</code> 和作用域继承等底层特性构建的要容易得多。</p>\n<p>To be Angular compatible, an AngularJS component directive should configure these attributes:</p>\n<p>要与 Angular 兼容，AngularJS 的组件型指令应该配置下列属性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Attributes</th>\n<th align=\"left\">Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"left\">详情</td>\n</tr>\n<tr>\n<td align=\"left\"><code>restrict: 'E'</code></td>\n<td align=\"left\">Components are usually used as elements.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>restrict: 'E'</code></td>\n<td align=\"left\">组件通常会以元素的方式使用。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>scope: {}</code></td>\n<td align=\"left\">An isolate scope. In Angular, components are always isolated from their surroundings, and you should do this in AngularJS too.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>scope: {}</code></td>\n<td align=\"left\">一个独立作用域。在 Angular 中，组件永远是从它们的环境中被隔离出来的，在 AngularJS 中也同样如此。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>bindToController: {}</code></td>\n<td align=\"left\">Component inputs and outputs should be bound to the controller instead of using the <code>$scope</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>bindToController: {}</code></td>\n<td align=\"left\">组件的输入和输出应该绑定到控制器，而不是 <code>$scope</code>。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>controller</code> <br> <code>controllerAs</code></td>\n<td align=\"left\">Components have their own controllers.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>controller</code> <br> <code>controllerAs</code></td>\n<td align=\"left\">组件要有自己的控制器。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>template</code> <br> <code>templateUrl</code></td>\n<td align=\"left\">Components have their own templates.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>template</code> <br> <code>templateUrl</code></td>\n<td align=\"left\">组件要有自己的模板。</td>\n</tr>\n</tbody>\n</table>\n<p>Component directives may also use the following attributes:</p>\n<p>组件型指令还可能使用下列属性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Attributes</th>\n<th align=\"left\">Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">属性</td>\n<td align=\"left\">详情</td>\n</tr>\n<tr>\n<td align=\"left\"><code>transclude: true/{}</code></td>\n<td align=\"left\">If the component needs to transclude content from elsewhere.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>transclude: true/{}</code></td>\n<td align=\"left\">如果组件需要从其它地方透传内容，就设置它。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>require</code></td>\n<td align=\"left\">If the component needs to communicate with the controller of some parent component.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>require</code></td>\n<td align=\"left\">如果组件需要和父组件的控制器通讯，就设置它。</td>\n</tr>\n</tbody>\n</table>\n<p>Component directives <strong>should not</strong> use the following attributes:</p>\n<p>组件型指令<strong>不能</strong>使用下列属性：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Attributes (avoid)</th>\n<th align=\"left\">Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">不能使用的属性</td>\n<td align=\"left\">详情</td>\n</tr>\n<tr>\n<td align=\"left\"><code>compile</code></td>\n<td align=\"left\">This will not be supported in Angular.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>compile</code></td>\n<td align=\"left\">Angular 不再支持它。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>replace: true</code></td>\n<td align=\"left\">Angular never replaces a component element with the component template. This attribute is also deprecated in AngularJS.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>replace: true</code></td>\n<td align=\"left\">Angular 永远不会用组件模板替换一个组件元素。这个特性在 AngularJS 中也同样不建议使用了。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>priority</code> <br> <code>terminal</code></td>\n<td align=\"left\">While AngularJS components may use these, they are not used in Angular and it is better not to write code that relies on them.</td>\n</tr>\n<tr>\n<td align=\"left\"><code>priority</code> <br> <code>terminal</code></td>\n<td align=\"left\">虽然 AngularJS 的组件可能使用这些，但它们在 Angular 中已经没用了，并且最好不要再写依赖它们的代码。</td>\n</tr>\n</tbody>\n</table>\n<p>An AngularJS component directive that is fully aligned with the Angular architecture may look something like this:</p>\n<p>AngularJS 中一个完全向 Angular 架构对齐过的组件型指令是这样的：</p>\n<code-example header=\"hero-detail.directive.ts\" path=\"upgrade-module/src/app/hero-detail.directive.ts\">\nexport function heroDetailDirective() {\n  return {\n    restrict: 'E',\n    scope: {},\n    bindToController: {\n      hero: '=',\n      deleted: '&#x26;'\n    },\n    template: `\n      &#x3C;h2>{{$ctrl.hero.name}} details!&#x3C;/h2>\n      &#x3C;div>&#x3C;label>id: &#x3C;/label>{{$ctrl.hero.id}}&#x3C;/div>\n      &#x3C;button type=\"button\" ng-click=\"$ctrl.onDelete()\">Delete&#x3C;/button>\n    `,\n    controller: function HeroDetailController() {\n      this.onDelete = () => {\n        this.deleted({hero: this.hero});\n      };\n    },\n    controllerAs: '$ctrl'\n  };\n}\n\n\n</code-example>\n<p>AngularJS 1.5 introduces the <a href=\"https://docs.angularjs.org/api/ng/type/angular.Module#component\" title=\"component(name, options); - angular.Module | API | AngularJS\">component API</a> that makes it easier to define component directives like these.\nIt is a good idea to use this API for component directives for several reasons:</p>\n<p>AngularJS 1.5 引入了<a href=\"https://docs.angularjs.org/api/ng/type/angular.Module#component\" title=\"component(name, options); - angular.Module | API | AngularJS\">组件 API</a>，它让定义指令变得更简单了。\n为组件型指令使用这个 API 是一个好主意，因为：</p>\n<ul>\n<li>\n<p>It requires less boilerplate code.</p>\n<p>它需要更少的样板代码。</p>\n</li>\n<li>\n<p>It enforces the use of component best practices like <code>controllerAs</code>.</p>\n<p>它强制你遵循组件的最佳实践，比如 <code>controllerAs</code>。</p>\n</li>\n<li>\n<p>It has good default values for directive attributes like <code>scope</code> and <code>restrict</code>.</p>\n<p>指令中像 <code>scope</code> 和 <code>restrict</code> 这样的属性应该有良好的默认值。</p>\n</li>\n</ul>\n<p>The component directive example from above looks like this when expressed using the component API:</p>\n<p>如果使用这个组件 API 进行表示，那么上面看到的组件型指令就变成了这样：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&#x3C;',\n    deleted: '&#x26;'\n  },\n  template: `\n    &#x3C;h2>{{$ctrl.hero.name}} details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>{{$ctrl.hero.id}}&#x3C;/div>\n    &#x3C;button type=\"button\" ng-click=\"$ctrl.onDelete()\">Delete&#x3C;/button>\n  `,\n  controller: function HeroDetailController() {\n    this.onDelete = () => {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<p>Controller lifecycle hook methods <code>$onInit()</code>, <code>$onDestroy()</code>, and <code>$onChanges()</code> are another convenient feature that AngularJS 1.5 introduces.\nThey all have nearly exact <a href=\"guide/lifecycle-hooks\" title=\"Lifecycle hooks | Angular\">equivalents in Angular</a>, so organizing component lifecycle logic around them will ease the eventual Angular upgrade process.</p>\n<p>控制器的生命周期钩子 <code>$onInit()</code>、<code>$onDestroy()</code> 和 <code>$onChanges()</code> 是 AngularJS 1.5 引入的另一些便利特性。\n它们都很像<a href=\"guide/lifecycle-hooks\" title=\"Lifecycle hooks | Angular\">Angular 中的等价物</a>，所以，围绕它们组织组件生命周期的逻辑在升级到 Angular 时会更容易。</p>\n<h2 id=\"upgrading-with-ngupgrade\">Upgrading with ngUpgrade<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-with-ngupgrade\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"使用-ngupgrade-升级\">使用 ngUpgrade 升级<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#使用-ngupgrade-升级\"><i class=\"material-icons\">link</i></a></h2>\n<p>The ngUpgrade library in Angular is a very useful tool for upgrading anything but the smallest of applications.\nWith it you can mix and match AngularJS and Angular components in the same application and have them interoperate seamlessly.\nThat means you don't have to do the upgrade work all at once, since there is a natural coexistence between the two frameworks during the transition period.</p>\n<p>不管要升级什么，Angular 中的 <code>ngUpgrade</code> 库都会是一个非常有用的工具 —— 除非是小到没功能的应用。借助它，你可以在同一个应用程序中混用并匹配 AngularJS 和 Angular 的组件，并让它们实现无缝的互操作。这意味着你不用被迫一次性做完所有的升级工作，因为在整个演进过程中，这两个框架可以很自然的和睦相处。</p>\n<div class=\"alert is-helpful\">\n<p>The <a href=\"https://blog.angular.io/finding-a-path-forward-with-angularjs-7e186fdd4429\" title=\"Finding a Path Forward with AngularJS | Angular Blog\">end of life of AngularJS</a> is December 31st, 2021.\nWith this event, ngUpgrade is now in a feature complete state.\nWe will continue publishing security and bug fixes for ngUpgrade at least until December 31st, 2023.</p>\n<p>由于 <a href=\"https://blog.angular.io/finding-a-path-forward-with-angularjs-7e186fdd4429\" title=\"Finding a Path Forward with AngularJS | Angular Blog\">AngularJS 即将停止维护</a>，ngUpgrade 现在处于特性开发完毕的状态。我们将会继续发布安全补丁和 BUG 修复，直到 2023-12-31。</p>\n</div>\n<h3 id=\"how-ngupgrade-works\">How ngUpgrade Works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#how-ngupgrade-works\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"ngupgrade-的工作原理\">ngUpgrade 的工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#ngupgrade-的工作原理\"><i class=\"material-icons\">link</i></a></h3>\n<p>One of the primary tools provided by ngUpgrade is called the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>.\nThis is a module that contains utilities for bootstrapping and managing hybrid applications that support both Angular and AngularJS code.</p>\n<p><code>ngUpgrade</code> 提供的主要工具之一被称为 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>。这是一个服务，它可以启动并管理一个能同时支持 Angular 和 AngularJS 的混合式应用。</p>\n<p>When you use ngUpgrade, what you're really doing is <em>running both AngularJS and Angular at the same time</em>.\nAll Angular code is running in the Angular framework, and AngularJS code in the AngularJS framework.\nBoth of these are the actual, fully featured versions of the frameworks.\nThere is no emulation going on, so you can expect to have all the features and natural behavior of both frameworks.</p>\n<p>当使用 ngUpgrade 时，你实际上在<em>同时运行 AngularJS 和 Angular</em>。所有 Angular 的代码运行在 Angular 框架中，而 AngularJS 的代码运行在 AngularJS 框架中。所有这些都是真实的、全功能的框架版本。没有进行任何仿真，所以你可以认为同时存在着这两个框架的所有特性和自然行为。</p>\n<p>What happens on top of this is that components and services managed by one framework can interoperate with those from the other framework.\nThis happens in three main areas:\nDependency injection, the DOM, and change detection.</p>\n<p>所有这些事情的背后，本质上是一个框架中管理的组件和服务能和来自另一个框架的进行互操作。这些主要体现在三个方面：依赖注入、DOM 和变更检测。</p>\n<h4 id=\"dependency-injection\">Dependency Injection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#dependency-injection\"><i class=\"material-icons\">link</i></a></h4>\n<h4 id=\"依赖注入\">依赖注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#依赖注入\"><i class=\"material-icons\">link</i></a></h4>\n<p>Dependency injection is front and center in both AngularJS and Angular, but there are some key differences between the two frameworks in how it actually works.</p>\n<p>无论是在 AngularJS 中还是在 Angular 中，依赖注入都位于前沿和中心的位置，但在两个框架的工作原理上，却存在着一些关键的不同之处。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">AngularJS</th>\n<th align=\"left\">Angular</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">AngularJS</td>\n<td align=\"left\">角</td>\n</tr>\n<tr>\n<td align=\"left\">Dependency injection tokens are always strings</td>\n<td align=\"left\">Tokens <a href=\"guide/dependency-injection\" title=\"Dependency injection in Angular | Angular\">can have different types</a>. <br> They are often classes. <br> They may also be strings.</td>\n</tr>\n<tr>\n<td align=\"left\">依赖注入的令牌(Token)永远是字符串(译注：指服务名称)。</td>\n<td align=\"left\">令牌<a href=\"guide/dependency-injection\" title=\"Dependency injection in Angular | Angular\">可以有不同的类型</a>。<br> 通常是类。<br>也可能是字符串。</td>\n</tr>\n<tr>\n<td align=\"left\">There is exactly one injector. <br> Even in multi-module applications, everything is poured into one big namespace.</td>\n<td align=\"left\">There is a <a href=\"guide/hierarchical-dependency-injection\" title=\"Hierarchical injectors | Angular\">tree hierarchy of injectors</a>, with a root injector and an additional injector for each component.</td>\n</tr>\n<tr>\n<td align=\"left\">只有一个注入器。<br>即使在多模块的应用程序中，每样东西也都会被装入一个巨大的命名空间中。</td>\n<td align=\"left\">这是一个<a href=\"guide/hierarchical-dependency-injection\" title=\"Hierarchical injectors | Angular\">树状多级注入器</a>：有一个根注入器，而且每个组件也有一个自己的注入器。</td>\n</tr>\n</tbody>\n</table>\n<p>Even accounting for these differences you can still have dependency injection interoperability.\n<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> resolves the differences and makes everything work seamlessly:</p>\n<p>就算有这么多不同点，也并不妨碍你在依赖注入时进行互操作。<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 解决了这些差异，并让它们无缝的对接：</p>\n<ul>\n<li>\n<p>You can make AngularJS services available for injection to Angular code by <em>upgrading</em> them.\nThe same singleton instance of each service is shared between the frameworks.\nIn Angular these services will always be in the <em>root injector</em> and available to all components.</p>\n<p>通过升级它们，你就能让那些在 AngularJS 中能被注入的服务也可用于 Angular 的代码中。在框架之间共享的是服务的同一个单例对象。在 Angular 中，这些外来服务总是被放在<em>根注入器</em>中，并可用于所有组件。它们总是具有<em>字符串令牌</em> —— 跟它们在 AngularJS 中的令牌相同。</p>\n</li>\n<li>\n<p>You can also make Angular services available for injection to AngularJS code by <em>downgrading</em> them.\nOnly services from the Angular root injector can be downgraded.\nAgain, the same singleton instances are shared between the frameworks.\nWhen you register a downgraded service, you must explicitly specify a <em>string token</em> that you want to use in AngularJS.</p>\n<p>通过降级它们，你也能让那些在 Angular 中能被注入的服务在 AngularJS 的代码中可用。只有那些来自 Angular 根注入器的服务才能被降级。同样的，在框架之间共享的是同一个单例对象。当你注册一个要降级的服务时，要明确指定一个打算在 AngularJS 中使用的<em>字符串令牌</em>。</p>\n</li>\n</ul>\n<div class=\"lightbox\">\n<img alt=\"The two injectors in a hybrid application\" src=\"generated/images/guide/upgrade/injectors.png\" width=\"700\" height=\"262\">\n</div>\n<h4 id=\"components-and-the-dom\">Components and the DOM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#components-and-the-dom\"><i class=\"material-icons\">link</i></a></h4>\n<h4 id=\"组件与-dom\">组件与 DOM<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#组件与-dom\"><i class=\"material-icons\">link</i></a></h4>\n<p>In the DOM of a hybrid ngUpgrade application are components and directives from both AngularJS and Angular.\nThese components communicate with each other by using the input and output bindings of their respective frameworks, which ngUpgrade bridges together.\nThey may also communicate through shared injected dependencies, as described above.</p>\n<p>在混合式应用中，同时存在来自 AngularJS 和 Angular 中组件和指令的 DOM。这些组件通过它们各自框架中的输入和输出绑定来互相通讯，它们由 ngUpgrade 桥接在一起。它们也能通过共享被注入的依赖彼此通讯，就像前面所说的那样。</p>\n<p>The key thing to understand about a hybrid application is that every element in the DOM is owned by exactly one of the two frameworks.\nThe other framework ignores it.\nIf an element is owned by AngularJS, Angular treats it as if it didn't exist, and vice versa.</p>\n<p>理解混合式应用的关键在于，DOM 中的每一个元素都只能属于这两个框架之一，而另一个框架则会忽略它。如果一个元素属于 AngularJS，那么 Angular 就会当它不存在，反之亦然。</p>\n<p>So normally a hybrid application begins life as an AngularJS application, and it is AngularJS that processes the root template, for example, the index.html.\nAngular then steps into the picture when an Angular component is used somewhere in an AngularJS template.\nThe template of that component will then be managed by Angular, and it may contain any number of Angular components and directives.</p>\n<p>所以，混合式应用总是像 AngularJS 程序那样启动，处理根模板的也是 AngularJS. 然后，当这个应用的模板中使用到了 Angular 的组件时，Angular 才开始参与。这个组件的视图由 Angular 进行管理，而且它还可以使用一系列的 Angular 组件和指令。</p>\n<p>Beyond that, you may interleave the two frameworks.\nYou always cross the boundary between the two frameworks by one of two ways:</p>\n<p>更进一步说，你可以按照需要，任意穿插使用这两个框架。使用下面的两种方式之一，你可以在这两个框架之间自由穿梭：</p>\n<ol>\n<li>\n<p>By using a component from the other framework:\nAn AngularJS template using an Angular component, or an Angular template using an AngularJS component.</p>\n<p>通过使用来自另一个框架的组件：AngularJS 的模板中用到了 Angular 的组件，或者 Angular 的模板中使用了 AngularJS 的组件。</p>\n</li>\n<li>\n<p>By transcluding or projecting content from the other framework.\nngUpgrade bridges the related concepts of AngularJS transclusion and Angular content projection together.</p>\n<p>通过透传(transclude)或投影(project)来自另一个框架的内容。<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 牵线搭桥，把 AngularJS 的透传概念和 Angular 的内容投影概念关联起来。</p>\n</li>\n</ol>\n<div class=\"lightbox\">\n<img alt=\"DOM element ownership in a hybrid application\" src=\"generated/images/guide/upgrade/dom.png\" width=\"500\" height=\"294\">\n</div>\n<p>Whenever you use a component that belongs to the other framework, a switch between framework boundaries occurs.\nHowever, that switch only happens to the elements in the template of that component.\nConsider a situation where you use an Angular component from AngularJS like this:</p>\n<p>当你使用一个属于另一个框架的组件时，就会发生一次跨框架边界的切换。不过，这种切换只发生在该组件元素的<em>子节点</em>上。考虑一个场景，你从 AngularJS 中使用一个 Angular 组件，就像这样：</p>\n<code-example language=\"html\" escape=\"html\">\n\n&#x3C;a-component>&#x3C;/a-component>\n\n</code-example>\n<p>The DOM element <code>&#x3C;a-component></code> will remain to be an AngularJS managed element, because it is defined in an AngularJS template.\nThat also means you can apply additional AngularJS directives to it, but <em>not</em> Angular directives.\nIt is only in the template of the <code>&#x3C;a-component></code> where Angular steps in.\nThis same rule also applies when you use AngularJS component directives from Angular.</p>\n<p>此时，<code>&#x3C;a-component></code> 这个 DOM 元素仍然由 AngularJS 管理，因为它是在 AngularJS 的模板中定义的。这也意味着你可以往它上面添加别的 AngularJS 指令，却<em>不能</em>添加 Angular 的指令。只有在 <code>&#x3C;a-component></code> 组件的模板中才是 Angular 的天下。同样的规则也适用于在 Angular 中使用 AngularJS 组件型指令的情况。</p>\n<h4 id=\"change-detection\">Change Detection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#change-detection\"><i class=\"material-icons\">link</i></a></h4>\n<h4 id=\"变更检测\">变更检测<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#变更检测\"><i class=\"material-icons\">link</i></a></h4>\n<p>The <code>scope.$apply()</code> is how AngularJS detects changes and updates data bindings.\nAfter every event that occurs, <code>scope.$apply()</code> gets called.\nThis is done either automatically by the framework, or manually by you.</p>\n<p>AngularJS 中的变更检测全是关于 <code>scope.$apply()</code> 的。在每个事件发生之后，<code>scope.$apply()</code> 就会被调用。这或者由框架自动调用，或者在某些情况下由你自己的代码手动调用。</p>\n<p>In Angular things are different.\nWhile change detection still occurs after every event, no one needs to call <code>scope.$apply()</code> for that to happen.\nThis is because all Angular code runs inside something called the <a href=\"api/core/NgZone\" title=\"NgZone | Core - API | Angular\">Angular zone</a>.\nAngular always knows when the code finishes, so it also knows when it should kick off change detection.\nThe code itself doesn't have to call <code>scope.$apply()</code> or anything like it.</p>\n<p>在 Angular 中，事情有点不一样。虽然变更检测仍然会在每一个事件之后发生，却不再需要每次调用 <code>scope.$apply()</code> 了。\n这是因为所有 Angular 代码都运行在一个叫做 <a href=\"api/core/NgZone\" title=\"NgZone | Core - API | Angular\">Angular zone</a> 的地方。\nAngular 总是知道什么时候代码执行完了，也就知道了它什么时候应该触发变更检测。代码本身并不需要调用 <code>scope.$apply()</code> 或其它类似的东西。</p>\n<p>In the case of hybrid applications, the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> bridges the AngularJS and Angular approaches.\nHere is what happens:</p>\n<p>在这种混合式应用的案例中，<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 在 AngularJS 的方法和 Angular 的方法之间建立了桥梁。发生了什么呢？</p>\n<ul>\n<li>\n<p>Everything that happens in the application runs inside the Angular zone.\nThis is true whether the event originated in AngularJS or Angular code.\nThe zone triggers Angular change detection after every event.</p>\n<p>应用中发生的每件事都运行在 Angular 的 zone 里。无论事件发生在 AngularJS 还是 Angular 的代码中，都是如此。这个 zone 会在每个事件之后触发 Angular 的变更检测。</p>\n</li>\n<li>\n<p>The <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> will invoke the AngularJS <code>$rootScope.$apply()</code> after every turn of the Angular zone.\nThis also triggers AngularJS change detection after every event.</p>\n<p><code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 将在每一次离开 Angular zone 时调用 AngularJS 的 <code>$rootScope.$apply()</code>。这样也就同样会在每个事件之后触发 AngularJS 的变更检测。</p>\n</li>\n</ul>\n<div class=\"lightbox\">\n<img alt=\"Change detection in a hybrid application\" src=\"generated/images/guide/upgrade/change_detection.png\" width=\"600\" height=\"163\">\n</div>\n<p>In practice, you do not need to call <code>$apply()</code>, regardless of whether it is in AngularJS or Angular.\nThe <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> does it for us.\nYou <em>can</em> still call <code>$apply()</code> so there is no need to remove such calls from existing code.\nThose calls just trigger additional AngularJS change detection checks in a hybrid application.</p>\n<p>在实践中，你不用在自己的代码中调用 <code>$apply()</code>，而不用管这段代码是在 AngularJS 还是 Angular 中。<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 都替你做了。你仍然<em>可以</em>调用 <code>$apply()</code>，也就是说你不必从现有代码中移除此调用。在混合式应用中，这些调用只会触发一次额外的 AngularJS 变更检测。</p>\n<p>When you downgrade an Angular component and then use it from AngularJS, the inputs of the component will be watched using AngularJS change detection.\nWhen those inputs change, the corresponding properties in the component are set.\nYou can also hook into the changes by implementing the <a href=\"api/core/OnChanges\" title=\"OnChanges | Core - API | Angular\">OnChanges</a> interface in the component, just like you could if it hadn't been downgraded.</p>\n<p>当你降级一个 Angular 组件，然后把它用于 AngularJS 中时，组件的输入属性就会被 AngularJS 的变更检测体系监视起来。\n当那些输入属性发生变化时，组件中相应的属性就会被设置。你也能通过实现<a href=\"api/core/OnChanges\" title=\"OnChanges | Core - API | Angular\">OnChanges</a>\n接口来挂钩到这些更改，就像它未被降级时一样。</p>\n<p>Correspondingly, when you upgrade an AngularJS component and use it from Angular, all the bindings defined for <code>scope</code> (or <code>bindToController</code>) of the component directive will be hooked into Angular change detection.\nThey will be treated as regular Angular inputs.\nTheir values will be written to the scope (or controller) of the upgraded component when they change.</p>\n<p>相应的，当你把 AngularJS 的组件升级给 Angular 使用时，在这个组件型指令的 <code>scope</code>(或 <code>bindToController</code>)中定义的所有绑定，都将被挂钩到 Angular 的变更检测体系中。它们将和标准的 Angular 输入属性被同等对待，并当它们发生变化时设置回 scope(或控制器)上。</p>\n<h3 id=\"using-upgrademodule-with-angular-ngmodules\">Using UpgradeModule with Angular <em>NgModules</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-upgrademodule-with-angular-ngmodules\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"通过-angular-的-ngmodule-来使用-upgrademodule\">通过 Angular 的 <em>NgModule</em> 来使用 UpgradeModule<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#通过-angular-的-ngmodule-来使用-upgrademodule\"><i class=\"material-icons\">link</i></a></h3>\n<p>Both AngularJS and Angular have their own concept of modules to help organize an application into cohesive blocks of functionality.</p>\n<p>AngularJS 和 Angular 都有自己的模块概念，来帮你把应用按功能组织成内聚的代码块。</p>\n<p>Their details are quite different in architecture and implementation.\nIn AngularJS, you add Angular assets to the <code>angular.module</code> property.\nIn Angular, you create one or more classes adorned with an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator that describes Angular assets in metadata.\nThe differences blossom from there.</p>\n<p>它们在架构和实现的细节上有着显著的不同。在 AngularJS 中，你要把 AngularJS 的资源添加到 <code>angular.module</code> 属性上。在 Angular 中，你要创建一个或多个带有 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 装饰器的类，这些装饰器用来在元数据中描述 Angular 资源。差异主要来自这里。</p>\n<p>In a hybrid application you run both versions of Angular at the same time.\nThat means that you need at least one module each from both AngularJS and Angular.\nYou will import <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> inside the NgModule, and then use it for bootstrapping the AngularJS module.</p>\n<p>在混合式应用中，你同时运行了两个版本的 Angular。这意味着你至少需要 AngularJS 和 Angular 各提供一个模块。当你使用 AngularJS 的模块进行引导时，就得把 Angular 的模块传给 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>。</p>\n<div class=\"alert is-helpful\">\n<p>For more information, see <a href=\"guide/ngmodules\" title=\"NgModules | Angular\">NgModules</a>.</p>\n<p>要了解更多，请参阅<a href=\"guide/ngmodules\" title=\"NgModules | Angular\">NgModules</a>页。</p>\n</div>\n<h3 id=\"bootstrapping-hybrid-applications\">Bootstrapping hybrid applications<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-hybrid-applications\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"引导混合应用程序\">引导混合应用程序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#引导混合应用程序\"><i class=\"material-icons\">link</i></a></h3>\n<p>To bootstrap a hybrid application, you must bootstrap each of the Angular and\nAngularJS parts of the application.\nYou must bootstrap the Angular bits first and then ask the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> to bootstrap the AngularJS bits next.</p>\n<p>要想引导混合式应用，就必须在应用中分别引导 Angular 和 AngularJS 应用的一部分。你必须先引导 Angular，然后再调用 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 来引导 AngularJS。</p>\n<p>In an AngularJS application you have a root AngularJS module, which will also be used to bootstrap the AngularJS application.</p>\n<p>在 AngularJS 应用中有一个 AngularJS 的根模块，它用于引导 AngularJS 应用。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"ng1module\">\nangular.module('heroApp', [])\n  .controller('MainCtrl', function() {\n    this.message = 'Hello world';\n  });\n\n</code-example>\n<p>Pure AngularJS applications can be automatically bootstrapped by using an <code>ng-app</code> directive somewhere on the HTML page.\nBut for hybrid applications, you manually bootstrap using the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>.\nTherefore, it is a good preliminary step to switch AngularJS applications to use the manual JavaScript <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\"><code>angular.bootstrap</code></a> method even before switching them to hybrid mode.</p>\n<p>单纯的 AngularJS 应用可以在 HTML 页面中使用 <code>ng-app</code> 指令进行引导，但对于混合式应用你要通过 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 模块进行手动引导。因此，在切换成混合式应用之前，最好先把 AngularJS 改写成使用 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\"><code>angular.bootstrap</code></a> 进行手动引导的方式。</p>\n<p>Say you have an <code>ng-app</code> driven bootstrap such as this one:</p>\n<p>比如你现在有这样一个通过 <code>ng-app</code> 进行引导的应用：</p>\n<code-example path=\"upgrade-module/src/index-ng-app.html\">\n&#x3C;!DOCTYPE HTML>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;base href=\"/\">\n    &#x3C;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.5.3/angular.js\">&#x3C;/script>\n    &#x3C;script src=\"app/ajs-ng-app/app.module.js\">&#x3C;/script>\n  &#x3C;/head>\n\n  &#x3C;body ng-app=\"heroApp\" ng-strict-di>\n    &#x3C;div id=\"message\" ng-controller=\"MainCtrl as mainCtrl\">\n      {{ mainCtrl.message }}\n    &#x3C;/div>\n  &#x3C;/body>\n&#x3C;/html>\n\n\n</code-example>\n<p>You can remove the <code>ng-app</code> and <code>ng-strict-di</code> directives from the HTML and instead switch to calling <code>angular.bootstrap</code> from JavaScript, which will result in the same thing:</p>\n<p>你可以从 HTML 中移除 <code>ng-app</code> 和 <code>ng-strict-di</code> 指令，改为从 JavaScript 中调用 <code>angular.bootstrap</code>，它能达到同样效果：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"bootstrap\">\nangular.bootstrap(document.body, ['heroApp'], { strictDi: true });\n\n</code-example>\n<p>To begin converting your AngularJS application to a hybrid, you need to load the Angular framework.\nYou can see how this can be done with SystemJS by following the instructions in <a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">Setup for Upgrading to AngularJS</a> for selectively copying code from the <a href=\"https://github.com/angular/quickstart\" title=\"angular/quickstart | GitHub\">QuickStart GitHub repository</a>.</p>\n<p>要想把 AngularJS 应用变成 Hybrid 应用，就要先加载 Angular 框架。\n根据<a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">准备升级到 AngularJS</a> 中给出的步骤，选择性的把<a href=\"https://github.com/angular/quickstart\" title=\"angular/quickstart | GitHub\">快速入门 GitHub 代码仓</a>中的代码复制过来。</p>\n<p>You also need to install the <code>@angular/upgrade</code> package using <code>npm install @angular/upgrade --save</code> and add a mapping for the <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> package:</p>\n<p>你还需要用 <code>npm install @angular/upgrade --save</code> 安装 <code>@angular/upgrade</code> 包，并添加一个指向 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 包的映射：</p>\n<code-example header=\"systemjs.config.js (map)\" path=\"upgrade-module/src/systemjs.config.1.js\" region=\"upgrade-static-package\">\n'@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/fesm2015/static.mjs',\n\n</code-example>\n<p>Next, create an <code>app.module.ts</code> file and add the following <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> class:</p>\n<p>接下来，创建一个 <code>app.module.ts</code> 文件，并添加下列 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 类：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"ngmodule\">\nimport { <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p>This bare minimum <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> imports <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>, the module every Angular browser-based application must have.\nIt also imports <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> from <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code>, which exports providers that will be used for upgrading and downgrading services and components.</p>\n<p>最小化的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 导入了 <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>，它是每个基于浏览器的 Angular 应用必备的。它还从 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 中导入了 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，它导出了一些服务提供者，这些提供者会用于升级、降级服务和组件。</p>\n<p>In the constructor of the <code>AppModule</code>, use dependency injection to get a hold of the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> instance, and use it to bootstrap the AngularJS application in the <code>AppModule.ngDoBootstrap</code> method.\nThe <code>upgrade.bootstrap</code> method takes the exact same arguments as <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\">angular.bootstrap</a>:</p>\n<p>在 <code>AppModule</code> 的构造函数中，使用依赖注入技术获取了一个 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 实例，并用它在 <code>AppModule.ngDoBootstrap</code> 方法中启动 AngularJS 应用。\n<code>upgrade.bootstrap</code> 方法接受和 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\">angular.bootstrap</a> 完全相同的参数。</p>\n<div class=\"alert is-helpful\">\n<p><strong>NOTE</strong>: <br>\nYou do not add a <code>bootstrap</code> declaration to the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator, since AngularJS will own the root template of the application.</p>\n<p><strong>注意</strong>：<br>\n你不需要在 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中加入 <code>bootstrap</code> 声明，因为 AngularJS 控制着该应用的根模板。</p>\n</div>\n<p>Now you can bootstrap <code>AppModule</code> using the <code>platformBrowserDynamic.bootstrapModule</code> method.</p>\n<p>现在，你就可以使用 <code>platformBrowserDynamic.bootstrapModule</code> 方法来启动 <code>AppModule</code> 了。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"bootstrap\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n</code-example>\n<p>Congratulations.\nYou're running a hybrid application.\nThe existing AngularJS code works as before <em>and</em> you're ready to start adding Angular code.</p>\n<p>恭喜！你就要开始运行这个混合式应用了！所有现存的 AngularJS 代码会像以前一样正常工作，但是你现在也同样可以运行 Angular 代码了。</p>\n<h3 id=\"using-angular-components-from-angularjs-code\">Using Angular Components from AngularJS Code<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angular-components-from-angularjs-code\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"从-angularjs-代码中使用-angular-组件\">从 AngularJS 代码中使用 Angular 组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#从-angularjs-代码中使用-angular-组件\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"lightbox\">\n<img alt=\"Using an Angular component from AngularJS code\" class=\"left\" src=\"generated/images/guide/upgrade/ajs-to-a.png\" width=\"250\" height=\"44\">\n</div>\n<p>Once you're running a hybrid app, you can start the gradual process of upgrading code.\nOne of the more common patterns for doing that is to use an Angular component in an AngularJS context.\nThis could be a completely new component or one that was previously AngularJS but has been rewritten for Angular.</p>\n<p>一旦你开始运行混合式应用，你就可以开始逐渐升级代码了。一种更常见的工作模式就是在 AngularJS 的上下文中使用 Angular 的组件。该组件可能是全新的，也可能是把原本 AngularJS 的组件用 Angular 重写而成的。</p>\n<p>Say you have an Angular component that shows information about a hero:</p>\n<p>假设你有一个用来显示英雄信息的 Angular 组件：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/downgrade-static/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>Windstorm details!&#x3C;/h2>\n    &#x3C;div>id: 1&#x3C;/div>\n  `\n})\nexport class HeroDetailComponent { }\n\n\n</code-example>\n<p>If you want to use this component from AngularJS, you need to <em>downgrade</em> it using the <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> method.\nThe result is an AngularJS <em>directive</em>, which you can then register in the AngularJS module:</p>\n<p>如果你想在 AngularJS 中使用这个组件，就得用 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 方法把它<em>降级</em>。其结果是一个 AngularJS 的<em>指令</em>，你可以把它注册到 AngularJS 的模块中：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"downgradecomponent\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n/* . . . */\n\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('heroApp', [])\n  .directive(\n    'heroDetail',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({ component: HeroDetailComponent }) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>By default, Angular change detection will also run on the component for everyAngularJS <code>$digest</code> cycle.\nIf you want to only have change detection run when the inputs change, you can set <code>propagateDigest</code> to <code>false</code> when calling <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code>.</p>\n<p>默认情况下，Angular 变更检测也会在 AngularJS 的每个 <code>$digest</code> 周期中运行。如果你希望只在输入属性发生变化时才运行变更检测，可以在调用 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 时把 <code>propagateDigest</code> 设置为 <code>false</code>。</p>\n</div>\n<p>Because <code>HeroDetailComponent</code> is an Angular component, you must also add it to the <code>declarations</code> in the <code>AppModule</code>.</p>\n<p>由于 <code>HeroDetailComponent</code> 是一个 Angular 组件，所以你必须同时把它加入 <code>AppModule</code> 的 <code>declarations</code> 字段中。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"ngmodule\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  declarations: [\n    HeroDetailComponent\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>All Angular components, directives, and pipes must be declared in an NgModule.</p>\n<p>所有 Angular 组件、指令和管道都必须声明在 NgModule 中。</p>\n</div>\n<p>The net result is an AngularJS directive called <code>heroDetail</code>, that you can use like any other directive in AngularJS templates.</p>\n<p>最终的结果是一个叫做 <code>heroDetail</code> 的 AngularJS 指令，你可以像用其它指令一样把它用在 AngularJS 模板中。</p>\n<code-example path=\"upgrade-module/src/index-downgrade-static.html\" region=\"usecomponent\">\n&#x3C;hero-detail>&#x3C;/hero-detail>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p><strong>NOTE</strong>: <br>\nThis AngularJS is an element directive (<code>restrict: 'E'</code>) called <code>heroDetail</code>.\nAn AngularJS element directive is matched based on its <em>name</em>.\n<em>The <code>selector</code> metadata of the downgraded Angular component is ignored</em>.</p>\n<p><strong>注意</strong>：<br>\n它在 AngularJS 中是一个名叫 <code>heroDetail</code> 的元素型指令（<code>restrict: 'E'</code>）。\nAngularJS 的元素型指令是基于它的<em>名字</em>匹配的。\n<em>Angular 组件中的 <code>selector</code> 元数据，在降级后的版本中会被忽略。</em></p>\n</div>\n<p>Most components are not quite this simple, of course.\nMany of them have <em>inputs and outputs</em> that connect them to the outside world.\nAn Angular hero detail component with inputs and outputs might look like this:</p>\n<p>当然，大多数组件都不像这个这么简单。它们中很多都有<em>输入属性和输出属性</em>，来把它们连接到外部世界。Angular 的英雄详情组件带有像这样的输入属性与输出属性：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/downgrade-io/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>{{hero.name}} details!&#x3C;/h2>\n    &#x3C;div>id: {{hero.id}}&#x3C;/div>\n    &#x3C;button type=\"button\" (click)=\"onDelete()\">Delete&#x3C;/button>\n  `\n})\nexport class HeroDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleted = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>();\n  onDelete() {\n    this.deleted.emit(this.hero);\n  }\n}\n\n\n</code-example>\n<p>These inputs and outputs can be supplied from the AngularJS template, and the <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> method takes care of wiring them up:</p>\n<p>这些输入属性和输出属性的值来自于 AngularJS 的模板，而 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 方法负责桥接它们：</p>\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"usecomponent\">\n&#x3C;div ng-controller=\"MainController as mainCtrl\">\n  &#x3C;hero-detail [hero]=\"mainCtrl.hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\">\n  &#x3C;/hero-detail>\n&#x3C;/div>\n\n</code-example>\n<p>Even though you are in an AngularJS template, <strong>you are using Angular attribute syntax to bind the inputs and outputs</strong>.\nThis is a requirement for downgraded components.\nThe expressions themselves are still regular AngularJS expressions.</p>\n<p>注意，虽然你正在 AngularJS 的模板中，<strong>但却在使用 Angular 的属性(Attribute)语法来绑定到输入属性与输出属性</strong>。这是降级的组件本身要求的。而表达式本身仍然是标准的 AngularJS 表达式。</p>\n<div class=\"callout is-important\">\n<header>Use kebab-case for downgraded component attributes</header>\n<header>在降级过的组件属性中使用中线命名法</header>\n<p>There is one notable exception to the rule of using Angular attribute syntax for downgraded components.\nIt has to do with input or output names that consist of multiple words.\nIn Angular, you would bind these attributes using camelCase:</p>\n<p>为降级过的组件使用 Angular 的属性(Attribute)语法规则时有一个值得注意的例外。它适用于由多个单词组成的输入或输出属性。在 Angular 中，你要使用小驼峰命名法绑定这些属性：</p>\n<code-example language=\"html\">\n\n[myHero]=\"hero\"\n(heroDeleted)=\"handleHeroDeleted($event)\"\n\n</code-example>\n<p>But when using them from AngularJS templates, you must use kebab-case:</p>\n<p>但是从 AngularJS 的模板中使用它们时，你得使用中线命名法：</p>\n<code-example language=\"html\">\n\n[my-hero]=\"hero\"\n(hero-deleted)=\"handleHeroDeleted($event)\"\n\n</code-example>\n</div>\n<p>The <code>$event</code> variable can be used in outputs to gain access to the object that was emitted.\nIn this case it will be the <code>Hero</code> object, because that is what was passed to <code>this.deleted.emit()</code>.</p>\n<p><code>$event</code> 变量能被用在输出属性里，以访问这个事件所发出的对象。这个案例中它是 <code>Hero</code> 对象，因为 <code>this.deleted.emit()</code> 函数曾把它传了出来。</p>\n<p>Since this is an AngularJS template, you can still use other AngularJS directives on the element, even though it has Angular binding attributes on it.\nFor example, you can easily make multiple copies of the component using <code>ng-repeat</code>:</p>\n<p>由于这是一个 AngularJS 模板，虽然它已经有了 Angular 中绑定的属性(Attribute)，你仍可以在这个元素上使用其它 AngularJS 指令。比如，你可以用 <code>ng-repeat</code> 简单的制作该组件的多份拷贝：</p>\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"userepeatedcomponent\">\n&#x3C;div ng-controller=\"MainController as mainCtrl\">\n  &#x3C;hero-detail [hero]=\"hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\"\n               ng-repeat=\"hero in mainCtrl.heroes\">\n  &#x3C;/hero-detail>\n&#x3C;/div>\n\n</code-example>\n<h3 id=\"using-angularjs-component-directives-from-angular-code\">Using AngularJS Component Directives from Angular Code<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angularjs-component-directives-from-angular-code\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"从-angular-代码使用-angularjs-组件指令\">从 Angular 代码使用 AngularJS 组件指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#从-angular-代码使用-angularjs-组件指令\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"lightbox\">\n<img alt=\"Using an AngularJS component from Angular code\" class=\"left\" src=\"generated/images/guide/upgrade/a-to-ajs.png\" width=\"250\" height=\"44\">\n</div>\n<p>So, you can write an Angular component and then use it from AngularJS code.\nThis is useful when you start to migrate from lower-level components and work your way up.\nBut in some cases it is more convenient to do things in the opposite order:\nTo start with higher-level components and work your way down.\nThis too can be done using the <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code>.\nYou can <em>upgrade</em> AngularJS component directives and then use them from Angular.</p>\n<p>现在，你已经能在 Angular 中写一个组件，并把它用于 AngularJS 代码中了。当你从低级组件开始移植，并往上走时，这非常有用。但在另外一些情况下，从相反的方向进行移植会更加方便：从高级组件开始，然后往下走。这也同样能用 <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 完成。你可以<em>升级</em>AngularJS 组件型指令，然后从 Angular 中用它们。</p>\n<p>Not all kinds of AngularJS directives can be upgraded.\nThe directive really has to be a <em>component directive</em>, with the characteristics <a href=\"guide/upgrade#using-component-directives\" title=\"Using Component Directives - Upgrading from AngularJS to Angular | Angular\">described in the preparation guide above</a>.\nThe safest bet for ensuring compatibility is using the <a href=\"https://docs.angularjs.org/api/ng/type/angular.Module\" title=\"angular.Module | API | AngularJS\">component API</a> introduced in AngularJS 1.5.</p>\n<p>不是所有种类的 AngularJS 指令都能升级。该指令必须是一个严格的<em>组件型指令</em>，具有<a href=\"guide/upgrade#using-component-directives\" title=\"Using Component Directives - Upgrading from AngularJS to Angular | Angular\">上面的准备指南中描述的</a>那些特征。\n确保兼容性的最安全的方式是 AngularJS 1.5 中引入的<a href=\"https://docs.angularjs.org/api/ng/type/angular.Module\" title=\"angular.Module | API | AngularJS\">组件 API</a>。</p>\n<p>An example of an upgradeable component is one that just has a template and a controller:</p>\n<p>可升级组件的简单例子是只有一个模板和一个控制器的指令：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail\">\nexport const heroDetail = {\n  template: `\n    &#x3C;h2>Windstorm details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>1&#x3C;/div>\n  `,\n  controller: function HeroDetailController() {\n  }\n};\n\n</code-example>\n<p>You can <em>upgrade</em> this component to Angular using the <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code> class.\nBy creating a new Angular <strong>directive</strong> that extends <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code> and doing a <code>super</code> call inside its constructor, you have a fully upgraded AngularJS component to be used inside Angular.\nAll that is left is to add it to the <code>declarations</code> array of <code>AppModule</code>.</p>\n<p>你可以使用 <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code> 方法来把这个组件<em>升级</em>到 Angular。具体方法是创建一个 Angular<strong>指令</strong>，继承 <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code>，在其构造函数中进行 <code>super</code> 调用，这样你就得到一个完全升级的 AngularJS 组件，并且可以 Angular 中使用。剩下是工作就是把它加入到 <code>AppModule</code> 的 <code>declarations</code> 数组。</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail-upgrade\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>, <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a> } from '@angular/core';\nimport { <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> {\n  constructor(elementRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/upgrade-static/app.module.ts\" region=\"hero-detail-upgrade\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  declarations: [\n    HeroDetailDirective,\n  /* . . . */\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>Upgraded components are Angular <strong>directives</strong>, instead of <strong>components</strong>, because Angular is unaware that AngularJS will create elements under it.\nAs far as Angular knows, the upgraded component is just a directive —a tag— and Angular doesn't have to concern itself with its children.</p>\n<p>升级后的组件是 Angular 的<strong>指令</strong>，而不是<strong>组件</strong>，因为 Angular 不知道 AngularJS 将在它下面创建元素。Angular 所知道的是升级后的组件只是一个指令（一个标签），Angular 不需要关心组件本身及其子元素。</p>\n</div>\n<p>An upgraded component may also have inputs and outputs, as defined by the scope/controller bindings of the original AngularJS component directive.\nWhen you use the component from an Angular template, provide the inputs and outputs using <strong>Angular template syntax</strong>, observing the following rules:</p>\n<p>升级后的组件也可能有输入属性和输出属性，它们是在原 AngularJS 组件型指令的 scope/controller 绑定中定义的。当你从 Angular 模板中使用该组件时，就要使用<strong>Angular 模板语法</strong>来提供这些输入属性和输出属性，但要遵循下列规则：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Bindings</th>\n<th align=\"left\">Binding definition</th>\n<th align=\"left\">Template syntax</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">绑定</td>\n<td align=\"left\">绑定定义</td>\n<td align=\"left\">模板语法</td>\n</tr>\n<tr>\n<td align=\"left\">Attribute binding</td>\n<td align=\"left\"><code>myAttribute: '@myAttribute'</code></td>\n<td align=\"left\"><code>&#x3C;my-component myAttribute=\"value\"></code></td>\n</tr>\n<tr>\n<td align=\"left\">属性绑定</td>\n<td align=\"left\"><code>myAttribute: '@myAttribute'</code></td>\n<td align=\"left\"><code>&#x3C;my-component myAttribute=\"value\"></code></td>\n</tr>\n<tr>\n<td align=\"left\">Expression binding</td>\n<td align=\"left\"><code>myOutput: '&#x26;myOutput'</code></td>\n<td align=\"left\"><code>&#x3C;my-component (myOutput)=\"action()\"></code></td>\n</tr>\n<tr>\n<td align=\"left\">表达式绑定</td>\n<td align=\"left\"><code>myOutput: '&#x26;myOutput'</code></td>\n<td align=\"left\"><code>&#x3C;my-component (myOutput)=\"action()\"></code></td>\n</tr>\n<tr>\n<td align=\"left\">One-way binding</td>\n<td align=\"left\"><code>myValue: '&#x3C;myValue'</code></td>\n<td align=\"left\"><code>&#x3C;my-component [myValue]=\"anExpression\"></code></td>\n</tr>\n<tr>\n<td align=\"left\">单向绑定</td>\n<td align=\"left\"><code>myValue: '&#x3C;myValue'</code></td>\n<td align=\"left\"><code>&#x3C;my-component [myValue]=\"anExpression\"></code></td>\n</tr>\n<tr>\n<td align=\"left\">Two-way binding</td>\n<td align=\"left\"><code>myValue: '=myValue'</code></td>\n<td align=\"left\">As a two-way binding: <br> <code>&#x3C;my-component [(myValue)]=\"anExpression\"></code> <br> Since most AngularJS two-way bindings actually only need a one-way binding in practice, <code>&#x3C;my-component [myValue]=\"anExpression\"></code> is often enough.</td>\n</tr>\n<tr>\n<td align=\"left\">双向绑定</td>\n<td align=\"left\"><code>myValue: '=myValue'</code></td>\n<td align=\"left\">用作双向绑定：<code>&#x3C;my-component [(myValue)]=\"anExpression\"></code>。<br> 由于大多数 AngularJS 的双向绑定实际上只是单向绑定，因此通常写成 <code>&#x3C;my-component [myValue]=\"anExpression\"></code> 也够用了。</td>\n</tr>\n</tbody>\n</table>\n<p>For example, imagine a hero detail AngularJS component directive with one input and one output:</p>\n<p>举个例子，假设 AngularJS 中有一个表示“英雄详情”的组件型指令，它带有一个输入属性和一个输出属性：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&#x3C;',\n    deleted: '&#x26;'\n  },\n  template: `\n    &#x3C;h2>{{$ctrl.hero.name}} details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>{{$ctrl.hero.id}}&#x3C;/div>\n    &#x3C;button type=\"button\" ng-click=\"$ctrl.onDelete()\">Delete&#x3C;/button>\n  `,\n  controller: function HeroDetailController() {\n    this.onDelete = () => {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<p>You can upgrade this component to Angular, annotate inputs and outputs in the upgrade directive, and then provide the input and output using Angular template syntax:</p>\n<p>你可以把这个组件升级到 Angular，然后使用 Angular 的模板语法提供这个输入属性和输出属性：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io-upgrade\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a> } from '@angular/core';\nimport { <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleted: <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>;\n\n  constructor(elementRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example header=\"container.component.ts\" path=\"upgrade-module/src/app/upgrade-io/container.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-container',\n  template: `\n    &#x3C;h1>Tour of Heroes&#x3C;/h1>\n    &#x3C;hero-detail [hero]=\"hero\"\n                 (deleted)=\"heroDeleted($event)\">\n    &#x3C;/hero-detail>\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm');\n  heroDeleted(hero: Hero) {\n    hero.name = 'Ex-' + hero.name;\n  }\n}\n\n\n</code-example>\n<h3 id=\"projecting-angularjs-content-into-angular-components\">Projecting AngularJS Content into Angular Components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#projecting-angularjs-content-into-angular-components\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"把-angularjs-的内容投影到-angular-组件中\">把 AngularJS 的内容投影到 Angular 组件中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#把-angularjs-的内容投影到-angular-组件中\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"lightbox\">\n<img alt=\"Projecting AngularJS content into Angular\" class=\"left\" src=\"generated/images/guide/upgrade/ajs-to-a-with-projection.png\" width=\"250\" height=\"48\">\n</div>\n<p>When you are using a downgraded Angular component from an AngularJS template, the need may arise to <em>transclude</em> some content into it.\nThis is also possible.\nWhile there is no such thing as transclusion in Angular, there is a very similar concept called <em>content projection</em>.\n<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> is able to make these two features interoperate.</p>\n<p>如果你在 AngularJS 模板中使用降级后的 Angular 组件时，可能会需要把模板中的一些内容投影进那个组件。这也是可能的，虽然在 Angular 中并没有透传(transclude)这样的东西，但它有一个非常相似的概念，叫做<em>内容投影</em>。<code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> 也能让这两个特性实现互操作。</p>\n<p>Angular components that support content projection make use of an <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&#x3C;ng-content></a></code> tag within them.\nHere is an example of such a component:</p>\n<p>Angular 的组件通过使用 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&#x3C;ng-content></a></code> 标签来支持内容投影。下面是这类组件的一个例子：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/ajs-to-a-projection/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>{{hero.name}}&#x3C;/h2>\n    &#x3C;div>\n      &#x3C;ng-content>&#x3C;/ng-content>\n    &#x3C;/div>\n  `\n})\nexport class HeroDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n}\n\n\n</code-example>\n<p>When using the component from AngularJS, you can supply contents for it.\nJust like they would be transcluded in AngularJS, they get projected to the location of the <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&#x3C;ng-content></a></code> tag in Angular:</p>\n<p>当从 AngularJS 中使用该组件时，你可以为它提供内容。正如它们将在 AngularJS 中被透传一样，它们也在 Angular 中被投影到了 <code><a href=\"api/core/ng-content\" class=\"code-anchor\">&#x3C;ng-content></a></code> 标签所在的位置：</p>\n<code-example path=\"upgrade-module/src/index-ajs-to-a-projection.html\" region=\"usecomponent\">\n&#x3C;div ng-controller=\"MainController as mainCtrl\">\n  &#x3C;hero-detail [hero]=\"mainCtrl.hero\">\n    &#x3C;!-- Everything here will get projected -->\n    &#x3C;p>{{mainCtrl.hero.description}}&#x3C;/p>\n  &#x3C;/hero-detail>\n&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>When AngularJS content gets projected inside an Angular component, it still remains in \"AngularJS land\" and is managed by the AngularJS framework.</p>\n<p>当 AngularJS 的内容被投影到 Angular 组件中时，它仍然留在“AngularJS 王国”中，并被 AngularJS 框架管理着。</p>\n</div>\n<h3 id=\"transcluding-angular-content-into-angularjs-component-directives\">Transcluding Angular Content into AngularJS Component Directives<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"把-angular-的内容透传进-angularjs-的组件型指令\">把 Angular 的内容透传进 AngularJS 的组件型指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#把-angular-的内容透传进-angularjs-的组件型指令\"><i class=\"material-icons\">link</i></a></h3>\n<div class=\"lightbox\">\n<img alt=\"Projecting Angular content into AngularJS\" class=\"left\" src=\"generated/images/guide/upgrade/a-to-ajs-with-transclusion.png\" width=\"250\" height=\"48\">\n</div>\n<p>Just as you can project AngularJS content into Angular components, you can <em>transclude</em> Angular content into AngularJS components, whenever you are using upgraded versions from them.</p>\n<p>就像可以把 AngularJS 的内容投影进 Angular 组件一样，你也能把 Angular 的内容<em>透传</em>进 AngularJS 的组件，但不管怎样，你都要使用它们升级过的版本。</p>\n<p>When an AngularJS component directive supports transclusion, it may use the <code>ng-transclude</code> directive in its template to mark the transclusion point:</p>\n<p>如果一个 AngularJS 组件型指令支持透传，它就会在自己的模板中使用 <code>ng-transclude</code> 指令标记出透传到的位置：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/a-to-ajs-transclusion/hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: '='\n  },\n  template: `\n    &#x3C;h2>{{$ctrl.hero.name}}&#x3C;/h2>\n    &#x3C;div>\n      &#x3C;ng-transclude>&#x3C;/ng-transclude>\n    &#x3C;/div>\n  `,\n  transclude: true\n};\n\n</code-example>\n<p>If you upgrade this component and use it from Angular, you can populate the component tag with contents that will then get transcluded:</p>\n<p>如果你升级这个组件，并把它用在 Angular 中，你就能把准备透传的内容放进这个组件的标签中。</p>\n<code-example header=\"container.component.ts\" path=\"upgrade-module/src/app/a-to-ajs-transclusion/container.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-container',\n  template: `\n    &#x3C;hero-detail [hero]=\"hero\">\n      &#x3C;!-- Everything here will get transcluded -->\n      &#x3C;p>{{hero.description}}&#x3C;/p>\n    &#x3C;/hero-detail>\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm', 'Specific powers of controlling winds');\n}\n\n\n</code-example>\n<h3 id=\"making-angularjs-dependencies-injectable-to-angular\">Making AngularJS Dependencies Injectable to Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"让-angularjs-中的依赖可被注入到-angular\">让 AngularJS 中的依赖可被注入到 Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#让-angularjs-中的依赖可被注入到-angular\"><i class=\"material-icons\">link</i></a></h3>\n<p>When running a hybrid app, you may encounter situations where you need to inject some AngularJS dependencies into your Angular code.\nMaybe you have some business logic still in AngularJS services.\nMaybe you want access to built-in services of AngularJS like <code>$location</code> or <code>$timeout</code>.</p>\n<p>当运行一个混合式应用时，可能会遇到这种情况：你需要把某些 AngularJS 的依赖注入到 Angular 代码中。这可能是因为某些业务逻辑仍然在 AngularJS 服务中，或者需要某些 AngularJS 的内置服务，比如 <code>$location</code> 或 <code>$timeout</code>。</p>\n<p>In these situations, it is possible to <em>upgrade</em> an AngularJS provider to Angular.\nThis makes it possible to then inject it somewhere in Angular code.\nFor example, you might have a service called <code>HeroesService</code> in AngularJS:</p>\n<p>在这些情况下，把一个 AngularJS 提供者<em>升级到</em>Angular 也是有可能的。这就让它将来有可能被注入到 Angular 代码中的某些地方。比如，你可能在 AngularJS 中有一个名叫 <code>HeroesService</code> 的服务：</p>\n<code-example header=\"heroes.service.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/heroes.service.ts\">\nimport { Hero } from '../hero';\n\nexport class HeroesService {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p>You can upgrade the service using an Angular [factory provider][AioGuideDependencyInjectionProvidersFactoryProviders] that requests the service from the AngularJS <code>$injector</code>.</p>\n<p>你可以用 Angular 的[工厂提供者][AioGuideDependencyInjectionProvidersFactoryProviders]升级该服务，\n它从 AngularJS 的 <code>$injector</code> 请求服务。</p>\n<p>Many developers prefer to declare the factory provider in a separate <code>ajs-upgraded-providers.ts</code> file so that they are all together, making it easier to reference them, create new ones and delete them once the upgrade is over.</p>\n<p>很多开发者都喜欢在一个独立的 <code>ajs-upgraded-providers.ts</code> 中声明这个工厂提供者，以便把它们都放在一起，这样便于引用、创建新的以及在升级完毕时删除它们。</p>\n<p>It is also recommended to export the <code>heroesServiceFactory</code> function so that Ahead-of-Time compilation can pick it up.</p>\n<p>同时，建议导出 <code>heroesServiceFactory</code> 函数，以便 AOT 编译器可以拿到它们。</p>\n<div class=\"alert is-helpful\">\n<p><strong>NOTE</strong>: <br>\nThe 'heroes' string inside the factory refers to the AngularJS <code>HeroesService</code>.\nIt is common in AngularJS applications to choose a service name for the token, for example \"heroes\", and append the \"Service\" suffix to create the class name.</p>\n<p><strong>注意</strong>：<br>\n这个工厂中的字符串 'heroes' 指向的是 AngularJS 的 <code>HeroesService</code>。\nAngularJS 应用中通常使用服务名作为令牌，比如 'heroes'，并为其追加 'Service' 后缀来创建其类名。</p>\n</div>\n<code-example header=\"ajs-upgraded-providers.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/ajs-upgraded-providers.ts\">\nimport { HeroesService } from './heroes.service';\n\nexport function heroesServiceFactory(i: any) {\n  return i.get('heroes');\n}\n\nexport const heroesServiceProvider = {\n  provide: HeroesService,\n  useFactory: heroesServiceFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<p>You can then provide the service to Angular by adding it to the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>:</p>\n<p>然后，你就可以把这个服务添加到 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中来把它暴露给 Angular：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/app.module.ts\" region=\"register\">\nimport { heroesServiceProvider } from './ajs-upgraded-providers';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  providers: [\n    heroesServiceProvider\n  ],\n/* . . . */\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p>Then use the service inside your component by injecting it in the component constructor using its class as a type annotation:</p>\n<p>然后在组件的构造函数中使用该服务的类名作为类型注解注入到组件中，从而在组件中使用它：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/ajs-to-a-providers/hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HeroesService } from './heroes.service';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>{{hero.id}}: {{hero.name}}&#x3C;/h2>\n  `\n})\nexport class HeroDetailComponent {\n  hero: Hero;\n  constructor(heroes: HeroesService) {\n    this.hero = heroes.get()[0];\n  }\n}\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>In this example you upgraded a service class.\nYou can use a TypeScript type annotation when you inject it.\nWhile it doesn't affect how the dependency is handled, it enables the benefits of static type checking.\nThis is not required though, and any AngularJS service, factory, or provider can be upgraded.</p>\n<p>在这个例子中，你升级了服务类。当注入它时，你可以使用 TypeScript 类型注解来获得这些额外的好处。它没有影响该依赖的处理过程，同时还得到了启用静态类型检查的好处。任何 AngularJS 中的服务、工厂和提供者都能被升级 —— 尽管这不是必须的。</p>\n</div>\n<h3 id=\"making-angular-dependencies-injectable-to-angularjs\">Making Angular Dependencies Injectable to AngularJS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angular-dependencies-injectable-to-angularjs\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"让-angular-的依赖能被注入到-angularjs-中\">让 Angular 的依赖能被注入到 AngularJS 中<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#让-angular-的依赖能被注入到-angularjs-中\"><i class=\"material-icons\">link</i></a></h3>\n<p>In addition to upgrading AngularJS dependencies, you can also <em>downgrade</em> Angular dependencies, so that you can use them from AngularJS.\nThis can be useful when you start migrating services to Angular or creating new services in Angular while retaining components written in AngularJS.</p>\n<p>除了能升级 AngularJS 依赖之外，你还能<em>降级</em>Angular 的依赖，以便在 AngularJS 中使用它们。当你已经开始把服务移植到 Angular 或在 Angular 中创建新服务，但同时还有一些用 AngularJS 写成的组件时，这会非常有用。</p>\n<p>For example, you might have an Angular service called <code>Heroes</code>:</p>\n<p>比如，你可能有一个 Angular 的 <code>Heroes</code> 服务：</p>\n<code-example header=\"heroes.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/heroes.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Heroes {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p>Again, as with Angular components, register the provider with the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> by adding it to the <code>providers</code> list of the module.</p>\n<p>仿照 Angular 组件，把该提供者加入 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>providers</code> 列表中，以注册它。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"ngmodule\">\nimport { Heroes } from './heroes';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  providers: [ Heroes ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p>Now wrap the Angular <code>Heroes</code> in an <em>AngularJS factory function</em> using <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> and plug the factory into an AngularJS module.\nThe name of the AngularJS dependency is up to you:</p>\n<p>现在，用 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> 来把 Angular 的 <code>Heroes</code> 包装成<em>AngularJS 的工厂函数</em>，并把这个工厂注册进 AngularJS 的模块中。依赖在 AngularJS 中的名字你可以自己定：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"register\">\nimport { Heroes } from './heroes';\n/* . . . */\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('heroApp', [])\n  .factory('heroes', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Heroes))\n  .component('heroDetail', heroDetailComponent);\n\n</code-example>\n<p>After this, the service is injectable anywhere in AngularJS code:</p>\n<p>此后，该服务就能被注入到 AngularJS 代码中的任何地方了：</p>\n<code-example header=\"hero-detail.component.ts\" path=\"upgrade-module/src/app/a-to-ajs-providers/hero-detail.component.ts\">\nexport const heroDetailComponent = {\n  template: `\n    &#x3C;h2>{{$ctrl.hero.id}}: {{$ctrl.hero.name}}&#x3C;/h2>\n  `,\n  controller: ['heroes', function(heroes: Heroes) {\n    this.hero = heroes.get()[0];\n  }]\n};\n\n\n</code-example>\n<h2 id=\"lazy-loading-angularjs\">Lazy Loading AngularJS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#lazy-loading-angularjs\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"惰性加载-angularjs\">惰性加载 AngularJS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#惰性加载-angularjs\"><i class=\"material-icons\">link</i></a></h2>\n<p>When building applications, you want to ensure that only the required resources are loaded when necessary.\nWhether that be loading of assets or code, making sure everything that can be deferred until needed keeps your application running efficiently.\nThis is especially true when running different frameworks in the same application.</p>\n<p>在构建应用时，你需要确保只在必要的时候才加载所需的资源，无论是加载静态资产（Asset）还是代码。要确保任何事都尽量推迟到必要时才去做，以便让应用更高效的运行。当要在同一个应用中运行不同的框架时，更是如此。</p>\n<p><a href=\"guide/glossary#lazy-loading\" title=\"lazy loading - Glossary | Angular\">Lazy loading</a> is a technique that defers the loading of required assets and code resources until they are actually used.\nThis reduces startup time and increases efficiency, especially when running different frameworks in the same application.</p>\n<p><a href=\"guide/glossary#lazy-loading\" title=\"lazy loading - Glossary | Angular\">惰性加载</a>是一项技术，它会推迟到使用时才加载所需静态资产和代码资源。这可以减少启动时间、提高效率，特别是要在同一个应用中运行不同的框架时。</p>\n<p>When migrating large applications from AngularJS to Angular using a hybrid approach, you want to migrate some of the most commonly used features first, and only use the less commonly used features if needed.\nDoing so helps you ensure that the application is still providing a seamless experience for your users while you are migrating.</p>\n<p>当你采用混合式应用的方式将大型应用从 AngularJS 迁移到 Angular 时，你首先要迁移一些最常用的特性，并且只在必要的时候才使用那些不太常用的特性。这样做有助于确保应用程序在迁移过程中仍然能为用户提供无缝的体验。</p>\n<p>In most environments where both Angular and AngularJS are used to render the application, both frameworks are loaded in the initial bundle being sent to the client.\nThis results in both increased bundle size and possible reduced performance.</p>\n<p>在大多数需要同时用 Angular 和 AngularJS 渲染应用的环境中，这两个框架都会包含在发送给客户端的初始发布包中。这会导致发布包的体积增大、性能降低。</p>\n<p>Overall application performance is affected in cases where the user stays on Angular-rendered pages because the AngularJS framework and application are still loaded and running, even if they are never accessed.</p>\n<p>当用户停留在由 Angular 渲染的页面上时，应用的整体性能也会受到影响。这是因为 AngularJS 的框架和应用仍然被加载并运行了 —— 即使它们从未被访问过。</p>\n<p>You can take steps to mitigate both bundle size and performance issues.\nBy isolating your AngularJS application to a separate bundle, you can take advantage of <a href=\"guide/glossary#lazy-loading\" title=\"lazy loading - Glossary | Angular\">lazy loading</a> to load, bootstrap, and render the AngularJS application only when needed.\nThis strategy reduces your initial bundle size, defers any potential impact from loading both frameworks until absolutely necessary, and keeps your application running as efficiently as possible.</p>\n<p>你可以采取一些措施来缓解这些包的大小和性能问题。通过把 AngularJS 应用程序分离到一个单独的发布包中，你就可以利用<a href=\"guide/glossary#lazy-loading\" title=\"lazy loading - Glossary | Angular\">惰性加载</a>技术来只在必要的时候才加载、引导和渲染这个 AngularJS 应用。这种策略减少了你的初始发布包大小，推迟了同时加载两个框架的潜在影响 —— 直到绝对必要时才加载，以便让你的应用尽可能高效地运行。</p>\n<p>The steps below show you how to do the following:</p>\n<p>下面的步骤介绍了应该如何去做：</p>\n<ul>\n<li>\n<p>Setup a callback function for your AngularJS bundle.</p>\n<p>为 AngularJS 发布包设置一个回调函数。</p>\n</li>\n<li>\n<p>Create a service that lazy loads and bootstraps your AngularJS app.</p>\n<p>创建一个服务，以便惰性加载并引导你的 AngularJS 应用。</p>\n</li>\n<li>\n<p>Create a routable component for AngularJS content</p>\n<p>为 AngularJS 内容创建一个可路由的组件</p>\n</li>\n<li>\n<p>Create a custom <code>matcher</code> function for AngularJS-specific URLs and configure the Angular <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> with the custom matcher for AngularJS routes.</p>\n<p>为 AngularJS 特有的 URL 创建自定义的 <code>matcher</code> 函数，并为 AngularJS 的各个路由配上带有自定义匹配器的 Angular 路由器。</p>\n</li>\n</ul>\n<h3 id=\"create-a-service-to-lazy-load-angularjs\">Create a service to lazy load AngularJS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-a-service-to-lazy-load-angularjs\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"为惰性加载-angularjs-创建一个服务\">为惰性加载 AngularJS 创建一个服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#为惰性加载-angularjs-创建一个服务\"><i class=\"material-icons\">link</i></a></h3>\n<p>As of Angular version 8, lazy loading code can be accomplished by using the dynamic import syntax <code>import('...')</code>.\nIn your application, you create a new service that uses dynamic imports to lazy load AngularJS.</p>\n<p>在 Angular 的版本 8 中，惰性加载代码只需使用动态导入语法 <code>import('...')</code> 即可。在这个应用中，你创建了一个新服务，它使用动态导入技术来惰性加载 AngularJS。</p>\n<code-example header=\"src/app/lazy-loader.service.ts\" path=\"upgrade-lazy-load-ajs/src/app/lazy-loader.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport * as angular from 'angular';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root'\n})\nexport class LazyLoaderService {\n  private app: angular.auto.IInjectorService | undefined;\n\n  load(el: HTMLElement): void {\n    import('./angularjs-app').then(app => {\n      try {\n        this.app = app.bootstrap(el);\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n\n  destroy() {\n    if (this.app) {\n      this.app.get('$rootScope').$destroy();\n    }\n  }\n}\n\n\n</code-example>\n<p>The service uses the <code>import()</code> method to load your bundled AngularJS application lazily.\nThis decreases the initial bundle size of your application as you're not loading code your user doesn't need yet.\nYou also need to provide a way to <em>bootstrap</em> the application manually after it has been loaded.\nAngularJS provides a way to manually bootstrap an application using the <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\">angular.bootstrap()</a> method with a provided HTML element.\nYour AngularJS application should also expose a <code>bootstrap</code> method that bootstraps the AngularJS app.</p>\n<p>该服务使用 <code>import()</code> 方法惰性加载打包好的 AngularJS 应用。这会减少应用初始包的大小，因为你尚未加载用户目前不需要的代码。你还要提供一种方法，在加载完毕后手动<em>启动</em>它。AngularJS 提供了一种使用 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\" title=\"angular.bootstrap | API | AngularJS\">angular.bootstrap()</a> 方法并传入一个 HTML 元素来手动引导应用的方法。你的 AngularJS 应用也应该公开一个用来引导 AngularJS 应用的 <code>bootstrap</code> 方法。</p>\n<p>To ensure any necessary teardown is triggered in the AngularJS app, such as removal of global listeners, you also implement a method to call the <code>$rootScope.destroy()</code> method.</p>\n<p>要确保 AngularJS 应用中的任何清理工作都触发过（比如移除全局监听器），你还可以实现一个方法来调用 <code>$rootScope.destroy()</code> 方法。</p>\n<code-example header=\"angularjs-app\" path=\"upgrade-lazy-load-ajs/src/app/angularjs-app/index.ts\">\nimport * as angular from 'angular';\nimport 'angular-route';\n\nconst appModule = angular.module('myApp', [\n  'ngRoute'\n])\n.config(['$routeProvider', '$locationProvider',\n  function config($routeProvider: angular.route.IRouteProvider,\n                  $locationProvider: angular.ILocationProvider) {\n    $locationProvider.html5Mode(true);\n\n    $routeProvider.\n      when('/users', {\n        template: `\n          &#x3C;p>\n            Users Page\n          &#x3C;/p>\n        `\n      }).\n      otherwise({\n        template: ''\n      });\n  }]\n);\n\nexport function bootstrap(el: HTMLElement) {\n  return angular.bootstrap(el,  [appModule.name]);\n}\n\n\n</code-example>\n<p>Your AngularJS application is configured with only the routes it needs to render content.\nThe remaining routes in your application are handled by the Angular Router.\nThe exposed <code>bootstrap</code> method is called in your Angular application to bootstrap the AngularJS application after the bundle is loaded.</p>\n<p>你的 AngularJS 应用只配置了渲染内容所需的那部分路由。而 Angular 路由器会处理应用中其余的路由。你的 Angular 应用中会调用公开的 <code>bootstrap</code> 方法，让它在加载完发布包之后引导 AngularJS 应用。</p>\n<div class=\"alert is-important\">\n<p><strong>NOTE</strong>: <br>\nAfter AngularJS is loaded and bootstrapped, listeners such as those wired up in your route configuration will continue to listen for route changes.\nTo ensure listeners are shut down when AngularJS isn't being displayed, configure an <code>otherwise</code> option with the <a href=\"https://docs.angularjs.org/api/ngRoute/provider/$routeProvider\" title=\"$routeProvider | API | AngularJS\">$routeProvider</a> that renders an empty template.\nThis assumes all other routes will be handled by Angular.</p>\n<p><strong>注意：</strong>当 AngularJS 加载并引导完毕后，监听器（比如路由配置中的那些监听器）会继续监听路由的变化。为了确保当 AngularJS 尚未显示时先关闭监听器，请在 <a href=\"https://docs.angularjs.org/api/ngRoute/provider/$routeProvider\" title=\"$routeProvider | API | AngularJS\">$routeProvider</a> 中配置一个渲染空模板 <code>otherwise</code> 选项。这里假设 Angular 将处理所有其它路由。</p>\n</div>\n<h3 id=\"create-a-component-to-render-angularjs-content\">Create a component to render AngularJS content<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-a-component-to-render-angularjs-content\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"创建一个用来渲染-angularjs-内容的组件\">创建一个用来渲染 AngularJS 内容的组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#创建一个用来渲染-angularjs-内容的组件\"><i class=\"material-icons\">link</i></a></h3>\n<p>In your Angular application, you need a component as a placeholder for your AngularJS content.\nThis component uses the service you create to load and bootstrap your AngularJS application after the component is initialized.</p>\n<p>在 Angular 应用中，你需要一个组件作为 AngularJS 内容的占位符。该组件使用你创建的服务，并在组件初始化完成后加载并引导你的 AngularJS 应用。</p>\n<code-example header=\"src/app/angular-js/angular-js.component.ts\" path=\"upgrade-lazy-load-ajs/src/app/angular-js/angular-js.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\nimport { LazyLoaderService } from '../lazy-loader.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-angular-js',\n  template: '&#x3C;div ng-view>&#x3C;/div>'\n})\nexport class AngularJSComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n  constructor(\n    private lazyLoader: LazyLoaderService,\n    private elRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>\n  ) {}\n\n  ngOnInit() {\n    this.lazyLoader.load(this.elRef.nativeElement);\n  }\n\n\n  ngOnDestroy() {\n    this.lazyLoader.destroy();\n  }\n}\n\n\n</code-example>\n<p>When the Angular Router matches a route that uses AngularJS, the <code>AngularJSComponent</code> is rendered, and the content is rendered within the AngularJS <a href=\"https://docs.angularjs.org/api/ngRoute/directive/ngView\" title=\"ngView | API | AngularJS\"><code>ng-view</code></a> directive.\nWhen the user navigates away from the route, the <code>$rootScope</code> is destroyed on the AngularJS application.</p>\n<p>当 Angular 的路由器匹配到使用 AngularJS 的路由时，会渲染 <code>AngularJSComponent</code>，并在 AngularJS 的 <a href=\"https://docs.angularjs.org/api/ngRoute/directive/ngView\" title=\"ngView | API | AngularJS\"><code>ng-view</code></a> 指令中渲染内容。当用户导航离开本路由时，<code>$rootScope</code> 会在 AngularJS 应用中被销毁。</p>\n<h3 id=\"configure-a-custom-route-matcher-for-angularjs-routes\">Configure a custom route matcher for AngularJS routes<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#configure-a-custom-route-matcher-for-angularjs-routes\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"为那些-angularjs-路由配置自定义路由匹配器\">为那些 AngularJS 路由配置自定义路由匹配器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#为那些-angularjs-路由配置自定义路由匹配器\"><i class=\"material-icons\">link</i></a></h3>\n<p>To configure the Angular Router, you must define a route for AngularJS URLs.\nTo match those URLs, you add a route configuration that uses the <code>matcher</code> property.\nThe <code>matcher</code> allows you to use custom pattern matching for URL paths.\nThe Angular Router tries to match on more specific routes such as static and variable routes first.\nWhen it doesn't find a match, it then looks at custom matchers defined in your route configuration.\nIf the custom matchers don't match a route, it then goes to catch-all routes, such as a 404 page.</p>\n<p>为了配置 Angular 的路由器，你必须为 AngularJS 的 URL 定义路由。要匹配这些 URL，你需要添加一个使用 <code>matcher</code> 属性的路由配置。这个 <code>matcher</code> 允许你使用自定义模式来匹配这些 URL 路径。Angular 的路由器会首先尝试匹配更具体的路由，比如静态路由和可变路由。当它找不到匹配项时，就会求助于路由配置中的自定义匹配器。如果自定义匹配器与某个路由不匹配，它就会转到用于 \"捕获所有\"（catch-all）的路由，比如 404 页面。</p>\n<p>The following example defines a custom matcher function for AngularJS routes.</p>\n<p>下面的例子给 AngularJS 路由定义了一个自定义匹配器函数。</p>\n<code-example header=\"src/app/app-routing.module.ts\" path=\"upgrade-lazy-load-ajs/src/app/app-routing.module.ts\" region=\"matcher\">\nexport function isAngularJSUrl(url: <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a>[]) {\n  return url.length > 0 &#x26;&#x26; url[0].path.startsWith('users') ? ({consumed: url}) : null;\n}\n\n</code-example>\n<p>The following code adds a route object to your routing configuration using the <code>matcher</code> property and custom matcher, and the <code>component</code> property with <code>AngularJSComponent</code>.</p>\n<p>下列代码往你的路由配置中添加了一个路由对象，其 <code>matcher</code> 属性是这个自定义匹配器，而 <code>component</code> 属性为 <code>AngularJSComponent</code>。</p>\n<code-example header=\"src/app/app-routing.module.ts\" path=\"upgrade-lazy-load-ajs/src/app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a> } from '@angular/router';\nimport { AngularJSComponent } from './angular-js/angular-js.component';\nimport { HomeComponent } from './home/home.component';\nimport { App404Component } from './app404/app404.component';\n\n// Match any URL that starts with `users`\nexport function isAngularJSUrl(url: <a href=\"api/router/UrlSegment\" class=\"code-anchor\">UrlSegment</a>[]) {\n  return url.length > 0 &#x26;&#x26; url[0].path.startsWith('users') ? ({consumed: url}) : null;\n}\n\nexport const routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  // <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> rendered by Angular\n  { path: '', component: HomeComponent },\n\n  // AngularJS routes\n  { matcher: isAngularJSUrl, component: AngularJSComponent },\n\n  // Catch-all route\n  { path: '**', component: App404Component }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p>When your application matches a route that needs AngularJS, the AngularJS application is loaded and bootstrapped, the AngularJS routes match the necessary URL to render their content, and your application continues to run with both AngularJS and Angular frameworks.</p>\n<p>当你的应用匹配上需要 AngularJS 的路由时，AngularJS 应用就会被加载并引导。AngularJS 路由会匹配必要的 URL 以渲染它们的内容，而接下来你的应用就会同时运行 AngularJS 和 Angular 框架。</p>\n<h2 id=\"using-the-unified-angular-location-service\">Using the Unified Angular Location Service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-the-unified-angular-location-service\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"使用统一的-angular-位置服务location\">使用统一的 Angular 位置服务（Location）<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#使用统一的-angular-位置服务location\"><i class=\"material-icons\">link</i></a></h2>\n<p>In AngularJS, the <a href=\"https://docs.angularjs.org/api/ng/service/$location\" title=\"$location | API | AngularJS\">$location service</a> handles all routing configuration and navigation, encoding and decoding of URLS, redirects, and interactions with browser APIs.\nAngular uses its own underlying <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code> service for all of these tasks.</p>\n<p>在 AngularJS 中，<a href=\"https://docs.angularjs.org/api/ng/service/$location\" title=\"$location | API | AngularJS\">$location 服务</a>会处理所有路由配置和导航工作，并对各个 URL 进行编码和解码、重定向、以及与浏览器 API 交互。Angular 在所有这些任务中都使用了自己的底层服务 <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code>。</p>\n<p>When you migrate from AngularJS to Angular you will want to move as much responsibility as possible to Angular, so that you can take advantage of new APIs.\nTo help with the transition, Angular provides the <code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>.\nThis module enables a <em>unified</em> location service that shifts responsibilities from the AngularJS <code>$location</code> service to the Angular <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code> service.</p>\n<p>当你从 AngularJS 迁移到 Angular 时，你会希望把尽可能多的责任移交给 Angular，以便利用新的 API。为了帮你完成这种转换，Angular 提供了 <code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>。该模块支持<em>统一</em>位置服务，可以把 AngularJS 中 <code>$location</code> 服务的职责转给 Angular 的 <code><a href=\"api/common/Location\" class=\"code-anchor\">Location</a></code> 服务。</p>\n<p>To use the <code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>, import the symbol from <code>@angular/common/upgrade</code> and add it to your <code>AppModule</code> imports using the static <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> method.</p>\n<p>要使用 <code><a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a></code>，就会从 <code>@angular/common/upgrade</code> 中导入此符号，并使用静态方法 <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 把它添加到你的 <code>AppModule</code> 导入表（<code>imports</code>）中。</p>\n<code-example language=\"typescript\">\n\n// Other imports …\nimport { <a href=\"api/common/upgrade/LocationUpgradeModule\" class=\"code-anchor\">LocationUpgradeModule</a> } from '@angular/common/upgrade';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    // Other <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> imports…\n    LocationUpgradeModule.config()\n  ]\n})\nexport class AppModule {}\n\n</code-example>\n<p>The <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> method accepts a configuration object that allows you to configure options including the <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code> with the <code>useHash</code> property, and the URL prefix with the <code>hashPrefix</code> property.</p>\n<p><code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 方法接受一个配置对象，该对象的 <code>useHash</code> 为 <code><a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a></code>，<code>hashPrefix</code> 为 URL 前缀。</p>\n<p>The <code>useHash</code> property defaults to <code>false</code>, and the <code>hashPrefix</code> defaults to an empty <code>string</code>.\nPass the configuration object to override the defaults.</p>\n<p><code>useHash</code> 属性默认为 <code>false</code>，而 <code>hashPrefix</code> 默认为空 <code>string</code>。传递配置对象可以覆盖默认值。</p>\n<code-example language=\"typescript\">\n\nLocationUpgradeModule.config({\n  useHash: true,\n  hashPrefix: '!'\n})\n\n</code-example>\n<div class=\"alert is-important\">\n<p><strong>NOTE</strong>: <br>\nSee the <code><a href=\"api/common/upgrade/LocationUpgradeConfig\" class=\"code-anchor\">LocationUpgradeConfig</a></code> for more configuration options available to the <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> method.</p>\n<p><strong>注意：</strong>关于 <code><a href=\"api/common/upgrade/LocationUpgradeModule#config\" class=\"code-anchor\">LocationUpgradeModule.config()</a></code> 方法的更多可用配置项，请参阅 <code><a href=\"api/common/upgrade/LocationUpgradeConfig\" class=\"code-anchor\">LocationUpgradeConfig</a></code>。</p>\n</div>\n<p>This registers a drop-in replacement for the <code>$location</code> provider in AngularJS.\nOnce registered, all navigation, routing broadcast messages, and any necessary digest cycles in AngularJS triggered during navigation are handled by Angular.\nThis gives you a single way to navigate within both sides of your hybrid application consistently.</p>\n<p>这会为 AngularJS 中的 <code>$location</code> 提供者注册一个替代品。一旦注册成功，导航过程中所有由 AngularJS 触发的导航、路由广播消息以及任何必需的变更检测周期都会改由 Angular 进行处理。这样，你就可以通过这个唯一的途径在此混合应用的两个框架间进行导航了。</p>\n<p>For usage of the <code>$location</code> service as a provider in AngularJS, you need to downgrade the <code><a href=\"api/common/upgrade/$locationShim\" class=\"code-anchor\">$locationShim</a></code> using a factory provider.</p>\n<p>要想在 AngularJS 中使用 <code>$location</code> 服务作为提供者，你需要使用一个工厂提供者来降级 <code><a href=\"api/common/upgrade/$locationShim\" class=\"code-anchor\">$locationShim</a></code>。</p>\n<code-example language=\"typescript\">\n\n// Other imports …\nimport { $locationShim } from '@angular/common/upgrade';\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('myHybridApp', […])\n  .factory('$location', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>($locationShim));\n\n</code-example>\n<p>Once you introduce the Angular Router, using the Angular Router triggers navigations through the unified location service, still providing a single source for navigating with AngularJS and Angular.</p>\n<p>一旦引入了 Angular 路由器，你只要使用 Angular 路由器就可以通过统一位置服务来触发导航了，同时，你仍然可以通过 AngularJS 和 Angular 进行导航。</p>\n<!--TODO:\n\nCorrectly document how to use AOT with SystemJS-based `ngUpgrade` apps (or better yet update the `ngUpgrade` examples/guides to use `@angular/cli`).\nSee [https://github.com/angular/angular/issues/35989][GithubAngularAngularIssues35989].\n\n## Using Ahead-of-time compilation with hybrid apps\n\n## 使用混合式应用进行预先编译\n\nYou can take advantage of Ahead-of-time (AOT) compilation on hybrid apps just like on any other Angular application.\nThe setup for a hybrid app is mostly the same as described in the [Ahead-of-time Compilation chapter][AioGuideAotCompiler] save for differences in `index.html` and `main-aot.ts`\n\n你可以像在任何其他 Angular 应用程序上一样在混合应用程序上利用 Ahead-of-time (AOT) 编译。混合应用程序的设置与[提前编译章节][AioGuideAotCompiler]中描述的基本相同，只是 `index.html` 和 `main-aot.ts` 有所不同\n\nThe `index.html` will likely have script tags loading AngularJS files, so the `index.html` for AOT must also load those files.\nAn easy way to copy them is by adding each to the `copy-dist-files.js` file.\n\n`index.html` 可能会有加载 AngularJS 文件的 script 标签，因此 AOT 的 `index.html` 也必须加载这些文件。复制它们的一种简单方法是将每个都添加到 `copy-dist-files.js` 文件中。\n\nYou'll need to use the generated `AppModuleFactory`, instead of the original `AppModule` to bootstrap the hybrid app:\n\n你需要使用生成的 `AppModuleFactory`，而不是原始的 `AppModule` 来引导混合应用程序：\n\n<code-example header=\"app/main-aot.ts\" path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\">\nimport { platformBrowser } from &#39;@angular/platform-browser&#39;;\n\nimport { AppModule } from &#39;./app.module&#39;;\n\nplatformBrowser().bootstrapModule(AppModule);\n\n\n</code-example>\n\nAnd that s all you need do to get the full benefit of AOT for Angular apps!\n\n这就是你要充分利用 AOT for Angular 应用程序的全部优势！\n\n-->\n<h2 id=\"phonecat-upgrade-tutorial\">PhoneCat Upgrade Tutorial<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#phonecat-upgrade-tutorial\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"phonecat-升级教程\">PhoneCat 升级教程<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#phonecat-升级教程\"><i class=\"material-icons\">link</i></a></h2>\n<p>In this section, you'll learn to prepare and upgrade an application with <code>ngUpgrade</code>.\nThe example application is <a href=\"https://github.com/angular/angular-phonecat\" title=\"angular/angular-phonecat | GitHub\">Angular PhoneCat</a> from <a href=\"https://docs.angularjs.org/tutorial\" title=\"PhoneCat Tutorial App | Tutorial | AngularJS\">the original AngularJS tutorial</a>, which is where many of us began our Angular adventures.\nNow you'll see how to bring that application to the brave new world of Angular.</p>\n<p>在本节和下节中，你将看一个完整的例子，它使用 <code>upgrade</code> 模块准备和升级了一个应用程序。\n该应用就是来自<a href=\"https://docs.angularjs.org/tutorial\" title=\"PhoneCat Tutorial App | Tutorial | AngularJS\">原 AngularJS 教程</a>中的<a href=\"https://github.com/angular/angular-phonecat\" title=\"angular/angular-phonecat | GitHub\">Angular PhoneCat</a>。\n那是我们很多人当初开始 Angular 探险之旅的地方。\n现在，你会看到如何把该应用带入 Angular 的美丽新世界。</p>\n<p>During the process you'll learn how to apply the steps outlined in the <a href=\"guide/upgrade#preparation\" title=\"Preparation - Upgrading from AngularJS to Angular | Angular\">preparation guide</a>.\nYou'll align the application with Angular and also start writing in TypeScript.</p>\n<p>这期间，你将学到如何在实践中应用<a href=\"guide/upgrade#preparation\" title=\"Preparation - Upgrading from AngularJS to Angular | Angular\">准备指南</a>中列出的那些重点步骤。\n你要先让该应用向 Angular 看齐，并开始写 TypeScript。</p>\n<p>This tutorial is based on the 1.5.x version of the <code>angular-phonecat</code> tutorial, which is preserved in the <a href=\"https://github.com/angular/angular-phonecat/commits/1.5-snapshot\" title=\"angular/angular-phonecat v1.5 | GitHub\">1.5-snapshot</a> branch of the repository.\nTo follow along, clone the <a href=\"https://github.com/angular/angular-phonecat\" title=\"angular/angular-phonecat | GitHub\">angular-phonecat</a> repository, check out the <code>1.5-snapshot</code> branch and apply the steps as you go.</p>\n<p>本教程基于 <code>angular-phonecat</code> 教程的 1.5.x 版本，该教程保存在代码仓库的 <a href=\"https://github.com/angular/angular-phonecat/commits/1.5-snapshot\" title=\"angular/angular-phonecat v1.5 | GitHub\">1.5-snapshot</a> 分支中。接下来，克隆 <a href=\"https://github.com/angular/angular-phonecat\" title=\"angular/angular-phonecat | GitHub\">angular-phonecat</a> 代码仓库，check out <code>1.5-snapshot</code> 分支并应用这些步骤。</p>\n<p>In terms of project structure, this is where the work begins:</p>\n<p>在项目结构方面，工作的起点是这样的：</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    angular-phonecat\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      bower.json\n    </div>\n    <div class=\"file\">\n      karma.conf.js\n    </div>\n    <div class=\"file\">\n      package.json\n    </div>\n    <div class=\"file\">\n      app\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        core\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          checkmark\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            checkmark.filter.js\n          </div>\n          <div class=\"file\">\n            checkmark.filter.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          phone\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            phone.module.js\n          </div>\n          <div class=\"file\">\n            phone.service.js\n          </div>\n          <div class=\"file\">\n            phone.service.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          core.module.js\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-detail\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-detail.component.js\n        </div>\n        <div class=\"file\">\n          phone-detail.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-detail.module.js\n        </div>\n        <div class=\"file\">\n          phone-detail.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-list\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-list.component.js\n        </div>\n        <div class=\"file\">\n          phone-list.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-list.module.js\n        </div>\n        <div class=\"file\">\n          phone-list.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        img\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           …\n        </div>\n      </div>\n      <div class=\"file\">\n        phones\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           …\n        </div>\n      </div>\n      <div class=\"file\">\n        app.animations.js\n      </div>\n      <div class=\"file\">\n        app.config.js\n      </div>\n      <div class=\"file\">\n        app.css\n      </div>\n      <div class=\"file\">\n        app.module.js\n      </div>\n      <div class=\"file\">\n        index.html\n      </div>\n    </div>\n    <div class=\"file\">\n      e2e-tests\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        protractor-conf.js\n      </div>\n      <div class=\"file\">\n        scenarios.js\n      </div>\n    </div>\n  </div>\n</div>\n<p>This is actually a pretty good starting point.\nThe code uses the AngularJS 1.5 component API and the organization follows the <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\" title=\"Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">AngularJS Style Guide</a>, which is an important <a href=\"guide/upgrade#follow-the-angularjs-style-guide\" title=\"Follow the AngularJS Style Guide - Upgrading from AngularJS to Angular | Angular\">preparation step</a> before a successful upgrade.</p>\n<p>这确实是一个很好地起点。这些代码使用了 AngularJS 1.5 的组件 API，并遵循了 <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\" title=\"Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">AngularJS 风格指南</a>进行组织，\n在成功升级之前，这是一个很重要的<a href=\"guide/upgrade#follow-the-angularjs-style-guide\" title=\"Follow the AngularJS Style Guide - Upgrading from AngularJS to Angular | Angular\">准备步骤</a>。</p>\n<ul>\n<li>\n<p>Each component, service, and filter is in its own source file, as per the <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\" title=\"Single Responsibility - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Rule of 1</a>.</p>\n<p>每个组件、服务和过滤器都在它自己的源文件中 —— 就像<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\" title=\"Single Responsibility - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">单一规则</a>所要求的。</p>\n</li>\n<li>\n<p>The <code>core</code>, <code>phone-detail</code>, and <code>phone-list</code> modules are each in their own subdirectory.\nThose subdirectories contain the JavaScript code as well as the HTML templates that go with each particular feature.\nThis is in line with the <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\" title=\"Folders-by-Feature Structure - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Folders-by-Feature Structure</a> and <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\" title=\"Modularity - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Modularity</a> rules.</p>\n<p><code>core</code>、<code>phone-detail</code> 和 <code>phone-list</code> 模块都在它们自己的子目录中。那些子目录除了包含 HTML 模板之外，还包含 JavaScript 代码，它们共同完成一个特性。\n这是<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\" title=\"Folders-by-Feature Structure - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">按特性分目录的结构</a>\n和<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\" title=\"Modularity - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">模块化</a>规则所要求的。</p>\n</li>\n<li>\n<p>Unit tests are located side-by-side with application code where they are easily found, as described in the rules for <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\" title=\"Organizing Tests - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">Organizing Tests</a>.</p>\n<p>单元测试都和应用代码在一起，它们很容易找到。就像规则\n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\" title=\"Organizing Tests - Angular 1 Style Guide | johnpapa/angular-styleguide | GitHub\">组织测试文件</a>中要求的那样。</p>\n</li>\n</ul>\n<h3 id=\"switching-to-typescript\">Switching to TypeScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#switching-to-typescript\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"切换到-typescript\">切换到 TypeScript<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#切换到-typescript\"><i class=\"material-icons\">link</i></a></h3>\n<p>Since you're going to be writing Angular code in TypeScript, it makes sense to bring in the TypeScript compiler even before you begin upgrading.</p>\n<p>因为你将使用 TypeScript 编写 Angular 的代码，所以在开始升级之前，先要把 TypeScript 的编译器设置好。</p>\n<p>You'll also start to gradually phase out the Bower package manager in favor of NPM, installing all new dependencies using NPM, and eventually removing Bower from the project.</p>\n<p>你还将开始逐步淘汰 Bower 包管理器，换成 NPM。后面你将使用 NPM 来安装新的依赖包，并最终从项目中移除 Bower。</p>\n<p>Begin by installing TypeScript to the project.</p>\n<p>先把 TypeScript 包安装到项目中。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm i typescript --save-dev\n\n</code-example>\n<p>Install type definitions for the existing libraries that you're using but that don't come with prepackaged types:\nAngularJS, AngularJS Material, and the Jasmine unit test framework.</p>\n<p>还要为那些没有自带类型信息的库（比如 AngularJS、AngularJS Material 和 Jasmine）安装类型定义文件。</p>\n<p>For the PhoneCat app, we can install the necessary type definitions by running the following command:</p>\n<p>对于 PhoneCat 应用，我们可以运行下列命令来安装必要的类型定义文件：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @types/jasmine @types/angular @types/angular-animate @types/angular-aria @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n\n</code-example>\n<p>If you are using AngularJS Material, you can install the type definitions via:</p>\n<p>如果你正在使用 AngularJS Material，你可以通过下列命令安装其类型定义：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install @types/angular-material --save-dev\n\n</code-example>\n<p>You should also configure the TypeScript compiler with a <code>tsconfig.json</code> in the project directory as described in the <a href=\"guide/typescript-configuration\" title=\"TypeScript configuration | Angular\">TypeScript Configuration</a> guide.\nThe <code>tsconfig.json</code> file tells the TypeScript compiler how to turn your TypeScript files into ES5 code bundled into CommonJS modules.</p>\n<p>你还应该要往项目目录下添加一个 <code>tsconfig.json</code> 文件，\n就像在 <a href=\"guide/typescript-configuration\" title=\"TypeScript configuration | Angular\">TypeScript 配置</a>中讲过的那样。\n<code>tsconfig.json</code> 文件会告诉 TypeScript 编译器如何把 TypeScript 文件转成 ES5 代码，并打包进 CommonJS 模块中。</p>\n<p>Finally, you should add some npm scripts in <code>package.json</code> to compile the TypeScript files to JavaScript (based on the <code>tsconfig.json</code> configuration file):</p>\n<p>最后，你应该把下列 npm 脚本添加到 <code>package.json</code> 中，用于把 TypeScript 文件编译成 JavaScript（根据 <code>tsconfig.json</code> 的配置）：</p>\n<code-example format=\"shell\" language=\"shell\">\n\n\"scripts\": {\n  \"tsc\": \"tsc\",\n  \"tsc:w\": \"tsc -w\",\n  …\n\n</code-example>\n<p>Now launch the TypeScript compiler from the command line in watch mode:</p>\n<p>现在，从命令行中用监视模式启动 TypeScript 编译器：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm run tsc:w\n\n</code-example>\n<p>Keep this process running in the background, watching and recompiling as you make changes.</p>\n<p>让这个进程一直在后台运行，监听任何变化并自动重新编译。</p>\n<p>Next, convert your current JavaScript files into TypeScript.\nSince TypeScript is a super-set of ECMAScript 2015, which in turn is a super-set of ECMAScript 5, you can switch the file extensions from <code>.js</code> to <code>.ts</code> and everything will work just like it did before.\nAs the TypeScript compiler runs, it emits the corresponding <code>.js</code> file for every <code>.ts</code> file and the compiled JavaScript is what actually gets executed.\nIf you start the project HTTP server with <code>npm start</code>, you should see the fully functional application in your browser.</p>\n<p>接下来，把 JavaScript 文件转换成 TypeScript 文件。由于 TypeScript 是 ECMAScript 2015 的一个超集，而 ES2015 又是 ECMAScript 5 的超集，所以你可以简单的把文件的扩展名从 <code>.js</code> 换成 <code>.ts</code>，它们还是会像以前一样工作。由于 TypeScript 编译器仍在运行，它会为每一个 <code>.ts</code> 文件生成对应的 <code>.js</code> 文件，而真正运行的是编译后的 <code>.js</code> 文件。如果你用 <code>npm start</code> 开启了本项目的 HTTP 服务器，你会在浏览器中看到一个功能完好的应用。</p>\n<p>Now that you have TypeScript though, you can start benefiting from some of its features.\nThere is a lot of value the language can provide to AngularJS applications.</p>\n<p>有了 TypeScript，你就可以从它的一些特性中获益了。此语言可以为 AngularJS 应用提供很多价值。</p>\n<p>For one thing, TypeScript is a superset of ES2015.\nAny application that has previously been written in ES5 —like the PhoneCat example has— can with TypeScript start incorporating all of the JavaScript features that are new to ES2015.\nThese include things like <code>let</code>s and <code>const</code>s, arrow functions, default function parameters, and destructuring assignments.</p>\n<p>首先，TypeScript 是一个 ES2015 的超集。任何以前用 ES5 写的程序(就像 PhoneCat 范例)都可以开始通过 TypeScript 纳入那些添加到 ES2015 中的新特性。这包括 <code>let</code>、<code>const</code>、箭头函数、函数默认参数以及解构(destructure)赋值。</p>\n<p>Another thing you can do is start adding <em>type safety</em> to your code.\nThis has actually partially already happened because of the AngularJS typings you installed.\nTypeScript are checking that you are calling AngularJS APIs correctly when you do things like register components to Angular modules.</p>\n<p>你能做的另一件事就是把<em>类型安全</em>添加到代码中。这实际上已经部分完成了，因为你已经安装了 AngularJS 的类型定义。TypeScript 会帮你检查是否正确调用了 AngularJS 的 API，—— 比如往 Angular 模块中注册组件。</p>\n<p>But you can also start adding <em>type annotations</em> to get even more out of type system of TypeScript.\nFor instance, you can annotate the checkmark filter so that it explicitly expects booleans as arguments.\nThis makes it clearer what the filter is supposed to do.</p>\n<p>你还能开始把<em>类型注解</em>添加到自己的代码中，来从 TypeScript 的类型系统中获得更多帮助。比如，你可以给 <code>checkmark</code> 过滤器加上注解，表明它期待一个 <code>boolean</code> 类型的参数。这可以更清楚的表明此过滤器打算做什么。</p>\n<code-example header=\"app/core/checkmark/checkmark.filter.ts\" path=\"upgrade-phonecat-1-typescript/app/core/checkmark/checkmark.filter.ts\">\nangular.\n  module('core').\n  filter('checkmark', () => (input: boolean) => input ? '\\u2713' : '\\u2718');\n\n\n</code-example>\n<p>In the <code>Phone</code> service, you can explicitly annotate the <code>$resource</code> service dependency as an <code>angular.resource.IResourceService</code> - a type defined by the AngularJS typings.</p>\n<p>在 <code>Phone</code> 服务中，你可以明确的把 <code>$resource</code> 服务声明为 <code>angular.resource.IResourceService</code>，一个 AngularJS 类型定义提供的类型。</p>\n<code-example header=\"app/core/phone/phone.service.ts\" path=\"upgrade-phonecat-1-typescript/app/core/phone/phone.service.ts\">\nangular.\n  module('core.phone').\n  factory('Phone', ['$resource',\n    ($resource: angular.resource.IResourceService) =>\n      $resource('phones/:phoneId.json', {}, {\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: {\n          method: 'GET',\n          params: {phoneId: 'phones'},\n          isArray: true\n        }\n      })\n  ]);\n\n\n</code-example>\n<p>You can apply the same trick to the route configuration file of the application in <code>app.config.ts</code>, where you are using the location and route services.\nBy annotating them accordingly TypeScript can verify you're calling their APIs with the correct kinds of arguments.</p>\n<p>你可以在应用的路由配置中使用同样的技巧，那里你用到了 location 和 route 服务。一旦为它们提供了类型信息，TypeScript 就能检查你是否在用类型的正确参数来调用它们了。</p>\n<code-example header=\"app/app.config.ts\" path=\"upgrade-phonecat-1-typescript/app/app.config.ts\">\nangular.\n  module('phonecatApp').\n  config(['$locationProvider', '$routeProvider',\n    function config($locationProvider: angular.ILocationProvider,\n                    $routeProvider: angular.route.IRouteProvider) {\n      $locationProvider.hashPrefix('!');\n\n      $routeProvider.\n        when('/phones', {\n          template: '&#x3C;phone-list>&#x3C;/phone-list>'\n        }).\n        when('/phones/:phoneId', {\n          template: '&#x3C;phone-detail>&#x3C;/phone-detail>'\n        }).\n        otherwise('/phones');\n    }\n  ]);\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>The <a href=\"https://www.npmjs.com/package/@types/angular\" title=\"@types/angular | npm\">AngularJS 1.x type definitions</a> you installed are not officially maintained by the Angular team, but are quite comprehensive.\nIt is possible to make an AngularJS 1.x application fully type-annotated with the help of these definitions.</p>\n<p>你用安装的这个<a href=\"https://www.npmjs.com/package/@types/angular\" title=\"@types/angular | npm\">AngularJS.x 类型定义文件</a>\n并不是由 Angular 开发组维护的，但它也已经足够全面了。借助这些类型定义的帮助，它可以为 AngularJS.x 程序加上全面的类型注解。</p>\n<p>If this is something you wanted to do, it would be a good idea to enable the <code>noImplicitAny</code> configuration option in <code>tsconfig.json</code>.\nThis would cause the TypeScript compiler to display a warning when there is any code that does not yet have type annotations.\nYou could use it as a guide to inform us about how close you are to having a fully annotated project.</p>\n<p>如果你想这么做，就在 <code>tsconfig.json</code> 中启用 <code>noImplicitAny</code> 配置项。这样，如果遇到什么还没有类型注解的代码，TypeScript 编译器就会显示一个警告。你可以用它作为指南，告诉你现在与一个完全类型化的项目距离还有多远。</p>\n</div>\n<p>Another TypeScript feature you can make use of is <em>classes</em>.\nIn particular, you can turn component controllers into classes.\nThat way they'll be a step closer to becoming Angular component classes, which will make life easier once you upgrade.</p>\n<p>你能用的另一个 TypeScript 特性是<em>类</em>。具体来讲，你可以把控制器转换成类。这种方式下，你离成为 Angular 组件类就又近了一步，它会令你的升级之路变得更简单。</p>\n<p>AngularJS expects controllers to be constructor functions.\nThat is exactly what ES2015/TypeScript classes are under the hood, so that means you can just plug in a class as a component controller and AngularJS will happily use it.</p>\n<p>AngularJS 期望控制器是一个构造函数。这实际上就是 ES2015/TypeScript 中的类，这也就意味着只要你把一个类注册为组件控制器，AngularJS 就会愉快的使用它。</p>\n<p>Here is what the new class for the phone list component controller looks like:</p>\n<p>新的“电话列表(phone list)”组件控制器类是这样的：</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-1-typescript/app/phone-list/phone-list.component.ts\">\nclass PhoneListController {\n  phones: any[];\n  orderProp: string;\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['Phone'];\n  constructor(Phone: any) {\n    this.phones = Phone.query();\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<p>What was previously done in the controller function is now done in the class constructor function.\nThe dependency injection annotations are attached to the class using a static property <code>$inject</code>.\nAt runtime this becomes the <code>PhoneListController.$inject</code> property.</p>\n<p>以前在控制器函数中实现的一切，现在都改由类的构造函数来实现了。类型注入注解通过静态属性 <code>$inject</code> 被附加到了类上。在运行时，它们变成了 <code>PhoneListController.$inject</code>。</p>\n<p>The class additionally declares three members:\nThe array of phones, the name of the current sort key, and the search query.\nThese are all things you have already been attaching to the controller but that weren't explicitly declared anywhere.\nThe last one of these isn't actually used in the TypeScript code since it is only referred to in the template, but for the sake of clarity you should define all of the controller members.</p>\n<p>该类还声明了另外三个成员：电话列表、当前排序键的名字和搜索条件。这些东西你以前就加到了控制器上，只是从来没有在任何地方显式定义过它们。最后一个成员从未真正在 TypeScript 代码中用过，因为它只是在模板中被引用过。但为了清晰起见，你还是应该定义出此控制器应有的所有成员。</p>\n<p>In the Phone detail controller, you'll have two members:\nOne for the phone that the user is looking at and another for the URL of the currently displayed image:</p>\n<p>在电话详情控制器中，你有两个成员：一个是用户正在查看的电话，另一个是正在显示的图像：</p>\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.ts\">\nclass PhoneDetailController {\n  phone: any;\n  mainImageUrl: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['$routeParams', 'Phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, Phone: any) {\n    const phoneId = $routeParams.phoneId;\n    this.phone = Phone.get({phoneId}, (phone: any) => {\n      this.setImage(phone.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p>This makes the controller code look a lot more like Angular already.\nYou're all set to actually introduce Angular into the project.</p>\n<p>这已经让你的控制器代码看起来更像 Angular 了。你的准备工作做好了，可以引进 Angular 到项目中了。</p>\n<p>If you had any AngularJS services in the project, those would also be a good candidate for converting to classes, since like controllers, they're also constructor functions.\nBut you only have the <code>Phone</code> factory in this project, and that is a bit special since it is an <code>ngResource</code> factory.\nSo you won't be doing anything to it in the preparation stage.\nYou'll instead turn it directly into an Angular service.</p>\n<p>如果项目中有任何 AngularJS 的服务，它们也是转换成类的优秀候选人，像控制器一样，它们也是构造函数。但是在本项目中，你只有一个 <code>Phone</code> 工厂，这有点特别，因为它是一个 <code>ngResource</code> 工厂。所以你不会在准备阶段中处理它，而是在下一节中直接把它转换成 Angular 服务。</p>\n<h3 id=\"installing-angular\">Installing Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#installing-angular\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"安装-angular\">安装 Angular<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#安装-angular\"><i class=\"material-icons\">link</i></a></h3>\n<p>Having completed the preparation work, get going with the Angular upgrade of PhoneCat.\nYou'll do this incrementally with the help of <a href=\"guide/upgrade#upgrading-with-ngupgrade\" title=\"Upgrading with ngUpgrade - Upgrading from AngularJS to Angular | Angular\">ngUpgrade</a> that comes with Angular.\nBy the time you're done, you'll be able to remove AngularJS from the project completely, but the key is to do this piece by piece without breaking the application.</p>\n<p>准备工作做完了，接下来就开始把 PhoneCat 升级到 Angular。\n你将在 Angular<a href=\"guide/upgrade#upgrading-with-ngupgrade\" title=\"Upgrading with ngUpgrade - Upgrading from AngularJS to Angular | Angular\">升级模块</a>的帮助下增量式的完成此项工作。\n做完这些之后，就能把 AngularJS 从项目中完全移除了，但其中的关键是在不破坏此程序的前提下一小块一小块的完成它。</p>\n<div class=\"alert is-important\">\n<p>The project also contains some animations.\nYou won't upgrade them in this version of the guide.\nTurn to the <a href=\"guide/animations\" title=\"Introduction to Angular animations | Angular\">Angular animations</a> guide to learn about that.</p>\n<p>该项目还包含一些动画，在此指南的当前版本你先不升级它，请到 <a href=\"guide/animations\" title=\"Introduction to Angular animations | Angular\">Angular 动画</a>中进一步学习。</p>\n</div>\n<p>Install Angular into the project, along with the SystemJS module loader.\nTake a look at the results of the <a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">upgrade setup instructions</a> and get the following configurations from there:</p>\n<p>用 SystemJS 模块加载器把 Angular 安装到项目中。\n看看<a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">升级的准备工作</a>中的指南，并从那里获得如下配置：</p>\n<ul>\n<li>\n<p>Add Angular and the other new dependencies to <code>package.json</code></p>\n<p>把 Angular 和其它新依赖添加到 <code>package.json</code> 中</p>\n</li>\n<li>\n<p>The SystemJS configuration file <code>systemjs.config.js</code> to the project root directory.</p>\n<p>把 SystemJS 的配置文件 <code>systemjs.config.js</code> 添加到项目的根目录。</p>\n</li>\n</ul>\n<p>Once these are done, run:</p>\n<p>这些完成之后，就运行：</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm install\n\n</code-example>\n<p>Soon you can load Angular dependencies into the application inside <code>index.html</code>, but first you need to do some directory path adjustments.\nYou'll need to load files from <code>node_modules</code> and the project root instead of from the <code>/app</code> directory as you've been doing to this point.</p>\n<p>很快你就可以通过 <code>index.html</code> 来把 Angular 的依赖快速加载到应用中，但首先，你得做一些目录结构调整。这是因为你正准备从 <code>node_modules</code> 中加载文件，然而目前项目中的每一个文件都是从 <code>/app</code> 目录下加载的。</p>\n<p>Move the <code>app/index.html</code> file to the project root directory.\nThen change the development server root path in <code>package.json</code> to also point to the project root instead of <code>app</code>:</p>\n<p>把 <code>app/index.html</code> 移入项目的根目录，然后把 <code>package.json</code> 中的开发服务器根目录也指向项目的根目录，而不再是 <code>app</code> 目录：</p>\n<code-example language=\"json\">\n\n\"start\": \"http-server ./ -a localhost -p 8000 -c-1\",\n\n</code-example>\n<p>Now you're able to serve everything from the project root to the web browser.\nBut you do <em>not</em> want to have to change all the image and data paths used in the application code to match the development setup.\nFor that reason, you'll add a <code>&#x3C;base></code> tag to <code>index.html</code>, which will cause relative URLs to be resolved back to the <code>/app</code> directory:</p>\n<p>现在，你就能把项目根目录下的每一样东西发给浏览器了。但你<em>不想</em>为了适应开发环境中的设置，被迫修改应用代码中用到的所有图片和数据的路径。因此，你要往 <code>index.html</code> 中添加一个 <code>&#x3C;base></code> 标签，它将导致各种相对路径被解析回 <code>/app</code> 目录：</p>\n<code-example header=\"index.html\" path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"base\">\n&#x3C;base href=\"/app/\">\n\n</code-example>\n<p>Now you can load Angular using SystemJS.\nYou'll add the Angular polyfills and the SystemJS configuration to the end of the <code>&#x3C;head></code> section, and then you'll use <code>System.import</code> to load the actual application:</p>\n<p>现在你可以通过 SystemJS 加载 Angular 了。你还要把 Angular 的腻子脚本(polyfills) 和 SystemJS 的配置加到 <code>&#x3C;head></code> 区的末尾，然后，你能就用 <code>System.import</code> 来加载实际的应用了：</p>\n<code-example header=\"index.html\" path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"angular\">\n&#x3C;script src=\"/node_modules/core-js/client/shim.min.js\">&#x3C;/script>\n&#x3C;script src=\"/node_modules/zone.js/bundles/zone.umd.js\">&#x3C;/script>\n&#x3C;script src=\"/node_modules/systemjs/dist/system.src.js\">&#x3C;/script>\n&#x3C;script src=\"/systemjs.config.js\">&#x3C;/script>\n&#x3C;script>\n  System.import('/app');\n&#x3C;/script>\n\n</code-example>\n<p>You also need to make a couple of adjustments to the <code>systemjs.config.js</code> file installed during <a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">upgrade setup</a>.</p>\n<p>你还需要对<a href=\"guide/upgrade-setup\" title=\"Setup for upgrading from AngularJS | Angular\">升级的准备工作</a>期间安装的 <code>systemjs.config.js</code> 文件做一些调整。</p>\n<p>Point the browser to the project root when loading things through SystemJS, instead of using the <code>&#x3C;base></code> URL.</p>\n<p>在 SystemJS 加载期间为浏览器指出项目的根在哪里，而不再使用 <code>&#x3C;base></code> URL。</p>\n<p>Install the <code>upgrade</code> package using <code>npm install @angular/upgrade --save</code> and add a mapping for the <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> package.</p>\n<p>再通过 <code>npm install @angular/upgrade --save</code> 安装 <code>upgrade</code> 包，并为 <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 包添加一个映射。</p>\n<code-example header=\"systemjs.config.js\" path=\"upgrade-phonecat-2-hybrid/systemjs.config.1.js\" region=\"paths\">\nSystem.config({\n  paths: {\n    // paths serve as alias\n    'npm:': '/node_modules/'\n  },\n  map: {\n    'ng-loader': '../src/systemjs-angular-loader.js',\n    app: '/app',\n    /* . . . */\n    '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/fesm2015/static.mjs',\n    /* . . . */\n  },\n\n</code-example>\n<h3 id=\"creating-the-appmodule\">Creating the <code>AppModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#creating-the-appmodule\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"创建-appmodule\">创建 <code>AppModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#创建-appmodule\"><i class=\"material-icons\">link</i></a></h3>\n<p>Now create the root <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> class called <code>AppModule</code>.\nThere is already a file named <code>app.module.ts</code> that holds the AngularJS module.\nRename it to <code>app.module.ajs.ts</code> and update the corresponding script name in the <code>index.html</code> as well.\nThe file contents remain:</p>\n<p>现在，创建一个名叫 <code>AppModule</code> 的根 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 类。这里已经有了一个名叫 <code>app.module.ts</code> 的文件，其中存放着 AngularJS 的模块。把它改名为 <code>app.module.ajs.ts</code>，同时也要在 <code>index.html</code> 中修改对应的脚本名。文件的内容保留：</p>\n<code-example header=\"app.module.ajs.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ajs.ts\">\n// Define the `phonecatApp` AngularJS module\nangular.module('phonecatApp', [\n  'ngAnimate',\n  'ngRoute',\n  'core',\n  'phoneDetail',\n  'phoneList',\n]);\n\n\n</code-example>\n<p>Now create a new <code>app.module.ts</code> with the minimum <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> class:</p>\n<p>然后创建一个新的 <code>app.module.ts</code> 文件，其中是一个最小化的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 类：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"bare\">\nimport { <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n}\n\n</code-example>\n<h3 id=\"bootstrapping-a-hybrid-phonecat\">Bootstrapping a hybrid PhoneCat<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-a-hybrid-phonecat\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"引导-phonecat-的混合式应用\">引导 PhoneCat 的混合式应用<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#引导-phonecat-的混合式应用\"><i class=\"material-icons\">link</i></a></h3>\n<p>Next, you'll bootstrap the application as a <em>hybrid application</em> that supports both AngularJS and Angular components.\nAfter that, you can start converting the individual pieces to Angular.</p>\n<p>接下来，你把该应用程序引导改装为一个同时支持 AngularJS 和 Angular 的<em>混合式应用</em>。然后，就能开始把这些不可分割的小块转换到 Angular 了。</p>\n<p>The application is currently bootstrapped using the AngularJS <code>ng-app</code> directive attached to the <code>&#x3C;html></code> element of the host page.\nThis will no longer work in the hybrid application.\nSwitch to the <a href=\"guide/upgrade#bootstrapping-hybrid-applications\" title=\"Bootstrapping hybrid applications - Upgrading from AngularJS to Angular | Angular\">ngUpgrade bootstrap</a> method instead.</p>\n<p>本应用现在是使用宿主页面中附加到 <code>&#x3C;html></code> 元素上的 AngularJS 指令 <code>ng-app</code> 引导的。\n但在混合式应用中，不能再这么用了。你得用<a href=\"guide/upgrade#bootstrapping-hybrid-applications\" title=\"Bootstrapping hybrid applications - Upgrading from AngularJS to Angular | Angular\">ngUpgrade bootstrap</a>方法代替。</p>\n<p>First, remove the <code>ng-app</code> attribute from <code>index.html</code>.\nThen import <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> in the <code>AppModule</code>, and override its <code>ngDoBootstrap</code> method:</p>\n<p>首先，从 <code>index.html</code> 中移除 <code>ng-app</code>。然后在 <code>AppModule</code> 中导入 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，并改写它的 <code>ngDoBootstrap</code> 方法：</p>\n<code-example header=\"app/app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"upgrademodule\">\nimport { <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p>You are bootstrapping the AngularJS module from inside <code>ngDoBootstrap</code>.\nThe arguments are the same as you would pass to <code>angular.bootstrap</code> if you were manually bootstrapping AngularJS:\nthe root element of the application; and an array of the AngularJS 1.x modules that you want to load.</p>\n<p>注意，你正在从内部的 <code>ngDoBootstrap</code> 中引导 AngularJS 模块。它的参数和你在手动引导 AngularJS 时传给 <code>angular.bootstrap</code> 的是一样的：应用的根元素，和所要加载的 AngularJS 1.x 模块的数组。</p>\n<p>Finally, bootstrap the <code>AppModule</code> in <code>app/main.ts</code>.\nThis file has been configured as the application entrypoint in <code>systemjs.config.js</code>, so it is already being loaded by the browser.</p>\n<p>最后，在 <code>app/main.ts</code> 中引导这个 <code>AppModule</code>。该文件在 <code>systemjs.config.js</code> 中被配置为了应用的入口，所以它已经被加载进了浏览器中。</p>\n<code-example header=\"app/main.ts\" path=\"upgrade-phonecat-2-hybrid/app/main.ts\" region=\"bootstrap\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n</code-example>\n<p>Now you're running both AngularJS and Angular at the same time.\nThat is pretty exciting!\nYou're not running any actual Angular components yet.\nThat is next.</p>\n<p>现在，你同时运行着 AngularJS 和 Angular。漂亮！不过你还没有运行什么实际的 Angular 组件，这就是接下来要做的。</p>\n<div class=\"callout is-helpful\">\n<header>Why declare *angular* as *angular.IAngularStatic*?</header>\n<header>为何要声明 *angular* 为*angular.IAngularStatic*？</header>\n<p><code>@types/angular</code> is declared as a UMD module, and due to the way <a href=\"https://github.com/Microsoft/TypeScript/wiki/What&#x27;s-new-in-TypeScript#support-for-umd-module-definitions\" title=\"Support for UMD module definitions - What&#x27;s new in TypeScript | microsoft/TypeScript | GitHub\">UMD typings</a> work, once you have an ES6 <code>import</code> statement in a file all UMD typed modules must also be imported using <code>import</code> statements instead of being globally available.</p>\n<p><code>@types/angular</code> 声明为 UMD 模块，根据 <a href=\"https://github.com/Microsoft/TypeScript/wiki/What&#x27;s-new-in-TypeScript#support-for-umd-module-definitions\" title=\"Support for UMD module definitions - What&#x27;s new in TypeScript | microsoft/TypeScript | GitHub\">UMD 类型</a>的工作方式，一旦你在文件中有一条 ES6 的 <code>import</code> 语句，所有的 UMD 类型化的模型必须都通过 <code>import</code> 语句导入，\n而是不是全局可用。</p>\n<p>AngularJS is currently loaded by a script tag in <code>index.html</code>, which means that the whole app has access to it as a global and uses the same instance of the <code>angular</code> variable.\nIf you used <code>import * as angular from 'angular'</code> instead, you'd also have to load every file in the AngularJS application to use ES2015 modules in order to ensure AngularJS was being loaded correctly.</p>\n<p>AngularJS 是日前是通过 <code>index.html</code> 中的 script 标签加载，这意味着整个应用是作为一个全局变量进行访问的，使用同一个 <code>angular</code> 变量的实例。但如果你使用 <code>import * as angular from 'angular'</code>，我还需要彻底修改 AngularJS 应用中加载每个文件的方式，确保 AngularJS 应用被正确加载。</p>\n<p>This is a considerable effort and it often isn't worth it, especially since you are in the process of moving your code to Angular.\nInstead, declare <code>angular</code> as <code>angular.IAngularStatic</code> to indicate it is a global variable and still have full typing support.</p>\n<p>这需要相当多的努力，通常也不值得去做，特别是当你正在朝着 Angular 前进时。但如果你把 <code>angular</code> 声明为 <code>angular.IAngularStatic</code>，指明它是一个全局变量，仍然可以获得全面的类型支持。</p>\n<div class=\"callout is-important\">\n<header>Manually create a UMD bundle for your Angular application</header>\n<header>为 Angular 应用手动创建 UMD 包</header>\n<p>Starting with Angular version 13, the <a href=\"https://github.com/angular/angular/issues/38366\" title=\" Issue 38366: RFC: Ivy Library Distribution| angular/angular | GitHub\">distribution format</a> no longer includes UMD bundles.</p>\n<p>从 Angular 版本 13 开始，<a href=\"https://github.com/angular/angular/issues/38366\" title=\" Issue 38366: RFC: Ivy Library Distribution| angular/angular | GitHub\">分发格式</a> 中不再包含 UMD 包。</p>\n<p>If your use case requires the UMD format, use <a href=\"https://rollupjs.org\" title=\"rollup.js\"><code>rollup</code></a> to manually produce a bundle from the flat ES module files.</p>\n<p>如果你的用例需要 UMD 格式，请使用 <a href=\"https://rollupjs.org\" title=\"rollup.js\"><code>rollup</code></a> 从平面 ES 模块文件手动生成包。</p>\n<ol>\n<li>\n<p>Use <code>npm</code> to globally install <code>rollup</code></p>\n<p>使用 <code>npm</code> 全局安装 <code>rollup</code></p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm i -g rollup\n\nnpm i -g 汇总\n\n</code-example>\n</li>\n<li>\n<p>Output the version of <code>rollup</code> and verify the installation was successful</p>\n<p>输出 <code>rollup</code> 的版本并验证安装是否成功</p>\n<code-example format=\"shell\" language=\"shell\">\n\nrollup -v\n\n</code-example>\n</li>\n<li>\n<p>Create the <code>rollup.config.js</code> configuration file for <code>rollup</code> to use the global <code>ng</code> command to reference all of the Angular framework exports.</p>\n<p>为 <code>rollup</code> 创建 <code>rollup.config.js</code> 配置文件，以使用全局 <code>ng</code> 命令来引用所有 Angular 框架的导出。</p>\n<ol>\n<li>\n<p>Create a file named <code>rollup.config.js</code></p>\n<p>创建一个名为 <code>rollup.config.js</code> 的文件</p>\n</li>\n<li>\n<p>Copy the following content into <code>rollup.config.js</code></p>\n<p>将以下内容复制到 <code>rollup.config.js</code></p>\n<code-example language=\"javascript\">\n\nexport default {\n  input: 'node_modules/@angular/core/fesm2015/core.js',\n  output: {\n    file: 'bundle.js',\n    format: 'umd',\n    name: 'ng'\n  }\n}\n\n</code-example>\n</li>\n</ol>\n</li>\n<li>\n<p>Use <code>rollup</code> to create the <code>bundle.js</code> UMD bundle using settings in <code>rollup.config.js</code></p>\n<p>使用 <code>rollup</code> 根据 <code>rollup.config.js</code> 中的设置创建 <code>bundle.js</code> UMD 包</p>\n<code-example format=\"shell\" language=\"shell\">\n\nrollup -c rollup.config.js\n\n</code-example>\n</li>\n</ol>\n<p>The <code>bundle.js</code> file contains your UMD bundle.\nFor an example on GitHub, see <a href=\"https://github.com/mgechev/angular-umd-bundle\" title=\"UMD Angular bundle | mgechev/angular-umd-bundle | GitHub\">UMD Angular bundle</a>.</p>\n<p><code>bundle.js</code> 文件包含你的 UMD 包。有关 GitHub 上的示例，请参阅 <a href=\"https://github.com/mgechev/angular-umd-bundle\" title=\"UMD Angular bundle | mgechev/angular-umd-bundle | GitHub\">UMD Angular 包</a>。</p>\n</div>\n</div>\n<h3 id=\"upgrading-the-phone-service\">Upgrading the Phone service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-the-phone-service\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"升级-phone-服务\">升级 <code>Phone</code> 服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#升级-phone-服务\"><i class=\"material-icons\">link</i></a></h3>\n<p>The first piece you'll port over to Angular is the <code>Phone</code> service, which resides in <code>app/core/phone/phone.service.ts</code> and makes it possible for components to load phone information from the server.\nRight now it is implemented with ngResource and you're using it for two things:</p>\n<p>你要移植到 Angular 的第一个片段是 <code>Phone</code> 工厂(位于 <code>app/core/phone/phone.service.ts</code>)，并且让它能帮助控制器从服务器上加载电话信息。目前，它是用 <code>ngResource</code> 实现的，你用它做两件事：</p>\n<ul>\n<li>\n<p>For loading the list of all phones into the phone list component</p>\n<p>把所有电话的列表加载到电话列表组件中。</p>\n</li>\n<li>\n<p>For loading the details of a single phone into the phone detail component</p>\n<p>把一台电话的详情加载到电话详情组件中。</p>\n</li>\n</ul>\n<p>You can replace this implementation with an Angular service class, while keeping the controllers in AngularJS land.</p>\n<p>你可以用 Angular 的服务类来替换这个实现，而把控制器继续留在 AngularJS 的地盘上。</p>\n<p>In the new version, you import the Angular HTTP module and call its <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service instead of <code>ngResource</code>.</p>\n<p>在这个新版本中，你导入了 Angular 的 HTTP 模块，并且用它的 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务替换掉 <code>ngResource</code>。</p>\n<p>Re-open the <code>app.module.ts</code> file, import and add <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> to the <code>imports</code> array of the <code>AppModule</code>:</p>\n<p>再次打开 <code>app.module.ts</code> 文件，导入并把 <code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> 添加到 <code>AppModule</code> 的 <code>imports</code> 数组中：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"httpclientmodule\">\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p>Now you're ready to upgrade the Phone service itself.\nReplace the ngResource-based service in <code>phone.service.ts</code> with a TypeScript class decorated as <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code>:</p>\n<p>现在，你已经准备好了升级 <code>Phone</code> 服务本身。你将为 <code>phone.service.ts</code> 文件中基于 ngResource 的服务加上 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 装饰器：</p>\n<code-example header=\"app/core/phone/phone.service.ts (skeleton)\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"classdef\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n/* . . . */\n}\n\n</code-example>\n<p>The <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> decorator will attach some dependency injection metadata to the class, letting Angular know about its dependencies.\nAs described by the <a href=\"guide/dependency-injection\" title=\"Dependency injection in Angular | Angular\">Dependency Injection Guide</a>, this is a marker decorator you need to use for classes that have no other Angular decorators but still need to have their dependencies injected.</p>\n<p><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 装饰器将把一些依赖注入相关的元数据附加到该类上，让 Angular 知道它的依赖信息。\n就像在<a href=\"guide/dependency-injection\" title=\"Dependency injection in Angular | Angular\">依赖注入指南</a>中描述过的那样，\n这是一个令牌装饰器，你要把它用在那些没有其它 Angular 装饰器，并且自己有依赖注入的类上。</p>\n<p>In its constructor the class expects to get the <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> service.\nIt will be injected to it and it is stored as a private field.\nThe service is then used in the two instance methods, one of which loads the list of all phones, and the other loads the details of a specified phone:</p>\n<p>在它的构造函数中，该类期待一个 <code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务。<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务将被注入进来并存入一个私有字段。然后该服务在两个实例方法中被使用到，一个加载所有电话的列表，另一个加载一台指定电话的详情：</p>\n<code-example header=\"app/core/phone/phone.service.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"fullclass\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&#x3C;PhoneData[]> {\n    return this.http.get&#x3C;PhoneData[]>(`phones/phones.json`);\n  }\n  get(id: string): Observable&#x3C;PhoneData> {\n    return this.http.get&#x3C;PhoneData>(`phones/${id}.json`);\n  }\n}\n\n</code-example>\n<p>The methods now return observables of type <code>PhoneData</code> and <code>PhoneData[]</code>.\nThis is a type you don't have yet.\nAdd a simple interface for it:</p>\n<p>该方法现在返回一个 <code>Phone</code> 类型或 <code>Phone[]</code> 类型的可观察对象(Observable)。这是一个你从未用过的类型，因此你得为它新增一个简单的接口：</p>\n<code-example header=\"app/core/phone/phone.service.ts (interface)\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"phonedata-interface\">\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n</code-example>\n<p><code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> has a <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a></code> method for the purpose of making Angular services available to AngularJS code.\nUse it to plug in the <code>Phone</code> service:</p>\n<p><code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> 有一个 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a></code> 方法，可以使 Angular 服务在 AngularJS 的代码中可用。使用它来插入 <code>Phone</code> 服务：</p>\n<code-example header=\"app/core/phone/phone.service.ts (downgrade)\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"downgrade-injectable\">\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n/* . . . */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n/* . . . */\n}\n\nangular.module('core.phone')\n  .factory('phone', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Phone));\n\n</code-example>\n<p>Here is the full, final code for the service:</p>\n<p>最终，该类的全部代码如下：</p>\n<code-example header=\"app/core/phone/phone.service.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\nimport { Observable } from 'rxjs';\n\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n  constructor(private <a href=\"api/common/http\" class=\"code-anchor\">http</a>: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&#x3C;PhoneData[]> {\n    return this.http.get&#x3C;PhoneData[]>(`phones/phones.json`);\n  }\n  get(id: string): Observable&#x3C;PhoneData> {\n    return this.http.get&#x3C;PhoneData>(`phones/${id}.json`);\n  }\n}\n\nangular.module('core.phone')\n  .factory('phone', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Phone));\n\n\n</code-example>\n<p>Notice that you're importing the <code>map</code> operator of the RxJS <code>Observable</code> separately.\nDo this for every RxJS operator.</p>\n<p>注意，你要单独导入了 RxJS <code>Observable</code> 中的 <code>map</code> 操作符。对每个 RxJS 操作符都要这么做。</p>\n<p>The new <code>Phone</code> service has the same features as the original, <code>ngResource</code>-based service.\nBecause it is an Angular service, you register it with the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> providers:</p>\n<p>这个新的 <code>Phone</code> 服务具有和老的基于 <code>ngResource</code> 的服务相同的特性。因为它是 Angular 服务，你通过 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>providers</code> 数组来注册它：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phone\">\nimport { Phone } from './core/phone/phone.service';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n  providers: [\n    Phone,\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p>Now that you are loading <code>phone.service.ts</code> through an import that is resolved by SystemJS, you should <strong>remove the &#x3C;script> tag</strong> for the service from <code>index.html</code>.\nThis is something you'll do to all components as you upgrade them.\nSimultaneously with the AngularJS to Angular upgrade you're also migrating code from scripts to modules.</p>\n<p>现在，你正在用 SystemJS 加载 <code>phone.service.ts</code>，你应该从 <code>index.html</code> 中<strong>移除该服务的 <code>&#x3C;script></code> 标签</strong>。这也是你在升级所有组件时将会做的事。在从 AngularJS 向 Angular 升级的同时，你也把代码从脚本移植为模块。</p>\n<p>At this point, you can switch the two components to use the new service instead of the old one.\nWhile you <code>$inject</code> it as the downgraded <code>phone</code> factory, it is really an instance of the <code>Phone</code> class and you annotate its type accordingly:</p>\n<p>这时，你可以把两个控制器从使用老的服务切换成使用新的。你像降级过的 <code>phone</code> 工厂一样 <code>$inject</code> 它，但它实际上是一个 <code>Phone</code> 类的实例，并且你可以据此注解它的类型：</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ajs.ts\">\ndeclare const angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneListController {\n  phones: PhoneData[];\n  orderProp: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['phone'];\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones => {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'app/phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ajs.ts\">\ndeclare const angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneDetailController {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $inject = ['$routeParams', 'phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, phone: Phone) {\n    const phoneId = $routeParams.phoneId;\n    phone.get(phoneId).subscribe(data => {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p>Now there are two AngularJS components using an Angular service!\nThe components don't need to be aware of this, though the fact that the service returns observables and not promises is a bit of a giveaway.\nIn any case, what you've achieved is a migration of a service to Angular without having to yet migrate the components that use it.</p>\n<p>这里的两个 AngularJS 控制器在使用 Angular 的服务！控制器不需要关心这一点，尽管实际上该服务返回的是可观察对象(Observable)，而不是承诺(Promise)。无论如何，你达到的效果都是把服务移植到 Angular，而不用被迫移植组件来使用它。</p>\n<div class=\"alert is-helpful\">\n<p>You could use the <code>toPromise</code> method of <code>Observable</code> to turn those observables into promises in the service.\nIn many cases that reduce the number of changes to the component controllers.</p>\n<p>你也能使用 <code>Observable</code> 的 <code>toPromise</code> 方法来在服务中把这些可观察对象转变成 Promise ，以进一步减小组件控制器中需要修改的代码量。</p>\n</div>\n<h3 id=\"upgrading-components\">Upgrading Components<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-components\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"升级组件\">升级组件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#升级组件\"><i class=\"material-icons\">link</i></a></h3>\n<p>Upgrade the AngularJS components to Angular components next.\nDo it one component at a time while still keeping the application in hybrid mode.\nAs you make these conversions, you'll also define your first Angular <em>pipes</em>.</p>\n<p>接下来，把 AngularJS 的控制器升级成 Angular 的组件。每次升级一个，同时仍然保持应用运行在混合模式下。在做转换的同时，你还将自定义首个 Angular<em>管道</em>。</p>\n<p>Look at the phone list component first.\nRight now it contains a TypeScript controller class and a component definition object.\nYou can morph this into an Angular component by just renaming the controller class and turning the AngularJS component definition object into an Angular <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> decorator.\nYou can then also remove the static <code>$inject</code> property from the class:</p>\n<p>先看看电话列表组件。它目前包含一个 TypeScript 控制器类和一个组件定义对象。重命名控制器类，并把 AngularJS 的组件定义对象更换为 Angular <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 装饰器，这样你就把它变形为 Angular 的组件了。然后，你还要从类中移除静态 <code>$inject</code> 属性。</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"initialclass\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n  phones: PhoneData[];\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: string;\n  orderProp: string;\n\n  constructor(phone: Phone) {\n    phone.query().subscribe(phones => {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n  /* . . . */\n}\n\n</code-example>\n<p>The <code>selector</code> attribute is a CSS selector that defines where on the page the component should go.\nIn AngularJS you do matching based on component names, but in Angular you have these explicit selectors.\nThis one will match elements with the name <code>phone-list</code>, just like the AngularJS version did.</p>\n<p><code>selector</code> 属性是一个 CSS 选择器，用来定义组件应该被放在页面的哪。在 AngularJS 中，你会基于组件名字来匹配，但是在 Angular 中，你要显式指定这些选择器。本组件将会对应元素名字 <code>phone-list</code>，和 AngularJS 版本一样。</p>\n<p>Now convert the template of this component into Angular syntax.\nThe search controls replace the AngularJS <code>$ctrl</code> expressions with the two-way <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> binding syntax of Angular:</p>\n<p>现在，将组件的模版也转换为 Angular 语法。在搜索控件中，把 AngularJS 的 <code>$ctrl</code> 表达式替换成 Angular 的双向绑定语法 <code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code>：</p>\n<code-example header=\"app/phone-list/phone-list.template.html (search controls)\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"controls\">\n&#x3C;p>\n  Search:\n  &#x3C;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"<a href=\"api/animations/query\" class=\"code-anchor\">query</a>\" />\n&#x3C;/p>\n\n&#x3C;p>\n  Sort by:\n  &#x3C;select [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"orderProp\">\n    &#x3C;option value=\"name\">Alphabetical&#x3C;/option>\n    &#x3C;option value=\"age\">Newest&#x3C;/option>\n  &#x3C;/select>\n&#x3C;/p>\n\n</code-example>\n<p>Replace the <code>ng-repeat</code> of the list with an <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> as <a href=\"guide/built-in-directives\" title=\"Built-in directives | Angular\">described in the Template Syntax page</a>.\nReplace the <code>ng-src</code> of the image tag with a binding to the native <code>src</code> property.</p>\n<p>把列表中的 <code>ng-repeat</code> 替换为 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>，\n就像<a href=\"guide/built-in-directives\" title=\"Built-in directives | Angular\">模板语法指南</a>中所讲的那样。\n再把 <code><a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a></code> 标签的 <code>ng-src</code> 替换为一个标准的 <code>src</code> 属性(property)绑定。</p>\n<code-example header=\"app/phone-list/phone-list.template.html (phones)\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"list\">\n&#x3C;ul class=\"phones\">\n  &#x3C;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\">\n    &#x3C;a href=\"/#!/phones/{{phone.id}}\" class=\"thumb\">\n      &#x3C;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"phone.imageUrl\" [alt]=\"phone.name\" />\n    &#x3C;/a>\n    &#x3C;a href=\"/#!/phones/{{phone.id}}\" class=\"name\">{{phone.name}}&#x3C;/a>\n    &#x3C;p>{{phone.snippet}}&#x3C;/p>\n  &#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<h4 id=\"no-angular-filter-or-orderby-filters\">No Angular <code>filter</code> or <code>orderBy</code> filters<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#no-angular-filter-or-orderby-filters\"><i class=\"material-icons\">link</i></a></h4>\n<h4 id=\"没有-angular-filter-或-orderby-过滤器\">没有 Angular <code>filter</code> 或 <code>orderBy</code> 过滤器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#没有-angular-filter-或-orderby-过滤器\"><i class=\"material-icons\">link</i></a></h4>\n<p>The built-in AngularJS <code>filter</code> and <code>orderBy</code> filters do not exist in Angular, so you need to do the filtering and sorting yourself.</p>\n<p>Angular 中并不存在 AngularJS 中内置的 <code>filter</code> 和 <code>orderBy</code> 过滤器。所以你得自己实现进行过滤和排序。</p>\n<p>You replaced the <code>filter</code> and <code>orderBy</code> filters with bindings to the <code>getPhones()</code> controller method, which implements the filtering and ordering logic inside the component itself.</p>\n<p>你把 <code>filter</code> 和 <code>orderBy</code> 过滤器改成绑定到控制器中的 <code>getPhones()</code> 方法，通过该方法，组件本身实现了过滤和排序逻辑。</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"getphones\">\ngetPhones(): PhoneData[] {\n  return this.sortPhones(this.filterPhones(this.phones));\n}\n\nprivate filterPhones(phones: PhoneData[]) {\n  if (phones &#x26;&#x26; this.query) {\n    return phones.filter(phone => {\n      const name = phone.name.toLowerCase();\n      const snippet = phone.snippet.toLowerCase();\n      return name.indexOf(this.query) >= 0 || snippet.indexOf(this.query) >= 0;\n    });\n  }\n  return phones;\n}\n\nprivate sortPhones(phones: PhoneData[]) {\n  if (phones &#x26;&#x26; this.orderProp) {\n    return phones\n      .slice(0) // Make a copy\n      .sort((a, b) => {\n        if (a[this.orderProp] &#x3C; b[this.orderProp]) {\n          return -1;\n        } else if ([b[this.orderProp] &#x3C; a[this.orderProp]]) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n  }\n  return phones;\n}\n\n</code-example>\n<p>Now you need to downgrade the Angular component so you can use it in AngularJS.\nInstead of registering a component, you register a <code>phoneList</code> <em>directive</em>, a downgraded version of the Angular component.</p>\n<p>现在你需要降级你的 Angular 组件，这样你就可以在 AngularJS 中使用它了。你要注册一个 <code>phoneList</code><em>指令</em>，而不是注册一个组件，它是一个降级版的 Angular 组件。</p>\n<p>The <code>as angular.IDirectiveFactory</code> cast tells the TypeScript compiler that the return value of the <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a></code> method is a directive factory.</p>\n<p>强制类型转换 <code>as angular.IDirectiveFactory</code> 告诉 TypeScript 编译器 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a></code> 方法 的返回值是一个指令工厂。</p>\n<code-example header=\"app/phone-list/phone-list.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"downgrade-component\">\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n/* . . . */\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n  /* . . . */\n}\n\nangular.module('phoneList')\n  .directive(\n    'phoneList',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({component: PhoneListComponent}) as angular.IDirectiveFactory\n  );\n\n</code-example>\n<p>The new <code>PhoneListComponent</code> uses the Angular <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> directive, located in the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>.\nAdd the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> to <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> imports and declare the new <code>PhoneListComponent</code> since you downgraded it:</p>\n<p>新的 <code>PhoneListComponent</code> 使用 Angular 的 <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 指令，它位于 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 中。把 <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 添加到 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>imports</code> 中，并声明新的 <code>PhoneListComponent</code> 组件，因为你降级了它：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonelist\">\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n  ],\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p>Remove the &#x3C;script> tag for the phone list component from <code>index.html</code>.</p>\n<p>从 <code>index.html</code> 中移除电话列表组件的&#x3C;script>标签。</p>\n<p>Now set the remaining <code>phone-detail.component.ts</code> as follows:</p>\n<p>现在，剩下的 <code>phone-detail.component.ts</code> 文件变成了这样：</p>\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ts\">\ndeclare const angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { RouteParams } from '../ajs-upgraded-providers';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html',\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(routeParams: RouteParams, phone: Phone) {\n    phone.get(routeParams.phoneId).subscribe(data => {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.module('phoneDetail')\n  .directive(\n    'phoneDetail',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({component: PhoneDetailComponent}) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<p>This is similar to the phone list component.\nThe new wrinkle is the <code>RouteParams</code> type annotation that identifies the <code>routeParams</code> dependency.</p>\n<p>这和电话列表组件很相似。这里的窍门在于 <code>RouteParams</code> 类型装饰器，它标记出了 <code>routeParams</code> 依赖项。</p>\n<p>The AngularJS injector has an AngularJS router dependency called <code>$routeParams</code>, which was injected into <code>PhoneDetails</code> when it was still an AngularJS controller.\nYou intend to inject it into the new <code>PhoneDetailsComponent</code>.</p>\n<p>AngularJS 注入器具有 AngularJS 路由器的依赖，叫做 <code>$routeParams</code>。它被注入到了 <code>PhoneDetails</code> 中，但 <code>PhoneDetails</code> 现在还是一个 AngularJS 控制器。你要把它注入到新的 <code>PhoneDetailsComponent</code> 中。</p>\n<p>Unfortunately, AngularJS dependencies are not automatically available to Angular components.\nYou must upgrade this service using a <a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\" title=\"Making AngularJS Dependencies Injectable to Angular - Upgrading from AngularJS to Angular | Angular\">factory provider</a> to make <code>$routeParams</code> an Angular injectable.\nDo that in a new file called <code>ajs-upgraded-providers.ts</code> and import it in <code>app.module.ts</code>:</p>\n<p>不幸的是，AngularJS 的依赖不会自动在 Angular 的组件中可用。\n你必须使用<a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\" title=\"Making AngularJS Dependencies Injectable to Angular - Upgrading from AngularJS to Angular | Angular\">工厂提供者（factory provider）</a>\n来把 <code>$routeParams</code> 包装成 Angular 的服务提供者。\n新建一个名叫 <code>ajs-upgraded-providers.ts</code> 的文件，并且在 <code>app.module.ts</code> 中导入它：</p>\n<code-example header=\"app/ajs-upgraded-providers.ts\" path=\"upgrade-phonecat-2-hybrid/app/ajs-upgraded-providers.ts\">\nexport abstract class RouteParams {\n  [key: string]: string;\n}\n\nexport function routeParamsFactory(i: any) {\n  return i.get('$routeParams');\n}\n\nexport const routeParamsProvider = {\n  provide: RouteParams,\n  useFactory: routeParamsFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<code-example header=\"app/app.module.ts ($routeParams)\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"routeparams\">\nimport { routeParamsProvider } from './ajs-upgraded-providers';\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n\n</code-example>\n<p>Convert the phone detail component template into Angular syntax as follows:</p>\n<p>把该组件的模板转变成 Angular 的语法，代码如下：</p>\n<code-example header=\"app/phone-detail/phone-detail.template.html\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.template.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"phone\">\n  &#x3C;div class=\"phone-images\">\n    &#x3C;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>\" class=\"phone\" alt=\"Phone {{ phone.name }} - thumbnail {{ index }}\"\n        [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{'selected': <a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> === mainImageUrl}\"\n        *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> of phone.images; let index = index;\" />\n  &#x3C;/div>\n\n  &#x3C;h1>{{phone.name}}&#x3C;/h1>\n\n  &#x3C;p>{{phone.description}}&#x3C;/p>\n\n  &#x3C;ul class=\"phone-thumbs\">\n    &#x3C;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let <a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> of phone.images; let index = index\">\n      &#x3C;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>\" (click)=\"setImage(<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>)\" alt=\"Phone {{ phone.name }} - thumbnail {{ index }}\"/>\n    &#x3C;/li>\n  &#x3C;/ul>\n\n  &#x3C;ul class=\"specs\">\n    &#x3C;li>\n      &#x3C;span>Availability and Networks&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Availability&#x3C;/dt>\n        &#x3C;dd *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let availability of phone.availability\">{{availability}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Battery&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt><a href=\"api/core/Type\" class=\"code-anchor\">Type</a>&#x3C;/dt>\n        &#x3C;dd>{{phone.battery?.type}}&#x3C;/dd>\n        &#x3C;dt>Talk <a href=\"api/common/Time\" class=\"code-anchor\">Time</a>&#x3C;/dt>\n        &#x3C;dd>{{phone.battery?.talkTime}}&#x3C;/dd>\n        &#x3C;dt>Standby time (<a href=\"api/forms/MaxValidator\" class=\"code-anchor\">max</a>)&#x3C;/dt>\n        &#x3C;dd>{{phone.battery?.standbyTime}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Storage and Memory&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>RAM&#x3C;/dt>\n        &#x3C;dd>{{phone.storage?.ram}}&#x3C;/dd>\n        &#x3C;dt>Internal Storage&#x3C;/dt>\n        &#x3C;dd>{{phone.storage?.flash}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Connectivity&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Network Support&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.cell}}&#x3C;/dd>\n        &#x3C;dt>WiFi&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.wifi}}&#x3C;/dd>\n        &#x3C;dt>Bluetooth&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.bluetooth}}&#x3C;/dd>\n        &#x3C;dt>Infrared&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.infrared | checkmark}}&#x3C;/dd>\n        &#x3C;dt>GPS&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.gps | checkmark}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Android&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>OS <a href=\"api/core/Version\" class=\"code-anchor\">Version</a>&#x3C;/dt>\n        &#x3C;dd>{{phone.android?.os}}&#x3C;/dd>\n        &#x3C;dt>UI&#x3C;/dt>\n        &#x3C;dd>{{phone.android?.ui}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Size and Weight&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Dimensions&#x3C;/dt>\n        &#x3C;dd *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let dim of phone.sizeAndWeight?.dimensions\">{{dim}}&#x3C;/dd>\n        &#x3C;dt>Weight&#x3C;/dt>\n        &#x3C;dd>{{phone.sizeAndWeight?.weight}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Display&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Screen size&#x3C;/dt>\n        &#x3C;dd>{{phone.display?.screenSize}}&#x3C;/dd>\n        &#x3C;dt>Screen resolution&#x3C;/dt>\n        &#x3C;dd>{{phone.display?.screenResolution}}&#x3C;/dd>\n        &#x3C;dt>Touch screen&#x3C;/dt>\n        &#x3C;dd>{{phone.display?.touchScreen | checkmark}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Hardware&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>CPU&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.cpu}}&#x3C;/dd>\n        &#x3C;dt>USB&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.usb}}&#x3C;/dd>\n        &#x3C;dt>Audio / headphone jack&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.audioJack}}&#x3C;/dd>\n        &#x3C;dt>FM Radio&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.fmRadio | checkmark}}&#x3C;/dd>\n        &#x3C;dt>Accelerometer&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.accelerometer | checkmark}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Camera&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Primary&#x3C;/dt>\n        &#x3C;dd>{{phone.camera?.primary}}&#x3C;/dd>\n        &#x3C;dt>Features&#x3C;/dt>\n        &#x3C;dd>{{phone.camera?.features?.join(', ')}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Additional Features&#x3C;/span>\n      &#x3C;dd>{{phone.additionalFeatures}}&#x3C;/dd>\n    &#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/div>\n\n\n</code-example>\n<p>There are several notable changes here:</p>\n<p>这里有几个值得注意的改动：</p>\n<ul>\n<li>\n<p>You've removed the <code>$ctrl.</code> prefix from all expressions</p>\n<p>你从所有表达式中移除了 <code>$ctrl.</code> 前缀。</p>\n</li>\n<li>\n<p>You've replaced <code>ng-src</code> with property bindings for the standard <code>src</code> property</p>\n<p>正如你在电话列表中做过的那样，你把 <code>ng-src</code> 替换成了标准的 <code>src</code> 属性绑定。</p>\n</li>\n<li>\n<p>You're using the property binding syntax around <code>ng-class</code>.\nThough Angular does have a <a href=\"guide/built-in-directives\" title=\"Built-in directives | Angular\">very similar <code>ngClass</code></a> as AngularJS does, its value is not magically evaluated as an expression.\nIn Angular, you always specify in the template when the value of an attribute is a property expression, as opposed to a literal string.</p>\n<p>你在 <code>ng-class</code> 周围使用了属性绑定语法。虽然 Angular 中有一个\n和 AngularJS 中<a href=\"guide/built-in-directives\" title=\"Built-in directives | Angular\">非常相似的 <code>ngClass</code></a>指令，\n但是它的值不会神奇的作为表达式进行计算。在 Angular 中，模板中的属性(Attribute)值总是被作为\n属性(Property)表达式计算，而不是作为字符串字面量。</p>\n</li>\n<li>\n<p>You've replaced <code>ng-repeat</code>s with <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code>s</p>\n<p>你把 <code>ng-repeat</code> 替换成了 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code></p>\n</li>\n<li>\n<p>You've replaced <code>ng-click</code> with an event binding for the standard <code>click</code></p>\n<p>你把 <code>ng-click</code> 替换成了一个到标准 <code>click</code> 事件的绑定</p>\n</li>\n<li>\n<p>You've wrapped the whole template in an <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> that causes it only to be rendered when there is a phone present.\nYou need this because when the component first loads, you don't have <code>phone</code> yet and the expressions will refer to a non-existing value.\nUnlike in AngularJS, Angular expressions do not fail silently when you try to refer to properties on undefined objects.\nYou need to be explicit about cases where this is expected.</p>\n<p>你把整个模板都包裹进了一个 <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 中，这导致只有当存在一个电话时它才会渲染。你必须这么做，是因为组件首次加载时你还没有 <code>phone</code> 变量，这些表达式就会引用到一个不存在的值。和 AngularJS 不同，当你尝试引用未定义对象上的属性时，Angular 中的表达式不会默默失败。你必须明确指出这种情况是你所期望的。</p>\n</li>\n</ul>\n<p>Add <code>PhoneDetailComponent</code> component to the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> <em>declarations</em>:</p>\n<p>把 <code>PhoneDetailComponent</code> 组件添加到 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <em>declarations</em> 中：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonedetail\">\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p>You should now also remove the phone detail component &#x3C;script> tag from <code>index.html</code>.</p>\n<p>你现在应该从 <code>index.html</code> 中移除电话详情组件的&#x3C;script>。</p>\n<h4 id=\"add-the-checkmarkpipe\">Add the <em>CheckmarkPipe</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-checkmarkpipe\"><i class=\"material-icons\">link</i></a></h4>\n<h4 id=\"添加-checkmarkpipe\">添加 <em>CheckmarkPipe</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#添加-checkmarkpipe\"><i class=\"material-icons\">link</i></a></h4>\n<p>The AngularJS directive had a <code>checkmark</code> <em>filter</em>.\nTurn that into an Angular <strong>pipe</strong>.</p>\n<p>AngularJS 指令中有一个 <code>checkmark</code><em>过滤器</em>，把它转换成 Angular 的<strong>管道</strong>。</p>\n<p>There is no upgrade method to convert filters into pipes.\nYou won't miss it.\nIt is easy to turn the filter function into an equivalent Pipe class.\nThe implementation is the same as before, repackaged in the <code>transform</code> method.\nRename the file to <code>checkmark.pipe.ts</code> to conform with Angular conventions:</p>\n<p>没有什么升级方法能把过滤器转换成管道。但你也并不需要它。把过滤器函数转换成等价的 Pipe 类非常简单。实现方式和以前一样，但把它们包装进 <code>transform</code> 方法中就可以了。把该文件改名成 <code>checkmark.pipe.ts</code>，以符合 Angular 中的命名约定：</p>\n<code-example header=\"app/core/checkmark/checkmark.pipe.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.ts\">\nimport { <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>, <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> } from '@angular/core';\n\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({name: 'checkmark'})\nexport class CheckmarkPipe implements <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> {\n  transform(input: boolean) {\n    return input ? '\\u2713' : '\\u2718';\n  }\n}\n\n\n</code-example>\n<p>Now import and declare the newly created pipe and remove the filter &#x3C;script> tag from <code>index.html</code>:</p>\n<p>现在，导入并声明这个新创建的管道，同时从 <code>index.html</code> 文件中移除该过滤器的 <code>&#x3C;script></code> 标签：</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"checkmarkpipe\">\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n    CheckmarkPipe\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule implements <a href=\"api/core/DoBootstrap\" class=\"code-anchor\">DoBootstrap</a> {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<h3 id=\"aot-compile-the-hybrid-app\">AOT compile the hybrid app<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#aot-compile-the-hybrid-app\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"对混合式应用做-aot-编译\">对混合式应用做 AOT 编译<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#对混合式应用做-aot-编译\"><i class=\"material-icons\">link</i></a></h3>\n<p>To use AOT with a hybrid app, you have to first set it up like any other Angular application, as shown in the <a href=\"guide/aot-compiler\" title=\"Ahead-of-time (AOT) compilation | Angular\">Ahead-of-time Compilation chapter</a>.</p>\n<p>要在混合式应用中使用 AOT 编译，你首先要像其它 Angular 应用一样设置它，就像<a href=\"guide/aot-compiler\" title=\"Ahead-of-time (AOT) compilation | Angular\">AOT 编译一章</a>所讲的那样。</p>\n<p>Then change <code>main-aot.ts</code> to bootstrap the <code>AppComponentFactory</code> that was generated by the AOT compiler:</p>\n<p>然后修改 <code>main-aot.ts</code> 的引导代码，来引导 AOT 编译器所生成的 <code>AppComponentFactory</code>：</p>\n<code-example header=\"app/main-aot.ts\" path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\">\nimport { <a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a> } from '@angular/platform-browser';\n\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>().bootstrapModule(AppModule);\n\n\n</code-example>\n<p>You need to load all the AngularJS files you already use in <code>index.html</code> in <code>aot/index.html</code> as well:</p>\n<p>你还要把在 <code>index.html</code> 中已经用到的所有 AngularJS 文件加载到 <code>aot/index.html</code> 中：</p>\n<code-example header=\"aot/index.html\" path=\"upgrade-phonecat-2-hybrid/aot/index.html\">\n&#x3C;!doctype html>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\">\n\n    &#x3C;base href=\"/app/\">\n\n    &#x3C;title>Google Phone Gallery&#x3C;/title>\n    &#x3C;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" />\n    &#x3C;link rel=\"stylesheet\" href=\"app.css\" />\n    &#x3C;link rel=\"stylesheet\" href=\"app.animations.css\" />\n\n    &#x3C;script src=\"https://code.jquery.com/jquery-2.2.4.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular-animate.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular-resource.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular-route.js\">&#x3C;/script>\n\n    &#x3C;script src=\"app.module.ajs.js\">&#x3C;/script>\n    &#x3C;script src=\"app.config.js\">&#x3C;/script>\n    &#x3C;script src=\"app.animations.js\">&#x3C;/script>\n    &#x3C;script src=\"core/core.module.js\">&#x3C;/script>\n    &#x3C;script src=\"core/phone/phone.module.js\">&#x3C;/script>\n    &#x3C;script src=\"phone-list/phone-list.module.js\">&#x3C;/script>\n    &#x3C;script src=\"phone-detail/phone-detail.module.js\">&#x3C;/script>\n\n    &#x3C;script src=\"/node_modules/core-js/client/shim.min.js\">&#x3C;/script>\n    &#x3C;script src=\"/node_modules/zone.js/bundles/zone.umd.min.js\">&#x3C;/script>\n\n    &#x3C;script>window.module = 'aot';&#x3C;/script>\n  &#x3C;/head>\n\n  &#x3C;body>\n    &#x3C;div class=\"view-container\">\n      &#x3C;div ng-view class=\"view-frame\">&#x3C;/div>\n    &#x3C;/div>\n  &#x3C;/body>\n  &#x3C;script src=\"/dist/build.js\">&#x3C;/script>\n&#x3C;/html>\n\n\n</code-example>\n<p>These files need to be copied together with the polyfills.\nThe files the application needs at runtime, like the <code>.json</code> phone lists and images, also need to be copied.</p>\n<p>这些文件要带着相应的腻子脚本复制到一起。应用运行时需要的文件，比如电话列表 <code>.json</code> 和图片，也需要复制过去。</p>\n<p>Install <code>fs-extra</code> using <code>npm install fs-extra --save-dev</code> for better file copying, and change <code>copy-dist-files.js</code> to the following:</p>\n<p>通过 <code>npm install fs-extra --save-dev</code> 安装 <code>fs-extra</code> 可以更好的复制文件，并且把 <code>copy-dist-files.js</code> 文件改成这样：</p>\n<code-example header=\"copy-dist-files.js\" path=\"upgrade-phonecat-2-hybrid/copy-dist-files.js\">\nvar fsExtra = require('fs-extra');\nvar resources = [\n  // polyfills\n  'node_modules/core-js/client/shim.min.js',\n  'node_modules/zone.js/bundles/zone.umd.min.js',\n  // css\n  'app/app.css',\n  'app/app.animations.css',\n  // images and json files\n  'app/<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a>/',\n  'app/phones/',\n  // app files\n  'app/app.module.ajs.js',\n  'app/app.config.js',\n  'app/app.animations.js',\n  'app/core/core.module.js',\n  'app/core/phone/phone.module.js',\n  'app/phone-list/phone-list.module.js',\n  'app/phone-detail/phone-detail.module.js'\n];\nresources.map(function(sourcePath) {\n  // Need to rename zone.umd.min.js to zone.min.js\n  var destPath = `aot/${sourcePath}`.replace('.umd.min.js', '.min.js');\n  fsExtra.copySync(sourcePath, destPath);\n});\n\n\n</code-example>\n<p>And that is all you need to use AOT while upgrading your app!</p>\n<p>这就是想要在升级应用期间 AOT 编译所需的一切！</p>\n<h3 id=\"adding-the-angular-router-and-bootstrap\">Adding The Angular Router And Bootstrap<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#adding-the-angular-router-and-bootstrap\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"添加-angular-路由器和引导程序\">添加 Angular 路由器和引导程序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#添加-angular-路由器和引导程序\"><i class=\"material-icons\">link</i></a></h3>\n<p>At this point, you've replaced all AngularJS application components with their Angular counterparts, even though you're still serving them from the AngularJS router.</p>\n<p>此刻，你已经把所有 AngularJS 的组件替换成了它们在 Angular 中的等价物，不过你仍然在 AngularJS 路由器中使用它们。</p>\n<h4 id=\"add-the-angular-router\">Add the Angular router<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-angular-router\"><i class=\"material-icons\">link</i></a></h4>\n<h4 id=\"添加-angular-路由器\">添加 Angular 路由器<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#添加-angular-路由器\"><i class=\"material-icons\">link</i></a></h4>\n<p>Angular has an <a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">all-new router</a>.</p>\n<p>Angular 有一个<a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">全新的路由器</a>。</p>\n<p>Like all routers, it needs a place in the UI to display routed views.\nFor Angular that is the <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code> and it belongs in a <em>root component</em> at the top of the applications component tree.</p>\n<p>像所有的路由器一样，它需要在 UI 中指定一个位置来显示路由的视图。在 Angular 中，它是 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>，并位于应用组件树顶部的<em>根组件</em>中。</p>\n<p>You don't yet have such a root component, because the application is still managed as an AngularJS app.\nCreate a new <code>app.component.ts</code> file with the following <code>AppComponent</code> class:</p>\n<p>你还没有这样一个根组件，因为该应用仍然是像一个 AngularJS 应用那样被管理的。创建新的 <code>app.component.ts</code> 文件，放入像这样的 <code>AppComponent</code> 类：</p>\n<code-example header=\"app/app.component.ts\" path=\"upgrade-phonecat-3-final/app/app.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phonecat-app',\n  template: '&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>&#x3C;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>>'\n})\nexport class AppComponent { }\n\n\n</code-example>\n<p>It has a template that only includes the <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>.\nThis component just renders the contents of the active route and nothing else.</p>\n<p>它有一个很简单的模板，只包含 <code>&#x3C;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>></code>。该组件只负责渲染活动路由的内容，此外啥也不干。</p>\n<p>The selector tells Angular to plug this root component into the <code>&#x3C;phonecat-app></code> element on the host web page when the application launches.</p>\n<p>该选择器告诉 Angular：当应用启动时就把这个根组件插入到宿主页面的 <code>&#x3C;phonecat-app></code> 元素中。</p>\n<p>Add this <code>&#x3C;phonecat-app></code> element to the <code>index.html</code>.\nIt replaces the old AngularJS <code>ng-view</code> directive:</p>\n<p>把这个 <code>&#x3C;phonecat-app></code> 元素插入到 <code>index.html</code> 中。用它来代替 AngularJS 中的 <code>ng-view</code> 指令：</p>\n<code-example header=\"index.html (body)\" path=\"upgrade-phonecat-3-final/index.html\" region=\"appcomponent\">\n&#x3C;body>\n  &#x3C;phonecat-app>&#x3C;/phonecat-app>\n&#x3C;/body>\n\n</code-example>\n<h4 id=\"create-the-routing-module\">Create the <em>Routing Module</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-the-routing-module\"><i class=\"material-icons\">link</i></a></h4>\n<h4 id=\"创建路由模块\">创建<em>路由模块</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#创建路由模块\"><i class=\"material-icons\">link</i></a></h4>\n<p>A router needs configuration whether it is the AngularJS or Angular or any other router.</p>\n<p>无论在 AngularJS 还是 Angular 或其它框架中，路由器都需要进行配置。</p>\n<p>The details of Angular router configuration are best left to the <a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">Routing documentation</a> which recommends that you create a <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> dedicated to router configuration (called a <em>Routing Module</em>).</p>\n<p>Angular 路由器配置的详情最好去查阅下<a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">路由与导航</a>文档。\n它建议你创建一个专们用于路由器配置的 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>（名叫<em>路由模块</em>）。</p>\n<code-example header=\"app/app-routing.module.ts\" path=\"upgrade-phonecat-3-final/app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router';\nimport { <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a>, <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a> } from '@angular/common';\n\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: '', redirectTo: 'phones', pathMatch: 'full' },\n  { path: 'phones',          component: PhoneListComponent },\n  { path: 'phones/:phoneId', component: PhoneDetailComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ RouterModule.forRoot(routes) ],\n  exports: [ <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> ],\n  providers: [\n    { provide: <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, useValue: '!' },\n    { provide: <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a>, useClass: <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a> },\n  ]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p>This module defines a <code>routes</code> object with two routes to the two phone components and a default route for the empty path.\nIt passes the <code>routes</code> to the <code>RouterModule.forRoot</code> method which does the rest.</p>\n<p>该模块定义了一个 <code>routes</code> 对象，它带有两个路由，分别指向两个电话组件，以及为空路径指定的默认路由。它把 <code>routes</code> 传给 <code>RouterModule.forRoot</code> 方法，该方法会完成剩下的事。</p>\n<p>A couple of extra providers enable routing with \"hash\" URLs such as <code>#!/phones</code> instead of the default \"push state\" strategy.</p>\n<p>一些额外的提供者让路由器使用“hash”策略解析 URL，比如 <code>#!/phones</code>，而不是默认的“Push State”策略。</p>\n<p>Now update the <code>AppModule</code> to import this <code>AppRoutingModule</code> and also the declare the root <code>AppComponent</code> as the bootstrap component.\nThat tells Angular that it should bootstrap the application with the <em>root</em> <code>AppComponent</code> and insert its view into the host web page.</p>\n<p>现在，修改 <code>AppModule</code>，让它导入这个 <code>AppRoutingModule</code>，并同时声明根组件 <code>AppComponent</code>。这会告诉 Angular，它应该使用根组件 <code>AppComponent</code> 引导应用，并把它的视图插入到宿主页面中。</p>\n<p>You must also remove the bootstrap of the AngularJS module from <code>ngDoBootstrap()</code> in <code>app.module.ts</code> and the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> import.</p>\n<p>你还要从 <code>app.module.ts</code> 中移除调用 <code>ngDoBootstrap()</code> 来引导 AngularJS 模块的代码，以及对 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 的导入代码。</p>\n<code-example header=\"app/app.module.ts\" path=\"upgrade-phonecat-3-final/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\nimport { Phone } from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p>And since you are routing to <code>PhoneListComponent</code> and <code>PhoneDetailComponent</code> directly rather than using a route template with a <code>&#x3C;phone-list></code> or <code>&#x3C;phone-detail></code> tag, you can do away with their Angular selectors as well.</p>\n<p>而且，由于你现在直接路由到 <code>PhoneListComponent</code> 和 <code>PhoneDetailComponent</code>，而不再使用带 <code>&#x3C;phone-list></code> 或 <code>&#x3C;phone-detail></code> 标签的路由模板，因此你同样不再需要它们的 Angular 选择器。</p>\n<h4 id=\"generate-links-for-each-phone\">Generate links for each phone<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#generate-links-for-each-phone\"><i class=\"material-icons\">link</i></a></h4>\n<h4 id=\"为每个电话生成链接\">为每个电话生成链接<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#为每个电话生成链接\"><i class=\"material-icons\">link</i></a></h4>\n<p>You no longer have to hardcode the links to phone details in the phone list.\nYou can generate data bindings for the <code>id</code> of each phone to the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> directive and let that directive construct the appropriate URL to the <code>PhoneDetailComponent</code>:</p>\n<p>在电话列表中，你不用再被迫硬编码电话详情的链接了。你可以通过把每个电话的 <code>id</code> 绑定到 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 指令来生成它们了，该指令的构造函数会为 <code>PhoneDetailComponent</code> 生成正确的 URL：</p>\n<code-example header=\"app/phone-list/phone-list.template.html (list with links)\" path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.template.html\" region=\"list\">\n&#x3C;ul class=\"phones\">\n  &#x3C;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\">\n    &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/phones', phone.id]\" class=\"thumb\">\n      &#x3C;<a href=\"api/common/NgOptimizedImage\" class=\"code-anchor\">img</a> [src]=\"phone.imageUrl\" [alt]=\"phone.name\" />\n    &#x3C;/a>\n    &#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"['/phones', phone.id]\" class=\"name\">{{phone.name}}&#x3C;/a>\n    &#x3C;p>{{phone.snippet}}&#x3C;/p>\n  &#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>See the <a href=\"guide/router\" title=\"Common Routing Tasks | Angular\">Routing</a> page for details.</p>\n<p>要了解详情，请查看<a href=\"guide/router\">路由与导航</a>页。</p>\n</div>\n<h4 id=\"use-route-parameters\">Use route parameters<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#use-route-parameters\"><i class=\"material-icons\">link</i></a></h4>\n<h4 id=\"使用路由参数\">使用路由参数<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#使用路由参数\"><i class=\"material-icons\">link</i></a></h4>\n<p>The Angular router passes route parameters differently.\nCorrect the <code>PhoneDetail</code> component constructor to expect an injected <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> object.\nExtract the <code>phoneId</code> from the <code>ActivatedRoute.snapshot.params</code> and fetch the phone data as before:</p>\n<p>Angular 路由器会传入不同的路由参数。改正 <code>PhoneDetail</code> 组件的构造函数，让它改用注入进来的 <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 对象。从 <code>ActivatedRoute.snapshot.params</code> 中提取出 <code>phoneId</code>，并像以前一样获取手机的数据：</p>\n<code-example header=\"app/phone-detail/phone-detail.component.ts\" path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html'\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(activatedRoute: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, phone: Phone) {\n    phone.get(activatedRoute.snapshot.paramMap.get('phoneId'))\n      .subscribe((p: PhoneData) => {\n        this.phone = p;\n        this.setImage(p.images[0]);\n      });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\n\n</code-example>\n<p>You are now running a pure Angular application!</p>\n<p>你现在运行的就是纯正的 Angular 应用了！</p>\n<h3 id=\"say-goodbye-to-angularjs\">Say Goodbye to AngularJS<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#say-goodbye-to-angularjs\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"再见angularjs\">再见，AngularJS！<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#再见angularjs\"><i class=\"material-icons\">link</i></a></h3>\n<p>It is time to take off the training wheels and let the application begin its new life as a pure, shiny Angular app.\nThe remaining tasks all have to do with removing code - which of course is every programmer's favorite task!</p>\n<p>终于可以把辅助训练的轮子摘下来了！让你的应用作为一个纯粹、闪亮的 Angular 程序开始它的新生命吧。剩下的所有任务就是移除代码 —— 这当然是每个程序员最喜欢的任务！</p>\n<p>The application is still bootstrapped as a hybrid app.\nThere is no need for that anymore.</p>\n<p>应用仍然以混合式应用的方式启动，然而这再也没有必要了。</p>\n<p>Switch the bootstrap method of the application from the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> to the Angular way.</p>\n<p>把应用的引导（<code>bootstrap</code>）方式从 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 的改为 Angular 的。</p>\n<code-example header=\"main.ts\" path=\"upgrade-phonecat-3-final/app/main.ts\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n\n</code-example>\n<p>If you haven't already, remove all references to the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> from <code>app.module.ts</code>, as well as any <a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\" title=\"Making AngularJS Dependencies Injectable to Angular - Upgrading from AngularJS to Angular | Angular\">factory provider</a> for AngularJS services, and the <code>app/ajs-upgraded-providers.ts</code> file.</p>\n<p>如果你还没有这么做，请从 <code>app.module.ts 删除所有 </code>UpgradeModule 的引用，\n以及所有用于 AngularJS 服务的<a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">工厂提供者（factory provider）</a>和 <code>app/ajs-upgraded-providers.ts</code> 文件。</p>\n<p>Also remove any <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> or <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> you find, together with the associated AngularJS factory or directive declarations.</p>\n<p>还要删除所有的 <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> 或 <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> 以及与 AngularJS 相关的工厂或指令声明。</p>\n<code-example header=\"app.module.ts\" path=\"upgrade-phonecat-3-final/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\nimport { Phone } from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p>You may also completely remove the following files.\nThey are AngularJS module configuration files and not needed in Angular:</p>\n<p>你还要完全移除了下列文件。它们是 AngularJS 的模块配置文件和类型定义文件，在 Angular 中不需要了：</p>\n<ul>\n<li>\n<p><code>app/app.module.ajs.ts</code></p>\n</li>\n<li>\n<p><code>app/app.config.ts</code></p>\n</li>\n<li>\n<p><code>app/core/core.module.ts</code></p>\n</li>\n<li>\n<p><code>app/core/phone/phone.module.ts</code></p>\n</li>\n<li>\n<p><code>app/phone-detail/phone-detail.module.ts</code></p>\n</li>\n<li>\n<p><code>app/phone-list/phone-list.module.ts</code></p>\n</li>\n</ul>\n<p>The external typings for AngularJS may be uninstalled as well.\nThe only ones you still need are for Jasmine and Angular polyfills.\nThe <code>@angular/upgrade</code> package and its mapping in <code>systemjs.config.js</code> can also go.</p>\n<p>还需要卸载 AngularJS 的外部类型定义文件。你现在只需要留下 Jasmine 和 Angular 所需的腻子脚本。<code>systemjs.config.js</code> 中的 <code>@angular/upgrade</code> 包及其映射也可以移除了。</p>\n<code-example format=\"shell\" language=\"shell\">\n\nnpm uninstall @angular/upgrade --save\nnpm uninstall @types/angular @types/angular-animate @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n\n</code-example>\n<p>Finally, from <code>index.html</code>, remove all references to AngularJS scripts and jQuery.\nWhen you're done, this is what it should look like:</p>\n<p>最后，从 <code>index.html</code> 中，移除所有对 AngularJS 和 jQuery 脚本的引用。当这些全部做完时，<code>index.html</code> 应该是这样的：</p>\n<code-example header=\"index.html\" path=\"upgrade-phonecat-3-final/index.html\" region=\"full\">\n&#x3C;!doctype html>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\">\n    &#x3C;base href=\"/app/\">\n    &#x3C;title>Google Phone Gallery&#x3C;/title>\n    &#x3C;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" />\n    &#x3C;link rel=\"stylesheet\" href=\"app.css\" />\n\n    &#x3C;script src=\"/node_modules/core-js/client/shim.min.js\">&#x3C;/script>\n    &#x3C;script src=\"/node_modules/zone.js/bundles/zone.umd.js\">&#x3C;/script>\n    &#x3C;script src=\"/node_modules/systemjs/dist/system.src.js\">&#x3C;/script>\n    &#x3C;script src=\"/systemjs.config.js\">&#x3C;/script>\n    &#x3C;script>\n      System.import('/app');\n    &#x3C;/script>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;phonecat-app>&#x3C;/phonecat-app>\n  &#x3C;/body>\n&#x3C;/html>\n\n</code-example>\n<p>That is the last you'll see of AngularJS!\nIt has served us well but now it is time to say goodbye.</p>\n<p>这是你最后一次看到 AngularJS 了！它曾经带给你很多帮助，不过现在，该说再见了。</p>\n<h2 id=\"appendix-upgrading-phonecat-tests\">Appendix: Upgrading PhoneCat Tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#appendix-upgrading-phonecat-tests\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"附录升级-phonecat-的测试\">附录：升级 PhoneCat 的测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#附录升级-phonecat-的测试\"><i class=\"material-icons\">link</i></a></h2>\n<p>Tests can not only be retained through an upgrade process, but they can also be used as a valuable safety measure when ensuring that the application does not break during the upgrade.\nE2E tests are especially useful for this purpose.</p>\n<p>测试不仅要在升级过程中被保留，它还是确保应用在升级过程中不会被破坏的一个安全指示器。要达到这个目的，E2E 测试尤其有用。</p>\n<h3 id=\"e2e-tests\">E2E Tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#e2e-tests\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"e2e-测试\">E2E 测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#e2e-测试\"><i class=\"material-icons\">link</i></a></h3>\n<p>The PhoneCat project has both E2E Protractor tests and some Karma unit tests in it.\nOf these two, E2E tests can be dealt with much more easily:\nBy definition, E2E tests access the application from the <em>outside</em> by interacting with the various UI elements the application puts on the screen.\nE2E tests aren't really that concerned with the internal structure of the application components.\nThat also means that, although you modify the project quite a bit during the upgrade, the E2E test suite should keep passing with just minor modifications.\nYou didn't change how the application behaves from the user's point of view.</p>\n<p>PhoneCat 项目中同时有基于 Protractor 的 E2E 测试和一些基于 Karma 的单元测试。对这两者来说，E2E 测试的转换要容易得多：根据定义，E2E 测试通过与应用中显示的这些 UI 元素互动，从<em>外部</em>访问你的应用来进行测试。E2E 测试实际上并不关心这些应用中各部件的内部结构。这也意味着，虽然你已经修改了此应用程序，但是 E2E 测试套件仍然应该能像以前一样全部通过。因为从用户的角度来说，你并没有改变应用的行为。</p>\n<p>During TypeScript conversion, there is nothing to do to keep E2E tests working.\nBut when you change the bootstrap to that of a Hybrid app, you must make a few changes.</p>\n<p>在转成 TypeScript 期间，你不用做什么就能让 E2E 测试正常工作。但是当你想改成按照混合式应用进行引导时，必须做一些修改。</p>\n<p>Update the <code>protractor-conf.js</code> to sync with hybrid applications:</p>\n<p>再对 <code>protractor-conf.js</code> 做下列修改，与混合应用同步：</p>\n<code-example language=\"javascript\">\n\nng12Hybrid: true\n\n</code-example>\n<p>When you start to upgrade components and their templates to Angular, you'll make more changes because the E2E tests have matchers that are specific to AngularJS.\nFor PhoneCat you need to make the following changes in order to make things work with Angular:</p>\n<p>当你开始组件和模块升级到 Angular 时，还需要一系列后续的修改。这是因为 E2E 测试有一些匹配器是 AngularJS 中特有的。对于 PhoneCat 来说，为了让它能在 Angular 下工作，你得做下列修改：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Previous code</th>\n<th align=\"left\">New code</th>\n<th align=\"left\">Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">老代码</td>\n<td align=\"left\">新代码</td>\n<td align=\"left\">详情</td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.repeater('phone in $ctrl.phones').column('phone.name')</code></td>\n<td align=\"left\"><code>by.css('.phones .name')</code></td>\n<td align=\"left\">The repeater matcher relies on AngularJS <code>ng-repeat</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.repeater('phone in $ctrl.phones').column('phone.name')</code></td>\n<td align=\"left\"><code>by.css('.phones .name')</code></td>\n<td align=\"left\">repeater 匹配器依赖于 AngularJS 中的 <code>ng-repeat</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.repeater('phone in $ctrl.phones')</code></td>\n<td align=\"left\"><code>by.css('.phones li')</code></td>\n<td align=\"left\">The repeater matcher relies on AngularJS <code>ng-repeat</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.repeater('phone in $ctrl.phones')</code></td>\n<td align=\"left\"><code>by.css('.phones li')</code></td>\n<td align=\"left\">repeater 匹配器依赖于 AngularJS 中的 <code>ng-repeat</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.model('$ctrl.query')</code></td>\n<td align=\"left\"><code>by.css('input')</code></td>\n<td align=\"left\">The model matcher relies on AngularJS <code>ng-model</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.model('$ctrl.query')</code></td>\n<td align=\"left\"><code>by.css('input')</code></td>\n<td align=\"left\">模型匹配器依赖于 AngularJS <code>ng-model</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.model('$ctrl.orderProp')</code></td>\n<td align=\"left\"><code>by.css('select')</code></td>\n<td align=\"left\">The model matcher relies on AngularJS <code>ng-model</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.model('$ctrl.orderProp')</code></td>\n<td align=\"left\"><code>by.css('select')</code></td>\n<td align=\"left\">模型匹配器依赖于 AngularJS <code>ng-model</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.binding('$ctrl.phone.name')</code></td>\n<td align=\"left\"><code>by.css('h1')</code></td>\n<td align=\"left\">The binding matcher relies on AngularJS data binding</td>\n</tr>\n<tr>\n<td align=\"left\"><code>by.binding('$ctrl.phone.name')</code></td>\n<td align=\"left\"><code>by.css('h1')</code></td>\n<td align=\"left\">binding 匹配器依赖于 AngularJS 的数据绑定</td>\n</tr>\n</tbody>\n</table>\n<p>When the bootstrap method is switched from that of <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> to pure Angular, AngularJS ceases to exist on the page completely.\nAt this point, you need to tell Protractor that it should not be looking for an AngularJS application anymore, but instead it should find <em>Angular apps</em> from the page.</p>\n<p>当引导方式从 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 切换到纯 Angular 的时，AngularJS 就从页面中完全消失了。此时，你需要告诉 Protractor，它不用再找 AngularJS 应用了，而是从页面中查找 <em>Angular</em> 应用。</p>\n<p>Replace the <code>ng12Hybrid</code> previously added with the following in <code>protractor-conf.js</code>:</p>\n<p>替换之前在 <code>protractor-conf.js</code> 中加入 <code>ng12Hybrid</code>，象这样：</p>\n<code-example language=\"javascript\">\n\nuseAllAngular2AppRoots: true,\n\n</code-example>\n<p>Also, there are a couple of Protractor API calls in the PhoneCat test code that are using the AngularJS <code>$location</code> service under the hood.\nAs that service is no longer present after the upgrade, replace those calls with ones that use the generic URL APIs of WebDriver instead.\nThe first of these is the redirection spec:</p>\n<p>同样，<code>PhoneCat</code> 的测试代码中有两个 Protractor API 调用内部使用了 AngularJS 的 <code>$location</code>。该服务没有了，你就得把这些调用用一个 WebDriver 的通用 URL API 代替。第一个 API 是“重定向(redirect)”规约：</p>\n<code-example header=\"e2e-tests/scenarios.ts\" path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"redirect\">\nit('should redirect `index.html` to `index.html#!/phones', async () => {\n  await browser.get('index.html');\n  await browser.waitForAngular();\n  const url = await browser.getCurrentUrl();\n  expect(url.endsWith('/phones')).toBe(true);\n});\n\n</code-example>\n<p>And the second is the phone links spec:</p>\n<p>然后是“电话链接(phone links)”规约：</p>\n<code-example header=\"e2e-tests/scenarios.ts\" path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"links\">\nit('should render phone specific links', async () => {\n  const <a href=\"api/animations/query\" class=\"code-anchor\">query</a> = element(by.css('input'));\n  await query.sendKeys('nexus');\n  await element.all(by.css('.phones li a')).first().click();\n  const url = await browser.getCurrentUrl();\n  expect(url.endsWith('/phones/nexus-s')).toBe(true);\n});\n\n</code-example>\n<h3 id=\"unit-tests\">Unit Tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#unit-tests\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"单元测试\">单元测试<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#单元测试\"><i class=\"material-icons\">link</i></a></h3>\n<p>For unit tests, on the other hand, more conversion work is needed.\nEffectively they need to be <em>upgraded</em> along with the production code.</p>\n<p>另一方面，对于单元测试来说，需要更多的转化工作。实际上，它们需要随着产品代码一起升级。</p>\n<p>During TypeScript conversion no changes are strictly necessary.\nBut it may bea good idea to convert the unit test code into TypeScript as well.</p>\n<p>在转成 TypeScript 期间，严格来讲没有什么改动是必须的。但把单元测试代码转成 TypeScript 仍然是个好主意，。</p>\n<p>For instance, in the phone detail component spec, you can use ES2015 features like arrow functions and block-scoped variables and benefit from the type definitions of the AngularJS services you're consuming:</p>\n<p>比如，在这个电话详情组件的规约中，你不仅用到了 ES2015 中的箭头函数和块作用域变量这些特性，还为所用的一些 AngularJS 服务提供了类型定义。</p>\n<code-example header=\"app/phone-detail/phone-detail.component.spec.ts\" path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.spec.ts\">\ndescribe('phoneDetail', () => {\n\n  // Load the module that contains the `phoneDetail` component before each test\n  beforeEach(angular.mock.module('phoneDetail'));\n\n  // Test the controller\n  describe('PhoneDetailController', () => {\n    let $httpBackend: angular.IHttpBackendService;\n    let ctrl: any;\n    const xyzPhoneData = {\n      name: 'phone xyz',\n      images: ['image/url1.png', 'image/url2.png']\n    };\n\n    beforeEach(inject(($componentController: any,\n                       _$httpBackend_: angular.IHttpBackendService,\n                       $routeParams: angular.route.IRouteParamsService) => {\n      $httpBackend = _$httpBackend_;\n      $httpBackend.expectGET('phones/xyz.json').respond(xyzPhoneData);\n\n      $routeParams.phoneId = 'xyz';\n\n      ctrl = $componentController('phoneDetail');\n    }));\n\n    it('should fetch the phone details', () => {\n      jasmine.addCustomEqualityTester(angular.equals);\n\n      expect(ctrl.phone).toEqual({});\n\n      $httpBackend.flush();\n      expect(ctrl.phone).toEqual(xyzPhoneData);\n    });\n\n  });\n\n});\n\n\n</code-example>\n<p>Once you start the upgrade process and bring in SystemJS, configuration changes are needed for Karma.\nYou need to let SystemJS load all the new Angular code, which can be done with the following kind of shim file:</p>\n<p>一旦你开始了升级过程并引入了 SystemJS，还需要对 Karma 进行配置修改。你需要让 SystemJS 加载所有的 Angular 新代码，</p>\n<code-example header=\"karma-test-shim.js\" path=\"upgrade-phonecat-2-hybrid/karma-test-shim.1.js\">\n// /*<a href=\"api/core/global\" class=\"code-anchor\">global</a> jasmine, __karma__, window*/\nError.stackTraceLimit = 0; // \"No stacktrace\"\" is usually best for app testing.\n\n// Uncomment to get full stacktrace output. Sometimes helpful, usually not.\n// Error.stackTraceLimit = Infinity; //\n\njasmine.DEFAULT_TIMEOUT_INTERVAL = 1000;\n\nvar builtPath = '/base/app/';\n\n__karma__.loaded = function () { };\n\nfunction isJsFile(path) {\n  return path.slice(-3) == '.js';\n}\n\nfunction isSpecFile(path) {\n  return /\\.spec\\.(.*\\.)?js$/.test(path);\n}\n\nfunction isBuiltFile(path) {\n  return isJsFile(path) &#x26;&#x26; (path.slice(0, builtPath.length) == builtPath);\n}\n\nvar allSpecFiles = Object.keys(window.__karma__.files)\n  .filter(isSpecFile)\n  .filter(isBuiltFile);\n\nSystem.config({\n  baseURL: '/base',\n  // Extend usual application package list with test folder\n  packages: { 'testing': { main: 'index.js', defaultExtension: 'js' } },\n\n  // Assume npm: is set in `paths` in systemjs.config\n  // Map the angular testing bundles\n  map: {\n    '@angular/core/testing': 'npm:@angular/core/fesm2015/testing.mjs',\n    '@angular/common/testing': 'npm:@angular/common/fesm2015/testing.mjs',\n    '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing': 'npm:@angular/common/fesm2015/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing.mjs',\n    '@angular/compiler/testing': 'npm:@angular/compiler/fesm2015/testing.mjs',\n    '@angular/platform-browser/testing': 'npm:@angular/platform-browser/fesm2015/testing.mjs',\n    '@angular/platform-browser-dynamic/testing': 'npm:@angular/platform-browser-dynamic/fesm2015/testing.mjs',\n    '@angular/router/testing': 'npm:@angular/router/fesm2015/testing.mjs',\n    '@angular/forms/testing': 'npm:@angular/forms/fesm2015/testing.mjs',\n  },\n});\n\nSystem.import('systemjs.config.js')\n  .then(importSystemJsExtras)\n  .then(initTestBed)\n  .then(initTesting);\n\n/** <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a> SystemJS configuration extras. Keep going w/o it */\nfunction importSystemJsExtras(){\n  return System.import('systemjs.config.extras.js')\n  .catch(function(reason) {\n    console.log(\n      'Warning: System.import could not load the optional \"systemjs.config.extras.js\". Did you omit it by accident? Continuing without it.'\n    );\n    console.log(reason);\n  });\n}\n\nfunction initTestBed() {\n  return Promise.all([\n    System.import('@angular/core/testing'),\n    System.import('@angular/platform-browser-dynamic/testing')\n  ])\n\n  .then(function (providers) {\n    var coreTesting    = providers[0];\n    var browserTesting = providers[1];\n\n    coreTesting.TestBed.initTestEnvironment(\n      browserTesting.BrowserDynamicTestingModule,\n      browserTesting.platformBrowserDynamicTesting());\n  })\n}\n\n// Import all spec files and start karma\nfunction initTesting() {\n  return Promise.all(\n    allSpecFiles.map(function (moduleName) {\n      return System.import(moduleName);\n    })\n  )\n  .then(__karma__.start, __karma__.error);\n}\n\n\n</code-example>\n<p>The shim first loads the SystemJS configuration, then the test the support libraries of Angular, and then the spec files of the application themselves.</p>\n<p>这个 shim 文件首先加载了 SystemJS 的配置，然后是 Angular 的测试支持库，然后是应用本身的规约文件。</p>\n<p>Karma configuration should then be changed so that it uses the application root dir as the base directory, instead of <code>app</code>.</p>\n<p>然后需要修改 Karma 配置，来让它使用本应用的根目录作为基础目录(base directory)，而不是 <code>app</code>。</p>\n<code-example header=\"karma.conf.js\" path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"basepath\">\nbasePath: './',\n\n</code-example>\n<p>Once done, you can load SystemJS and other dependencies, and also switch the configuration for loading application files so that they are <em>not</em> included to the page by Karma.\nYou'll let the shim and SystemJS load them.</p>\n<p>一旦这些完成了，你就能加载 SystemJS 和其它依赖，并切换配置文件来加载那些应用文件，而<em>不用</em>在 Karma 页面中包含它们。你要让这个 shim 文件和 SystemJS 去加载它们。</p>\n<code-example header=\"karma.conf.js\" path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"files\">\n// System.js for module loading\n'node_modules/systemjs/dist/system.src.js',\n\n// Polyfills\n'node_modules/core-js/client/shim.js',\n\n// zone.js\n'node_modules/zone.js/bundles/zone.umd.js',\n'node_modules/zone.js/bundles/zone-testing.umd.js',\n\n// RxJs.\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/rxjs/**/*.js', included: false, watched: false },\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/rxjs/**/*.js.map', included: false, watched: false },\n\n// Angular itself and the testing library\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/@angular/**/*.mjs', included: false, watched: false },\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/@angular/**/*.mjs.map', included: false, watched: false },\n\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/tslib/tslib.js', included: false, watched: false },\n{ <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'node_modules/systemjs-plugin-babel/**/*.js', included: false, watched: false },\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'systemjs.config.js', included: false, watched: false},\n'karma-test-shim.js',\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/**/*.module.js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/*!(.module|.spec).js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/!(bower_components)/**/*!(.module|.spec).js', included: false, watched: true},\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: 'app/**/*.spec.js', included: false, watched: true},\n\n{<a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>: '**/*.html', included: false, watched: true},\n\n</code-example>\n<p>Since the HTML templates of Angular components will be loaded as well, you must help Karma out a bit so that it can route them to the right paths:</p>\n<p>由于 Angular 组件中的 HTML 模板也同样要被加载，所以你得帮 Karma 一把，帮它在正确的路径下找到这些模板：</p>\n<code-example header=\"karma.conf.js\" path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"html\">\n// proxied base paths for loading assets\nproxies: {\n  // required for component assets fetched by Angular's compiler\n  '/phone-detail': '/base/app/phone-detail',\n  '/phone-list': '/base/app/phone-list'\n},\n\n</code-example>\n<p>The unit test files themselves also need to be switched to Angular when their production counterparts are switched.\nThe specs for the checkmark pipe are probably the most straightforward, as the pipe has no dependencies:</p>\n<p>如果产品代码被切换到了 Angular，单元测试文件本身也需要切换过来。对勾(checkmark)管道的规约可能是最直观的，因为它没有任何依赖：</p>\n<code-example header=\"app/core/checkmark/checkmark.pipe.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.spec.ts\">\nimport { CheckmarkPipe } from './checkmark.pipe';\n\ndescribe('CheckmarkPipe', () => {\n\n  it('should convert boolean values to unicode checkmark or cross', () => {\n    const checkmarkPipe = new CheckmarkPipe();\n    expect(checkmarkPipe.transform(true)).toBe('\\u2713');\n    expect(checkmarkPipe.transform(false)).toBe('\\u2718');\n  });\n});\n\n\n</code-example>\n<p>The unit test for the phone service is a bit more involved.\nYou need to switch from the mocked-out AngularJS <code>$httpBackend</code> to a mocked-out Angular Http backend.</p>\n<p><code>Phone</code> 服务的测试会牵扯到一点别的。你需要把模拟版的 AngularJS <code>$httpBackend</code> 服务切换到模拟板的 Angular Http 后端。</p>\n<code-example header=\"app/core/phone/phone.service.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.spec.ts\">\nimport { inject, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>, <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a> } from '@angular/common/<a href=\"api/common/http\" class=\"code-anchor\">http</a>/testing';\nimport { Phone, PhoneData } from './phone.service';\n\ndescribe('Phone', () => {\n  let phone: Phone;\n  const phonesData: PhoneData[] = [\n    {name: 'Phone X', snippet: '', images: []},\n    {name: 'Phone Y', snippet: '', images: []},\n    {name: 'Phone Z', snippet: '', images: []}\n  ];\n  let httpMock: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>\n      ],\n      providers: [\n        Phone,\n      ]\n    });\n  });\n\n  beforeEach(inject([<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>, Phone], (_httpMock_: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>, _phone_: Phone) => {\n    httpMock = _httpMock_;\n    phone = _phone_;\n  }));\n\n  afterEach(() => {\n    httpMock.verify();\n  });\n\n  it('should fetch the phones data from `/phones/phones.json`', () => {\n    phone.query().subscribe(result => {\n      expect(result).toEqual(phonesData);\n    });\n    const req = httpMock.expectOne(`/phones/phones.json`);\n    req.flush(phonesData);\n  });\n\n});\n\n\n\n</code-example>\n<p>For the component specs, you can mock out the <code>Phone</code> service itself, and have it provide canned phone data.\nYou use the component unit testing APIs of Angular for both components.</p>\n<p>对于组件的规约，你可以模拟出 <code>Phone</code> 服务本身，并且让它提供电话的数据。你可以对这些组件使用 Angular 的组件单元测试 API。</p>\n<code-example header=\"app/phone-detail/phone-detail.component.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.spec.ts\">\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable, of } from 'rxjs';\n\nimport { PhoneDetailComponent } from './phone-detail.component';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { CheckmarkPipe } from '../core/checkmark/checkmark.pipe';\n\nfunction xyzPhoneData(): PhoneData {\n  return {name: 'phone xyz', snippet: '', images: ['image/url1.png', 'image/url2.png']};\n}\n\nclass MockPhone {\n  get(id: string): Observable&#x3C;PhoneData> {\n    return of(xyzPhoneData());\n  }\n}\n\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n\ndescribe('PhoneDetailComponent', () => {\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { phoneId: 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n  it('should fetch phone detail', () => {\n    const fixture = TestBed.createComponent(PhoneDetailComponent);\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('h1').textContent).toContain(xyzPhoneData().name);\n  });\n});\n\n\n</code-example>\n<code-example header=\"app/phone-list/phone-list.component.spec.ts\" path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.spec.ts\">\nimport {<a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>} from '@angular/common/testing';\nimport {<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>} from '@angular/core';\nimport {<a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>} from '@angular/core/testing';\nimport {<a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>} from '@angular/router';\nimport {Observable, of} from 'rxjs';\n\nimport {Phone, PhoneData} from '../core/phone/phone.service';\n\nimport {PhoneListComponent} from './phone-list.component';\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\nclass MockPhone {\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&#x3C;PhoneData[]> {\n    return of([\n      {name: 'Nexus S', snippet: '', images: []}, {name: 'Motorola DROID', snippet: '', images: []}\n    ]);\n  }\n}\n\nlet fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&#x3C;PhoneListComponent>;\n\ndescribe('PhoneList', () => {\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          declarations: [PhoneListComponent],\n          providers: [\n            {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({params: {phoneId: 1}})},\n            {provide: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>, useClass: <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>},\n            {provide: Phone, useClass: MockPhone},\n          ],\n          schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n        })\n        .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n  it('should create \"phones\" model with 2 phones fetched from xhr', () => {\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelectorAll('.phone-list-item').length).toBe(2);\n    expect(compiled.querySelector('.phone-list-item:nth-child(1)').textContent)\n        .toContain('Motorola DROID');\n    expect(compiled.querySelector('.phone-list-item:nth-child(2)').textContent)\n        .toContain('Nexus S');\n  });\n\n  xit('should set the default value of orderProp model', () => {\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('select option:last-child').selected).toBe(true);\n  });\n});\n\n\n</code-example>\n<p>Finally, revisit both of the component tests when you switch to the Angular router.\nFor the details component, provide a mock of Angular <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> object instead of using the AngularJS <code>$routeParams</code>.</p>\n<p>最后，当你切换到 Angular 路由时，需要重新过一遍这些组件测试。对详情组件来说，你需要提供一个 Angular <code>RouteParams</code> 的 mock 对象，而不再用 AngularJS 中的 <code>$routeParams</code>。</p>\n<code-example header=\"app/phone-detail/phone-detail.component.spec.ts\" path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.spec.ts\" region=\"activatedroute\">\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a> } from '@angular/core/testing';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n/* . . . */\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n  /* . . . */\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n    TestBed.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { phoneId: 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n</code-example>\n<p>And for the phone list component, a few adjustments to the router make the <code>RouteLink</code> directives work.</p>\n<p>对于电话列表组件，还要再做少量的调整，以便路由器能让 <code>RouteLink</code> 指令正常工作。</p>\n<code-example header=\"app/phone-list/phone-list.component.spec.ts\" path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.component.spec.ts\" region=\"routestuff\">\nimport {<a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>} from '@angular/common/testing';\nimport {<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>} from '@angular/core';\nimport {<a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>, <a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>} from '@angular/core/testing';\nimport {<a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>} from '@angular/router';\nimport {Observable, of} from 'rxjs';\n\nimport {Phone, PhoneData} from '../core/phone/phone.service';\n\nimport {PhoneListComponent} from './phone-list.component';\n\n  /* . . . */\n\n  beforeEach(<a href=\"api/core/testing/waitForAsync\" class=\"code-anchor\">waitForAsync</a>(() => {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>\n        .configureTestingModule({\n          declarations: [PhoneListComponent],\n          providers: [\n            {provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({params: {phoneId: 1}})},\n            {provide: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>, useClass: <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a>},\n            {provide: Phone, useClass: MockPhone},\n          ],\n          schemas: [<a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a>]\n        })\n        .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(PhoneListComponent);\n  });\n\n</code-example>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间： 2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - api/common\n - api/common/upgrade\n - api/common/upgrade/$locationShim\n - api/common/upgrade/LocationUpgradeModule\n - api/upgrade/static/downgradeComponent\n - guide/deprecations\n - guide/releases\n - guide/updating\n - guide/upgrade-performance\n - guide/upgrade-setup\n-->\n<!-- links from this doc:\n - api/animations/query\n - api/common/APP_BASE_HREF\n - api/common/HashLocationStrategy\n - api/common/Location\n - api/common/LocationStrategy\n - api/common/NgClass\n - api/common/NgFor\n - api/common/NgIf\n - api/common/NgOptimizedImage\n - api/common/Time\n - api/common/http\n - api/common/http/HttpClient\n - api/common/http/HttpClientModule\n - api/common/http/testing/HttpClientTestingModule\n - api/common/http/testing/HttpTestingController\n - api/common/testing/SpyLocation\n - api/common/upgrade/$locationShim\n - api/common/upgrade/LocationUpgradeConfig\n - api/common/upgrade/LocationUpgradeModule\n - api/common/upgrade/LocationUpgradeModule#config\n - api/core/Component\n - api/core/Directive\n - api/core/DoBootstrap\n - api/core/ElementRef\n - api/core/EventEmitter\n - api/core/Injectable\n - api/core/Injector\n - api/core/Input\n - api/core/NO_ERRORS_SCHEMA\n - api/core/NgModule\n - api/core/NgZone\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/Optional\n - api/core/Output\n - api/core/Pipe\n - api/core/PipeTransform\n - api/core/SimpleChanges\n - api/core/Type\n - api/core/Version\n - api/core/global\n - api/core/ng-content\n - api/core/testing/ComponentFixture\n - api/core/testing/TestBed\n - api/core/testing/waitForAsync\n - api/forms/FormsModule\n - api/forms/MaxValidator\n - api/forms/NgModel\n - api/forms/PatternValidator\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/BrowserModule\n - api/platform-browser/platformBrowser\n - api/router/ActivatedRoute\n - api/router/Router\n - api/router/RouterLink\n - api/router/RouterModule\n - api/router/RouterOutlet\n - api/router/Routes\n - api/router/UrlSegment\n - api/upgrade/static\n - api/upgrade/static/UpgradeComponent\n - api/upgrade/static/UpgradeModule\n - api/upgrade/static/downgradeComponent\n - api/upgrade/static/downgradeInjectable\n - guide/animations\n - guide/aot-compiler\n - guide/built-in-directives\n - guide/dependency-injection\n - guide/glossary#lazy-loading\n - guide/hierarchical-dependency-injection\n - guide/lifecycle-hooks\n - guide/ngmodules\n - guide/router\n - guide/typescript-configuration\n - guide/upgrade#add-the-angular-router\n - guide/upgrade#add-the-checkmarkpipe\n - guide/upgrade#adding-the-angular-router-and-bootstrap\n - guide/upgrade#aot-compile-the-hybrid-app\n - guide/upgrade#appendix-upgrading-phonecat-tests\n - guide/upgrade#bootstrapping-a-hybrid-phonecat\n - guide/upgrade#bootstrapping-hybrid-applications\n - guide/upgrade#change-detection\n - guide/upgrade#components-and-the-dom\n - guide/upgrade#configure-a-custom-route-matcher-for-angularjs-routes\n - guide/upgrade#create-a-component-to-render-angularjs-content\n - guide/upgrade#create-a-service-to-lazy-load-angularjs\n - guide/upgrade#create-the-routing-module\n - guide/upgrade#creating-the-appmodule\n - guide/upgrade#dependency-injection\n - guide/upgrade#e2e-tests\n - guide/upgrade#e2e-测试\n - guide/upgrade#follow-the-angularjs-style-guide\n - guide/upgrade#generate-links-for-each-phone\n - guide/upgrade#how-ngupgrade-works\n - guide/upgrade#installing-angular\n - guide/upgrade#lazy-loading-angularjs\n - guide/upgrade#making-angular-dependencies-injectable-to-angularjs\n - guide/upgrade#making-angularjs-dependencies-injectable-to-angular\n - guide/upgrade#migrating-to-typescript\n - guide/upgrade#ngupgrade-的工作原理\n - guide/upgrade#no-angular-filter-or-orderby-filters\n - guide/upgrade#phonecat-upgrade-tutorial\n - guide/upgrade#phonecat-升级教程\n - guide/upgrade#preparation\n - guide/upgrade#projecting-angularjs-content-into-angular-components\n - guide/upgrade#say-goodbye-to-angularjs\n - guide/upgrade#switching-to-typescript\n - guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\n - guide/upgrade#unit-tests\n - guide/upgrade#upgrading-components\n - guide/upgrade#upgrading-from-angularjs-to-angular\n - guide/upgrade#upgrading-the-phone-service\n - guide/upgrade#upgrading-with-ngupgrade\n - guide/upgrade#use-route-parameters\n - guide/upgrade#using-a-module-loader\n - guide/upgrade#using-angular-components-from-angularjs-code\n - guide/upgrade#using-angularjs-component-directives-from-angular-code\n - guide/upgrade#using-component-directives\n - guide/upgrade#using-the-unified-angular-location-service\n - guide/upgrade#using-upgrademodule-with-angular-ngmodules\n - guide/upgrade#为惰性加载-angularjs-创建一个服务\n - guide/upgrade#为每个电话生成链接\n - guide/upgrade#为那些-angularjs-路由配置自定义路由匹配器\n - guide/upgrade#从-angular-代码使用-angularjs-组件指令\n - guide/upgrade#从-angularjs-代码中使用-angular-组件\n - guide/upgrade#从-angularjs-升级到-angular\n - guide/upgrade#使用-ngupgrade-升级\n - guide/upgrade#使用模块加载器\n - guide/upgrade#使用组件型指令\n - guide/upgrade#使用统一的-angular-位置服务location\n - guide/upgrade#使用路由参数\n - guide/upgrade#依赖注入\n - guide/upgrade#再见angularjs\n - guide/upgrade#准备工作\n - guide/upgrade#切换到-typescript\n - guide/upgrade#创建-appmodule\n - guide/upgrade#创建一个用来渲染-angularjs-内容的组件\n - guide/upgrade#创建路由模块\n - guide/upgrade#升级-phone-服务\n - guide/upgrade#升级组件\n - guide/upgrade#单元测试\n - guide/upgrade#变更检测\n - guide/upgrade#安装-angular\n - guide/upgrade#对混合式应用做-aot-编译\n - guide/upgrade#引导-phonecat-的混合式应用\n - guide/upgrade#引导混合应用程序\n - guide/upgrade#惰性加载-angularjs\n - guide/upgrade#把-angular-的内容透传进-angularjs-的组件型指令\n - guide/upgrade#把-angularjs-的内容投影到-angular-组件中\n - guide/upgrade#没有-angular-filter-或-orderby-过滤器\n - guide/upgrade#添加-angular-路由器\n - guide/upgrade#添加-angular-路由器和引导程序\n - guide/upgrade#添加-checkmarkpipe\n - guide/upgrade#组件与-dom\n - guide/upgrade#让-angular-的依赖能被注入到-angularjs-中\n - guide/upgrade#让-angularjs-中的依赖可被注入到-angular\n - guide/upgrade#迁移到-typescript\n - guide/upgrade#通过-angular-的-ngmodule-来使用-upgrademodule\n - guide/upgrade#遵循-angularjs-风格指南\n - guide/upgrade#附录升级-phonecat-的测试\n - guide/upgrade-setup\n - http://browserify.org\n - https://blog.angular.io/finding-a-path-forward-with-angularjs-7e186fdd4429\n - https://docs.angularjs.org/api/ng/function/angular.bootstrap\n - https://docs.angularjs.org/api/ng/service/$location\n - https://docs.angularjs.org/api/ng/type/angular.Module\n - https://docs.angularjs.org/api/ng/type/angular.Module#component\n - https://docs.angularjs.org/api/ngRoute/directive/ngView\n - https://docs.angularjs.org/api/ngRoute/provider/$routeProvider\n - https://docs.angularjs.org/tutorial\n - https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#support-for-umd-module-definitions\n - https://github.com/angular/angular-cn/edit/cn/aio/content/guide/upgrade.md?message=docs%3A%20请简述你的修改...\n - https://github.com/angular/angular-phonecat\n - https://github.com/angular/angular-phonecat/commits/1.5-snapshot\n - https://github.com/angular/angular/issues/38366\n - https://github.com/angular/quickstart\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\n - https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\n - https://github.com/mgechev/angular-umd-bundle\n - https://github.com/systemjs/systemjs\n - https://rollupjs.org\n - https://webpack.github.io\n - https://www.npmjs.com/package/@types/angular\n-->"
}