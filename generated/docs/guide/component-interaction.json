{
  "id": "guide/component-interaction",
  "title": "组件之间的交互",
  "contents": "\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/cn/aio/content/guide/component-interaction.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"component-interaction\">Component interaction<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#component-interaction\"><i class=\"material-icons\">link</i></a></h1>\n<h1 id=\"组件之间的交互\">组件之间的交互<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#组件之间的交互\"><i class=\"material-icons\">link</i></a></h1>\n<p><a id=\"top\"></a></p>\n<p>This cookbook contains recipes for common component communication scenarios in which two or more components share information.</p>\n<p>本文包含了常见的组件通讯场景，也就是让两个或多个组件之间共享信息的方法。</p>\n<p><a id=\"toc\"></a></p>\n<!--\n\n# Contents\n\n# 目录\n\n* [Pass data from parent to child with input binding](guide/component-interaction#parent-to-child)\n\n  [使用输入绑定把数据从父组件传给子组件](guide/component-interaction#parent-to-child)\n\n* [Intercept input property changes with a setter](guide/component-interaction#parent-to-child-setter)\n\n  [使用赋值器（setter）拦截输入属性的变化](guide/component-interaction#parent-to-child-setter)\n\n* [Intercept input property changes with `ngOnChanges()`](guide/component-interaction#parent-to-child-on-changes)\n\n  [使用 `ngOnChanges()` 拦截输入属性的变化](guide/component-interaction#parent-to-child-on-changes)\n\n* [Parent calls an `@ViewChild()`](guide/component-interaction#parent-to-view-child)\n\n  [在父组件中调用 `@ViewChild()`](guide/component-interaction#parent-to-view-child)\n\n* [Parent and children communicate via a service](guide/component-interaction#bidirectional-service)\n\n  [通过服务进行父子通讯](guide/component-interaction#bidirectional-service)\n\n-->\n<p><strong>See the <live-example name=\"component-interaction\"></live-example></strong>.</p>\n<p><strong>参阅<live-example name=\"component-interaction\"></live-example></strong>。</p>\n<p><a id=\"parent-to-child\"></a></p>\n<h2 id=\"pass-data-from-parent-to-child-with-input-binding\">Pass data from parent to child with input binding<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#pass-data-from-parent-to-child-with-input-binding\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"通过输入型绑定把数据从父组件传到子组件\">通过输入型绑定把数据从父组件传到子组件。<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#通过输入型绑定把数据从父组件传到子组件\"><i class=\"material-icons\">link</i></a></h2>\n<p><code>HeroChildComponent</code> has two <strong><em>input properties</em></strong>, typically adorned with <a href=\"guide/inputs-outputs#input\">@Input() decorator</a>.</p>\n<p><code>HeroChildComponent</code> 有两个<strong><em>输入型属性</em></strong>，它们通常带<a href=\"guide/inputs-outputs#input\">@Input 装饰器</a>。</p>\n<code-example header=\"component-interaction/src/app/hero-child.component.ts\" path=\"component-interaction/src/app/hero-child.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\nimport { Hero } from './hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-child',\n  template: `\n    &#x3C;h3>{{hero.name}} says:&#x3C;/h3>\n    &#x3C;p>I, {{hero.name}}, am at your service, {{masterName}}.&#x3C;/p>\n  `\n})\nexport class HeroChildComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero!: Hero;\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('master') masterName = '';\n}\n\n</code-example>\n<p>The second <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> aliases the child component property name <code>masterName</code> as <code>'master'</code>.</p>\n<p>第二个 <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 为子组件的属性名 <code>masterName</code> 指定一个别名 <code>master</code>(译者注：不推荐为起别名，参阅风格指南).</p>\n<p>The <code>HeroParentComponent</code> nests the child <code>HeroChildComponent</code> inside an <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> repeater, binding its <code>master</code> string property to the child's <code>master</code> alias, and each iteration's <code>hero</code> instance to the child's <code>hero</code> property.</p>\n<p>父组件 <code>HeroParentComponent</code> 把子组件的 <code>HeroChildComponent</code> 放到 <code>*<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a></code> 循环器中，把自己的 <code>master</code> 字符串属性绑定到子组件的 <code>master</code> 别名上，并把每个循环的 <code>hero</code> 实例绑定到子组件的 <code>hero</code> 属性。</p>\n<code-example header=\"component-interaction/src/app/hero-parent.component.ts\" path=\"component-interaction/src/app/hero-parent.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { HEROES } from './hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-parent',\n  template: `\n    &#x3C;h2>{{master}} controls {{heroes.length}} heroes&#x3C;/h2>\n\n    &#x3C;app-hero-child\n      *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"\n      [hero]=\"hero\"\n      [master]=\"master\">\n    &#x3C;/app-hero-child>\n  `\n})\nexport class HeroParentComponent {\n  heroes = HEROES;\n  master = 'Master';\n}\n\n</code-example>\n<p>The running application displays three heroes:</p>\n<p>运行应用程序会显示三个英雄：</p>\n<div class=\"lightbox\">\n<img alt=\"Parent-to-child\" src=\"generated/images/guide/component-interaction/parent-to-child.png\" width=\"346\" height=\"298\">\n</div>\n<h3 id=\"test-it-for-pass-data-from-parent-to-child-with-input-binding\">Test it for Pass data from parent to child with input binding<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it-for-pass-data-from-parent-to-child-with-input-binding\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"测试它以了解如何借助输入绑定将数据从父级传递给子级\">测试它，以了解如何借助输入绑定将数据从父级传递给子级<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#测试它以了解如何借助输入绑定将数据从父级传递给子级\"><i class=\"material-icons\">link</i></a></h3>\n<p>E2E test that all children were instantiated and displayed as expected:</p>\n<p>端到端测试，用于确保所有的子组件都如预期般初始化并显示出来：</p>\n<code-example header=\"component-interaction/e2e/src/app.e2e-spec.ts\" path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"parent-to-child\">\n// ...\nconst heroNames = ['Dr. IQ', 'Magneta', 'Bombasto'];\nconst masterName = 'Master';\n\nit('should pass properties to children properly', async () => {\n  const parent = element(by.tagName('app-hero-parent'));\n  const heroes = parent.all(by.tagName('app-hero-child'));\n\n  for (let i = 0; i &#x3C; heroNames.length; i++) {\n    const childTitle = await heroes.get(i).element(by.tagName('h3')).getText();\n    const childDetail = await heroes.get(i).element(by.tagName('p')).getText();\n    expect(childTitle).toEqual(heroNames[i] + ' says:');\n    expect(childDetail).toContain(masterName);\n  }\n});\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n<p><a href=\"guide/component-interaction#top\">回到顶部</a></p>\n<p><a id=\"parent-to-child-setter\"></a></p>\n<h2 id=\"intercept-input-property-changes-with-a-setter\">Intercept input property changes with a setter<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#intercept-input-property-changes-with-a-setter\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"通过-setter-截听输入属性值的变化\">通过 setter 截听输入属性值的变化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#通过-setter-截听输入属性值的变化\"><i class=\"material-icons\">link</i></a></h2>\n<p>Use an input property setter to intercept and act upon a value from the parent.</p>\n<p>使用一个输入属性的 setter，以拦截父组件中值的变化，并采取行动。</p>\n<p>The setter of the <code>name</code> input property in the child <code>NameChildComponent</code> trims the whitespace from a name and replaces an empty value with default text.</p>\n<p>子组件 <code>NameChildComponent</code> 的输入属性 <code>name</code> 上的这个 setter，会 trim 掉名字里的空格，并把空值替换成默认字符串。</p>\n<code-example header=\"component-interaction/src/app/name-child.component.ts\" path=\"component-interaction/src/app/name-child.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-name-child',\n  template: '&#x3C;h3>\"{{name}}\"&#x3C;/h3>'\n})\nexport class NameChildComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  get name(): string { return this._name; }\n  set name(name: string) {\n    this._name = (name &#x26;&#x26; name.trim()) || '&#x3C;no name set>';\n  }\n  private _name = '';\n}\n\n</code-example>\n<p>Here's the <code>NameParentComponent</code> demonstrating name variations including a name with all spaces:</p>\n<p>下面的 <code>NameParentComponent</code> 展示了各种名字的处理方式，包括一个全是空格的名字。</p>\n<code-example header=\"component-interaction/src/app/name-parent.component.ts\" path=\"component-interaction/src/app/name-parent.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-name-parent',\n  template: `\n    &#x3C;h2>Master controls {{names.length}} names&#x3C;/h2>\n\n    &#x3C;app-name-child *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let name of names\" [name]=\"name\">&#x3C;/app-name-child>\n  `\n})\nexport class NameParentComponent {\n  // Displays 'Dr. IQ', '&#x3C;no name set>', 'Bombasto'\n  names = ['Dr. IQ', '   ', '  Bombasto  '];\n}\n\n</code-example>\n<div class=\"lightbox\">\n<img alt=\"Parent-to-child-setter\" src=\"generated/images/guide/component-interaction/setter.png\" width=\"332\" height=\"190\">\n</div>\n<h3 id=\"test-it-for-intercept-input-property-changes-with-a-setter\">Test it for Intercept input property changes with a setter<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it-for-intercept-input-property-changes-with-a-setter\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"测试它以了解如何使用设置器拦截输入属性更改\">测试它，以了解如何使用设置器拦截输入属性更改<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#测试它以了解如何使用设置器拦截输入属性更改\"><i class=\"material-icons\">link</i></a></h3>\n<p>E2E tests of input property setter with empty and non-empty names:</p>\n<p>端到端测试：输入属性的 setter，分别使用空名字和非空名字。</p>\n<code-example header=\"component-interaction/e2e/src/app.e2e-spec.ts\" path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"parent-to-child-setter\">\n// ...\nit('should display trimmed, non-empty names', async () => {\n  const nonEmptyNameIndex = 0;\n  const nonEmptyName = '\"Dr. IQ\"';\n  const parent = element(by.tagName('app-name-parent'));\n  const hero = parent.all(by.tagName('app-name-child')).get(nonEmptyNameIndex);\n\n  const displayName = await hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(nonEmptyName);\n});\n\nit('should replace empty name with default name', async () => {\n  const emptyNameIndex = 1;\n  const defaultName = '\"&#x3C;no name set>\"';\n  const parent = element(by.tagName('app-name-parent'));\n  const hero = parent.all(by.tagName('app-name-child')).get(emptyNameIndex);\n\n  const displayName = await hero.element(by.tagName('h3')).getText();\n  expect(displayName).toEqual(defaultName);\n});\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n<p><a href=\"guide/component-interaction#top\">回到顶部</a></p>\n<p><a id=\"parent-to-child-on-changes\"></a></p>\n<h2 id=\"intercept-input-property-changes-with-ngonchanges\">Intercept input property changes with <code>ngOnChanges()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#intercept-input-property-changes-with-ngonchanges\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"通过-ngonchanges-来截听输入属性值的变化\">通过 <code>ngOnChanges()</code> 来截听输入属性值的变化<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#通过-ngonchanges-来截听输入属性值的变化\"><i class=\"material-icons\">link</i></a></h2>\n<p>Detect and act upon changes to input property values with the <code>ngOnChanges()</code> method of the <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> lifecycle hook interface.</p>\n<p>使用 <code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> 生命周期钩子接口的 <code>ngOnChanges()</code> 方法来监测输入属性值的变化并做出回应。</p>\n<div class=\"alert is-helpful\">\n<p>You might prefer this approach to the property setter when watching multiple, interacting input properties.</p>\n<p>当需要监视多个、交互式输入属性的时候，本方法比用属性的 setter 更合适。</p>\n<p>Learn about <code>ngOnChanges()</code> in the <a href=\"guide/lifecycle-hooks\">Lifecycle Hooks</a> chapter.</p>\n<p>学习关于 <code>ngOnChanges()</code> 的更多知识，参阅<a href=\"guide/lifecycle-hooks\">生命周期钩子</a>一章。</p>\n</div>\n<p>This <code>VersionChildComponent</code> detects changes to the <code>major</code> and <code>minor</code> input properties and composes a log message reporting these changes:</p>\n<p>这个 <code>VersionChildComponent</code> 会监测输入属性 <code>major</code> 和 <code>minor</code> 的变化，并把这些变化编写成日志以报告这些变化。</p>\n<code-example header=\"component-interaction/src/app/version-child.component.ts\" path=\"component-interaction/src/app/version-child.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a>, <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-version-child',\n  template: `\n    &#x3C;h3><a href=\"api/core/Version\" class=\"code-anchor\">Version</a> {{major}}.{{minor}}&#x3C;/h3>\n    &#x3C;h4>Change log:&#x3C;/h4>\n    &#x3C;ul>\n      &#x3C;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let change of changeLog\">{{change}}&#x3C;/li>\n    &#x3C;/ul>\n  `\n})\nexport class VersionChildComponent implements <a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() major = 0;\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() minor = 0;\n  changeLog: string[] = [];\n\n  ngOnChanges(changes: <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a>) {\n    const log: string[] = [];\n    for (const propName in changes) {\n      const changedProp = changes[propName];\n      const to = JSON.stringify(changedProp.currentValue);\n      if (changedProp.isFirstChange()) {\n        log.push(`Initial value of ${propName} set to ${to}`);\n      } else {\n        const from = JSON.stringify(changedProp.previousValue);\n        log.push(`${propName} changed from ${from} to ${to}`);\n      }\n    }\n    this.changeLog.push(log.join(', '));\n  }\n}\n\n</code-example>\n<p>The <code>VersionParentComponent</code> supplies the <code>minor</code> and <code>major</code> values and binds buttons to methods that change them.</p>\n<p><code>VersionParentComponent</code> 提供 <code>minor</code> 和 <code>major</code> 值，把修改它们值的方法绑定到按钮上。</p>\n<code-example header=\"component-interaction/src/app/version-parent.component.ts\" path=\"component-interaction/src/app/version-parent.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-version-parent',\n  template: `\n    &#x3C;h2>Source code version&#x3C;/h2>\n    &#x3C;button type=\"button\" (click)=\"newMinor()\">New minor version&#x3C;/button>\n    &#x3C;button type=\"button\" (click)=\"newMajor()\">New major version&#x3C;/button>\n    &#x3C;app-version-child [major]=\"major\" [minor]=\"minor\">&#x3C;/app-version-child>\n  `\n})\nexport class VersionParentComponent {\n  major = 1;\n  minor = 23;\n\n  newMinor() {\n    this.minor++;\n  }\n\n  newMajor() {\n    this.major++;\n    this.minor = 0;\n  }\n}\n\n</code-example>\n<p>Here's the output of a button-pushing sequence:</p>\n<p>下面是点击按钮的结果。</p>\n<div class=\"lightbox\">\n<img alt=\"Parent-to-child-onchanges\" src=\"generated/images/guide/component-interaction/parent-to-child-on-changes.gif\" width=\"481\" height=\"264\">\n</div>\n<h3 id=\"test-it-for-intercept-input-property-changes-with-ngonchanges\">Test it for Intercept input property changes with <code>ngOnChanges()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it-for-intercept-input-property-changes-with-ngonchanges\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"测试它以了解如何使用-ngonchanges-来拦截输入属性更改\">测试它，以了解如何使用 <code>ngOnChanges()</code> 来拦截输入属性更改<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#测试它以了解如何使用-ngonchanges-来拦截输入属性更改\"><i class=\"material-icons\">link</i></a></h3>\n<p>Test that <strong><em>both</em></strong> input properties are set initially and that button clicks trigger the expected <code>ngOnChanges</code> calls and values:</p>\n<p>测试确保<strong><em>这两个</em></strong>输入属性值都被初始化了，当点击按钮后，<code>ngOnChanges</code> 应该被调用，属性的值也符合预期。</p>\n<code-example header=\"component-interaction/e2e/src/app.e2e-spec.ts\" path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"parent-to-child-onchanges\">\n// ...\n// Test must all execute in this exact order\nit('should set expected initial values', async () => {\n  const actual = await getActual();\n\n  const initialLabel = '<a href=\"api/core/Version\" class=\"code-anchor\">Version</a> 1.23';\n  const initialLog = 'Initial value of major set to 1, Initial value of minor set to 23';\n\n  expect(actual.label).toBe(initialLabel);\n  expect(actual.count).toBe(1);\n  expect(await actual.logs.get(0).getText()).toBe(initialLog);\n});\n\nit(\"should set expected values after clicking 'Minor' twice\", async () => {\n  const repoTag = element(by.tagName('app-version-parent'));\n  const newMinorButton = repoTag.all(by.tagName('button')).get(0);\n\n  await newMinorButton.click();\n  await newMinorButton.click();\n\n  const actual = await getActual();\n\n  const labelAfter2Minor = '<a href=\"api/core/Version\" class=\"code-anchor\">Version</a> 1.25';\n  const logAfter2Minor = 'minor changed from 24 to 25';\n\n  expect(actual.label).toBe(labelAfter2Minor);\n  expect(actual.count).toBe(3);\n  expect(await actual.logs.get(2).getText()).toBe(logAfter2Minor);\n});\n\nit(\"should set expected values after clicking 'Major' once\", async () => {\n  const repoTag = element(by.tagName('app-version-parent'));\n  const newMajorButton = repoTag.all(by.tagName('button')).get(1);\n\n  await newMajorButton.click();\n  const actual = await getActual();\n\n  const labelAfterMajor = '<a href=\"api/core/Version\" class=\"code-anchor\">Version</a> 2.0';\n  const logAfterMajor = 'major changed from 1 to 2, minor changed from 23 to 0';\n\n  expect(actual.label).toBe(labelAfterMajor);\n  expect(actual.count).toBe(2);\n  expect(await actual.logs.get(1).getText()).toBe(logAfterMajor);\n});\n\nasync function getActual() {\n  const versionTag = element(by.tagName('app-version-child'));\n  const label = await versionTag.element(by.tagName('h3')).getText();\n  const ul = versionTag.element((by.tagName('ul')));\n  const logs = ul.all(by.tagName('li'));\n\n  return {\n    label,\n    logs,\n    count: await logs.count(),\n  };\n}\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n<p><a href=\"guide/component-interaction#top\">回到顶部</a></p>\n<p><a id=\"child-to-parent\"></a></p>\n<h2 id=\"parent-listens-for-child-event\">Parent listens for child event<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#parent-listens-for-child-event\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"父组件监听子组件的事件\">父组件监听子组件的事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#父组件监听子组件的事件\"><i class=\"material-icons\">link</i></a></h2>\n<p>The child component exposes an <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> property with which it <code>emits</code> events when something happens.\nThe parent binds to that event property and reacts to those events.</p>\n<p>子组件暴露一个 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 属性，当事件发生时，子组件利用该属性 <code>emits</code>(向上弹射)事件。父组件绑定到这个事件属性，并在事件发生时作出回应。</p>\n<p>The child's <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> property is an <strong><em>output property</em></strong>, typically adorned with an <a href=\"guide/inputs-outputs#output\">@Output() decorator</a> as seen in this <code>VoterComponent</code>:</p>\n<p>子组件的 <code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 属性是一个<strong>输出属性</strong>，通常带有<a href=\"guide/inputs-outputs#output\">@Output 装饰器</a>，就像在 <code>VoterComponent</code> 中看到的。</p>\n<code-example header=\"component-interaction/src/app/voter.component.ts\" path=\"component-interaction/src/app/voter.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-voter',\n  template: `\n    &#x3C;h4>{{name}}&#x3C;/h4>\n    &#x3C;button type=\"button\" (click)=\"vote(true)\"  [disabled]=\"didVote\">Agree&#x3C;/button>\n    &#x3C;button type=\"button\" (click)=\"vote(false)\" [disabled]=\"didVote\">Disagree&#x3C;/button>\n  `\n})\nexport class VoterComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()  name = '';\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() voted = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;boolean>();\n  didVote = false;\n\n  vote(agreed: boolean) {\n    this.voted.emit(agreed);\n    this.didVote = true;\n  }\n}\n\n</code-example>\n<p>Clicking a button triggers emission of a <code>true</code> or <code>false</code>, the boolean <em>payload</em>.</p>\n<p>点击按钮会触发 <code>true</code> 或 <code>false</code>(布尔型<em>有效载荷</em>)的事件。</p>\n<p>The parent <code>VoteTakerComponent</code> binds an event handler called <code>onVoted()</code> that responds to the child event payload <code>$event</code> and updates a counter.</p>\n<p>父组件 <code>VoteTakerComponent</code> 绑定了一个事件处理器(<code>onVoted()</code>)，用来响应子组件的事件(<code>$event</code>)并更新一个计数器。</p>\n<code-example header=\"component-interaction/src/app/votetaker.component.ts\" path=\"component-interaction/src/app/votetaker.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-vote-taker',\n  template: `\n    &#x3C;h2>Should mankind colonize the Universe?&#x3C;/h2>\n    &#x3C;h3>Agree: {{agreed}}, Disagree: {{disagreed}}&#x3C;/h3>\n\n    &#x3C;app-voter\n      *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let voter of voters\"\n      [name]=\"voter\"\n      (voted)=\"onVoted($event)\">\n    &#x3C;/app-voter>\n  `\n})\nexport class VoteTakerComponent {\n  agreed = 0;\n  disagreed = 0;\n  voters = ['Dr. IQ', 'Celeritas', 'Bombasto'];\n\n  onVoted(agreed: boolean) {\n    if (agreed) {\n      this.agreed++;\n    } else {\n      this.disagreed++;\n    }\n  }\n}\n\n</code-example>\n<p>The framework passes the event argument —represented by <code>$event</code>— to the handler method, and the method processes it:</p>\n<p>本框架把事件参数(用 <code>$event</code> 表示)传给事件处理方法，该方法会处理它：</p>\n<div class=\"lightbox\">\n<img alt=\"Child-to-parent\" src=\"generated/images/guide/component-interaction/child-to-parent.gif\" width=\"476\" height=\"524\">\n</div>\n<h3 id=\"test-it-for-parent-listens-for-child-event\">Test it for Parent listens for child event<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it-for-parent-listens-for-child-event\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"测试它以了解如何用父级监听子级的事件\">测试它，以了解如何用父级监听子级的事件<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#测试它以了解如何用父级监听子级的事件\"><i class=\"material-icons\">link</i></a></h3>\n<p>Test that clicking the <em>Agree</em> and <em>Disagree</em> buttons update the appropriate counters:</p>\n<p>测试确保点击 <em>Agree</em> 和 <em>Disagree</em> 按钮时，计数器被正确更新。</p>\n<code-example header=\"component-interaction/e2e/src/app.e2e-spec.ts\" path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"child-to-parent\">\n// ...\nit('should not emit the event initially', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 0');\n});\n\nit('should process Agree vote', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  const agreeButton1 = element.all(by.tagName('app-voter')).get(0)\n    .all(by.tagName('button')).get(0);\n\n  await agreeButton1.click();\n\n  expect(await voteLabel.getText()).toBe('Agree: 1, Disagree: 0');\n});\n\nit('should process Disagree vote', async () => {\n  const voteLabel = element(by.tagName('app-vote-taker')).element(by.tagName('h3'));\n  const agreeButton1 = element.all(by.tagName('app-voter')).get(1)\n    .all(by.tagName('button')).get(1);\n\n  await agreeButton1.click();\n\n  expect(await voteLabel.getText()).toBe('Agree: 0, Disagree: 1');\n});\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n<p><a href=\"guide/component-interaction#top\">回到顶部</a></p>\n<h2 id=\"parent-interacts-with-child-using-local-variable\">Parent interacts with child using <em>local variable</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#parent-interacts-with-child-using-local-variable\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"父组件与子组件通过本地变量互动\">父组件与子组件通过<em>本地变量</em>互动<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#父组件与子组件通过本地变量互动\"><i class=\"material-icons\">link</i></a></h2>\n<p>A parent component cannot use data binding to read child properties or invoke child methods.\nDo both by creating a template reference variable for the child element and then reference that variable <em>within the parent template</em> as seen in the following example.</p>\n<p>父组件不能使用数据绑定来读取子组件的属性或调用子组件的方法。但可以在父组件模板里，新建一个本地变量来代表子组件，然后利用这个变量来读取子组件的属性和调用子组件的方法，如下例所示。</p>\n<p><a id=\"countdown-timer-example\"></a></p>\n<p>The following is a child <code>CountdownTimerComponent</code> that repeatedly counts down to zero and launches a rocket.\nThe <code>start</code> and <code>stop</code> methods control the clock and a countdown status message displays in its own template.</p>\n<p>子组件 <code>CountdownTimerComponent</code> 进行倒计时，归零时发射一个导弹。<code>start</code> 和 <code>stop</code> 方法负责控制时钟并在模板里显示倒计时的状态信息。</p>\n<code-example header=\"component-interaction/src/app/countdown-timer.component.ts\" path=\"component-interaction/src/app/countdown-timer.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-countdown-timer',\n  template: '&#x3C;p>{{message}}&#x3C;/p>'\n})\nexport class CountdownTimerComponent implements <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n\n  intervalId = 0;\n  message = '';\n  seconds = 11;\n\n  ngOnDestroy() { this.clearTimer(); }\n\n  start() { this.countDown(); }\n  stop()  {\n    this.clearTimer();\n    this.message = `Holding at T-${this.seconds} seconds`;\n  }\n\n  private clearTimer() { clearInterval(this.intervalId); }\n\n  private countDown() {\n    this.clearTimer();\n    this.intervalId = window.setInterval(() => {\n      this.seconds -= 1;\n      if (this.seconds === 0) {\n        this.message = 'Blast off!';\n      } else {\n        if (this.seconds &#x3C; 0) { this.seconds = 10; } // reset\n        this.message = `T-${this.seconds} seconds and counting`;\n      }\n    }, 1000);\n  }\n}\n\n\n</code-example>\n<p>The <code>CountdownLocalVarParentComponent</code> that hosts the timer component is as follows:</p>\n<p>计时器组件的宿主组件 <code>CountdownLocalVarParentComponent</code> 如下：</p>\n<code-example header=\"component-interaction/src/app/countdown-parent.component.ts\" path=\"component-interaction/src/app/countdown-parent.component.ts\" region=\"lv\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { CountdownTimerComponent } from './countdown-timer.component';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-countdown-parent-lv',\n  template: `\n    &#x3C;h3>Countdown to Liftoff (via local variable)&#x3C;/h3>\n    &#x3C;button type=\"button\" (click)=\"timer.start()\">Start&#x3C;/button>\n    &#x3C;button type=\"button\" (click)=\"timer.stop()\">Stop&#x3C;/button>\n    &#x3C;div class=\"seconds\">{{timer.seconds}}&#x3C;/div>\n    &#x3C;app-countdown-timer #timer>&#x3C;/app-countdown-timer>\n  `,\n  styleUrls: ['../assets/demo.css']\n})\nexport class CountdownLocalVarParentComponent { }\n\n</code-example>\n<p>The parent component cannot data bind to the child's <code>start</code> and <code>stop</code> methods nor to its <code>seconds</code> property.</p>\n<p>父组件不能通过数据绑定使用子组件的 <code>start</code> 和 <code>stop</code> 方法，也不能访问子组件的 <code>seconds</code> 属性。</p>\n<p>Place a local variable, <code>#timer</code>, on the tag <code>&#x3C;app-countdown-timer></code> representing the child component.\nThat gives you a reference to the child component and the ability to access <em>any of its properties or methods</em> from within the parent template.</p>\n<p>把本地变量(<code>#timer</code>)放到(<code>&#x3C;app-countdown-timer></code>)标签中，用来代表子组件。这样父组件的模板就得到了子组件的引用，于是可以在父组件的模板中访问子组件的所有属性和方法。</p>\n<p>This example wires parent buttons to the child's <code>start</code> and <code>stop</code> and uses interpolation to display the child's <code>seconds</code> property.</p>\n<p>这个例子把父组件的按钮绑定到子组件的 <code>start</code> 和 <code>stop</code> 方法，并用插值来显示子组件的 <code>seconds</code> 属性。</p>\n<p>Here, the parent and child are working together.</p>\n<p>下面是父组件和子组件一起工作时的效果。</p>\n<div class=\"lightbox\">\n<img alt=\"countdown timer\" src=\"generated/images/guide/component-interaction/countdown-timer-anim.gif\" width=\"212\" height=\"172\">\n</div>\n<p><a id=\"countdown-tests\"></a></p>\n<h3 id=\"test-it-for-parent-interacts-with-child-using-local-variable\">Test it for Parent interacts with child using <em>local variable</em><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it-for-parent-interacts-with-child-using-local-variable\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"测试它以了解父级如何使用局部变量与其子级交互\">测试它，以了解父级如何使用<em>局部变量</em>与其子级交互<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#测试它以了解父级如何使用局部变量与其子级交互\"><i class=\"material-icons\">link</i></a></h3>\n<p>Test that the seconds displayed in the parent template match the seconds displayed in the child's status message.\nTest also that clicking the <em>Stop</em> button pauses the countdown timer:</p>\n<p>测试确保在父组件模板中显示的秒数和子组件状态信息里的秒数同步。它还会点击 <em>Stop</em> 按钮来停止倒计时：</p>\n<code-example header=\"component-interaction/e2e/src/app.e2e-spec.ts\" path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"countdown-timer-tests\">\n// ...\n// The tests <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> periodic asynchronous operations (via `setInterval()`), which will prevent\n// the app from stabilizing. See https://angular.io/api/core/<a href=\"api/core/ApplicationRef\" class=\"code-anchor\">ApplicationRef</a>#is-stable-examples\n// for more details.\n// To allow the tests to complete, we will disable automatically waiting for the Angular app to\n// stabilize.\nbeforeEach(() => browser.waitForAngularEnabled(false));\nafterEach(() => browser.waitForAngularEnabled(true));\n\nit('timer and parent seconds should match', async () => {\n  const parent = element(by.tagName(parentTag));\n  const startButton = parent.element(by.buttonText('Start'));\n  const seconds = parent.element(by.className('seconds'));\n  const timer = parent.element(by.tagName('app-countdown-timer'));\n\n  await startButton.click();\n\n  // Wait for `&#x3C;app-countdown-timer>` to be populated with any text.\n  await browser.wait(() => timer.getText(), 2000);\n\n  expect(await timer.getText()).toContain(await seconds.getText());\n});\n\nit('should stop the countdown', async () => {\n  const parent = element(by.tagName(parentTag));\n  const startButton = parent.element(by.buttonText('Start'));\n  const stopButton = parent.element(by.buttonText('Stop'));\n  const timer = parent.element(by.tagName('app-countdown-timer'));\n\n  await startButton.click();\n  expect(await timer.getText()).not.toContain('Holding');\n\n  await stopButton.click();\n  expect(await timer.getText()).toContain('Holding');\n});\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n<p><a href=\"guide/component-interaction#top\">回到顶部</a></p>\n<p><a id=\"parent-to-view-child\"></a></p>\n<h2 id=\"parent-calls-an-viewchild\">Parent calls an <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#parent-calls-an-viewchild\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"父级调用-viewchild\">父级调用 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#父级调用-viewchild\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <em>local variable</em> approach is straightforward.\nBut it is limited because the parent-child wiring must be done entirely within the parent template.\nThe parent component <em>itself</em> has no access to the child.</p>\n<p>这个<em>本地变量</em>方法是个简单明了的方法。但是它也有局限性，因为父组件-子组件的连接必须全部在父组件的模板中进行。父组件本身的代码对子组件没有访问权。</p>\n<p>You can't use the <em>local variable</em> technique if the parent component's <em>class</em> relies on the child component's <em>class</em>.\nThe parent-child relationship of the components is not established within each component's respective <em>class</em> with the <em>local variable</em> technique.\nBecause the <em>class</em> instances are not connected to one another, the parent <em>class</em> cannot access the child <em>class</em> properties and methods.</p>\n<p>如果父组件的<em>类</em>需要依赖于子组件类，就不能使用<em>本地变量</em>方法。组件之间的父子关系 组件的父子关系不能通过在每个组件的<em>类</em>中各自定义<em>本地变量</em>来建立。这是因为这两个<em>类</em>的实例互相不知道，因此父<em>类</em>也就不能访问子<em>类</em>中的属性和方法。</p>\n<p>When the parent component <em>class</em> requires that kind of access, <strong><em>inject</em></strong> the child component into the parent as a <em>ViewChild</em>.</p>\n<p>当父组件<em>类</em>需要这种访问时，可以把子组件作为 <em>ViewChild</em>，<strong><em>注入</em></strong>到父组件里面。</p>\n<p>The following example illustrates this technique with the same <a href=\"guide/component-interaction#countdown-timer-example\">Countdown Timer</a> example.\nNeither its appearance nor its behavior changes.\nThe child <a href=\"guide/component-interaction#countdown-timer-example\">CountdownTimerComponent</a> is the same as well.</p>\n<p>下面的例子用与<a href=\"guide/component-interaction#countdown-timer-example\">倒计时</a>相同的范例来解释这种技术。它的外观或行为没有变化。子组件<a href=\"guide/component-interaction#countdown-timer-example\">CountdownTimerComponent</a>也和原来一样。</p>\n<div class=\"alert is-helpful\">\n<p>The switch from the <em>local variable</em> to the <em>ViewChild</em> technique is solely for the purpose of demonstration.</p>\n<p>由<em>本地变量</em>切换到 <em>ViewChild</em> 技术的唯一目的就是做示范。</p>\n</div>\n<p>Here is the parent, <code>CountdownViewChildParentComponent</code>:</p>\n<p>下面是父组件 <code>CountdownViewChildParentComponent</code>:</p>\n<code-example header=\"component-interaction/src/app/countdown-parent.component.ts\" path=\"component-interaction/src/app/countdown-parent.component.ts\" region=\"vc\">\nimport { <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>, <a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a> } from '@angular/core';\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { CountdownTimerComponent } from './countdown-timer.component';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-countdown-parent-vc',\n  template: `\n    &#x3C;h3>Countdown to Liftoff (via <a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>)&#x3C;/h3>\n    &#x3C;button type=\"button\" (click)=\"start()\">Start&#x3C;/button>\n    &#x3C;button type=\"button\" (click)=\"stop()\">Stop&#x3C;/button>\n    &#x3C;div class=\"seconds\">{{ seconds() }}&#x3C;/div>\n    &#x3C;app-countdown-timer>&#x3C;/app-countdown-timer>\n  `,\n  styleUrls: ['../assets/demo.css']\n})\nexport class CountdownViewChildParentComponent implements <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(CountdownTimerComponent)\n  private timerComponent!: CountdownTimerComponent;\n\n  seconds() { return 0; }\n\n  ngAfterViewInit() {\n    // Redefine `seconds()` to get from the `CountdownTimerComponent.seconds` ...\n    // but wait a <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> first to avoid one-time devMode\n    // unidirectional-data-flow-violation error\n    setTimeout(() => this.seconds = () => this.timerComponent.seconds, 0);\n  }\n\n  start() { this.timerComponent.start(); }\n  stop() { this.timerComponent.stop(); }\n}\n\n</code-example>\n<p>It takes a bit more work to get the child view into the parent component <em>class</em>.</p>\n<p>把子组件的视图插入到父组件类需要做一点额外的工作。</p>\n<p>First, you have to import references to the <code><a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> decorator and the <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a></code> lifecycle hook.</p>\n<p>首先，你必须导入对装饰器 <code><a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 以及生命周期钩子 <code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a></code> 的引用。</p>\n<p>Next, inject the child <code>CountdownTimerComponent</code> into the private <code>timerComponent</code> property using the <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> property decoration.</p>\n<p>接着，通过 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code> 属性装饰器，将子组件 <code>CountdownTimerComponent</code> 注入到私有属性 <code>timerComponent</code> 里面。</p>\n<p>The <code>#timer</code> local variable is gone from the component metadata.\nInstead, bind the buttons to the parent component's own <code>start</code> and <code>stop</code> methods and present the ticking seconds in an interpolation around the parent component's <code>seconds</code> method.</p>\n<p>组件元数据里就不再需要 <code>#timer</code> 本地变量了。而是把按钮绑定到父组件自己的 <code>start</code> 和 <code>stop</code> 方法，使用父组件的 <code>seconds</code> 方法的插值来展示秒数变化。</p>\n<p>These methods access the injected timer component directly.</p>\n<p>这些方法可以直接访问被注入的计时器组件。</p>\n<p>The <code>ngAfterViewInit()</code> lifecycle hook is an important wrinkle.\nThe timer component isn't available until <em>after</em> Angular displays the parent view.\nSo it displays <code>0</code> seconds initially.</p>\n<p><code>ngAfterViewInit()</code> 生命周期钩子是非常重要的一步。被注入的计时器组件只有在 Angular 显示了父组件视图之后才能访问，所以它先把秒数显示为 0。</p>\n<p>Then Angular calls the <code>ngAfterViewInit</code> lifecycle hook at which time it is <em>too late</em> to update the parent view's display of the countdown seconds.\nAngular's unidirectional data flow rule prevents updating the parent view's in the same cycle.\nThe application must <em>wait one turn</em> before it can display the seconds.</p>\n<p>然后 Angular 会调用 <code>ngAfterViewInit</code> 生命周期钩子，但这时候再更新父组件视图的倒计时就已经太晚了。Angular 的单向数据流规则会阻止在同一个周期内更新父组件视图。应用在显示秒数之前会被迫<em>再等一轮</em>。</p>\n<p>Use <code>setTimeout()</code> to wait one tick and then revise the <code>seconds()</code> method so that it takes future values from the timer component.</p>\n<p>使用 <code>setTimeout()</code> 来等下一轮，然后改写 <code>seconds()</code> 方法，这样它接下来就会从注入的这个计时器组件里获取秒数的值。</p>\n<h3 id=\"test-it-for-parent-calls-an-viewchild\">Test it for Parent calls an <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it-for-parent-calls-an-viewchild\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"测试它以了解父级如何调用-viewchild\">测试它，以了解父级如何调用 <code>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>()</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#测试它以了解父级如何调用-viewchild\"><i class=\"material-icons\">link</i></a></h3>\n<p>Use <a href=\"guide/component-interaction#countdown-tests\">the same countdown timer tests</a> as before.</p>\n<p>使用和之前<a href=\"guide/component-interaction#countdown-tests\">一样的倒计时测试</a>。</p>\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n<p><a href=\"guide/component-interaction#top\">回到顶部</a></p>\n<p><a id=\"bidirectional-service\"></a></p>\n<h2 id=\"parent-and-children-communicate-using-a-service\">Parent and children communicate using a service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#parent-and-children-communicate-using-a-service\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"父组件和子组件通过服务来通讯\">父组件和子组件通过服务来通讯<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#父组件和子组件通过服务来通讯\"><i class=\"material-icons\">link</i></a></h2>\n<p>A parent component and its children share a service whose interface enables bidirectional communication <em>within the family</em>.</p>\n<p>父组件和它的子组件共享同一个服务，利用该服务<em>在组件家族内部</em>实现双向通讯。</p>\n<p>The scope of the service instance is the parent component and its children.\nComponents outside this component subtree have no access to the service or their communications.</p>\n<p>该服务实例的作用域被限制在父组件和其子组件内。这个组件子树之外的组件将无法访问该服务或者与它们通讯。</p>\n<p>This <code>MissionService</code> connects the <code>MissionControlComponent</code> to multiple <code>AstronautComponent</code> children.</p>\n<p>这个 <code>MissionService</code> 把 <code>MissionControlComponent</code> 和多个 <code>AstronautComponent</code> 子组件连接起来。</p>\n<code-example header=\"component-interaction/src/app/mission.service.ts\" path=\"component-interaction/src/app/mission.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class MissionService {\n\n  // Observable string sources\n  private missionAnnouncedSource = new Subject&#x3C;string>();\n  private missionConfirmedSource = new Subject&#x3C;string>();\n\n  // Observable string streams\n  missionAnnounced$ = this.missionAnnouncedSource.asObservable();\n  missionConfirmed$ = this.missionConfirmedSource.asObservable();\n\n  // Service message commands\n  announceMission(mission: string) {\n    this.missionAnnouncedSource.next(mission);\n  }\n\n  confirmMission(astronaut: string) {\n    this.missionConfirmedSource.next(astronaut);\n  }\n}\n\n</code-example>\n<p>The <code>MissionControlComponent</code> both provides the instance of the service that it shares with its children (through the <code>providers</code> metadata array) and injects that instance into itself through its constructor:</p>\n<p><code>MissionControlComponent</code> 提供服务的实例，并将其共享给它的子组件(通过 <code>providers</code> 元数据数组)，子组件可以通过构造函数将该实例注入到自身。</p>\n<code-example header=\"component-interaction/src/app/missioncontrol.component.ts\" path=\"component-interaction/src/app/missioncontrol.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { MissionService } from './mission.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-mission-control',\n  template: `\n    &#x3C;h2>Mission Control&#x3C;/h2>\n    &#x3C;button type=\"button\" (click)=\"announce()\">Announce mission&#x3C;/button>\n\n    &#x3C;app-astronaut\n      *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let astronaut of astronauts\"\n      [astronaut]=\"astronaut\">\n    &#x3C;/app-astronaut>\n\n    &#x3C;h3>History&#x3C;/h3>\n    &#x3C;ul>\n      &#x3C;li *<a href=\"api/common/NgFor\" class=\"code-anchor\">ngFor</a>=\"let event of history\">{{event}}&#x3C;/li>\n    &#x3C;/ul>\n  `,\n  providers: [MissionService]\n})\nexport class MissionControlComponent {\n  astronauts = ['Lovell', 'Swigert', 'Haise'];\n  history: string[] = [];\n  missions = ['Fly to the moon!',\n              'Fly to mars!',\n              'Fly to Vegas!'];\n  nextMission = 0;\n\n  constructor(private missionService: MissionService) {\n    missionService.missionConfirmed$.subscribe(\n      astronaut => {\n        this.history.push(`${astronaut} confirmed the mission`);\n      });\n  }\n\n  announce() {\n    const mission = this.missions[this.nextMission++];\n    this.missionService.announceMission(mission);\n    this.history.push(`Mission \"${mission}\" announced`);\n    if (this.nextMission >= this.missions.length) { this.nextMission = 0; }\n  }\n}\n\n</code-example>\n<p>The <code>AstronautComponent</code> also injects the service in its constructor.\nEach <code>AstronautComponent</code> is a child of the <code>MissionControlComponent</code> and therefore receives its parent's service instance:</p>\n<p><code>AstronautComponent</code> 也通过自己的构造函数注入该服务。由于每个 <code>AstronautComponent</code> 都是 <code>MissionControlComponent</code> 的子组件，所以它们获取到的也是父组件的这个服务实例。</p>\n<code-example header=\"component-interaction/src/app/astronaut.component.ts\" path=\"component-interaction/src/app/astronaut.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> } from '@angular/core';\n\nimport { MissionService } from './mission.service';\nimport { Subscription } from 'rxjs';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-astronaut',\n  template: `\n    &#x3C;p>\n      {{astronaut}}: &#x3C;strong>{{mission}}&#x3C;/strong>\n      &#x3C;button\n        type=\"button\"\n        (click)=\"confirm()\"\n        [disabled]=\"!announced || confirmed\">\n        Confirm\n      &#x3C;/button>\n    &#x3C;/p>\n  `\n})\nexport class AstronautComponent implements <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() astronaut = '';\n  mission = '&#x3C;no mission announced>';\n  confirmed = false;\n  announced = false;\n  subscription: Subscription;\n\n  constructor(private missionService: MissionService) {\n    this.subscription = missionService.missionAnnounced$.subscribe(\n      mission => {\n        this.mission = mission;\n        this.announced = true;\n        this.confirmed = false;\n    });\n  }\n\n  confirm() {\n    this.confirmed = true;\n    this.missionService.confirmMission(this.astronaut);\n  }\n\n  ngOnDestroy() {\n    // prevent memory leak when component destroyed\n    this.subscription.unsubscribe();\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p>Notice that this example captures the <code>subscription</code> and <code>unsubscribe()</code> when the <code>AstronautComponent</code> is destroyed.\nThis is a memory-leak guard step.\nThere is no actual risk in this application because the lifetime of a <code>AstronautComponent</code> is the same as the lifetime of the application itself.\nThat <em>would not</em> always be true in a more complex application.</p>\n<p>注意，这个例子保存了 <code>subscription</code> 变量，并在 <code>AstronautComponent</code> 被销毁时调用 <code>unsubscribe()</code> 退订。这是一个用于防止内存泄漏的保护措施。实际上，在这个应用程序中并没有这个风险，因为 <code>AstronautComponent</code> 的生命期和应用程序的生命期一样长。但在更复杂的应用程序环境中就不一定了。</p>\n<p>You don't add this guard to the <code>MissionControlComponent</code> because, as the parent,\nit controls the lifetime of the <code>MissionService</code>.</p>\n<p>不需要在 <code>MissionControlComponent</code> 中添加这个保护措施，因为它作为父组件，控制着 <code>MissionService</code> 的生命期。</p>\n</div>\n<p>The <em>History</em> log demonstrates that messages travel in both directions between the parent <code>MissionControlComponent</code> and the <code>AstronautComponent</code> children, facilitated by the service:</p>\n<p><em>History</em> 日志证明了：在父组件 <code>MissionControlComponent</code> 和子组件 <code>AstronautComponent</code> 之间，信息通过该服务实现了双向传递。</p>\n<div class=\"lightbox\">\n<img alt=\"bidirectional-service\" src=\"generated/images/guide/component-interaction/bidirectional-service.gif\" width=\"310\" height=\"346\">\n</div>\n<h3 id=\"test-it-for-parent-and-children-communicate-using-a-service\">Test it for Parent and children communicate using a service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#test-it-for-parent-and-children-communicate-using-a-service\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"测试它以了解父级和子级如何使用服务进行通信\">测试它，以了解父级和子级如何使用服务进行通信<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component-interaction#测试它以了解父级和子级如何使用服务进行通信\"><i class=\"material-icons\">link</i></a></h3>\n<p>Tests click buttons of both the parent <code>MissionControlComponent</code> and the <code>AstronautComponent</code> children and verify that the history meets expectations:</p>\n<p>测试确保点击父组件 <code>MissionControlComponent</code> 和子组件 <code>AstronautComponent</code> 两个的组件的按钮时，<em>History</em> 日志和预期的一样。</p>\n<code-example header=\"component-interaction/e2e/src/app.e2e-spec.ts\" path=\"component-interaction/e2e/src/app.e2e-spec.ts\" region=\"bidirectional-service\">\n// ...\nit('should announce a mission', async () => {\n  const missionControl = element(by.tagName('app-mission-control'));\n  const announceButton = missionControl.all(by.tagName('button')).get(0);\n  const history = missionControl.all(by.tagName('li'));\n\n  await announceButton.click();\n\n  expect(await history.count()).toBe(1);\n  expect(await history.get(0).getText()).toMatch(/Mission.* announced/);\n});\n\nit('should confirm the mission by Lovell', async () => {\n  await testConfirmMission(1, 'Lovell');\n});\n\nit('should confirm the mission by Haise', async () => {\n  await testConfirmMission(3, 'Haise');\n});\n\nit('should confirm the mission by Swigert', async () => {\n  await testConfirmMission(2, 'Swigert');\n});\n\nasync function testConfirmMission(buttonIndex: number, astronaut: string) {\n  const missionControl = element(by.tagName('app-mission-control'));\n  const announceButton = missionControl.all(by.tagName('button')).get(0);\n  const confirmButton = missionControl.all(by.tagName('button')).get(buttonIndex);\n  const history = missionControl.all(by.tagName('li'));\n\n  await announceButton.click();\n  await confirmButton.click();\n\n  expect(await history.count()).toBe(2);\n  expect(await history.get(1).getText()).toBe(`${astronaut} confirmed the mission`);\n}\n// ...\n\n</code-example>\n<p><a href=\"guide/component-interaction#top\">Back to top</a></p>\n<p><a href=\"guide/component-interaction#top\">回到顶部</a></p>\n<!-- links -->\n<!-- external links -->\n<!-- end links -->\n\n  <div class=\"reviewed\">最后复查时间： 2/28/2022</div>\n</div>\n\n\n<!-- links to this doc:\n - guide/example-apps-list\n - start\n-->\n<!-- links from this doc:\n - api/animations/trigger\n - api/common/NgFor\n - api/core/AfterViewInit\n - api/core/ApplicationRef\n - api/core/Component\n - api/core/EventEmitter\n - api/core/Injectable\n - api/core/Input\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/Output\n - api/core/SimpleChanges\n - api/core/Version\n - api/core/ViewChild\n - api/core/testing/tick\n - guide/component-interaction#component-interaction\n - guide/component-interaction#countdown-tests\n - guide/component-interaction#countdown-timer-example\n - guide/component-interaction#intercept-input-property-changes-with-a-setter\n - guide/component-interaction#intercept-input-property-changes-with-ngonchanges\n - guide/component-interaction#parent-and-children-communicate-using-a-service\n - guide/component-interaction#parent-calls-an-viewchild\n - guide/component-interaction#parent-interacts-with-child-using-local-variable\n - guide/component-interaction#parent-listens-for-child-event\n - guide/component-interaction#pass-data-from-parent-to-child-with-input-binding\n - guide/component-interaction#test-it-for-intercept-input-property-changes-with-a-setter\n - guide/component-interaction#test-it-for-intercept-input-property-changes-with-ngonchanges\n - guide/component-interaction#test-it-for-parent-and-children-communicate-using-a-service\n - guide/component-interaction#test-it-for-parent-calls-an-viewchild\n - guide/component-interaction#test-it-for-parent-interacts-with-child-using-local-variable\n - guide/component-interaction#test-it-for-parent-listens-for-child-event\n - guide/component-interaction#test-it-for-pass-data-from-parent-to-child-with-input-binding\n - guide/component-interaction#top\n - guide/component-interaction#测试它以了解如何使用-ngonchanges-来拦截输入属性更改\n - guide/component-interaction#测试它以了解如何使用设置器拦截输入属性更改\n - guide/component-interaction#测试它以了解如何借助输入绑定将数据从父级传递给子级\n - guide/component-interaction#测试它以了解如何用父级监听子级的事件\n - guide/component-interaction#测试它以了解父级和子级如何使用服务进行通信\n - guide/component-interaction#测试它以了解父级如何使用局部变量与其子级交互\n - guide/component-interaction#测试它以了解父级如何调用-viewchild\n - guide/component-interaction#父级调用-viewchild\n - guide/component-interaction#父组件与子组件通过本地变量互动\n - guide/component-interaction#父组件和子组件通过服务来通讯\n - guide/component-interaction#父组件监听子组件的事件\n - guide/component-interaction#组件之间的交互\n - guide/component-interaction#通过-ngonchanges-来截听输入属性值的变化\n - guide/component-interaction#通过-setter-截听输入属性值的变化\n - guide/component-interaction#通过输入型绑定把数据从父组件传到子组件\n - guide/inputs-outputs#input\n - guide/inputs-outputs#output\n - guide/lifecycle-hooks\n - https://github.com/angular/angular-cn/edit/cn/aio/content/guide/component-interaction.md?message=docs%3A%20请简述你的修改...\n-->"
}