{
  "id": "guide/cheatsheet",
  "title": "Cheat Sheet",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/cheatsheet.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 class=\"no-toc\" id=\"cheat-sheet\" translation-result=\"on\">速查表<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cheatsheet#cheat-sheet\"><i class=\"material-icons\">link</i></a></h1><h1 class=\"no-toc\" translation-origin=\"off\" id=\"cheat-sheet\">Cheat Sheet<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/cheatsheet#cheat-sheet\"><i class=\"material-icons\">link</i></a></h1>\n\n<div id=\"cheatsheet\">\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>\n<p translation-result=\"on\">    引导/启动</p><p translation-origin=\"off\">    Bootstrapping</p>\n\n</th>\n<th><p><code>import { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-browser-dynamic';</code></p>\n</th>\n</tr>\n<tr>\n<td><code><b><a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule</b>(AppModule);</code></td>\n<td>\n    <p translation-result=\"on\">用 <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中指定的根组件进行启动。</p><p translation-origin=\"off\">Bootstraps the app, using the root component from the specified <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>. </p>\n    \n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>NgModules</th>\n<th><p><code>import { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';</code></p></th>\n</tr>\n<tr>\n<td>\n<p>    <code>@<b><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></b>({ declarations: ..., imports: ...,<br>     exports: ..., providers: ..., bootstrap: ...})<br>class MyModule {}</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">定义一个模块，其中可以包含组件、指令、管道和服务提供者。</p><p translation-origin=\"off\">Defines a module that contains components, directives, pipes, and providers.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>declarations:</b> [MyRedComponent, MyBlueComponent, MyDatePipe]</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">属于当前模块的组件、指令和管道的列表。</p><p translation-origin=\"off\">List of components, directives, and pipes that belong to this module.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>imports:</b> [<a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>, SomeOtherModule]</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">本模块所导入的模块列表</p><p translation-origin=\"off\">List of modules to import into this module. Everything from the imported modules\nis available to <code>declarations</code> of this module.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>exports:</b> [MyRedComponent, MyDatePipe]</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">那些导入了本模块的模块所能看到的组件、指令和管道的列表</p><p translation-origin=\"off\">List of components, directives, and pipes visible to modules that import this module.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>providers:</b> [MyService, { provide: ... }]</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">依赖注入提供者的列表，本模块以及本模块导入的所有模块中的内容都可以看见它们。</p><p translation-origin=\"off\">List of dependency injection providers visible both to the contents of this module and to importers of this module.</p>\n    \n</td>\n</tr><tr>\n<td><code><b>entryComponents:</b> [SomeComponent, OtherComponent]</code></td>\n<td>\n<p translation-result=\"on\">任何未在可达模板中引用过的组件列表，比如从代码中动态创建的。</p><p translation-origin=\"off\">List of components not referenced in any reachable template, for example dynamically created from code.</p>\n\n</td>\n</tr><tr>\n<td>\n<p>    <code><b>bootstrap:</b> [MyAppComponent]</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">当本模块启动时，随之启动的组件列表。</p><p translation-origin=\"off\">List of components to bootstrap when this module is bootstrapped.</p>\n    \n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>\n<p translation-result=\"on\">    模板语法</p><p translation-origin=\"off\">    Template syntax</p>\n\n</th>\n<th>\n</th>\n</tr>\n<tr>\n<td>\n<p>    <code>&#x3C;input <b>[value]</b>=\"firstName\"></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把<code>value</code>属性绑定到表达式<code>firstName</code></p><p translation-origin=\"off\">Binds property <code>value</code> to the result of expression <code>firstName</code>.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;div <b>[attr.role]</b>=\"myAriaRole\"></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把属性（Attribute）<code>role</code>绑定到表达式<code>myAriaRole</code>的结果。</p><p translation-origin=\"off\">Binds attribute <code>role</code> to the result of expression <code>myAriaRole</code>.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;div <b>[class.extra-sparkle]</b>=\"isDelightful\"></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">根据<code>isDelightful</code>表达式的结果是否为真，决定 CSS 类<code>extra-sparkle</code>是否出现在当前元素上。</p><p translation-origin=\"off\">Binds the presence of the CSS class <code>extra-sparkle</code> on the element to the truthiness of the expression <code>isDelightful</code>.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;div <b>[style.width.px]</b>=\"mySize\"></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把 CSS 样式属性<code>width</code>的 px（像素）值绑定到表达式<code>mySize</code>的结果。单位是可选的。</p><p translation-origin=\"off\">Binds style property <code>width</code> to the result of expression <code>mySize</code> in pixels. Units are optional.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;button <b>(click)</b>=\"readRainbow($event)\"></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">当这个按钮元素（及其子元素）上的 click 事件触发时，调用方法<code>readRainbow</code>，并把这个事件对象作为参数传进去。</p><p translation-origin=\"off\">Calls method <code>readRainbow</code> when a click event is triggered on this button element (or its children) and passes in the event object.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;div title=\"Hello <b>{{ponyName}}</b>\"></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把一个属性绑定到插值字符串（如\"Hello Seabiscuit\"）。这种写法等价于<code>&#x3C;div [title]=\"'Hello ' + ponyName\"></code></p><p translation-origin=\"off\">Binds a property to an interpolated string, for example, \"Hello Seabiscuit\". Equivalent to:\n<code>&#x3C;div [title]=\"'Hello ' + ponyName\"></code></p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;p>Hello <b>{{ponyName}}</b>&#x3C;/p></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把文本内容绑定到插值字符串（如\"Hello Seabiscuit\"）</p><p translation-origin=\"off\">Binds text content to an interpolated string, for example, \"Hello Seabiscuit\".</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;my-cmp <b>[(title)]</b>=\"name\"></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">设置双向绑定。等价于<code>&#x3C;my-cmp [title]=\"name\" (titleChange)=\"name=$event\"></code>。</p><p translation-origin=\"off\">Sets up two-way data binding. Equivalent to: <code>&#x3C;my-cmp [title]=\"name\" (titleChange)=\"name=$event\"></code></p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;video <b>#movieplayer</b> ...><br>  &#x3C;button <b>(click)</b>=\"movieplayer.play()\"><br>&#x3C;/video></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">创建一个局部变量<code>movieplayer</code>，支持在当前模板的数据绑定和事件绑定表达式中访问<code>video</code>元素的实例。</p><p translation-origin=\"off\">Creates a local variable <code>movieplayer</code> that provides access to the <code>video</code> element instance in data-binding and event-binding expressions in the current template.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;p <b>*myUnless</b>=\"myExpression\">...&#x3C;/p></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">这个 <code>*</code> 符号会把当前元素转换成一个内嵌的模板。它等价于：\n<code>&#x3C;ng-template [myUnless]=\"myExpression\">&#x3C;p>...&#x3C;/p>&#x3C;/ng-template></code></p><p translation-origin=\"off\">The <code>*</code> symbol turns the current element into an embedded template. Equivalent to:\n<code>&#x3C;ng-template [myUnless]=\"myExpression\">&#x3C;p>...&#x3C;/p>&#x3C;/ng-template></code></p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;p>Card No.: <b>{{cardNumber | myCardNumberFormatter}}</b>&#x3C;/p></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">使用名叫<code>myCardNumberFormatter</code>的管道对表达式<code>cardNumber</code>的当前值进行转换。</p><p translation-origin=\"off\">Transforms the current value of expression <code>cardNumber</code> via the pipe called <code>myCardNumberFormatter</code>.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;p>Employer: <b>{{employer?.companyName}}</b>&#x3C;/p></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">安全导航操作符（<code>?</code>）表示<code>employer</code>字段是可选的，如果它是 <code>undefined</code>，那么表达式其余的部分就会被忽略，并返回 <code>undefined</code>。</p><p translation-origin=\"off\">The safe navigation operator (<code>?</code>) means that the <code>employer</code> field is optional and if <code>undefined</code>, the rest of the expression should be ignored.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;<b>svg:</b>rect x=\"0\" y=\"0\" width=\"100\" height=\"100\"/></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">模板中的 SVG 片段需要给它的根元素加上<code>svg:</code>前缀，以便把 SVG 元素和 HTML 元素区分开。</p><p translation-origin=\"off\">An SVG snippet template needs an <code>svg:</code> prefix on its root element to disambiguate the SVG element from an HTML component.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;<b>svg</b>><br>  &#x3C;rect x=\"0\" y=\"0\" width=\"100\" height=\"100\"/><br>&#x3C;/<b>svg</b>></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">以<code>&#x3C;svg></code>作为根元素时会自动识别为 SVG 元素，不需要前缀。</p><p translation-origin=\"off\">An <code>&#x3C;svg></code> root element is detected as an SVG element automatically, without the prefix.</p>\n    \n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>\n<p translation-result=\"on\">    内置指令</p><p translation-origin=\"off\">    Built-in directives</p>\n\n</th>\n<th>\n    <p><code>import { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';</code>\n</p>\n</th>\n</tr>\n<tr>\n<td>\n<p>    <code>&#x3C;section <b>*ngIf</b>=\"showSection\"></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">根据<code>showSection</code>表达式的结果，移除或重新创建 DOM 树的一部分。</p><p translation-origin=\"off\">Removes or recreates a portion of the DOM tree based on the <code>showSection</code> expression.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;li <b>*ngFor</b>=\"let item of list\"></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把 li 元素及其内容变成一个模板，并使用这个模板为列表中的每一个条目实例化一个视图。</p><p translation-origin=\"off\">Turns the li element and its contents into a template, and uses that to instantiate a view for each item in list.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;div <b>[<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]</b>=\"conditionExpression\"><br>  &#x3C;ng-template <b>[<b><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a></b>]</b>=\"case1Exp\">...&#x3C;/ng-template><br>  &#x3C;ng-template <b>ngSwitchCase</b>=\"case2LiteralString\">...&#x3C;/ng-template><br>  &#x3C;ng-template <b>ngSwitchDefault</b>>...&#x3C;/ng-template><br>&#x3C;/div></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">根据<code>conditionExpression</code>的当前值选择一个嵌入式模板，并据此决定是否替换掉这个 div 的内容。</p><p translation-origin=\"off\">Conditionally swaps the contents of the div by selecting one of the embedded templates based on the current value of <code>conditionExpression</code>.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;div <b>[ngClass]</b>=\"{'active': isActive, 'disabled': isDisabled}\"></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">根据 map 中的 value 是否为真，来决定该元素上是否出现与 name 对应的 CSS 类。右侧的表达式应该返回一个形如 <code>{class-name: true/false}</code> 的 map。</p><p translation-origin=\"off\">Binds the presence of CSS classes on the element to the truthiness of the associated map values. The right-hand expression should return {class-name: true/false} map.</p>\n    \n</td>\n</tr>\n<tr>\n<td>\n<p>    <code>&#x3C;div <b>[ngStyle]</b>=\"{'property': 'value'}\"></code><br><code>&#x3C;div <b>[ngStyle]</b>=\"dynamicStyles()\"></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">允许你使用 CSS 为 HTML 元素指定样式。你可以像第一个例子那样直接使用 CSS，也可以调用组件中的方法。</p><p translation-origin=\"off\">Allows you to assign styles to an HTML element using CSS. You can use CSS directly, as in the first example, or you can call a method from the component.</p>\n    \n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>\n<p translation-result=\"on\">    表单</p><p translation-origin=\"off\">    Forms</p>\n\n</th>\n<th>\n    <p><code>import { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';</code>\n</p>\n</th>\n</tr>\n<tr>\n<td>\n<p>    <code>&#x3C;input <b>[(ngModel)]</b>=\"userName\"></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">为表单控件提供双向数据绑定、解析和验证功能。</p><p translation-origin=\"off\">Provides two-way data-binding, parsing, and validation for form controls.</p>\n    \n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>\n<p translation-result=\"on\">    类装饰器</p><p translation-origin=\"off\">    Class decorators</p>\n\n</th>\n<th>\n    <p><code>import { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, ... } from '@angular/core';</code>\n</p>\n</th>\n</tr>\n<tr>\n<td>\n<p>    <code><b>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({...})</b><br>class MyComponent() {}</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">声明一个类是组件，并提供该组件的元数据。</p><p translation-origin=\"off\">Declares that a class is a component and provides metadata about the component.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})</b><br>class MyDirective() {}</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">声明一个类是指令，并提供该指令的元数据。</p><p translation-origin=\"off\">Declares that a class is a directive and provides metadata about the directive.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({...})</b><br>class MyPipe() {}</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">声明一个类是管道，并提供该管道的元数据。</p><p translation-origin=\"off\">Declares that a class is a pipe and provides metadata about the pipe.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</b><br>class MyService() {}</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">声明某个类可以注册为提供者，并能被另一个类注入。如果没有该装饰器，编译器就不会生成足够的元数据，当它被注入到别处时，就无法正常创建该类。</p><p translation-origin=\"off\">Declares that a class can be provided and injected by other classes. Without this decorator, the compiler won't generate enough metadata to allow the class to be created properly when it's injected somewhere.</p>\n    \n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>\n<p translation-result=\"on\">    指令配置项</p><p translation-origin=\"off\">    Directive configuration</p>\n\n</th>\n<th>\n    <p><code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ property1: value1, ... })</code>\n</p>\n</th>\n</tr>\n<tr>\n<td>\n<p>    <code><b>selector:</b> '.cool-button:not(a)'</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">指定一个 CSS 选择器，用于在模板中标记出该指令。支持的选择器类型包括：<code>元素名</code>、<code>[属性名]</code>, <code>.类名</code> 和 <code>:not()</code>。</p><p translation-origin=\"off\">Specifies a CSS selector that identifies this directive within a template. Supported selectors include <code>element</code>,\n<code>[attribute]</code>, <code>.class</code>, and <code>:not()</code>.</p>\n    \n<p translation-result=\"on\">但不支持指定父子关系的选择器。</p><p translation-origin=\"off\">Does not support parent-child relationship selectors.</p>\n\n</td>\n</tr><tr>\n<td>\n<p>    <code><b>providers:</b> [MyService, { provide: ... }]</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">该指令及其子指令的依赖注入提供者列表。</p><p translation-origin=\"off\">List of dependency injection providers for this directive and its children.</p>\n    \n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>\n<p translation-result=\"on\">    组件配置项</p><p translation-origin=\"off\">    Component configuration</p>\n\n</th>\n<th>\n    <p translation-result=\"on\"><code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 继承自 <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>，\n    因此，<code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 的这些配置项也同样适用于组件。</p><p translation-origin=\"off\">\n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> extends <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code>,\nso the <code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> configuration applies to components as well</p>\n    \n</th>\n</tr>\n<tr>\n<td>\n<p>    <code><b>moduleId:</b> module.id</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">如果设置了，那么 <code>templateUrl</code> 和 <code>styleUrl</code> 的路径就会相对于当前组件进行解析。</p><p translation-origin=\"off\">If set, the <code>templateUrl</code> and <code>styleUrl</code> are resolved relative to the component.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>viewProviders:</b> [MyService, { provide: ... }]</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">依赖注入提供者列表，但它们的范围被限定为当前组件的视图。</p><p translation-origin=\"off\">List of dependency injection providers scoped to this component's view.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>template:</b> 'Hello {{name}}'<br><b>templateUrl:</b> 'my-component.html'</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">当前组件视图的内联模板或外部模板的 URL。</p><p translation-origin=\"off\">Inline template or external template URL of the component's view.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>styles:</b> ['.primary {color: red}']<br><b>styleUrls:</b> ['my-component.css']</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">用于为当前组件的视图提供样式的内联 CSS 或外部样式表 URL 的列表。</p><p translation-origin=\"off\">List of inline CSS styles or external stylesheet URLs for styling the component’s view.</p>\n    \n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>\n<p translation-result=\"on\">    给指令和组件使用的类属性配置项</p><p translation-origin=\"off\">    Class field decorators for directives and components</p>\n\n</th>\n<th>\n    <p><code>import { <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, ... } from '@angular/core';</code>\n</p>\n</th>\n</tr>\n<tr>\n<td>\n<p>    <code><b>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</b> myProperty;</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">声明一个输入属性，你可以通过属性绑定来更新它，如 <code>&#x3C;my-cmp [myProperty]=\"someExpression\"></code>。</p><p translation-origin=\"off\">Declares an input property that you can update via property binding (example:\n<code>&#x3C;my-cmp [myProperty]=\"someExpression\"></code>).</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</b> myEvent = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>();</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">声明一个输出属性，它发出事件，你可以用事件绑定来订阅它们（如：<code>&#x3C;my-cmp (myEvent)=\"doSomething()\"></code>）。</p><p translation-origin=\"off\">Declares an output property that fires events that you can subscribe to with an event binding (example: <code>&#x3C;my-cmp (myEvent)=\"doSomething()\"></code>).</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>@<a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a>('class.valid')</b> isValid;</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把宿主元素的一个属性（这里是 CSS 类 <code>valid</code>）绑定到指令或组件上的 <code>isValid</code> 属性。</p><p translation-origin=\"off\">Binds a host element property (here, the CSS class <code>valid</code>) to a directive/component property (<code>isValid</code>).</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>@<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('click', ['$event'])</b> onClick(e) {...}</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">用指令或组件上的<code>onClick</code>方法订阅宿主元素上的<code>click</code>事件，并从中获取<code>$event</code>参数（可选）</p><p translation-origin=\"off\">Subscribes to a host element event (<code>click</code>) with a directive/component method (<code>onClick</code>), optionally passing an argument (<code>$event</code>).</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>@<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(myPredicate)</b> myChildComponent;</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把组件内容查询（<code>myPredicate</code>）的第一个结果绑定到该类的 <code>myChildComponent</code> 属性上。</p><p translation-origin=\"off\">Binds the first result of the component content query (<code>myPredicate</code>) to a property (<code>myChildComponent</code>) of the class.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>@<a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a>(myPredicate)</b> myChildComponents;</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把组件内容查询（<code>myPredicate</code>）的全部结果绑定到该类的 <code>myChildComponents</code> 属性上</p><p translation-origin=\"off\">Binds the results of the component content query (<code>myPredicate</code>) to a property (<code>myChildComponents</code>) of the class.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>@<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(myPredicate)</b> myChildComponent;</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把组件视图查询（<code>myPredicate</code>）的第一个结果绑定到该类的 <code>myChildComponent</code> 属性上。对指令无效。</p><p translation-origin=\"off\">Binds the first result of the component view query (<code>myPredicate</code>) to a property (<code>myChildComponent</code>) of the class. Not available for directives.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>@<a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a>(myPredicate)</b> myChildComponents;</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把组件视图查询（<code>myPredicate</code>）的全部结果绑定到该类的 <code>myChildComponents</code> 属性上。对指令无效。</p><p translation-origin=\"off\">Binds the results of the component view query (<code>myPredicate</code>) to a property (<code>myChildComponents</code>) of the class. Not available for directives.</p>\n    \n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>\n<p translation-result=\"on\">    指令与组件的变更检测与生命周期钩子</p><p translation-origin=\"off\">    Directive and component change detection and lifecycle hooks</p>\n\n</th>\n<th>\n    <p translation-result=\"on\">（作为类的方法实现。）</p><p translation-origin=\"off\">(implemented as class methods)\n</p>\n    \n</th>\n</tr>\n<tr>\n<td>\n<p>    <code><b>constructor(myService: MyService, ...)</b> { ... }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">在任何其它生命周期钩子之前调用。可以用它来注入依赖项，但不要在这里做正事。</p><p translation-origin=\"off\">Called before any other lifecycle hook. Use it to inject dependencies, but avoid any serious work here.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>ngOnChanges(changeRecord)</b> { ... }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">每当输入属性发生变化时就会调用，但位于处理内容（<code>ng-content</code>）或子视图之前。</p><p translation-origin=\"off\">Called after every change to input properties and before processing content or child views.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>ngOnInit()</b> { ... }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">在调用完构造函数、初始化完所有输入属性并首次调用过<code>ngOnChanges</code>之后调用。</p><p translation-origin=\"off\">Called after the constructor, initializing input properties, and the first call to <code>ngOnChanges</code>.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>ngDoCheck()</b> { ... }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">每当对组件或指令的输入属性进行变更检测时就会调用。可以用它来扩展变更检测逻辑，执行自定义的检测逻辑。</p><p translation-origin=\"off\">Called every time that the input properties of a component or a directive are checked. Use it to extend change detection by performing a custom check.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>ngAfterContentInit()</b> { ... }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\"><code>ngOnInit</code>完成之后，当组件或指令的内容（<code>ng-content</code>）已经初始化完毕时调用。</p><p translation-origin=\"off\">Called after <code>ngOnInit</code> when the component's or directive's content has been initialized.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>ngAfterContentChecked()</b> { ... }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">每当组件或指令的内容（<code>ng-content</code>）做变更检测时调用。</p><p translation-origin=\"off\">Called after every check of the component's or directive's content.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>ngAfterViewInit()</b> { ... }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">当<code>ngAfterContentInit</code>完毕，并且组件的视图及其子视图或指令所属的视图已经初始化完毕时调用。\n</p><p translation-origin=\"off\">Called after <code>ngAfterContentInit</code> when the component's views and child views / the view that a directive is in has been initialized.</p>\n    </td>\n</tr><tr>\n<td>\n<p>    <code><b>ngAfterViewChecked()</b> { ... }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">当组件的视图及其子视图或指令所属的视图每次执行变更检测时调用。</p><p translation-origin=\"off\">Called after every check of the component's views and child views / the view that a directive is in.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><b>ngOnDestroy()</b> { ... }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">只在实例被销毁前调用一次。</p><p translation-origin=\"off\">Called once, before the instance is destroyed.</p>\n    \n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>\n<p translation-result=\"on\">    依赖注入配置项</p><p translation-origin=\"off\">    Dependency injection configuration</p>\n\n</th>\n<th>\n</th>\n</tr>\n<tr>\n<td>\n<p>    <code>{ <b>provide</b>: MyService, <b>useClass</b>: MyMockService }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把 <code>MyService</code> 的服务提供者设置或改写为 <code>MyMockService</code> 类。</p><p translation-origin=\"off\">Sets or overrides the provider for <code>MyService</code> to the <code>MyMockService</code> class.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>{ <b>provide</b>: MyService, <b>useFactory</b>: myFactory }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把 <code>MyService</code> 的服务提供者设置或改写为 <code>myFactory</code> 工厂函数。</p><p translation-origin=\"off\">Sets or overrides the provider for <code>MyService</code> to the <code>myFactory</code> factory function.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>{ <b>provide</b>: MyValue, <b>useValue</b>: 41 }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">把 <code>MyValue</code> 的服务提供者改写为一个特定的值 <code>41</code>。</p><p translation-origin=\"off\">Sets or overrides the provider for <code>MyValue</code> to the value <code>41</code>.</p>\n    \n</td>\n</tr>\n</tbody></table>\n<table class=\"is-full-width is-fixed-layout\">\n<tbody><tr>\n<th>\n<p translation-result=\"on\">    路由与导航</p><p translation-origin=\"off\">    Routing and navigation</p>\n\n</th>\n<th>\n    <p><code>import { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>, ... } from '@angular/router';</code>\n</p>\n</th>\n</tr>\n<tr>\n<td>\n<p>    <code>const routes: <b><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></b> = [<br>  { path: '', component: HomeComponent },<br>  { path: 'path/:routeParam', component: MyComponent },<br>  { path: 'staticPath', component: ... },<br>  { path: '**', component: ... },<br>  { path: 'oldPath', redirectTo: '/staticPath' },<br>  { path: ..., component: ..., data: { message: 'Custom' } }<br>]);<br><br>const routing = RouterModule.forRoot(routes);</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">为该应用配置路由。支持静态、参数化、重定向和通配符路由。也支持自定义路由数据和解析（resolve）函数。</p><p translation-origin=\"off\">Configures routes for the application. Supports static, parameterized, redirect, and wildcard routes. Also supports custom route data and resolve.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><br>&#x3C;<b><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a></b>>&#x3C;/<b><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a></b>><br>&#x3C;<b><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a></b> name=\"aux\">&#x3C;/<b>router-outlet</b>><br></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">标记出一个位置，用来加载活动路由的组件。</p><p translation-origin=\"off\">Marks the location to load the component of the active route.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code><br>&#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/path\"><br>&#x3C;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <b>[<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]</b>=\"[ '/path', routeParam ]\"><br>&#x3C;a <b>[routerLink]</b>=\"[ '/path', { matrixParam: 'value' } ]\"><br>&#x3C;a <b>[routerLink]</b>=\"[ '/path' ]\" [queryParams]=\"{ page: 1 }\"><br>&#x3C;a <b>[routerLink]</b>=\"[ '/path' ]\" fragment=\"anchor\"><br></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">使用路由体系创建一个到其它视图的链接。路由体系由路由路径、必要参数、可选参数、查询参数和文档片段组成。要导航到根路由，请使用<code>/</code>前缀；要导航到子路由，使用<code>./</code>前缀；要导航到兄弟路由或父级路由，使用<code>../</code>前缀。</p><p translation-origin=\"off\">Creates a link to a different view based on a route instruction consisting of a route path, required and optional parameters, query parameters, and a fragment. To navigate to a root route, use the <code>/</code> prefix; for a child route, use the <code>./</code>prefix; for a sibling or parent, use the <code>../</code> prefix.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>&#x3C;a [<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]=\"[ '/path' ]\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\"></code></p>\n</td>\n<td>\n    <p translation-result=\"on\">当 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 指向的路由变成活动路由时，为当前元素添加一些类（比如这里的 <code>active</code>）。</p><p translation-origin=\"off\">The provided classes are added to the element when the <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> becomes the current active route.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>class <b><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></b>Guard implements <b><a href=\"api/router/CanActivate\" class=\"code-anchor\">CanActivate</a></b> {<br>    canActivate(<br>      route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,<br>      state: RouterStateSnapshot<br>    ): Observable&#x3C;boolean|UrlTree>|Promise&#x3C;boolean|UrlTree>|boolean|UrlTree { ... }<br>}<br><br>{ path: ..., canActivate: [<b>CanActivate</b>Guard] }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">用来定义类的接口。路由器会首先调用本接口来决定是否激活该路由。应该返回一个 <code>boolean|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> 或能解析成 <code>boolean|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> 的 <code>Observable/Promise</code>。</p><p translation-origin=\"off\">An interface for defining a class that the router should call first to determine if it should activate this component. Should return a boolean|UrlTree or an Observable/Promise that resolves to a boolean|UrlTree.</p>\n    \n</td>\n</tr><tr>\n<td><code>class <b><a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a></b>Guard implements <b><a href=\"api/router/CanDeactivate\" class=\"code-anchor\">CanDeactivate</a></b>&#x3C;T> {<br>    canDeactivate(<br>      component: T,<br>      route: ActivatedRouteSnapshot,<br>      state: RouterStateSnapshot<br>    ): Observable&#x3C;boolean|UrlTree>|Promise&#x3C;boolean|UrlTree>|boolean|UrlTree { ... }<br>}<br><br>{ path: ..., canDeactivate: [<b>CanDeactivate</b>Guard] }</code></td>\n<td>\n<p translation-result=\"on\">用来定义类的接口。路由器会在导航离开前首先调用本接口以决定是否取消激活本路由。应该返回一个 <code>boolean|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> 或能解析成 <code>boolean|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> 的 <code>Observable/Promise</code>。</p><p translation-origin=\"off\">An interface for defining a class that the router should call first to determine if it should deactivate this component after a navigation. Should return a boolean|UrlTree or an Observable/Promise that resolves to a boolean|UrlTree.</p>\n    \n</td>\n</tr><tr>\n<td><code>class <b><a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a></b>Guard implements <b><a href=\"api/router/CanActivateChild\" class=\"code-anchor\">CanActivateChild</a></b> {<br>    canActivateChild(<br>      route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,<br>      state: RouterStateSnapshot<br>    ): Observable&#x3C;boolean|UrlTree>|Promise&#x3C;boolean|UrlTree>|boolean|UrlTree { ... }<br>}<br><br>{ path: ..., canActivateChild: [CanActivateGuard],<br>    children: ... }</code></td>\n<td>\n<p translation-result=\"on\">用来定义类的接口。路由器会首先调用本接口来决定是否激活一个子路由。应该返回一个 <code>boolean|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> 或能解析成 <code>boolean|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> 的 <code>Observable/Promise</code>。</p><p translation-origin=\"off\">An interface for defining a class that the router should call first to determine if it should activate the child route. Should return a boolean|UrlTree or an Observable/Promise that resolves to a boolean|UrlTree.</p>\n\n</td>\n</tr><tr>\n<td>\n<p>    <code>class <b><a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a></b>Guard implements <b><a href=\"api/router/Resolve\" class=\"code-anchor\">Resolve</a></b>&#x3C;T> {<br>    resolve(<br>      route: <a href=\"api/router/ActivatedRouteSnapshot\" class=\"code-anchor\">ActivatedRouteSnapshot</a>,<br>      state: RouterStateSnapshot<br>    ): Observable&#x3C;any>|Promise&#x3C;any>|any { ... }<br>}<br><br>{ path: ..., resolve: [<b>Resolve</b>Guard] }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">用来定义类的接口。路由器会在渲染该路由之前，首先调用它来解析路由数据。应该返回一个值或能解析成值的 <code>Observable/Promise</code>。</p><p translation-origin=\"off\">An interface for defining a class that the router should call first to resolve route data before rendering the route. Should return a value or an Observable/Promise that resolves to a value.</p>\n    \n</td>\n</tr><tr>\n<td>\n<p>    <code>class <b><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></b>Guard implements <b><a href=\"api/router/CanLoad\" class=\"code-anchor\">CanLoad</a></b> {<br>    canLoad(<br>      route: <a href=\"api/router/Route\" class=\"code-anchor\">Route</a><br>    ): Observable&#x3C;boolean|UrlTree>|Promise&#x3C;boolean|UrlTree>|boolean|UrlTree { ... }<br>}<br><br>{ path: ..., canLoad: [<b>CanLoad</b>Guard], loadChildren: ... }</code></p>\n</td>\n<td>\n    <p translation-result=\"on\">用来定义类的接口。路由器会首先调用它来决定是否应该加载一个惰性加载模块。应该返回一个 <code>boolean|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> 或能解析成 <code>boolean|<a href=\"api/router/UrlTree\" class=\"code-anchor\">UrlTree</a></code> 的 <code>Observable/Promise</code>。</p><p translation-origin=\"off\">An interface for defining a class that the router should call first to check if the lazy loaded module should be loaded. Should return a boolean|UrlTree or an Observable/Promise that resolves to a boolean|UrlTree.</p>\n    \n</td>\n</tr>\n</tbody></table>\n</div>\n\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/common/CommonModule\n - api/common/NgSwitch\n - api/common/NgSwitchCase\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Directive\n - api/core/EventEmitter\n - api/core/HostBinding\n - api/core/HostListener\n - api/core/Injectable\n - api/core/Input\n - api/core/NgModule\n - api/core/Output\n - api/core/Pipe\n - api/core/ViewChild\n - api/core/ViewChildren\n - api/forms/FormsModule\n - api/platform-browser-dynamic/platformBrowserDynamic\n - api/platform-browser/BrowserModule\n - api/router/ActivatedRouteSnapshot\n - api/router/CanActivate\n - api/router/CanActivateChild\n - api/router/CanDeactivate\n - api/router/CanLoad\n - api/router/Resolve\n - api/router/Route\n - api/router/RouterLink\n - api/router/RouterLinkActive\n - api/router/RouterLinkWithHref\n - api/router/RouterModule\n - api/router/RouterOutlet\n - api/router/Routes\n - api/router/UrlTree\n - guide/cheatsheet#cheat-sheet\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/cheatsheet.md?message=docs%3A%20请简述你的修改...\n-->"
}