{
  "id": "guide/singleton-services",
  "title": "Singleton services",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/angular/angular-cn/edit/aio/aio/content/guide/singleton-services.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"singleton-services\" translation-result=\"on\">单例服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#singleton-services\"><i class=\"material-icons\">link</i></a></h1><h1 translation-origin=\"off\" id=\"singleton-services\">Singleton services<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#singleton-services\"><i class=\"material-icons\">link</i></a></h1>\n\n<p translation-result=\"on\">单例服务是指在应用中只存在一个实例的服务。</p><p translation-origin=\"off\">A singleton service is a service for which only one instance exists in an app.</p>\n\n<p translation-result=\"on\">本页中描述的这种全应用级单例服务的例子位于<live-example name=\"ngmodules\"></live-example>，它示范了 NgModule 的所有已文档化的特性。</p><p translation-origin=\"off\">For a sample app using the app-wide singleton service that this page describes, see the\n<live-example name=\"ngmodules\"></live-example> showcasing all the documented features of NgModules.</p>\n\n<h2 id=\"providing-a-singleton-service\" translation-result=\"on\">提供单例服务<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#providing-a-singleton-service\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"providing-a-singleton-service\">Providing a singleton service<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#providing-a-singleton-service\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">在 Angular 中有两种方式来生成单例服务：</p><p translation-origin=\"off\">There are two ways to make a service a singleton in Angular:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">把 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 中的 <code>providedIn</code> 属性设置为 <code>\"root\"</code>。</p><p translation-origin=\"off\">Set the <code>providedIn</code> property of the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> to <code>\"root\"</code>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把该服务包含在 <code>AppModule</code> 或某个只会被 <code>AppModule</code> 导入的模块中。</p><p translation-origin=\"off\">Include the service in the <code>AppModule</code> or in a module that is only imported by the <code>AppModule</code></p>\n\n</li>\n</ul>\n<a id=\"providedIn\"></a>\n<h3 id=\"using-providedin\" translation-result=\"on\">使用 <code>providedIn</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#using-providedin\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"using-providedin\">Using <code>providedIn</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#using-providedin\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">从 Angular 6.0 开始，创建单例服务的首选方式就是在那个服务类的 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 装饰器上把 <code>providedIn</code> 设置为 <code>root</code>。这会告诉 Angular 在应用的根上提供此服务。</p><p translation-origin=\"off\">Beginning with Angular 6.0, the preferred way to create a singleton service is to set <code>providedIn</code> to <code>root</code> on the service's <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator. This tells Angular\nto provide the service in the application root.</p>\n\n<code-example path=\"providers/src/app/user.service.0.ts\" header=\"src/app/user.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>({\n  providedIn: 'root',\n})\nexport class UserService {\n}\n\n\n</code-example>\n<p translation-result=\"on\">要想深入了解关于服务的信息，参见<a href=\"tutorial\">《英雄指南》教程</a>中的<a href=\"tutorial/toh-pt4\">服务</a>一章。</p><p translation-origin=\"off\">For more detailed information on services, see the <a href=\"tutorial/toh-pt4\">Services</a> chapter of the\n<a href=\"tutorial\">Tour of Heroes tutorial</a>.</p>\n\n<h3 id=\"ngmodule-providers-array\" translation-result=\"on\">NgModule 的 <code>providers</code> 数组<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#ngmodule-providers-array\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"ngmodule-providers-array\">NgModule <code>providers</code> array<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#ngmodule-providers-array\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\">在基于 Angular 6.0 以前的版本构建的应用中，服务是注册在 NgModule 的 <code>providers</code> 数组中的，就像这样：</p><p translation-origin=\"off\">In apps built with Angular versions prior to 6.0, services are registered NgModule <code>providers</code> arrays as follows:</p>\n\n<code-example language=\"ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  ...\n  providers: [UserService],\n  ...\n})\n</code-example>\n<p translation-result=\"on\">如果这个 NgModule 是根模块 <code>AppModule</code>，此 <code>UserService</code> 就会是单例的，并且在整个应用中都可用。虽然你可能会看到这种形式的代码，但是最好使用在服务自身的 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器上设置 <code>providedIn</code> 属性的形式，因为 Angular 6.0 可以对这些服务进行摇树优化。</p><p translation-origin=\"off\">If this NgModule were the root <code>AppModule</code>, the <code>UserService</code> would be a singleton and available\nthroughout the app. Though you may see it coded this way, using the <code>providedIn</code> property of the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator on the service itself is preferable as of Angular 6.0 as it makes your services tree-shakable.</p>\n\n<a id=\"forRoot\"></a>\n<h2 id=\"the-forroot-pattern\" translation-result=\"on\"><code>forRoot()</code> 模式<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#the-forroot-pattern\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"the-forroot-pattern\">The <code>forRoot()</code> pattern<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#the-forroot-pattern\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">通常，你只需要用 <code>providedIn</code> 提供服务，用 <code>forRoot()</code>/<code>forChild()</code> 提供路由即可。\n不过，理解 <code>forRoot()</code> 为何能够确保服务只有单个实例，可以让你学会更深层次的开发知识。</p><p translation-origin=\"off\">Generally, you'll only need <code>providedIn</code> for providing services and <code>forRoot()</code>/<code>forChild()</code> for routing. However, understanding how <code>forRoot()</code> works to make sure a service is a singleton will inform your development at a deeper level.</p>\n\n<p translation-result=\"on\">如果模块同时定义了 providers（服务）和 declarations（组件、指令、管道），那么，当你同时在多个特性模块中加载此模块时，这些服务就会被注册在多个地方。这会导致出现多个服务实例，并且该服务的行为不再像单例一样。</p><p translation-origin=\"off\">If a module defines both providers and declarations (components, directives, pipes),\nthen loading the module in multiple feature modules would duplicate the registration of the service. This could result in multiple service instances and the service would no longer behave as a singleton.</p>\n\n<p translation-result=\"on\">有多种方式来防止这种现象：</p><p translation-origin=\"off\">There are multiple ways to prevent this:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\">用 <a href=\"guide/singleton-services#providedIn\"><code>providedIn</code> 语法</a>代替在模块中注册服务的方式。</p><p translation-origin=\"off\">Use the <a href=\"guide/singleton-services#providedIn\"><code>providedIn</code> syntax</a> instead of registering the service in the module.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把你的服务分离到它们自己的模块中。</p><p translation-origin=\"off\">Separate your services into their own module.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">在模块中分别定义 <code>forRoot()</code> 和 <code>forChild()</code> 方法。</p><p translation-origin=\"off\">Define <code>forRoot()</code> and <code>forChild()</code> methods in the module.</p>\n\n</li>\n</ul>\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意：</strong>有两个范例应用可以让你查看这种情况，更高级的方式参见 <live-example nodownload=\"\" name=\"ngmodules\">NgModules 现场演练</live-example>，它在路由模块中包含 <code>forRoot()</code> 和 <code>forChild()</code>，而 <code>GreetingModule</code> 是一个比较简单的<live-example name=\"lazy-loading-ngmodules\" nodownload=\"\">惰性加载范例</live-example>。在<a href=\"guide/lazy-loading-ngmodules\">惰性加载模块</a>中有简要的解释。</p><p translation-origin=\"off\"><strong>Note:</strong> There are two example apps where you can see this scenario; the more advanced <live-example nodownload=\"\" name=\"ngmodules\">NgModules live example</live-example>, which contains <code>forRoot()</code> and <code>forChild()</code> in the routing modules and the <code>GreetingModule</code>, and the simpler <live-example name=\"lazy-loading-ngmodules\" nodownload=\"\">Lazy Loading live example</live-example>. For an introductory explanation see the <a href=\"guide/lazy-loading-ngmodules\">Lazy Loading Feature Modules</a> guide.</p>\n\n</div>\n<p translation-result=\"on\">使用 <code>forRoot()</code> 来把提供者从该模块中分离出去，这样你就能在根模块中导入该模块时带上 <code>providers</code>，并且在子模块中导入它时不带 <code>providers</code>。</p><p translation-origin=\"off\">Use <code>forRoot()</code> to\nseparate providers from a module so you can import that module into the root module\nwith <code>providers</code> and child modules without <code>providers</code>.</p>\n\n<ol>\n<li>\n<p translation-result=\"on\">在该模块中创建一个静态方法 <code>forRoot()</code>。</p><p translation-origin=\"off\">Create a static method <code>forRoot()</code> on the module.</p>\n\n</li>\n<li>\n<p translation-result=\"on\">把这些提供者放进 <code>forRoot()</code> 方法中。</p><p translation-origin=\"off\">Place the providers into the <code>forRoot()</code> method.</p>\n\n</li>\n</ol>\n<code-example path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"for-root\" header=\"src/app/greeting/greeting.module.ts\">\n<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: UserServiceConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&#x3C;GreetingModule> {\n  return {\n    ngModule: GreetingModule,\n    providers: [\n      {provide: UserServiceConfig, useValue: config }\n    ]\n  };\n}\n\n</code-example>\n<a id=\"forRoot-router\"></a>\n<h3 id=\"forroot-and-the-router\" translation-result=\"on\"><code>forRoot()</code> 和 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#forroot-and-the-router\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"forroot-and-the-router\"><code>forRoot()</code> and the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#forroot-and-the-router\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 中提供了 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 服务，同时还有一些路由指令，比如 <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 和 <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 等。应用的根模块导入了 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>，以便应用中有一个 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 服务，并且让应用的根组件可以访问各个路由器指令。任何一个特性模块也必须导入 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>，这样它们的组件模板中才能使用这些路由器指令。</p><p translation-origin=\"off\"><code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> provides the <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> service, as well as router directives, such as <code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> and <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code>. The root application module imports <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> so that the application has a <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> and the root application components can access the router directives. Any feature modules must also import <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> so that their components can place router directives into their templates.</p>\n\n<p translation-result=\"on\">如果 <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 没有 <code>forRoot()</code>，那么每个特性模块都会实例化一个新的 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 实例，而这会破坏应用的正常逻辑，因为应用中只能有一个 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 实例。通过使用 <code>forRoot()</code> 方法，应用的根模块中会导入 <code>RouterModule.forRoot(...)</code>，从而获得一个 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 实例，而所有的特性模块要导入 <code>RouterModule.forChild(...)</code>，它就不会实例化另外的 <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>。</p><p translation-origin=\"off\">If the <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> didn’t have <code>forRoot()</code> then each feature module would instantiate a new <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> instance, which would break the application as there can only be one <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>. By using the <code>forRoot()</code> method, the root application module imports <code>RouterModule.forRoot(...)</code> and gets a <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>, and all feature modules import <code>RouterModule.forChild(...)</code> which does not instantiate another <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>.</p>\n\n<div class=\"alert is-helpful\">\n<p translation-result=\"on\"><strong>注意：</strong>如果你的某个模块也同时有 providers 和 declarations，你也<em>可以</em>使用这种技巧来把它们分开。你可能会在某些传统应用中看到这种模式。\n不过，从 Angular 6.0 开始，提供服务的最佳实践是使用 <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 的 <code>providedIn</code> 属性。</p><p translation-origin=\"off\"><strong>Note:</strong> If you have a module which has both providers and declarations,\nyou <em>can</em> use this\ntechnique to separate them out and you may see this pattern in legacy apps.\nHowever, since Angular 6.0, the best practice for providing services is with the\n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> <code>providedIn</code> property.</p>\n\n</div>\n<h3 id=\"how-forroot-works\" translation-result=\"on\"><code>forRoot()</code> 的工作原理<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#how-forroot-works\"><i class=\"material-icons\">link</i></a></h3><h3 translation-origin=\"off\" id=\"how-forroot-works\">How <code>forRoot()</code> works<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#how-forroot-works\"><i class=\"material-icons\">link</i></a></h3>\n\n<p translation-result=\"on\"><code>forRoot()</code> 会接受一个服务配置对象，并返回一个 <a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a> 对象，它带有下列属性：</p><p translation-origin=\"off\"><code>forRoot()</code> takes a service configuration object and returns a\n<a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>, which is\na simple object with the following properties:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"><code>ngModule</code>：在这个例子中，就是 <code>GreetingModule</code> 类。</p><p translation-origin=\"off\"><code>ngModule</code>: in this example, the <code>GreetingModule</code> class.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <code>providers</code> - 配置好的服务提供者</p><p translation-origin=\"off\"><code>providers</code>: the configured providers.</p>\n\n</li>\n</ul>\n<p translation-result=\"on\">在这个 <live-example name=\"ngmodules\">现场演练</live-example>中，根模块 <code>AppModule</code> 导入了 <code>GreetingModule</code>，并把它的 <code>providers</code> 添加到了 <code>AppModule</code> 的服务提供者列表中。特别是，Angular 会把所有从其它模块导入的提供者追加到本模块的 <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 中列出的提供者之前。这种顺序可以确保你在 <code>AppModule</code> 的 <code>providers</code> 中显式列出的提供者，其优先级高于导入模块中给出的提供者。</p><p translation-origin=\"off\">In the <live-example name=\"ngmodules\">live example</live-example>\nthe root <code>AppModule</code> imports the <code>GreetingModule</code> and adds the\n<code>providers</code> to the <code>AppModule</code> providers. Specifically,\nAngular accumulates all imported providers\nbefore appending the items listed in <code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>.\nThis sequence ensures that whatever you add explicitly to\nthe <code>AppModule</code> providers takes precedence over the providers\nof imported modules.</p>\n\n<p translation-result=\"on\">在这个范例应用中，导入 <code>GreetingModule</code>，并只在 <code>AppModule</code> 中调用一次它的 <code>forRoot()</code> 方法。像这样注册它一次就可以防止出现多个实例。</p><p translation-origin=\"off\">The sample app imports <code>GreetingModule</code> and uses its <code>forRoot()</code> method one time, in <code>AppModule</code>. Registering it once like this prevents multiple instances.</p>\n\n<p translation-result=\"on\">你还可以在 <code>GreetingModule</code> 中添加一个用于配置 <code>UserService</code> 的 <code>forRoot()</code> 方法。</p><p translation-origin=\"off\">You can also add a <code>forRoot()</code> method in the <code>GreetingModule</code> that configures\nthe greeting <code>UserService</code>.</p>\n\n<p translation-result=\"on\">在下面的例子中，可选的注入 <code>UserServiceConfig</code> 扩展了 <code>UserService</code>。如果 <code>UserServiceConfig</code> 存在，就从这个配置中设置用户名。</p><p translation-origin=\"off\">In the following example, the optional, injected <code>UserServiceConfig</code>\nextends the greeting <code>UserService</code>. If a <code>UserServiceConfig</code> exists, the <code>UserService</code> sets the user name from that config.</p>\n\n<code-example path=\"ngmodules/src/app/greeting/user.service.ts\" region=\"ctor\" header=\"src/app/greeting/user.service.ts (constructor)\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() config?: UserServiceConfig) {\n  if (config) { this._userName = config.userName; }\n}\n\n</code-example>\n<p translation-result=\"on\">下面是一个接受 <code>UserServiceConfig</code> 参数的 <code>forRoot()</code> 方法：</p><p translation-origin=\"off\">Here's <code>forRoot()</code> that takes a <code>UserServiceConfig</code> object:</p>\n\n<code-example path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"for-root\" header=\"src/app/greeting/greeting.module.ts (forRoot)\">\n<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: UserServiceConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&#x3C;GreetingModule> {\n  return {\n    ngModule: GreetingModule,\n    providers: [\n      {provide: UserServiceConfig, useValue: config }\n    ]\n  };\n}\n\n</code-example>\n<p translation-result=\"on\">最后，在 <code>AppModule</code> 的 <code>imports</code><em>列表</em>中调用它。在下面的代码片段中，省略了文件的另一部分。要查看完整文件，参见 <live-example name=\"ngmodules\"></live-example> 或继续阅读本文档的后续章节。</p><p translation-origin=\"off\">Lastly, call it within the <code>imports</code> list of the <code>AppModule</code>. In the following\nsnippet, other parts of the file are left out. For the complete file, see the <live-example name=\"ngmodules\"></live-example>, or continue to the next section of this document.</p>\n\n<code-example path=\"ngmodules/src/app/app.module.ts\" region=\"import-for-root\" header=\"src/app/app.module.ts (imports)\">\nimport { GreetingModule } from './greeting/greeting.module';\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    GreetingModule.forRoot({userName: 'Miss Marple'}),\n  ],\n})\n\n</code-example>\n<p translation-result=\"on\">该应用不再显示默认的 “Sherlock Holmes”，而是用 “Miss Marple” 作为用户名称。</p><p translation-origin=\"off\">The app displays \"Miss Marple\" as the user instead of the default \"Sherlock Holmes\".</p>\n\n<p translation-result=\"on\">记住：在本文件的顶部要以 JavaScript  import 形式导入 <code>GreetingModule</code>，并且不要把它多次加入到本 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的 <code>imports</code> 列表中。</p><p translation-origin=\"off\">Remember to import <code>GreetingModule</code> as a Javascript import at the top of the file and don't add it to more than one <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> <code>imports</code> list.</p>\n\n<h2 id=\"prevent-reimport-of-the-greetingmodule\" translation-result=\"on\">防止重复导入 <code>GreetingModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#prevent-reimport-of-the-greetingmodule\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"prevent-reimport-of-the-greetingmodule\">Prevent reimport of the <code>GreetingModule</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#prevent-reimport-of-the-greetingmodule\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">只有根模块 <code>AppModule</code> 才能导入 <code>GreetingModule</code>。如果一个惰性加载模块也导入了它，\n该应用就会为服务生成<a href=\"guide/ngmodule-faq#q-why-bad\">多个实例</a>。</p><p translation-origin=\"off\">Only the root <code>AppModule</code> should import the <code>GreetingModule</code>. If a\nlazy-loaded module imports it too, the app can generate\n<a href=\"guide/ngmodule-faq#q-why-bad\">multiple instances</a> of a service.</p>\n\n<p translation-result=\"on\">要想防止惰性加载模块重复导入 <code>GreetingModule</code>，可以添加如下的 <code>GreetingModule</code> 构造函数。</p><p translation-origin=\"off\">To guard against a lazy loaded module re-importing <code>GreetingModule</code>, add the following <code>GreetingModule</code> constructor.</p>\n\n<code-example path=\"ngmodules/src/app/greeting/greeting.module.ts\" region=\"ctor\" header=\"src/app/greeting/greeting.module.ts\">\nconstructor (@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule?: GreetingModule) {\n  if (parentModule) {\n    throw new Error(\n      'GreetingModule is already loaded. Import it in the AppModule only');\n  }\n}\n\n</code-example>\n<p translation-result=\"on\">该构造函数要求 Angular 把 <code>GreetingModule</code> 注入它自己。\n如果 Angular 在<em>当前</em>注入器中查找 <code>GreetingModule</code>，这次注入就会导致死循环，但是 <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 装饰器的意思是 \"在注入器树中层次高于我的祖先注入器中查找 <code>GreetingModule</code>。\"</p><p translation-origin=\"off\">The constructor tells Angular to inject the <code>GreetingModule</code> into itself.\nThe injection would be circular if Angular looked for\n<code>GreetingModule</code> in the <em>current</em> injector, but the <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code>\ndecorator means \"look for <code>GreetingModule</code> in an ancestor\ninjector, above me in the injector hierarchy.\"</p>\n\n<p translation-result=\"on\">如果该构造函数如预期般执行在 <code>AppModule</code> 中，那就不会有任何祖先注入器可以提供 <code>CoreModule</code> 的实例，所以该注入器就会放弃注入。</p><p translation-origin=\"off\">If the constructor executes as intended in the <code>AppModule</code>,\nthere would be no ancestor injector that could provide an instance of <code>CoreModule</code> and the injector should give up.</p>\n\n<p translation-result=\"on\">默认情况下，当注入器找不到想找的提供者时，会抛出一个错误。\n但 <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 装饰器表示找不到该服务也无所谓。\n于是注入器会返回 <code>null</code>，<code>parentModule</code> 参数也就被赋成了空值，而构造函数没有任何异常。</p><p translation-origin=\"off\">By default, the injector throws an error when it can't\nfind a requested provider.\nThe <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> decorator means not finding the service is OK.\nThe injector returns <code>null</code>, the <code>parentModule</code> parameter is null,\nand the constructor concludes uneventfully.</p>\n\n<p translation-result=\"on\">但如果你把 <code>GreetingModule</code> 导入到像 <code>CustomerModule</code> 这样的惰性加载模块中，事情就不一样了。</p><p translation-origin=\"off\">It's a different story if you improperly import <code>GreetingModule</code> into a lazy loaded module such as <code>CustomersModule</code>.</p>\n\n<p translation-result=\"on\">Angular 创建惰性加载模块时会给它一个自己的注入器，它是根注入器的<em>子注入器</em>。\n<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> 让 Angular 在其父注入器中查找 <code>GreetingModule</code>，这次，它的父注入器是根注入器（而上次的父注入器是空）。\n当然，这次它找到了由根模块 <code>AppModule</code> 导入的实例。\n该构造函数检测到存在 <code>parentModule</code>，于是抛出一个错误。</p><p translation-origin=\"off\">Angular creates a lazy loaded module with its own injector,\na child of the root injector.\n<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>()</code> causes Angular to look for a <code>GreetingModule</code> in the parent injector, which this time is the root injector.\nOf course it finds the instance imported by the root <code>AppModule</code>.\nNow <code>parentModule</code> exists and the constructor throws the error.</p>\n\n<p translation-result=\"on\">以下这两个文件仅供参考：</p><p translation-origin=\"off\">Here are the two files in their entirety for reference:</p>\n\n<code-tabs>\n <code-pane header=\"app.module.ts\" path=\"ngmodules/src/app/app.module.ts\">\n\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-browser';\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\n\n/* App Root */\nimport { AppComponent } from './app.component';\n\n/* Feature Modules */\nimport { ContactModule } from './contact/contact.module';\nimport { GreetingModule } from './greeting/greeting.module';\n\n/* Routing Module */\nimport { AppRoutingModule } from './app-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    ContactModule,\n    GreetingModule.forRoot({userName: 'Miss Marple'}),\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n\n</code-pane>\n <code-pane header=\"greeting.module.ts\" region=\"whole-greeting-module\" path=\"ngmodules/src/app/greeting/greeting.module.ts\">\nimport { <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>, <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> } from '@angular/core';\n\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> } from '@angular/common';\n\nimport { GreetingComponent } from './greeting.component';\nimport { UserServiceConfig } from './user.service';\n\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> ],\n  declarations: [ GreetingComponent ],\n  exports:      [ GreetingComponent ]\n})\nexport class GreetingModule {\n  constructor (@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule?: GreetingModule) {\n    if (parentModule) {\n      throw new Error(\n        'GreetingModule is already loaded. Import it in the AppModule only');\n    }\n  }\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: UserServiceConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>&#x3C;GreetingModule> {\n    return {\n      ngModule: GreetingModule,\n      providers: [\n        {provide: UserServiceConfig, useValue: config }\n      ]\n    };\n  }\n}\n\n</code-pane>\n</code-tabs>\n<hr>\n<h2 id=\"more-on-ngmodules\" translation-result=\"on\">关于 NgModule 的更多知识<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#more-on-ngmodules\"><i class=\"material-icons\">link</i></a></h2><h2 translation-origin=\"off\" id=\"more-on-ngmodules\">More on NgModules<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/singleton-services#more-on-ngmodules\"><i class=\"material-icons\">link</i></a></h2>\n\n<p translation-result=\"on\">你还可能对下列内容感兴趣：</p><p translation-origin=\"off\">You may also be interested in:</p>\n\n<ul>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/sharing-ngmodules\">共享模块</a>解释了本页中涉及的这些概念。</p><p translation-origin=\"off\"><a href=\"guide/sharing-ngmodules\">Sharing Modules</a>, which elaborates on the concepts covered on this page.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/lazy-loading-ngmodules\">惰性加载模块</a>。</p><p translation-origin=\"off\"><a href=\"guide/lazy-loading-ngmodules\">Lazy Loading Modules</a>.</p>\n\n</li>\n<li>\n<p translation-result=\"on\"> <a href=\"guide/ngmodule-faq\">NgModule 常见问题</a>。</p><p translation-origin=\"off\"><a href=\"guide/ngmodule-faq\">NgModule FAQ</a>.</p>\n\n</li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - guide/creating-libraries\n - guide/lazy-loading-ngmodules\n - guide/ngmodule-faq\n - guide/providers\n - guide/router\n-->\n<!-- links from this doc:\n - api/common/CommonModule\n - api/core/Injectable\n - api/core/ModuleWithProviders\n - api/core/NgModule\n - api/core/NgModule#providers\n - api/core/Optional\n - api/core/SkipSelf\n - api/platform-browser/BrowserModule\n - api/router/Router\n - api/router/RouterLink\n - api/router/RouterModule\n - api/router/RouterOutlet\n - api/upgrade/static\n - guide/lazy-loading-ngmodules\n - guide/ngmodule-faq\n - guide/ngmodule-faq#q-why-bad\n - guide/sharing-ngmodules\n - guide/singleton-services#forroot-and-the-router\n - guide/singleton-services#how-forroot-works\n - guide/singleton-services#more-on-ngmodules\n - guide/singleton-services#ngmodule-providers-array\n - guide/singleton-services#prevent-reimport-of-the-greetingmodule\n - guide/singleton-services#providedIn\n - guide/singleton-services#providing-a-singleton-service\n - guide/singleton-services#singleton-services\n - guide/singleton-services#the-forroot-pattern\n - guide/singleton-services#using-providedin\n - tutorial\n - tutorial/toh-pt4\n - https://github.com/angular/angular-cn/edit/aio/aio/content/guide/singleton-services.md?message=docs%3A%20请简述你的修改...\n-->"
}