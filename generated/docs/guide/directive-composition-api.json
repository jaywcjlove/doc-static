{
  "id": "guide/directive-composition-api",
  "title": "指令组合 API",
  "contents": "\n\n\n<div class=\"github-links\">\n  <a href=\"https://github.com/angular/angular-cn/edit/cn/aio/content/guide/directive-composition-api.md?message=docs%3A%20请简述你的修改...\" aria-label=\"提供编辑建议\" title=\"提供编辑建议\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n</div>\n\n\n<div class=\"content\">\n  <h1 id=\"directive-composition-api\">Directive composition API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-composition-api\"><i class=\"material-icons\">link</i></a></h1>\n<h1 id=\"指令组合-api\">指令组合 API<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#指令组合-api\"><i class=\"material-icons\">link</i></a></h1>\n<p>Angular directives offer a great way to encapsulate reusable behaviors— directives can apply\nattributes, CSS classes, and event listeners to an element.</p>\n<p>Angular 指令提供了一种封装可复用行为的好方法 —— 指令可以将属性、CSS 类和事件侦听器应用于元素。</p>\n<p>The <em>directive composition API</em> lets you apply directives to a component's host element from\n<em>within</em> the component.</p>\n<p><em>指令组合 API</em> 允许你从组件<em>内部</em>将指令应用于此组件的宿主元素。</p>\n<h2 id=\"adding-directives-to-a-component\">Adding directives to a component<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-a-component\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"向组件添加指令\">向组件添加指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#向组件添加指令\"><i class=\"material-icons\">link</i></a></h2>\n<p>You apply directives to a component by adding a <code>hostDirectives</code> property to a component's\ndecorator. We call such directives <em>host directives</em>.</p>\n<p>你可以通过将 <code>hostDirectives</code> 属性添加到组件的装饰器来将指令应用于组件。我们称这样的指令为<em>宿主指令</em>。</p>\n<p>In this example, we apply the directive <code>MenuBehavior</code> to the host element of <code>AdminMenu</code>. This\nworks similarly to applying the <code>MenuBehavior</code> to the <code>&#x3C;admin-menu></code> element in a template.</p>\n<p>在此示例中，我们将指令 <code>MenuBehavior</code> 应用于 <code>AdminMenu</code> 的宿主元素。这类似于将 <code>MenuBehavior</code> 应用于模板中的 <code>&#x3C;admin-menu></code> 元素。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n</code-example>\n<p>When the framework renders a component, Angular also creates an instance of each host directive. The\ndirectives' host bindings apply to the component's host element. By default, host directive inputs\nand outputs are not exposed as part of the component's public API. See\n<a href=\"guide/directive-composition-api#including-inputs-and-outputs\">Including inputs and outputs</a> below for more information.</p>\n<p>当框架渲染组件时，Angular 还会创建每个宿主指令的实例。指令的宿主绑定被应用于组件的宿主元素。默认情况下，宿主指令的输入和输出不会作为组件公共 API 的一部分公开。有关更多信息，请参阅下面的<a href=\"guide/directive-composition-api#including-inputs-and-outputs\">包含输入属性和输出属性</a>。</p>\n<p><strong>Angular applies host directives statically at compile time.</strong> You cannot dynamically add\ndirectives at runtime.</p>\n<p><strong>Angular 会在编译时静态应用宿主指令</strong>。你不能在运行时动态添加指令。</p>\n<p><strong>Directives used in <code>hostDirectives</code> must be <code>standalone: true</code>.</strong></p>\n<p><strong><code>hostDirectives</code> 中使用的指令必须是 <code>standalone: true</code> 的。</strong></p>\n<p><strong>Angular ignores the <code>selector</code> of directives applied in the <code>hostDirectives</code> property.</strong></p>\n<p><strong>Angular 会忽略 <code>hostDirectives</code> 属性中所应用的那些指令的 <code>selector</code> 。</strong></p>\n<h2 id=\"including-inputs-and-outputs\">Including inputs and outputs<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#including-inputs-and-outputs\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"包含输入属性和输出属性\">包含输入属性和输出属性<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#包含输入属性和输出属性\"><i class=\"material-icons\">link</i></a></h2>\n<p>When you apply <code>hostDirectives</code> to your component, the inputs and outputs from the host directives\nare not included in your component's API by default. You can explicitly include inputs and outputs\nin your component's API by expanding the entry in <code>hostDirectives</code>:</p>\n<p>默认情况下，当你将 <code>hostDirectives</code> 应用于组件时，宿主指令的输入属性和输出属性不会包含在组件的 API 中。你可以通过扩展 <code>hostDirectives</code> 中的条目来在组件的 API 中显式包含输入和输出：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId'],\n    outputs: ['menuClosed'],\n  }],\n})\nexport class AdminMenu { }\n</code-example>\n<p>By explicitly specifying the inputs and outputs, consumers of the component with <code>hostDirective</code> can\nbind them in a template:</p>\n<p>通过显式指定输入和输出，使用 <code>hostDirective</code> 的组件的使用者可以将它们绑定在模板中：</p>\n<code-example language=\"html\">\n&#x3C;admin-menu menuId=\"top-menu\" (menuClosed)=\"logMenuClosed()\">\n</code-example>\n<p>Furthermore, you can alias inputs and outputs from <code>hostDirective</code> to customize the API of your\ncomponent:</p>\n<p>此外，你可以为 <code>hostDirective</code> 的输入和输出起别名来自定义组件的 API：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [{\n    directive: MenuBehavior,\n    inputs: ['menuId: id'],\n    outputs: ['menuClosed: closed'],\n  }],\n})\nexport class AdminMenu { }\n</code-example>\n<code-example language=\"html\">\n&#x3C;admin-menu id=\"top-menu\" (closed)=\"logMenuClosed()\">\n</code-example>\n<h2 id=\"adding-directives-to-another-directive\">Adding directives to another directive<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#adding-directives-to-another-directive\"><i class=\"material-icons\">link</i></a></h2>\n<h2 id=\"将指令添加到另一个指令\">将指令添加到另一个指令<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#将指令添加到另一个指令\"><i class=\"material-icons\">link</i></a></h2>\n<p>You can also add <code>hostDirectives</code> to other directives, in addition to components. This enables the\ntransitive aggregation of multiple behaviors.</p>\n<p>除了组件之外，你还可以将 <code>hostDirectives</code> 添加到其他指令。这启用了多个行为的可传递聚合能力。</p>\n<p>In the following example, we define two directives, <code>Menu</code> and <code>Tooltip</code>. We then compose the behavior\nof these two directives in <code>MenuWithTooltip</code>. Finally, we apply <code>MenuWithTooltip</code>\nto <code>SpecializedMenuWithTooltip</code>.</p>\n<p>在以下示例中，我们定义了两个指令，<code>Menu</code> 和 <code>Tooltip</code>。然后，我们会在 <code>MenuWithTooltip</code> 中组合这两个指令的行为。最后，我们将 <code>MenuWithTooltip</code> 应用到 <code>SpecializedMenuWithTooltip</code> 上。</p>\n<p>When <code>SpecializedMenuWithTooltip</code> is used in a template, it creates instances of all of <code>Menu</code>\n, <code>Tooltip</code>, and <code>MenuWithTooltip</code>. Each of these directives' host bindings apply to the host\nelement of <code>SpecializedMenuWithTooltip</code>.</p>\n<p>在模板中使用 <code>SpecializedMenuWithTooltip</code> 时，它会创建 <code>Menu</code>、<code>Tooltip</code> 和 <code>MenuWithTooltip</code> 的所有实例。这些指令的宿主绑定中的每一个都会应用于 <code>SpecializedMenuWithTooltip</code> 的宿主元素。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Menu { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Tooltip { }\n\n// MenuWithTooltip can compose behaviors from <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> other directives\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  hostDirectives: [Tooltip, Menu],\n})\nexport class MenuWithTooltip { }\n\n// CustomWidget can apply the already-composed behaviors from MenuWithTooltip\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  hostDirectives: [MenuWithTooltip],\n})\nexport class SpecializedMenuWithTooltip { }\n</code-example>\n<h2 id=\"host-directive-semantics\">Host directive semantics<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#host-directive-semantics\"><i class=\"material-icons\">link</i></a></h2>\n<p>##宿主指令的语义</p>\n<h3 id=\"directive-execution-order\">Directive execution order<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#directive-execution-order\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"指令的执行顺序\">指令的执行顺序<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#指令的执行顺序\"><i class=\"material-icons\">link</i></a></h3>\n<p>Host directives go through the same lifecycle as components and directives used directly in a\ntemplate. However, host directives always execute their constructor, lifecycle hooks, and bindings <em>\nbefore</em> the component or directive on which they are applied.</p>\n<p>宿主指令和直接在模板中使用的组件和指令会经历相同的生命周期。但是，宿主指令总是会在应用它们的组件或指令<em>之前</em>执行它们的构造函数、生命周期钩子和绑定。</p>\n<p>The following example shows minimal use of a host directive:</p>\n<p>以下示例显示了宿主指令的最小化使用：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'admin-menu',\n  template: 'admin-menu.html',\n  hostDirectives: [MenuBehavior],\n})\nexport class AdminMenu { }\n</code-example>\n<p>The order of execution here is:</p>\n<p>这里的执行顺序是：</p>\n<ol>\n<li>\n<p><code>MenuBehavior</code> instantiated</p>\n<p><code>MenuBehavior</code> 实例化</p>\n</li>\n<li>\n<p><code>AdminMenu</code> instantiated</p>\n<p><code>AdminMenu</code> 实例化</p>\n</li>\n<li>\n<p><code>MenuBehavior</code> receives inputs (<code>ngOnInit</code>)</p>\n<p><code>MenuBehavior</code> 接收输入（ <code>ngOnInit</code> ）</p>\n</li>\n<li>\n<p><code>AdminMenu</code> receives inputs (<code>ngOnInit</code>)</p>\n<p><code>AdminMenu</code> 接收输入 ( <code>ngOnInit</code> )</p>\n</li>\n<li>\n<p><code>MenuBehavior</code> applies host bindings</p>\n<p><code>MenuBehavior</code> 应用宿主绑定</p>\n</li>\n<li>\n<p><code>AdminMenu</code> applies host bindings</p>\n<p><code>AdminMenu</code> 应用宿主绑定</p>\n</li>\n</ol>\n<p>This order of operations means that components with <code>hostDirectives</code> can override any host bindings\nspecified by a host directive.</p>\n<p>这种操作顺序意味着带有 <code>hostDirectives</code> 的组件可以改写（override）宿主指令指定的任何宿主绑定。</p>\n<p>This order of operations extends to nested chains of host directives, as shown in the following\nexample.</p>\n<p>展开宿主指令的嵌套链的操作顺序，如下例所示。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({...})\nexport class Tooltip { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  hostDirectives: [Tooltip],\n})\nexport class CustomTooltip { }\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  hostDirectives: [CustomTooltip],\n})\nexport class EvenMoreCustomTooltip { }\n</code-example>\n<p>In the example above, the order of execution is:</p>\n<p>在上面的示例中，执行顺序是：</p>\n<ol>\n<li>\n<p><code>Tooltip</code> instantiated</p>\n<p><code>Tooltip</code> 实例化</p>\n</li>\n<li>\n<p><code>CustomTooltip</code> instantiated</p>\n<p><code>CustomTooltip</code> 实例化</p>\n</li>\n<li>\n<p><code>EvenMoreCustomTooltip</code> instantiated</p>\n<p><code>EvenMoreCustomTooltip</code> 实例化</p>\n</li>\n<li>\n<p><code>Tooltip</code> receives inputs (<code>ngOnInit</code>)</p>\n<p><code>Tooltip</code> 接收输入 ( <code>ngOnInit</code> )</p>\n</li>\n<li>\n<p><code>CustomTooltip</code> receives inputs (<code>ngOnInit</code>)</p>\n<p><code>CustomTooltip</code> 接收输入 ( <code>ngOnInit</code> )</p>\n</li>\n<li>\n<p><code>EvenMoreCustomTooltip</code> receives inputs (<code>ngOnInit</code>)</p>\n<p><code>EvenMoreCustomTooltip</code> 接收输入 ( <code>ngOnInit</code> )</p>\n</li>\n<li>\n<p><code>Tooltip</code> applies host bindings</p>\n<p><code>Tooltip</code> 应用宿主绑定</p>\n</li>\n<li>\n<p><code>CustomTooltip</code> applies host bindings</p>\n<p><code>CustomTooltip</code> 应用宿主绑定</p>\n</li>\n<li>\n<p><code>EvenMoreCustomTooltip</code> applies host bindings</p>\n<p><code>EvenMoreCustomTooltip</code> 应用宿主绑定</p>\n</li>\n</ol>\n<h3 id=\"dependency-injection\">Dependency injection<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#dependency-injection\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"依赖注入\">依赖注入<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#依赖注入\"><i class=\"material-icons\">link</i></a></h3>\n<p>A component or directive that specifies <code>hostDirectives</code> can inject the instances of those host\ndirectives and vice versa.</p>\n<p>指定了 <code>hostDirectives</code> 的组件或指令可以注入这些宿主指令的实例，反之亦然。</p>\n<p>When applying host directives to a component, both the component and host directives can define\nproviders.</p>\n<p>当把宿主指令应用于组件时，组件和宿主指令都可以定义提供者。</p>\n<p>If a component or directive with <code>hostDirectives</code> and those host directives both provide the same\ninjection token, the providers defined by class with <code>hostDirectives</code> take precedence over providers\ndefined by the host directives.</p>\n<p>如果带有 <code>hostDirectives</code> 的组件或指令以及这些宿主指令都提供相同的注入令牌，则带有 <code>hostDirectives</code> 的类定义的提供者会优先于宿主指令定义的提供者。</p>\n<h3 id=\"performance\">Performance<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#performance\"><i class=\"material-icons\">link</i></a></h3>\n<h3 id=\"性能\">性能<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/directive-composition-api#性能\"><i class=\"material-icons\">link</i></a></h3>\n<p>While the directive composition API offers a powerful tool for reusing common behaviors, excessive\nuse of host directives can impact your application's memory use. If you create components or\ndirectives that use <em>many</em> host directives, you may inadvertently balloon the memory used by your\napplication.</p>\n<p>虽然指令组合 API 提供了一个强大的工具来复用常见行为，但过度使用宿主指令会影响应用程序的内存使用。如果你创建使用<em>许多个</em>宿主指令的组件或指令，你可能会无意中让应用程序占用的内存膨胀。</p>\n<p>The following example shows a component that applies several host directives.</p>\n<p>以下示例显示了一个应用多个宿主指令的组件。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  hostDirectives: [\n    DisabledState,\n    RequiredState,\n    ValidationState,\n    ColorState,\n    RippleBehavior,\n  ],\n})\nexport class CustomCheckbox { }\n</code-example>\n<p>This example declares a custom checkbox component that includes five host directives. This\nmeans that Angular will create six objects each time a <code>CustomCheckbox</code> renders— one for the\ncomponent and one for each host directive. For a few checkboxes on a page, this won't pose any\nsignificant issues. However, if your page renders <em>hundreds</em> of checkboxes, such as in a table, then\nyou could start to see an impact of the additional object allocations. Always be sure to profile\nyour application to determine the right composition pattern for your use case.</p>\n<p>此示例声明了一个自定义复选框组件，其中包含五个宿主指令。这意味着每次 <code>CustomCheckbox</code> 渲染时，Angular 将创建六个对象 —— 组件用一个，每个宿主指令用一个。对于页面上的少量复选框，这不会构成任何重大问题。但是，如果你的页面渲染<em>数百个</em>复选框（例如在表格中），那么你可能会开始看到额外对象分配的影响。始终确保对你的应用程序进行性能剖析，以便为你的用例确定正确的组合模式。</p>\n\n  \n</div>\n\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/Directive\n - api/forms/SelectMultipleControlValueAccessor\n - guide/directive-composition-api#adding-directives-to-a-component\n - guide/directive-composition-api#adding-directives-to-another-directive\n - guide/directive-composition-api#dependency-injection\n - guide/directive-composition-api#directive-composition-api\n - guide/directive-composition-api#directive-execution-order\n - guide/directive-composition-api#host-directive-semantics\n - guide/directive-composition-api#including-inputs-and-outputs\n - guide/directive-composition-api#performance\n - guide/directive-composition-api#依赖注入\n - guide/directive-composition-api#包含输入属性和输出属性\n - guide/directive-composition-api#向组件添加指令\n - guide/directive-composition-api#将指令添加到另一个指令\n - guide/directive-composition-api#性能\n - guide/directive-composition-api#指令的执行顺序\n - guide/directive-composition-api#指令组合-api\n - https://github.com/angular/angular-cn/edit/cn/aio/content/guide/directive-composition-api.md?message=docs%3A%20请简述你的修改...\n-->"
}