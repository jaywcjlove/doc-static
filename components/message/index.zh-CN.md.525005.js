(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{3155:function(a,b){a.exports={content:["section",["p","全局展示操作反馈信息。"],["h2","何时使用"],["ul",["li",["p","可提供成功、警告和错误等反馈信息。"]],["li",["p","顶部居中显示并自动消失，是一种不打断用户操作的轻量级提示方式。"]]]],meta:{category:"Components",subtitle:"全局提示",type:"反馈",noinstant:!0,title:"Message",cover:"https://gw.alipayobjects.com/zos/alicdn/hAkKTIW0K/Message.svg",filename:"components/message/index.zh-CN.md"},toc:["ul",["li",["a",{className:"bisheng-toc-h2",href:"#何时使用",title:"何时使用"},"何时使用"]],["li",["a",{className:"bisheng-toc-h2",href:"#API",title:"API"},"API"]],["li",["a",{className:"bisheng-toc-h2",href:"#FAQ",title:"FAQ"},"FAQ"]]],api:["section",["h2","API"],["p","组件提供了一些静态方法，使用方式和参数如下："],["ul",["li",["p",["code","message.success(content, [duration], onClose)"]]],["li",["p",["code","message.error(content, [duration], onClose)"]]],["li",["p",["code","message.info(content, [duration], onClose)"]]],["li",["p",["code","message.warning(content, [duration], onClose)"]]],["li",["p",["code","message.warn(content, [duration], onClose)"]," // alias of warning"]],["li",["p",["code","message.loading(content, [duration], onClose)"]]]],["table",["thead",["tr",["th","参数"],["th","说明"],["th","类型"],["th","默认值"]]],["tbody",["tr",["td","content"],["td","提示内容"],["td","string ","|"," ReactNode ","|"," config"],["td","-"]],["tr",["td","duration"],["td","自动关闭的延时，单位秒。设为 0 时不自动关闭"],["td","number"],["td","3"]],["tr",["td","onClose"],["td","关闭时触发的回调函数"],["td","function"],["td","-"]]]],["p","组件同时提供 promise 接口。"],["ul",["li",["p",["code","message[level](content, [duration]).then(afterClose)"]]],["li",["p",["code","message[level](content, [duration], onClose).then(afterClose)"]]]],["p","其中",["code","message[level]"]," 是组件已经提供的静态方法。",["code","then"]," 接口返回值是 Promise。"],["p","也可以对象的形式传递参数："],["ul",["li",["p",["code","message.open(config)"]]],["li",["p",["code","message.success(config)"]]],["li",["p",["code","message.error(config)"]]],["li",["p",["code","message.info(config)"]]],["li",["p",["code","message.warning(config)"]]],["li",["p",["code","message.warn(config)"]," // alias of warning"]],["li",["p",["code","message.loading(config)"]]]],["p",["code","config"]," 对象属性如下："],["table",["thead",["tr",["th","参数"],["th","说明"],["th","类型"],["th","默认值"]]],["tbody",["tr",["td","content"],["td","提示内容"],["td","ReactNode"],["td","-"]],["tr",["td","duration"],["td","自动关闭的延时，单位秒。设为 0 时不自动关闭"],["td","number"],["td","3"]],["tr",["td","onClose"],["td","关闭时触发的回调函数"],["td","function"],["td","-"]],["tr",["td","icon"],["td","自定义图标"],["td","ReactNode"],["td","-"]],["tr",["td","key"],["td","当前提示的唯一标志"],["td","string ","|"," number"],["td","-"]],["tr",["td","className"],["td","自定义 CSS class"],["td","string"],["td","-"]],["tr",["td","style"],["td","自定义内联样式"],["td",["a",{title:null,href:"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/e434515761b36830c3e58a970abf5186f005adac/types/react/index.d.ts#L794"},"CSSProperties"]],["td","-"]]]],["h3","全局方法"],["p","还提供了全局配置和全局销毁方法："],["ul",["li",["p",["code","message.config(options)"]]],["li",["p",["code","message.destroy()"]]]],["h4","message.config"],["blockquote",["p","当你使用 ",["code","ConfigProvider"]," 进行全局化配置时，系统会默认自动开启 RTL 模式。(4.3.0+)"],["p","当你想单独使用，可通过如下设置开启 RTL 模式。"]],["pre",{lang:"js",highlighted:`message<span class="token punctuation">.</span><span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  top<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span>
  duration<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  maxCount<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  rtl<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  prefixCls<span class="token punctuation">:</span> <span class="token string">'my-message'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>`},["code",`message.config({
  top: 100,
  duration: 2,
  maxCount: 3,
  rtl: true,
  prefixCls: 'my-message',
});`]],["table",["thead",["tr",["th","参数"],["th","说明"],["th","类型"],["th","默认值"],["th","版本"]]],["tbody",["tr",["td","duration"],["td","默认自动关闭延时，单位秒"],["td","number"],["td","3"],["td"]],["tr",["td","getContainer"],["td","配置渲染节点的输出位置"],["td","() => HTMLElement"],["td","() => document.body"],["td"]],["tr",["td","maxCount"],["td","最大显示数, 超过限制时，最早的消息会被自动关闭"],["td","number"],["td","-"],["td"]],["tr",["td","top"],["td","消息距离顶部的位置"],["td","number"],["td","24"],["td"]],["tr",["td","rtl"],["td","是否开启 RTL 模式"],["td","boolean"],["td","false"],["td"]],["tr",["td","prefixCls"],["td","消息节点的 className 前缀"],["td","string"],["td",["code","ant-message"]],["td","4.5.0"]]]],["h2","FAQ"],["h3","为什么 message 不能获取 context、redux 的内容？"],["p","直接调用 message 方法，antd 会通过 ",["code","ReactDOM.render"]," 动态创建新的 React 实体。其 context 与当前代码所在 context 并不相同，因而无法获取 context 信息。"],["p","当你需要 context 信息（例如 ConfigProvider 配置的内容）时，可以通过 ",["code","message.useMessage"]," 方法会返回 ",["code","api"]," 实体以及 ",["code","contextHolder"]," 节点。将其插入到你需要获取 context 位置即可："],["pre",{lang:"tsx",highlighted:`<span class="token keyword">const</span> <span class="token punctuation">[</span>api<span class="token punctuation">,</span> contextHolder<span class="token punctuation">]</span> <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">useMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>

return <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>Context1<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token string">"Ant"</span><span class="token operator">></span>
    {<span class="token operator">/</span><span class="token operator">*</span> contextHolder 在 Context1 内，它可以获得 Context1 的 context <span class="token operator">*</span><span class="token operator">/</span>}
    {contextHolder}
    <span class="token operator">&lt;</span>Context2<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token string">"Design"</span><span class="token operator">></span>
      {<span class="token operator">/</span><span class="token operator">*</span> contextHolder 在 Context2 外，因而不会获得 Context2 的 context <span class="token operator">*</span><span class="token operator">/</span>}
    <span class="token operator">&lt;</span><span class="token operator">/</span>Context2<span class="token punctuation">.</span>Provider<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>Context1<span class="token punctuation">.</span>Provider<span class="token operator">></span>
<span class="token punctuation">)</span><span class="token comment" spellcheck="true">;</span>`},["code",`const [api, contextHolder] = message.useMessage();

return (
  <Context1.Provider value="Ant">
    {/* contextHolder 在 Context1 内，它可以获得 Context1 的 context */}
    {contextHolder}
    <Context2.Provider value="Design">
      {/* contextHolder 在 Context2 外，因而不会获得 Context2 的 context */}
    </Context2.Provider>
  </Context1.Provider>
);`]],["p",["strong","异同："],"通过 hooks 创建的 ",["code","contextHolder"]," 必须插入到子元素节点中才会生效，当你不需要上下文信息时请直接调用。"]]}}}]);
