{"componentChunkName":"component---src-templates-play-example-tsx","path":"/zh/play/typescript/primitives/any.ts.html","result":{"pageContext":{"name":"Any","title":"Any","lang":"zh","html":" Any 是 TypeScript 的一个例外，你可以用 any 来声明一段代码是\n 类似于 JavaScript 一样动态的，或者解决类型系统的一些限制。\n\n 解析 JSON 是一个很好的例子：\n\n<code><pre>\nconst myObject = JSON.parse(\"{}\");\n\n</pre></code>\n// Any 声明代表着 TypeScript 将认为你更了解你的代码，\n 并且认为你的代码是安全的，即使它并不一定严格正确。\n 这段代码将会崩溃：\n\n<code><pre>\nmyObject.x.y.z;\n\n</pre></code>\n// 使用 any 将会赋予你在舍弃一些类型安全性的前提下，\n 编写更接近原生 JavaScript 的代码能力。\n\n any 更像一个类型通配符，它可以允许你替换为任何类型（never 除外）\n 以使一种类型可以分配给另一种类型。\n\n<code><pre>\ndeclare function debug(value: any): void;\n\ndebug(\"a string\");\ndebug(23);\ndebug({ color: \"blue\" });\n\n</pre></code>\n// 每个 debug 函数的调用都是合法的，因为你可以将参数中的 any\n 替换为任何其他类型来进行匹配。\n\n TypeScript 将会以不同形式来匹配 any 的位置，\n 例如将这些元组作为函数的参数：\n\n<code><pre>\ndeclare function swap(x: [number, string]): [string, number];\n\ndeclare const pair: [any, any];\nswap(pair);\n\n</pre></code>\n// 对 swap 的调用是合法的，因为在将第一个 any 替换为 number，\n 第二个 any 替换为 string 后，参数可以正常被匹配到。\n\n 如果你没有了解过元组，查看: example:tuples\n\n unknown 是 any 的同级别的类型，如果 any 代表着 ”我知道什么是正确的“，\n 那么 unknown 代表着 “我不确定什么是正确的，所以你需要将类型告诉 TypeScript”。\n example:unknown-and-never\n","redirectHref":"zh/play/?#example/any"}},"staticQueryHashes":[]}