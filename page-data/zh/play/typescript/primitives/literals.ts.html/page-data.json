{"componentChunkName":"component---src-templates-play-example-tsx","path":"/zh/play/typescript/primitives/literals.ts.html","result":{"pageContext":{"name":"Literals","title":"Literals","lang":"zh","html":" TypeScript 对于代码中的字面量有一些有趣的特殊处理。\n\n 某种程度上，很大一部分支持在类型扩展和\n 缩小（example:type-widening-and-narrowing）中被支持，\n 建议首先了解一下他们。\n\n 字面量类型是一个类型中，更具体的一个子类型。\n 这意味着在类型系统中 “Hello World” 是一个字符串，\n 但是一个字符串并不一定是 “Hello World”。\n\n<code><pre>\nconst helloWorld = \"Hello World\";\nlet hiWorld = \"Hi World\"; // 这里的类型是字符串，因为它是由 let 定义的。\n\n// 这个函数接受所有的字符串。\ndeclare function allowsAnyString(arg: string);\nallowsAnyString(helloWorld);\nallowsAnyString(hiWorld);\n\n// 这个函数仅接受字符串字面量 “Hello World”。\ndeclare function allowsOnlyHello(arg: \"Hello World\");\nallowsOnlyHello(helloWorld);\nallowsOnlyHello(hiWorld);\n\n// 它可以让你使用并集类型，定义某个 API 仅接受一些特定的字面量值。\n\ndeclare function allowsFirstFiveNumbers(arg: 1 | 2 | 3 | 4 | 5);\nallowsFirstFiveNumbers(1);\nallowsFirstFiveNumbers(10);\n\nlet potentiallyAnyNumber = 3;\nallowsFirstFiveNumbers(potentiallyAnyNumber);\n\n// 看上去这个规则不适用于复杂的对象。\n\nconst myUser = {\n  name: \"Sabrina\",\n};\n\n</pre></code>\n// 可以看到虽然它被定义为不可变，但是它依旧\n 将 `name: \"Sabrina\"` 转换为 \"name: string\"。\n 这是因为 name 依旧可以被改变。\n\n<code><pre>\nmyUser.name = \"Cynthia\";\n\n</pre></code>\n// 因为 myUser 的 name 属性可以被改变，TypeScript 不能在类型系统\n 中使用字面量版本的类型。但是有一个功能可以允许你做到这一点。\n\n<code><pre>\nconst myUnchangingUser = {\n  name: \"Fatma\",\n} as const;\n\n</pre></code>\n// 当 \"as const\" 被应用到一个对象上，它将变为一个不可变的\n 对象字面量，而不是一个可以被改变的对象。\n\n<code><pre>\nmyUnchangingUser.name = \"Raîssa\";\n\n</pre></code>\n// \"as const\" 是用于常量数据的好工具，并且可以使代码变为内联的字面量。\n \"as const\" 同样可以用于数组。\n\n<code><pre>\nconst exampleUsers = [{ name: \"Brian\" }, { name: \"Fahrooq\" }] as const;\n","redirectHref":"zh/play/?#example/literals"}},"staticQueryHashes":[]}