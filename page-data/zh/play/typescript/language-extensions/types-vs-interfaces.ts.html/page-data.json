{"componentChunkName":"component---src-templates-play-example-tsx","path":"/zh/play/typescript/language-extensions/types-vs-interfaces.ts.html","result":{"pageContext":{"name":"Types vs Interfaces","title":"Types vs Interfaces","lang":"zh","html":" 声明一个对象的类型时，有两个主要的工具：接口（interface）和类型别名（type aliases）。\n\n 他们非常相似，并且在大多数情况下是相同的。\n\n<code><pre>\ntype BirdType = {\n  wings: 2;\n};\n\ninterface BirdInterface {\n  wings: 2;\n}\n\nconst bird1: BirdType = { wings: 2 };\nconst bird2: BirdInterface = { wings: 2 };\n\n</pre></code>\n// 因为 TypeScript 有着结构化类型系统。\n 我们也可以混合使用他们。\n\n<code><pre>\nconst bird3: BirdInterface = bird1;\n\n</pre></code>\n// 他们都支持扩展另一个些接口或类型。\n 类型别名通过并集类型来实现，接口通过 extends 关键字。\n\n<code><pre>\ntype Owl = { nocturnal: true } & BirdType;\ntype Robin = { nocturnal: false } & BirdInterface;\n\ninterface Peacock extends BirdType {\n  colourful: true;\n  flies: false;\n}\ninterface Chicken extends BirdInterface {\n  colourful: false;\n  flies: false;\n}\n\nlet owl: Owl = { wings: 2, nocturnal: true };\nlet chicken: Chicken = { wings: 2, colourful: false, flies: false };\n\n</pre></code>\n// 也就是说，我们建议您使用接口而不是类型别名，因为你可以在接口中获得更好的错误提示。\n 如果你将鼠标悬停在下面的错误上，你会看到在使用接口（例如 Chicken）时，\n TypeScript 会提供更简洁的提示信息。\n\n<code><pre>\nowl = chicken;\nchicken = owl;\n\n</pre></code>\n// 一个接口和类型别名的主要区别是，接口是开放的，类型别名是封闭的。\n 这意味着你可以你可以通过多次声明同一个接口来扩展它。\n\n<code><pre>\ninterface Kitten {\n  purrs: boolean;\n}\n\ninterface Kitten {\n  colour: string;\n}\n\n// 与此同时，类型别名不可以在外部变更它的声明。\n\ntype Puppy = {\n  color: string;\n};\n\ntype Puppy = {\n  toys: number;\n};\n\n</pre></code>\n// 基于你不同的目的，这个区别可以是证明的也可以是负面的。\n 一般来说，对于公开的需要暴露的类型，将他们作为接口是更好的选择。\n\n 要查看接口和类型定义之间所有边际条件，下面的 StackOverflow 讨论是最好的资源之一:\n\n https://stackoverflow.com/questions/37233735/typescript-interfaces-vs-types/52682220#52682220\n","redirectHref":"zh/play/?#example/types-vs-interfaces"}},"staticQueryHashes":[]}