{"componentChunkName":"component---src-templates-play-example-tsx","path":"/zh/play/typescript/type-primitives/built-in-utility-types.ts.html","result":{"pageContext":{"name":"Built-in Utility Types","title":"Built-in Utility Types","lang":"zh","html":"\n 当某种类型对于大多数代码来说都非常有用时，他们就会被添加到 TypeScript\n 中并且被大家使用。这意味着您可以在代码中直接使用他们，而无需担心它们的可用性。\n\n Partial<Type>\n\n 将一个类型的所有属性转换为可选的\n\n<code><pre>\ninterface Sticker {\n  id: number;\n  name: string;\n  createdAt: string;\n  updatedAt: string;\n  submitter: undefined | string;\n}\n\ntype StickerUpdateParam = Partial<Sticker>;\n\n// Readonly<Type>\n\n// 将一个类型的所有属性转换为只读的\n\ntype StickerFromAPI = Readonly<Sticker>;\n\n// Record<KeysFrom, Type>\n\n// 创建一个具有 KeysFrom 列表中所有指定属性的类型，并且将他们值的类型设置为 Type\n\n// 列出需要哪些 key。\ntype NavigationPages = \"home\" | \"stickers\" | \"about\" | \"contact\";\n\n// 每个数据（上面的key ^）都需要的数据的形状。\ninterface PageInfo {\n  title: string;\n  url: string;\n  axTitle?: string;\n}\n\nconst navigationInfo: Record<NavigationPages, PageInfo> = {\n  home: { title: \"Home\", url: \"/\" },\n  about: { title: \"About\", url: \"/about\" },\n  contact: { title: \"Contact\", url: \"/contact\" },\n  stickers: { title: \"Stickers\", url: \"/stickers/all\" },\n};\n\n// Pick<Type, Keys>\n\n</pre></code>\n// 由 Type 类型选取 Keys 中指定的属性并创建一个新的类型。\n 本质上是由某种类型中提取一部分类型信息。\n\n<code><pre>\ntype StickerSortPreview = Pick<Sticker, \"name\" | \"updatedAt\">;\n\n// Omit<Type, Keys>\n\n</pre></code>\n// 由 Type 类型排除 Keys 中指定的属性并创建一个新的类型。\n 本质上是由某种类型中排除一部分类型信息。\n\n<code><pre>\ntype StickerTimeMetadata = Omit<Sticker, \"name\">;\n\n// Exclude<Type, RemoveUnion>\n\n// 创建一个类型，其中 Type 的任何属性都与 RemoveUnion 不重合。\n\ntype HomeNavigationPages = Exclude<NavigationPages, \"home\">;\n\n// Extract<Type, MatchUnion>\n\n// 创建一个类型，其中 Type 的任何属性都与 MatchUnion 重合。\n\ntype DynamicPages = Extract<NavigationPages, \"home\" | \"stickers\">;\n\n// NonNullable<Type>\n\n// 从一组类型中将 null 和 undefined 排除后创建一个类型，对有效性检查非常有用。\n\ntype StickerLookupResult = Sticker | undefined | null;\ntype ValidatedResult = NonNullable<StickerLookupResult>;\n\n// ReturnType<Type>\n\n// 导出一个类型的返回值类型。\n\ndeclare function getStickerByID(id: number): Promise<StickerLookupResult>;\ntype StickerResponse = ReturnType<typeof getStickerByID>;\n\n// InstanceType<Type>\n\n// 创建一个是某个具有构造函数的类或对象的实例的类型。\n\nclass StickerCollection {\n  stickers: Sticker[];\n}\n\ntype CollectionItem = InstanceType<typeof StickerCollection>;\n\n// Required<Type>\n\n// 创建一个类型，将所有 Type 的可选属性转换为必要的。\n\ntype AccessiblePageInfo = Required<PageInfo>;\n\n// ThisType<Type>\n\n</pre></code>\n// 与其他类型不同，ThisType 不返回新的类型，而是操作函数定义内 this\n 的类型。您只可以在 TSConfig 中 noImplicitThis 开启的情况下使用 ThisType。\n\n https://www.typescriptlang.org/docs/handbook/utility-types.html\n","redirectHref":"zh/play/?strictNullChecks=true#example/built-in-utility-types"}},"staticQueryHashes":[]}