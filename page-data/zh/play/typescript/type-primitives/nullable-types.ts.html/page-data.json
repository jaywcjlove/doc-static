{"componentChunkName":"component---src-templates-play-example-tsx","path":"/zh/play/typescript/type-primitives/nullable-types.ts.html","result":{"pageContext":{"name":"Nullable Types","title":"Nullable Types","lang":"zh","html":"\n JavaScript 有两种不同的方法声明不存在的值，TypeScript 添加了额外的\n 语法，以提供更多方法来声明某些内容声明为可选或可空。\n\n 首先，两种 JavaScript 基本类型中的不同：undefined 和 null\n\n Undefined 是指找不到或无法设置某些内容\n\n<code><pre>\nconst emptyObj = {};\nconst anUndefinedProperty: undefined = emptyObj[\"anything\"];\n\n// Null 则在明确的没有值的情况下使用\n\nconst searchResults = {\n  video: { name: \"LEGO Movie\" },\n  text: null,\n  audio: { name: \"LEGO Movie Soundtrack\" },\n};\n\n</pre></code>\n// 为什么不使用 undefined？主要原因是让您可以正确的校验 text 是否被包含。\n 而如果 text 返回的是 undefined，那么这个值和没有被设置时相同。\n\n 这可能感觉没有什么用处，但是当转换为一个 JSON 字符串时，如果 text 是 undefined，\n 那么它将不会被包含在等效的字符串中，\n\n 严格的空检查\n\n 在 TypeScript 2.0 之前，类型系统中实际上忽略了 null 和 undefined。\n 这让 TypeScript 提供了一个更接近没有类型的 JavaScript 的开发环境。\n\n 2.0 版本添加了一个叫做 严格空检查（strictNullChecks）的编译选项，\n 这个选项要求人们将 undefined 和 null 视为需要通过代码流分析来处理的类型。\n （更多信息可以查看 example:code-flow）\n\n 一个让 TypeScript 将严格空检查打开的示例，将鼠标悬停\n 在下面的“Potential String”上。\n\n<code><pre>\ntype PotentialString = string | undefined | null;\n\n</pre></code>\n// PotentialString 丢弃了 undefined 和 null。如果您\n 在设置中开启严格空检查并返回这里，你可以看到悬停在 PotentialString 上时\n 会显示完整的并集类型。\n\n<code><pre>\ndeclare function getID(): PotentialString;\n\nconst userID = getID();\nconsole.log(\"User Logged in: \", userID.toUpperCase());\n\n// 只有在严格模式下时，以上操作会出错 ^\n\n</pre></code>\n// 同样有一些方式告诉 TypeScript 你知道更多信息\n 例如使用类型断言或通过非空断言操作符（!）\n\n<code><pre>\nconst definitelyString1 = getID() as string;\nconst definitelyString2 = getID()!;\n\n// 或者你可以通过 if 安全地检查是否存在：\n\nif (userID) {\n  console.log(userID);\n}\n\n// 可选属性\n\n// Void\n\n// Void 是一个函数没有返回值时返回的类型。\n\nconst voidFunction = () => {};\nconst resultOfVoidFunction = voidFunction();\n\n</pre></code>\n// 这通常是偶然的，TypeScript 会保留 void 类型以使您得到编译错误\n - 即使在运行时值将会是 undefined。\n","redirectHref":"zh/play/?strictNullChecks=false#example/nullable-types"}},"staticQueryHashes":[]}