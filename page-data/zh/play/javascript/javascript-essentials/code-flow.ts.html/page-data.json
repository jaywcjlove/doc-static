{"componentChunkName":"component---src-templates-play-example-tsx","path":"/zh/play/javascript/javascript-essentials/code-flow.ts.html","result":{"pageContext":{"name":"Code Flow","title":"Code Flow","lang":"zh","html":"\n JavaScript 文件中的代码流会影响整个程序的类型。\n\n<code><pre>\nconst users = [{ name: \"Ahmed\" }, { name: \"Gemma\" }, { name: \"Jon\" }];\n\n// 我们尝试找到名为 “jon” 的用户。\nconst jon = users.find((u) => u.name === \"jon\");\n\n</pre></code>\n// 在上面的情况中，“find” 可能失败，在这种情况下我们不能得到一个对象，\n 它会创建如下类型：\n\n   { name: string } | undefined\n\n 如果您将鼠标悬停在下面的三个用到 ‘jon’ 的地方，您会看到类型的\n 变化依赖于文本在哪里：\n\n<code><pre>\nif (jon) {\n  jon;\n} else {\n  jon;\n}\n\n</pre></code>\n// 类型 ‘{ name: string } | undefined’ 使用了叫做\n 并集类型的 TypeScript 的功能，并集类型是声明对象可能是\n 几种东西之一的方式。\n\n 管道符号充当不同类型间的分隔符，JavaScript 的动态特性意味着许多\n 函数会收到和返回不同类型的对象，因此我们需要能够表达需要处理的对象。\n\n 我们可以通过几种方式来使用它。让我们看一下具有不同类型的值的数组。\n\n<code><pre>\nconst identifiers = [\"Hello\", \"World\", 24, 19];\n\n</pre></code>\n// 我们可以使用 ‘typeof x === y’ 的 JavaScript 语法来检查第一个\n 元素的类型。您可以将鼠标悬停在下面的 ‘randomIdentifier’ 上以\n 查看它在不同的位置之间的变化。\n\n<code><pre>\nconst randomIdentifier = identifiers[0];\nif (typeof randomIdentifier === \"number\") {\n  randomIdentifier;\n} else {\n  randomIdentifier;\n}\n\n</pre></code>\n// 控制流分析代表着我们可以编写原始 JavaScript，而 TypeScript 将尝试\n 去了解代码类型在不同位置如何变化。\n\n 去了解更多关于代码流分析的信息：\n - example:type-guards\n\n 要继续阅读示例，您可以跳转到以下不同的位置：\n\n - 现代 JavaScript: example:immutability\n - 类型守卫: example:type-guards\n - JavaScript 函数式编程 example:function-chaining\n","redirectHref":"zh/play/?strictNullChecks=true#example/code-flow"}},"staticQueryHashes":[]}