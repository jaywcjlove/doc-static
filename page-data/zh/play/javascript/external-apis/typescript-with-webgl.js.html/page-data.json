{"componentChunkName":"component---src-templates-play-example-tsx","path":"/zh/play/javascript/external-apis/typescript-with-webgl.js.html","result":{"pageContext":{"name":"TypeScript with WebGL","title":"TypeScript with WebGL","lang":"zh","html":"\n 该例子通过使用 JavaScript 创建一个基于 WebGL 的 HTML canvas 来渲染一些旋转的彩色纸屑。\n 我们通过这些代码来了解它是如何工作的，看看 TypeScript 的工具所提供的便利。\n\n 该例子用于：example:working-with-the-dom\n\n 首先，我们需要创建一个 HTML canvas, 并通过 DOM API 来为该 canvas\n 设置一些样式：\n\n<code><pre>\nconst canvas = document.createElement('canvas')\ncanvas.id = 'spinning-canvas'\ncanvas.style.backgroundColor = '#0078D4'\ncanvas.style.position = 'fixed'\ncanvas.style.bottom = '10px'\ncanvas.style.right = '20px'\ncanvas.style.width = '500px'\ncanvas.style.height = '400px'\n\n</pre></code>\n// 下一步，为了更方便地看到修改后的运行效果，我们先在点击 “运行” 按钮之后\n 把已存在的 canvas 移除掉——现在，你可以修改代码并点击 “运行” 来看看效\n 果了（或者按 Command + Enter）：\n\n<code><pre>\nconst existingCanvas = document.getElementById(canvas.id)\nif (existingCanvas && existingCanvas.parentElement) {\n  existingCanvas.parentElement.removeChild(existingCanvas)\n}\n\n// 告知 canvas 我们会使用 WebGL 方式来绘图（而不是默认的光栅渲染引擎）\n\nconst gl = canvas.getContext('webgl')\n\n</pre></code>\n// 接着我们需要创建顶点着色器 - 简单来说，这些小的代码段会对输入的顶点\n 数组（浮点数）进行一系列数学变换。\n\n 你可以在着色器代码的最前面看到大量的属性，这些属性会在编译后被传递到\n 下面示例的着色器中。\n\n 该文章很好地介绍了 WebGL 是如何工作的：\n https://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html\n\n<code><pre>\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)\ngl.shaderSource(\n  vertexShader,\n  `\nprecision lowp float;\n\nattribute vec2 a_position; // XY 平面上的正方形\nattribute float a_startAngle;\nattribute float a_angularVelocity;\nattribute float a_rotationAxisAngle;\nattribute float a_particleDistance;\nattribute float a_particleAngle;\nattribute float a_particleY;\nuniform float u_time; // 全局状态\n\nvarying vec2 v_position;\nvarying vec3 v_color;\nvarying float v_overlight;\n\nvoid main() {\n  float angle = a_startAngle + a_angularVelocity * u_time;\n  float vertPosition = 1.1 - mod(u_time * .25 + a_particleY, 2.2);\n  float viewAngle = a_particleAngle + mod(u_time * .25, 6.28);\n\n  mat4 vMatrix = mat4(\n    1.3, 0.0, 0.0, 0.0,\n    0.0, 1.3, 0.0, 0.0,\n    0.0, 0.0, 1.0, 1.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  mat4 shiftMatrix = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    a_particleDistance * sin(viewAngle), vertPosition, a_particleDistance * cos(viewAngle), 1.0\n  );\n\n  mat4 pMatrix = mat4(\n    cos(a_rotationAxisAngle), sin(a_rotationAxisAngle), 0.0, 0.0,\n    -sin(a_rotationAxisAngle), cos(a_rotationAxisAngle), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  ) * mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(angle), sin(angle), 0.0,\n    0.0, -sin(angle), cos(angle), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  gl_Position = vMatrix * shiftMatrix * pMatrix * vec4(a_position * 0.03, 0.0, 1.0);\n  vec4 normal = vec4(0.0, 0.0, 1.0, 0.0);\n  vec4 transformedNormal = normalize(pMatrix * normal);\n\n  float dotNormal = abs(dot(normal.xyz, transformedNormal.xyz));\n  float regularLighting = dotNormal / 2.0 + 0.5;\n  float glanceLighting = smoothstep(0.92, 0.98, dotNormal);\n  v_color = vec3(\n    mix((0.5 - transformedNormal.z / 2.0) * regularLighting, 1.0, glanceLighting),\n    mix(0.5 * regularLighting, 1.0, glanceLighting),\n    mix((0.5 + transformedNormal.z / 2.0) * regularLighting, 1.0, glanceLighting)\n  );\n\n  v_position = a_position;\n  v_overlight = 0.9 + glanceLighting * 0.1;\n}\n`\n)\ngl.compileShader(vertexShader)\n\n</pre></code>\n// 下面的例子用了片段着色器——片段着色器是另外一种小的代码片段，它用于\n 计算 canvas 画布中每个像素的颜色。\n\n 在这个例子里面，你可以通过尝试手动修改一下里面的一些数字的值，这样你就大概知道它们\n 都代表着什么样的变化了，它们会影响到场景中的光线、以及彩色纸屑的边框半径：\n\n<code><pre>\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)\ngl.shaderSource(\n  fragmentShader,\n  `\nprecision lowp float;\nvarying vec2 v_position;\nvarying vec3 v_color;\nvarying float v_overlight;\n\nvoid main() {\n  gl_FragColor = vec4(v_color, 1.0 - smoothstep(0.8, v_overlight, length(v_position)));\n}\n`\n)\ngl.compileShader(fragmentShader)\n\n// 将编译后的着色器加入到 canvas 中的 WebGL 上下文中以供使用：\n\nconst shaderProgram = gl.createProgram()\ngl.attachShader(shaderProgram, vertexShader)\ngl.attachShader(shaderProgram, fragmentShader)\ngl.linkProgram(shaderProgram)\ngl.useProgram(shaderProgram)\n\ngl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())\n\n</pre></code>\n// 我们需要通过一种内存安全的方式来设置或者读取着色器变量，因此我们需要\n 先定义这些变量的长度以及偏移量：\n\n 译者注：\n    这些属性的数据类型都是浮点数，因此实际上 1 个单位空间长度相当于 4 个字节\n    这一点在后面的代码中有体现\n\n    例如：a_position 属性表示坐标位置，则包含 x 和 y. 在在内存中需要占 2 个单位长度的空间\n          a_startAngle 表示角度，只需要一个浮点数，占 1 个单位长度的空间\n\n<code><pre>\nconst attrs = [\n  { name: \"a_position\", length: 2, offset: 0 }, \n  { name: \"a_startAngle\", length: 1, offset: 2 }, // but angle is just 1 value\n  { name: \"a_angularVelocity\", length: 1, offset: 3 },\n  { name: \"a_rotationAxisAngle\", length: 1, offset: 4 },\n  { name: \"a_particleDistance\", length: 1, offset: 5 },\n  { name: \"a_particleAngle\", length: 1, offset: 6 },\n  { name: \"a_particleY\", length: 1, offset: 7 }\n]\n\nconst STRIDE = Object.keys(attrs).length + 1\n\n</pre></code>\n// 通过遍历我们上面定义的已知的属性，并在 JS 代码中为他们在内存中创建指针，通过这些指针我们可以把\n 值填充到着色器中。\n\n 为了更好理解这些 API，略作注解：WebGL 是一套基于 OpenGL 的状态机方式的 API。\n 你以特定的顺序输入命令，将内容呈现在屏幕上。\n\n 因此，我们常见的做法并不是把渲染的数据和对象传递给每一次 WebGL 的 API 调用，而是\n 把内容传递给一个函数，并由这个函数再传递给它的下一个函数调用，以此类推。所以，我们\n 在这里为 WebGL 创建一个顶点指针的数组：\n\n<code><pre>\nfor (var i = 0; i < attrs.length; i++) {\n  const name = attrs[i].name\n  const length = attrs[i].length\n  const offset = attrs[i].offset\n  const attribLocation = gl.getAttribLocation(shaderProgram, name)\n  gl.vertexAttribPointer(attribLocation, length, gl.FLOAT, false, STRIDE * 4, offset * 4)\n  gl.enableVertexAttribArray(attribLocation)\n}\n\n// 我们在把这些属性绑定到一个内存中的一个数组里：\n\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer())\n\n// 并定义一些渲染常量：\n\nconst NUM_PARTICLES = 200\nconst NUM_VERTICES = 4\n\n</pre></code>\n// 你可以试着减少这个值，并反复点击 运行” 按钮\n 该值表示每个彩纸上应该有多少个点，如果你把它赋值为一个奇数，它看起来\n 就会不太正常。\n\n<code><pre>\nconst NUM_INDICES = 6\n\n// 创建顶点着色器的输入数组\nconst vertices = new Float32Array(NUM_PARTICLES * STRIDE * NUM_VERTICES)\nconst indices = new Uint16Array(NUM_PARTICLES * NUM_INDICES)\n\nfor (let i = 0; i < NUM_PARTICLES; i++) {\n  const axisAngle = Math.random() * Math.PI * 2\n  const startAngle = Math.random() * Math.PI * 2\n  const groupPtr = i * STRIDE * NUM_VERTICES\n\n  const particleDistance = Math.sqrt(Math.random())\n  const particleAngle = Math.random() * Math.PI * 2\n  const particleY = Math.random() * 2.2\n  const angularVelocity = Math.random() * 2 + 1\n\n  for (let j = 0; j < 4; j++) {\n    const vertexPtr = groupPtr + j * STRIDE\n    vertices[vertexPtr + 2] = startAngle       // 初始角度\n    vertices[vertexPtr + 3] = angularVelocity  // 角速度\n    vertices[vertexPtr + 4] = axisAngle        // 角度差\n    vertices[vertexPtr + 5] = particleDistance // 粒子到 (0,0,0) 的距离\n    vertices[vertexPtr + 6] = particleAngle    // 粒子绕 Y 轴的旋转角度\n    vertices[vertexPtr + 7] = particleY        // 粒子的 Y 轴坐标\n  }\n\n  // 坐标\n  vertices[groupPtr] = vertices[groupPtr + STRIDE * 2] = -1\n  vertices[groupPtr + STRIDE] = vertices[groupPtr + STRIDE * 3] = +1\n  vertices[groupPtr + 1] = vertices[groupPtr + STRIDE + 1] = -1\n  vertices[groupPtr + STRIDE * 2 + 1] = vertices[groupPtr + STRIDE * 3 + 1] = +1\n\n  const indicesPtr = i * NUM_INDICES\n  const vertexPtr = i * NUM_VERTICES\n  indices[indicesPtr] = vertexPtr\n  indices[indicesPtr + 4] = indices[indicesPtr + 1] = vertexPtr + 1\n  indices[indicesPtr + 3] = indices[indicesPtr + 2] = vertexPtr + 2\n  indices[indicesPtr + 5] = vertexPtr + 3\n}\n\n// 把数据传递给 WebGL 上下文\ngl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW)\n\n\nconst timeUniformLocation = gl.getUniformLocation(shaderProgram, \"u_time\")\nconst startTime = (window.performance || Date).now()\n\n// 用黑色作为画布的擦除填充颜色\ngl.clearColor(0, 0, 0, 1)\n\n// 顶点着色器允许透明通道\ngl.enable(gl.BLEND)\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE)\n\n// 把 WebGL 上下文的尺寸设为和 canvas 的尺寸一致\ngl.viewport(0, 0, canvas.width, canvas.height)\n\n// 创建一个帧循环用于绘制彩纸\n;(function frame() {\n  gl.uniform1f(timeUniformLocation, ((window.performance || Date).now() - startTime) / 1000)\n\n  gl.clear(gl.COLOR_BUFFER_BIT)\n  gl.drawElements(\n    gl.TRIANGLES,\n    NUM_INDICES * NUM_PARTICLES,\n    gl.UNSIGNED_SHORT,\n    0\n  )\n  requestAnimationFrame(frame)\n})()\n\n</pre></code>\n// 把 canvas 加入到当前页面的右下角\n\n 译者注：原注释中是 \"bottom left\"，其实是 \"bottom right\"\n 如位置需要调整，可以修改该范例代码最前面的 CSS 样式\n<code><pre>\ndocument.body.appendChild(canvas)\n\n</pre></code>\n// 鸣谢: 基于 Subzey 的这个 JSFiddle 范例:\n https://jsfiddle.net/subzey/52sowezj/\n","redirectHref":"zh/play/?#example/typescript-with-webgl"}},"staticQueryHashes":[]}