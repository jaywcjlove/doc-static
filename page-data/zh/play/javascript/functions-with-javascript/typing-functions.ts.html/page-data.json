{"componentChunkName":"component---src-templates-play-example-tsx","path":"/zh/play/javascript/functions-with-javascript/typing-functions.ts.html","result":{"pageContext":{"name":"Typing Functions","title":"Typing Functions","lang":"zh","html":" TypeScript 的类型推断可以帮助您做很多事，但是还有很多其他方法可以\n 提供更丰富的标记函数形状的方法。\n\n 可选函数是看起来很棒的一点，它可以让其他人知道你可以跳过这个参数。\n\n<code><pre>\nlet i = 0;\nconst incrementIndex = (value?: number) => {\n  i += value === undefined ? 1 : value;\n};\n\n// 这个函数可以像这样调用：\n\nincrementIndex();\nincrementIndex(0);\nincrementIndex(3);\n\n// 你可以将参数标记为函数，从而在编写函数时提供类型推导。\n\nconst callbackWithIndex = (callback: (i: number) => void) => {\n  callback(i);\n};\n\n</pre></code>\n// 嵌入函数接口可能很难阅读（可能有很多箭头）。使用类型别名可以\n 为函数参数命名\n\n<code><pre>\ntype NumberCallback = (i: number) => void;\nconst callbackWithIndex2 = (callback: NumberCallback) => {\n  callback(i);\n};\n\n// 他们可以像这样调用：\n\ncallbackWithIndex((index) => {\n  console.log(index);\n});\n\n</pre></code>\n// 将鼠标悬停在上面的 index 上，您可以看到 TypeScript 可以正确\n 推断出 index 是一个 number 类型。\n\n 将函数作为实例的引用传递时，TypeScript 类型推导也可以正常工作。\n 为了展示这一点，我们会使用一个将 number 转换为 string 的函数：\n\n<code><pre>\nconst numberToString = (n: number) => {\n  return n.toString();\n};\n\n</pre></code>\n// 它可以适用于数组的 map 之类的方法中，比如将所有数字转换为字符串。\n 如果您将鼠标悬停在下面的 stringedNumbers 上，则可以看到期望的类型。\n<code><pre>\nconst stringedNumbers = [1, 4, 6, 10].map((i) => numberToString(i));\n\n// 我们可以使用快捷形式直接传递函数，并通过更简洁的代码获得相同的结果：\nconst stringedNumbersTerse = [1, 4, 6, 10].map(numberToString);\n\n</pre></code>\n// 您的函数可能可以接受许多类型，但是您可能只对其中一部分属性感兴趣。\n 而类型签名中的索引签名（indexed signature）对这种情况很有用。\n 以下类型声明此函数可以用于所有对象，只要它包含属性 name 即可：\n\n<code><pre>\ninterface AnyObjectButMustHaveName {\n  name: string;\n  [key: string]: any;\n}\n\nconst printFormattedName = (input: AnyObjectButMustHaveName) => {};\n\nprintFormattedName({ name: \"joey\" });\nprintFormattedName({ name: \"joey\", age: 23 });\n\n</pre></code>\n// 如果您希望了解更多关于索引签名的内容，我们建议访问以下链接：\n\n https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks\n https://basarat.gitbooks.io/typescript/docs/types/index-signatures.html\n\n 您还可以通过 tsconfig 配置中 suppressExcessPropertyErrors\n 的选项来在任何地方允许这种行为——但是您不知道其他使用您 API 的用户\n 是否关掉了这个选项。\n\n JavaScript 中的函数可以接受不同的参数。有两种常见的模式来描述：用于\n 参数和返回值的并集类型以及函数重载。\n\n 只有在仅有一两处不同且不需要在不同函数中展示不同的文档时，才适合在\n 参数中使用并集类型。\n\n<code><pre>\nconst boolOrNumberFunction = (input: boolean | number) => {};\n\nboolOrNumberFunction(true);\nboolOrNumberFunction(23);\n\n// 另一方面，函数重载为参数和返回类型提供了丰富的语法。\n\ninterface BoolOrNumberOrStringFunction {\n  /** 接受一个 bool，返回一个 bool */\n  (input: boolean): boolean;\n  /** 接受一个 number，返回一个 number */\n  (input: number): number;\n  /** 接受一个 string，返回一个 bool */\n  (input: string): boolean;\n}\n\n</pre></code>\n// 如果这是您第一次看到 declare 关键字，它使您可以告诉 TypeScript\n 文件中某些即使在运行时不存在的东西存在，对于映射有副作用的代码或\n 实现某些东西需要很多代码的 demo 来说都非常有用。\n\n<code><pre>\ndeclare const boolOrNumberOrStringFunction: BoolOrNumberOrStringFunction;\n\nconst boolValue = boolOrNumberOrStringFunction(true);\nconst numberValue = boolOrNumberOrStringFunction(12);\nconst boolValue2 = boolOrNumberOrStringFunction(\"string\");\n\n// 将鼠标悬停在上述值和函数上，您可以看到正确的文档和返回值。\n\n</pre></code>\n// 函数重载对您很有帮助，但是还有一种可以处理不同类型的输入\n 和返回值的工具，那就是泛型。\n\n 这为您提供了一种在类型定义中将类型作为占位符变量的方法。\n\n example:generic-functions\n example:function-chaining\n","redirectHref":"zh/play/?#example/typing-functions"}},"staticQueryHashes":[]}