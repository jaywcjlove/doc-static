{"componentChunkName":"component---src-templates-play-example-tsx","path":"/zh/play/javascript/modern-javascript/async-await.ts.html","result":{"pageContext":{"name":"Async Await","title":"Async Await","lang":"zh","html":"\n Modern JavaScript added a way to handle callbacks in an\n elegant way by adding a Promise based API which has special\n syntax that lets you treat asynchronous code as though it\n acts synchronously.\n\n Like all language features, this is a trade-off in\n complexity: making a function async means your return\n values are wrapped in Promises. What used to return a\n string, now returns a Promise<string>.\n\n<code><pre>\nconst func = () => \":wave:\";\nconst asyncFunc = async () => \":wave:\";\n\nconst myString = func();\nconst myPromiseString = asyncFunc();\n\nmyString.length;\n\n// myPromiseString is a Promise, not the string:\n\nmyPromiseString.length;\n\n</pre></code>\n// You can use the await keyword to convert a promise\n into its value. Today, these only work inside an async\n function.\n\n<code><pre>\nconst myWrapperFunction = async () => {\n  const myString = func();\n  const myResolvedPromiseString = await asyncFunc();\n\n  // Via the await keyword, now myResolvedPromiseString\n  // is a string\n  myString.length;\n  myResolvedPromiseString.length;\n};\n\n</pre></code>\n// Code which is running via an await can throw errors,\n and it's important to catch those errors somewhere.\n\n<code><pre>\nconst myThrowingFunction = async () => {\n  throw new Error(\"Do not call this\");\n};\n\n</pre></code>\n// We can wrap calling an async function in a try catch to\n handle cases where the function acts unexpectedly.\n\n<code><pre>\nconst asyncFunctionCatching = async () => {\n  const myReturnValue = \"Hello world\";\n  try {\n    await myThrowingFunction();\n  } catch (error) {\n    console.error(\"myThrowingFunction failed\", error);\n  }\n  return myReturnValue;\n};\n\n</pre></code>\n// Due to the ergonomics of this API being either returning\n a single value, or throwing, you should consider offering\n information about the result inside the returned value and\n use throw only when something truly exceptional has\n occurred.\n\n<code><pre>\nconst exampleSquareRootFunction = async (input: any) => {\n  if (isNaN(input)) {\n    throw new Error(\"Only numbers are accepted\");\n  }\n\n  if (input < 0) {\n    return { success: false, message: \"Cannot square root negative number\" };\n  } else {\n    return { success: true, value: Math.sqrt(input) };\n  }\n};\n\n</pre></code>\n// Then the function consumers can check in the response and\n 确定如何使用您的返回值。尽管这是一个简单的例子，但是一旦您开始使用\n 网络代码，这些 API 就需要使用额外的语法。\n\n<code><pre>\nconst checkSquareRoot = async (value: number) => {\n  const response = await exampleSquareRootFunction(value);\n  if (response.success) {\n    response.value;\n  }\n};\n\n// Async、Await 使如下代码：\n\n</pre></code>\n// getResponse(url, (response) => {\n   getResponse(response.url, (secondResponse) => {\n     const responseData = secondResponse.data\n     getResponse(responseData.url, (thirdResponse) => {\n       ...\n     })\n   })\n })\n\n 变为线性：\n\n const response = await getResponse(url)\n const secondResponse = await getResponse(response.url)\n const responseData = secondResponse.data\n const thirdResponse = await getResponse(responseData.url)\n ...\n\n 可以使代码左对齐，并且以一致的节奏阅读。\n","redirectHref":"zh/play/?#example/async-await"}},"staticQueryHashes":[]}