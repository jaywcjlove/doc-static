{"componentChunkName":"component---src-templates-play-example-tsx","path":"/zh/play/javascript/working-with-classes/mixins.ts.html","result":{"pageContext":{"name":"Mixins","title":"Mixins","lang":"zh","html":"\n 混合（Mixins）是 TypeScript 支持的 JavaScript 类的伪多重继承\n 模式。该模式允许您创建一个由许多类合并而成的类。\n\n 首先我们需要一种类型，用于扩展其他类。主要职责是声明传入的类型是一个类。\n\n<code><pre>\ntype Constructor = new (...args: any[]) => {};\n\n</pre></code>\n// 然后我们可以创建一系列的类，这些类通过包装最终的类来进行扩展。\n 此模式当相似的对象具有不同的功能时效果很好。\n\n 这个混合添加了 scale 属性，并带有用于使用封装的 private 属性\n 以及对其进行更改的 getter 和 setter：\n\n<code><pre>\nfunction Scale<TBase extends Constructor>(Base: TBase) {\n  return class extends Base {\n    private _scale = 1;\n\n    setScale(scale: number) {\n      this._scale = scale;\n    }\n\n    get scale(): number {\n      return this._scale;\n    }\n  };\n}\n\n// 该混合围绕 alpha 合成添加了额外的方法，现代计算机使用这些方法来创建深度：\n\nfunction Alpha<TBase extends Constructor>(Base: TBase) {\n  return class extends Base {\n    private alpha = 1;\n\n    setHidden() {\n      this.alpha = 0;\n    }\n\n    setVisible() {\n      this.alpha = 1;\n    }\n\n    setAlpha(alpha: number) {\n      this.alpha = alpha;\n    }\n  };\n}\n\n// 一个用于扩展的简单的 sprite 基类：\n\nclass Sprite {\n  name = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n// 我们将创建两种具有不同功能的 sprite：\n\nconst ModernDisplaySprite = Alpha(Scale(Sprite));\nconst EightBitSprite = Scale(Sprite);\n\n// 创建这些类的实例表明，由于对象的混合，这些对象具有不同的属性和方法：\n\nconst flappySprite = new ModernDisplaySprite(\"Bird\");\nflappySprite.x = 10;\nflappySprite.y = 20;\nflappySprite.setVisible();\nflappySprite.setScale(0.8);\nconsole.log(flappySprite.scale);\n\nconst gameBoySprite = new EightBitSprite(\"L block\");\ngameBoySprite.setScale(0.3);\n\n// 由于 EightBitSprite 没有用于更改 alpha 的混合而报错：\ngameBoySprite.setAlpha(0.5);\n\n// 如果要对包装的类提供更多的保证，则可以将构造函数与泛型一起使用。\n\ntype GConstructor<T = {}> = new (...args: any[]) => T;\n\n// 您可以声明只能在基类为特殊形状时应用此混合。\n\ntype Moveable = GConstructor<{ setXYAcceleration: (x: number, y: number) => void }>;\n\n</pre></code>\n// 然后我们可以创建一个混合，它依赖于上述 GConstructor 参数\n 中存在的函数。\n\n<code><pre>\nfunction Jumpable<TBase extends Moveable>(Base: TBase) {\n  return class extends Base {\n    jump() {\n      // 这个混合现在可以知道 setXYAcceleration\n      this.setXYAcceleration(0, 20);\n    }\n  };\n}\n\n</pre></code>\n// 只有在混合的结构中有一个添加 setXYAcceleration 的类之后\n 我们才能创建此 sprite：\n<code><pre>\nconst UserSprite = new Jumpable(ModernDisplaySprite);\n","redirectHref":"zh/play/?#example/mixins"}},"staticQueryHashes":[]}