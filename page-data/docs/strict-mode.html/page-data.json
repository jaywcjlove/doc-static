{"componentChunkName":"component---src-templates-docs-js","path":"/docs/strict-mode.html","result":{"data":{"markdownRemark":{"html":"<p><code class=\"gatsby-code-text\">StrictMode</code> 是一个用来突出显示应用程序中潜在问题的工具。与 <code class=\"gatsby-code-text\">Fragment</code> 一样，<code class=\"gatsby-code-text\">StrictMode</code> 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。</p>\n<blockquote>\n<p>注意：</p>\n<p>严格模式检查仅在开发模式下运行；<em>它们不会影响生产构建</em>。</p>\n</blockquote>\n<p>你可以为应用程序的任何部分启用严格模式。例如：\n<div class=\"gatsby-highlight\">\n        <pre class=\"gatsby-code-jsx\"><code><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">ExampleApplication</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Header</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\"></span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">React.StrictMode</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span></span><span class=\"token plain-text\">        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">          </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ComponentOne</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">          </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ComponentTwo</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">React.StrictMode</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span></span><span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Footer</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n        </div></p>\n<p>在上述的示例中，<em>不</em>会对 <code class=\"gatsby-code-text\">Header</code> 和 <code class=\"gatsby-code-text\">Footer</code> 组件运行严格模式检查。但是，<code class=\"gatsby-code-text\">ComponentOne</code> 和 <code class=\"gatsby-code-text\">ComponentTwo</code> 以及它们的所有后代元素都将进行检查。</p>\n<p><code class=\"gatsby-code-text\">StrictMode</code> 目前有助于：</p>\n<ul>\n<li><a href=\"#identifying-unsafe-lifecycles\">识别不安全的生命周期</a></li>\n<li><a href=\"#warning-about-legacy-string-ref-api-usage\">关于使用过时字符串 ref API 的警告</a></li>\n<li><a href=\"#warning-about-deprecated-finddomnode-usage\">关于使用废弃的 findDOMNode 方法的警告</a></li>\n<li><a href=\"#detecting-unexpected-side-effects\">检测意外的副作用</a></li>\n<li><a href=\"#detecting-legacy-context-api\">检测过时的 context API</a></li>\n</ul>\n<p>未来的 React 版本将添加更多额外功能。</p>\n<h3 id=\"identifying-unsafe-lifecycles\"><a href=\"#identifying-unsafe-lifecycles\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>识别不安全的生命周期 </h3>\n<p>正如<a href=\"/blog/2018/03/27/update-on-async-rendering.html\">这篇博文</a>所述，某些过时的生命周期方法在异步 React 应用程序中使用是不安全的。但是，如果你的应用程序使用了第三方库，很难确保它们不使用这些生命周期方法。幸运的是，严格模式可以帮助解决这个问题！</p>\n<p>当启用严格模式时，React 会列出使用了不安全生命周期方法的所有 class 组件，并打印一条包含这些组件信息的警告消息，如下所示：</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e4fdbff774b356881123e69ad88eda88/1628f/strict-mode-unsafe-lifecycles-warning.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 840px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 13.80952380952381%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAjElEQVQI112Oaw6CQAwGuf/RRBcJETWR8Fh5BNZkuUDHFkw0/pjka9NOm8jJIYcUSY87LkPOOXIpoa4R75G+h7aFpoFxhHWFGL9Y/SHBFlXA7Q7lFR4VdB5M5J977jqYJhgGlaq4qvaeoXPbMT1uJCHLWJwjFAUvFc/67ZznRPsmBGRZNixvWP6t//pvEpXgSjHsOOkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"strict mode unsafe lifecycles warning\"\n        title=\"\"\n        src=\"/static/e4fdbff774b356881123e69ad88eda88/1e088/strict-mode-unsafe-lifecycles-warning.png\"\n        srcset=\"/static/e4fdbff774b356881123e69ad88eda88/65ed1/strict-mode-unsafe-lifecycles-warning.png 210w,\n/static/e4fdbff774b356881123e69ad88eda88/d10fb/strict-mode-unsafe-lifecycles-warning.png 420w,\n/static/e4fdbff774b356881123e69ad88eda88/1e088/strict-mode-unsafe-lifecycles-warning.png 840w,\n/static/e4fdbff774b356881123e69ad88eda88/1628f/strict-mode-unsafe-lifecycles-warning.png 1232w\"\n        sizes=\"(max-width: 840px) 100vw, 840px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p><em>此时</em>解决项目中严格模式所识别出来的问题，会使得在未来的 React 版本中使用 concurrent 渲染变得更容易。</p>\n<h3 id=\"warning-about-legacy-string-ref-api-usage\"><a href=\"#warning-about-legacy-string-ref-api-usage\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>关于使用过时字符串 ref API 的警告 </h3>\n<p>以前，React 提供了两种方法管理 refs 的方式：已过时的字符串 ref API 的形式及回调函数 API 的形式。尽管字符串 ref API 在两者中使用更方便，但是它有<a href=\"https://github.com/facebook/react/issues/1373\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">一些缺点</a>，因此官方推荐采用<a href=\"/docs/refs-and-the-dom.html#legacy-api-string-refs\">回调的方式</a>。</p>\n<p>React 16.3 新增了第三种选择，它提供了使用字符串 ref 的便利性，并且不存在任何缺点：\n<div class=\"gatsby-highlight\">\n        <pre class=\"gatsby-code-jsx\"><code><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>inputRef <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">createRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>text<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">ref</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>inputRef<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>inputRef<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">.</span><span class=\"token function\">focus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n        </div></p>\n<p>由于对象 ref 主要是为了替换字符串 ref 而添加的，因此严格模式现在会警告使用字符串 ref。</p>\n<blockquote>\n<p><strong>注意：</strong></p>\n<p>除了新增加的 <code class=\"gatsby-code-text\">createRef</code> API，回调 ref 依旧适用。</p>\n<p>你无需替换组件中的回调 ref。它们更灵活，因此仍将作为高级功能保留。</p>\n</blockquote>\n<p><a href=\"/docs/refs-and-the-dom.html\">在此处了解有关 <code class=\"gatsby-code-text\">createRef</code> API 的更多信息</a></p>\n<h3 id=\"warning-about-deprecated-finddomnode-usage\"><a href=\"#warning-about-deprecated-finddomnode-usage\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>关于使用废弃的 findDOMNode 方法的警告 </h3>\n<p>React 支持用 <code class=\"gatsby-code-text\">findDOMNode</code> 来在给定 class 实例的情况下在树中搜索 DOM 节点。通常你不需要这样做，因为你可以<a href=\"/docs/refs-and-the-dom.html#creating-refs\">将 ref 直接绑定到 DOM 节点</a>。</p>\n<p><code class=\"gatsby-code-text\">findDOMNode</code> 也可用于 class 组件，但它违反了抽象原则，它使得父组件需要单独渲染子组件。它会产生重构危险，你不能更改组件的实现细节，因为父组件可能正在访问它的 DOM 节点。<code class=\"gatsby-code-text\">findDOMNode</code> 只返回第一个子节点，但是使用 Fragments，组件可以渲染多个 DOM 节点。<code class=\"gatsby-code-text\">findDOMNode</code> 是一个只读一次的 API。调用该方法只会返回第一次查询的结果。如果子组件渲染了不同的节点，则无法跟踪此更改。因此，<code class=\"gatsby-code-text\">findDOMNode</code> 仅在组件返回单个且不可变的 DOM 节点时才有效。</p>\n<p>你可以通过将 ref 传递给自定义组件并使用 <a href=\"/docs/forwarding-refs.html#forwarding-refs-to-dom-components\">ref 转发</a>来将其传递给 DOM 节点。</p>\n<p>你也可以在组件中创建一个 DOM 节点的 wrapper，并将 ref 直接绑定到它。</p>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>wrapper <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">createRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">ref</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>wrapper<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span></span>  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>注意：</p>\n<p>在 CSS 中，如果你不希望节点成为布局的一部分，则可以使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/display#display_contents\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code class=\"gatsby-code-text\">display: contents</code></a> 属性。</p>\n</blockquote>\n<h3 id=\"detecting-unexpected-side-effects\"><a href=\"#detecting-unexpected-side-effects\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>检测意外的副作用 </h3>\n<p>从概念上讲，React 分两个阶段工作：</p>\n<ul>\n<li><strong>渲染</strong> 阶段会确定需要进行哪些更改，比如 DOM。在此阶段，React 调用 <code class=\"gatsby-code-text\">render</code>，然后将结果与上次渲染的结果进行比较。</li>\n<li><strong>提交</strong> 阶段发生在当 React 应用变化时。（对于 React DOM 来说，会发生在 React 插入，更新及删除 DOM 节点的时候。）在此阶段，React 还会调用 <code class=\"gatsby-code-text\">componentDidMount</code> 和 <code class=\"gatsby-code-text\">componentDidUpdate</code> 之类的生命周期方法。</li>\n</ul>\n<p>提交阶段通常会很快，但渲染过程可能很慢。因此，即将推出的 concurrent 模式 (默认情况下未启用) 将渲染工作分解为多个部分，对任务进行暂停和恢复操作以避免阻塞浏览器。这意味着 React 可以在提交之前多次调用渲染阶段生命周期的方法，或者在不提交的情况下调用它们（由于出现错误或更高优先级的任务使其中断）。</p>\n<p>渲染阶段的生命周期包括以下 class 组件方法：</p>\n<ul>\n<li><code class=\"gatsby-code-text\">constructor</code></li>\n<li><code class=\"gatsby-code-text\">componentWillMount</code> (or <code class=\"gatsby-code-text\">UNSAFE_componentWillMount</code>)</li>\n<li><code class=\"gatsby-code-text\">componentWillReceiveProps</code> (or <code class=\"gatsby-code-text\">UNSAFE_componentWillReceiveProps</code>)</li>\n<li><code class=\"gatsby-code-text\">componentWillUpdate</code> (or <code class=\"gatsby-code-text\">UNSAFE_componentWillUpdate</code>)</li>\n<li><code class=\"gatsby-code-text\">getDerivedStateFromProps</code></li>\n<li><code class=\"gatsby-code-text\">shouldComponentUpdate</code></li>\n<li><code class=\"gatsby-code-text\">render</code></li>\n<li><code class=\"gatsby-code-text\">setState</code> 更新函数（第一个参数）</li>\n</ul>\n<p>因为上述方法可能会被多次调用，所以不要在它们内部编写副作用相关的代码，这点非常重要。忽略此规则可能会导致各种问题的产生，包括内存泄漏和或出现无效的应用程序状态。不幸的是，这些问题很难被发现，因为它们通常具有<a href=\"https://en.wikipedia.org/wiki/Deterministic_algorithm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">非确定性</a>。</p>\n<p>严格模式不能自动检测到你的副作用，但它可以帮助你发现它们，使它们更具确定性。通过故意重复调用以下函数来实现的该操作：</p>\n<ul>\n<li>class 组件的 <code class=\"gatsby-code-text\">constructor</code>，<code class=\"gatsby-code-text\">render</code> 以及 <code class=\"gatsby-code-text\">shouldComponentUpdate</code> 方法</li>\n<li>class 组件的生命周期方法 <code class=\"gatsby-code-text\">getDerivedStateFromProps</code></li>\n<li>函数组件体</li>\n<li>状态更新函数 (即 <code class=\"gatsby-code-text\">setState</code> 的第一个参数）</li>\n<li>函数组件通过使用 <code class=\"gatsby-code-text\">useState</code>，<code class=\"gatsby-code-text\">useMemo</code> 或者 <code class=\"gatsby-code-text\">useReducer</code></li>\n</ul>\n<blockquote>\n<p>注意：</p>\n<p>这仅适用于开发模式。<em>生产模式下生命周期不会被调用两次。</em></p>\n</blockquote>\n<p>例如，请考虑以下代码：\n<div class=\"gatsby-highlight\">\n        <pre class=\"gatsby-code-jsx\"><code><span class=\"token keyword\">class</span> <span class=\"token class-name\">TopLevelRoute</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    SharedApplicationState<span class=\"token punctuation\">.</span><span class=\"token function\">recordEvent</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ExampleComponent'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n        </div></p>\n<p>这段代码看起来似乎没有问题。但是如果 <code class=\"gatsby-code-text\">SharedApplicationState.recordEvent</code> 不是<a href=\"https://en.wikipedia.org/wiki/Idempotence#Computer_science_meaning\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">幂等</a>的情况下，多次实例化此组件可能会导致应用程序状态无效。这种小 bug 可能在开发过程中可能不会表现出来，或者说表现出来但并不明显，并因此被忽视。</p>\n<p>严格模式采用故意重复调用方法（如组件的构造函数）的方式，使得这种 bug 更容易被发现。</p>\n<blockquote>\n<p>注意：</p>\n<p>从 React 17 开始，React 会自动修改 console 的方法，例如 <code class=\"gatsby-code-text\">console.log()</code>，以在对生命周期函数的第二次调用中静默日志。然而，在某些<a href=\"https://github.com/facebook/react/issues/20090#issuecomment-715927125\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">可以使用替代解决方案</a>的情况下，这可能会导致一些不期望的行为的发生。</p>\n</blockquote>\n<h3 id=\"detecting-legacy-context-api\"><a href=\"#detecting-legacy-context-api\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>检测过时的 context API </h3>\n<p>过时的 context API 容易出错，将在未来的主要版本中删除。在所有 16.x 版本中它仍然有效，但在严格模式下，将显示以下警告：</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fca5c5e1fb2ef2e2d59afb100b432c12/51800/warn-legacy-context-in-strict-mode.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 840px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 18.57142857142857%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAsklEQVQI1z2O226DMBBE+f8/axM3JGkL+AakkEixcUxfK2aybqVKR0c7LztT/eiGR4X3muqFpzfWe1jNwdEbOk0nNhg8ppFjD9uxt5wuWLNQId6hm023YnyeYdptidsjbakYhQXpF7nzozhFxIAlVPSWX0P5d5s5Txw8Lz2lYex5ndE18BbewGlIs2DaEmWL01U8qHSqxUHtlo9zqlU87IN6DV2zXmd+r38LCzmX5v+45iddvdtOYuXXpwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"warn legacy context in strict mode\"\n        title=\"\"\n        src=\"/static/fca5c5e1fb2ef2e2d59afb100b432c12/1e088/warn-legacy-context-in-strict-mode.png\"\n        srcset=\"/static/fca5c5e1fb2ef2e2d59afb100b432c12/65ed1/warn-legacy-context-in-strict-mode.png 210w,\n/static/fca5c5e1fb2ef2e2d59afb100b432c12/d10fb/warn-legacy-context-in-strict-mode.png 420w,\n/static/fca5c5e1fb2ef2e2d59afb100b432c12/1e088/warn-legacy-context-in-strict-mode.png 840w,\n/static/fca5c5e1fb2ef2e2d59afb100b432c12/51800/warn-legacy-context-in-strict-mode.png 1196w\"\n        sizes=\"(max-width: 840px) 100vw, 840px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>阅读<a href=\"/docs/context.html\">新的 context API 文档</a>以帮助你迁移到新版本。</p>","frontmatter":{"title":"严格模式","next":null,"prev":null},"fields":{"path":"content/docs/strict-mode.md","slug":"docs/strict-mode.html"}}},"pageContext":{"slug":"docs/strict-mode.html"}},"staticQueryHashes":[]}