{"componentChunkName":"component---src-templates-docs-js","path":"/docs/concurrent-mode-adoption.html","result":{"data":{"markdownRemark":{"html":"<style>\n.scary > blockquote {\n  background-color: rgba(237, 51, 21, 0.2);\n  border-left-color: #ed3315;\n}\n</style>\n<div class=\"scary\">\n<blockquote>\n<p>注意：</p>\n<p>本章节所描述的功能还处于实验阶段，在稳定版本中尚不可用。它面向的人群是早期使用者以及好奇心较强的人。</p>\n<p>本页面中许多信息现已过时，仅仅是为了存档而存在。欲了解最新信息，<strong>请参阅 <a href=\"/blog/2021/06/08/the-plan-for-react-18.html\">React 18 Alpha 版公告</a></strong>。</p>\n<p>在 React 18 发布前，我们将用稳定的文档替代此章节。</p>\n</blockquote>\n</div>\n<ul>\n<li>\n<p><a href=\"#installation\">安装</a></p>\n<ul>\n<li><a href=\"#who-is-this-experimental-release-for\">此实验版本适用于谁？</a></li>\n<li><a href=\"#enabling-concurrent-mode\">开启 concurrent 模式</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#what-to-expect\">有何期望</a></p>\n<ul>\n<li><a href=\"#migration-step-blocking-mode\">迁移步骤： blocking 模式</a></li>\n<li><a href=\"#why-so-many-modes\">为什么有这么多模式？</a></li>\n<li><a href=\"#feature-comparison\">特性对比</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"installation\"><a href=\"#installation\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>安装 </h2>\n<p>concurrent 模式目前仅在 React 的<a href=\"/blog/2019/10/22/react-release-channels.html#experimental-channel\">实验版本</a>可用。安装命令：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"gatsby-code-text\"><code class=\"gatsby-code-text\">npm install react@experimental react-dom@experimental</code></pre></div>\n<p><strong>实验版本与语义版本不同。</strong>\n在 <code class=\"gatsby-code-text\">@experimental</code> 版本，API 会随时增删改。</p>\n<p><strong>实验版本经常会包含破坏性更改</strong></p>\n<p>你可以在个人项目或新分支中尝试这些实验性功能，但我们并不建议在生产环境中使用它们。在 Facebook，我们<strong>确实</strong>在生产环境中使用它们，但我们在使用的同时也修复了 bug。<strong>再次强调，请不要在生产环境使用！</strong></p>\n<h3 id=\"who-is-this-experimental-release-for\"><a href=\"#who-is-this-experimental-release-for\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>此实验版本适用于谁？ </h3>\n<p>这个版本主要针对功能早期使用者、库作者和对此好奇的人。</p>\n<p>我们在生产中使用这段代码，但是仍然有一些 bug、缺少许多特性，且文档存在缺陷。我们希望了解更多关于 concurrent 模式中的出现的问题，以便更好地为未来发布稳定版本做准备。</p>\n<h3 id=\"enabling-concurrent-mode\"><a href=\"#enabling-concurrent-mode\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>开启 concurrent 模式 </h3>\n<p>通常，当我们给 React 添加功能的时候，你可以立即使用。比如 Fragments，Context，甚至 Hook。你都可以直接在代码里使用他们，而不用修改之前的代码。</p>\n<p>concurrent 模式并不是这样。它给引入了新的语义，改变了 React 的工作方式。否则<em>不能启用</em><a href=\"/docs/concurrent-mode-patterns.html\">这些新功能</a>。这就是它被分组到了新的模式，而不是相继的发布出来。</p>\n<p>你不能为某个子树单独启用 concurrent 模式。你应该在 <code class=\"gatsby-code-text\">ReactDOM.render()</code> 里启用它。</p>\n<p><strong>这会在整个 <code class=\"gatsby-code-text\">&lt;App /></code> 结构树里启用 concurrent 模式：</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">'react-dom'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 如果你之前的代码是：</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// ReactDOM.render(&lt;App />, document.getElementById('root'));</span>\n<span class=\"token comment\">//</span>\n<span class=\"token comment\">// 你可以用下面的代码引入 concurrent 模式：</span>\n\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">unstable_createRoot</span><span class=\"token punctuation\">(</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">App</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<blockquote>\n<p>注意：</p>\n<p>concurrent 模式 API 如 <code class=\"gatsby-code-text\">createRoot</code> 只存在于 React 实验版本。</p>\n</blockquote>\n<p>在 concurrent 模式下，生命周期<a href=\"/blog/2018/03/27/update-on-async-rendering.html\">之前被标记过</a>为“不安全”是真的不安全，会比现在的 React 出现更多的 bug。在你的 app 完全兼容<a href=\"https://reactjs.org/docs/strict-mode.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">严格模式</a>之前，我们不建议使用 concurrent 模式。</p>\n<h2 id=\"what-to-expect\"><a href=\"#what-to-expect\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>有何期望 </h2>\n<p>如果你有已完成的大型 app，或着你的 app 有大量第三方依赖，请不要立即使用 concurrent 模式。<strong>比如在 Facebook 我们在新网站的开发上使用 concurrent 模式，并没有打算在旧的网站开发上使用。</strong> 这是因为我们旧网站的代码里使用了不安全的生命周期方法、不兼容第三方库、与 concurrent 模式也不兼容。</p>\n<p>根据我们的经验，使用常见的 React 开发模式，并且不依赖外部状态管理的代码最容易切换到 concurrent 模式。在接下来的几周内，我们会列出常见的问题和解决方案。</p>\n<h3 id=\"migration-step-blocking-mode\"><a href=\"#migration-step-blocking-mode\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>迁移步骤： blocking 模式 </h3>\n<p>对于较旧的代码库，concurrent 模式可能步子迈的太大。这就是我们在实验版本中提供“ blocking 模式”的原因。你可以通过使用 <code class=\"gatsby-code-text\">createBlockingRoot</code> 代替 <code class=\"gatsby-code-text\">createRoot</code> 尝试一下。它仅提供了 concurrent 模式的<em>小部分功能</em>，但它更接近于 React 今天的工作方式，可以作为迁移的一个步骤。</p>\n<p>回顾：</p>\n<ul>\n<li><strong>legacy 模式：</strong> <code class=\"gatsby-code-text\">ReactDOM.render(&lt;App />, rootNode)</code>。这是当前 React app 使用的方式。当前没有计划删除本模式，但是这个模式可能不支持这些新功能。</li>\n<li><strong>blocking 模式：</strong> <code class=\"gatsby-code-text\">ReactDOM.createBlockingRoot(rootNode).render(&lt;App />)</code>。目前正在实验中。作为迁移到 concurrent 模式的第一个步骤。</li>\n<li><strong>concurrent 模式：</strong> <code class=\"gatsby-code-text\">ReactDOM.createRoot(rootNode).render(&lt;App />)</code>。目前在实验中，未来稳定之后，打算作为 React 的默认开发模式。这个模式开启了<em>所有的</em>新功能。</li>\n</ul>\n<h3 id=\"why-so-many-modes\"><a href=\"#why-so-many-modes\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>为什么有这么多模式？</h3>\n<p>我们认为提供<a href=\"/docs/faq-versioning.html#commitment-to-stability\">渐进的迁移策略</a>比进行破坏性的更改或者使 React 停滞不前是更好的选择。</p>\n<p>实际上，我们希望今天使用 legacy 模式的大多数 app 至少能迁移到 blocking 模式（如果不能迁移到 concurrent 模式）。对于希望在短期内支持所有模式的库而言，碎片化可能是很讨厌的事情。但是组件将生态系统从 legacy 模式中移除，也会<em>解决</em>一些影响 React 主要库的问题。比如<a href=\"https://github.com/facebook/react/issues/14536\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">获取布局时令人迷惑的 Suspense 行为</a>和<a href=\"https://github.com/facebook/react/issues/15080\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">缺乏一致性的批处理</a>。legacy 模式下，如果不修改语义就无法修复的许多错误，在 blocking 模式和 concurrent 模式下就不存。</p>\n<p>你可以把 blocking 模式当作 concurrent 模式的“优雅降级”版本。<strong>所以长远来看，模式的数量会收敛，不用考虑不同的模式。</strong>但就目前而言，模式是一项重要的迁移策略。能让每个人都能决定自己什么时候迁移，并按照自己的速度进行迁移。</p>\n<h3 id=\"feature-comparison\"><a href=\"#feature-comparison\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>特性对比 </h3>\n<style>\n  #feature-table table { border-collapse: collapse; }\n  #feature-table th { padding-right: 30px; }\n  #feature-table tr { border-bottom: 1px solid #eee; }\n</style>\n<div id=\"feature-table\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>legacy 模式</th>\n<th>blocking 模式</th>\n<th>concurrent 模式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"/docs/refs-and-the-dom.html#legacy-api-string-refs\">String Refs</a></td>\n<td>✅</td>\n<td>🚫**</td>\n<td>🚫**</td>\n</tr>\n<tr>\n<td><a href=\"/docs/legacy-context.html\">Legacy Context</a></td>\n<td>✅</td>\n<td>🚫**</td>\n<td>🚫**</td>\n</tr>\n<tr>\n<td><a href=\"/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage\">findDOMNode</a></td>\n<td>✅</td>\n<td>🚫**</td>\n<td>🚫**</td>\n</tr>\n<tr>\n<td><a href=\"/docs/concurrent-mode-suspense.html#what-is-suspense-exactly\">Suspense</a></td>\n<td>✅</td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><a href=\"/docs/concurrent-mode-patterns.html#suspenselist\">SuspenseList</a></td>\n<td>🚫</td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Suspense SSR + Hydration</td>\n<td>🚫</td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Progressive Hydration</td>\n<td>🚫</td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Selective Hydration</td>\n<td>🚫</td>\n<td>🚫</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Cooperative Multitasking</td>\n<td>🚫</td>\n<td>🚫</td>\n<td>✅</td>\n</tr>\n<tr>\n<td>Automatic batching of multiple setStates     </td>\n<td>🚫*</td>\n<td>✅</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><a href=\"/docs/concurrent-mode-patterns.html#splitting-high-and-low-priority-state\">Priority-based Rendering</a></td>\n<td>🚫</td>\n<td>🚫</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><a href=\"/docs/concurrent-mode-intro.html#interruptible-rendering\">Interruptible Prerendering</a></td>\n<td>🚫</td>\n<td>🚫</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><a href=\"/docs/concurrent-mode-patterns.html#transitions\">useTransition</a></td>\n<td>🚫</td>\n<td>🚫</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><a href=\"/docs/concurrent-mode-patterns.html#deferring-a-value\">useDeferredValue</a></td>\n<td>🚫</td>\n<td>🚫</td>\n<td>✅</td>\n</tr>\n<tr>\n<td><a href=\"/docs/concurrent-mode-patterns.html#suspense-reveal-train\">Suspense Reveal “Train”</a></td>\n<td>🚫</td>\n<td>🚫</td>\n<td>✅</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>*：legacy 模式在合成事件中有自动批处理的功能，但仅限于一个浏览器任务。非 React 事件想使用这个功能必须使用 <code class=\"gatsby-code-text\">unstable_batchedUpdates</code>。在 blocking 模式和 concurrent 模式下，所有的 <code class=\"gatsby-code-text\">setState</code> 在默认情况下都是批处理的。</p>\n<p>**：会在开发中发出警告。</p>","frontmatter":{"title":"使用 Concurrent 模式（实验性）","next":"concurrent-mode-reference.html","prev":"concurrent-mode-patterns.html"},"fields":{"path":"content/docs/concurrent-mode-adoption.md","slug":"docs/concurrent-mode-adoption.html"}}},"pageContext":{"slug":"docs/concurrent-mode-adoption.html"}},"staticQueryHashes":[]}