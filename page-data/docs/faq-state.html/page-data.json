{"componentChunkName":"component---src-templates-docs-js","path":"/docs/faq-state.html","result":{"data":{"markdownRemark":{"html":"<h3 id=\"what-does-setstate-do\"><a href=\"#what-does-setstate-do\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">setState</code> 实际做了什么？ </h3>\n<p><code class=\"gatsby-code-text\">setState()</code> 会对一个组件的 <code class=\"gatsby-code-text\">state</code> 对象安排一次更新。当 state 改变了，该组件就会重新渲染。</p>\n<h3 id=\"what-is-the-difference-between-state-and-props\"><a href=\"#what-is-the-difference-between-state-and-props\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">state</code> 和 <code class=\"gatsby-code-text\">props</code> 之间的区别是什么？  </h3>\n<p><a href=\"/docs/components-and-props.html\"><code class=\"gatsby-code-text\">props</code></a>（“properties” 的缩写）和 <a href=\"/docs/state-and-lifecycle.html\"><code class=\"gatsby-code-text\">state</code></a> 都是普通的 JavaScript 对象。它们都是用来保存信息的，这些信息可以控制组件的渲染输出，而它们的一个重要的不同点就是：<code class=\"gatsby-code-text\">props</code> 是传递<em>给</em>组件的（类似于函数的形参），而 <code class=\"gatsby-code-text\">state</code> 是在组件<em>内</em>被组件自己管理的（类似于在一个函数内声明的变量）。</p>\n<p>下面是一些不错的资源，可以用来进一步了解使用 <code class=\"gatsby-code-text\">props</code> 或 <code class=\"gatsby-code-text\">state</code> 的最佳时机：</p>\n<ul>\n<li><a href=\"https://github.com/uberVU/react-guide/blob/master/props-vs-state.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Props vs State</a></li>\n<li><a href=\"https://lucybain.com/blog/2016/react-state-vs-pros/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ReactJS: Props vs. State</a></li>\n</ul>\n<h3 id=\"why-is-setstate-giving-me-the-wrong-value\"><a href=\"#why-is-setstate-giving-me-the-wrong-value\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>为什么 <code class=\"gatsby-code-text\">setState</code> 给了我一个错误的值？ </h3>\n<p>在 React 中，<code class=\"gatsby-code-text\">this.props</code> 和 <code class=\"gatsby-code-text\">this.state</code> 都代表着<em>已经被渲染了的</em>值，即当前屏幕上显示的值。</p>\n<p>调用 <code class=\"gatsby-code-text\">setState</code> 其实是异步的 —— 不要指望在调用 <code class=\"gatsby-code-text\">setState</code> 之后，<code class=\"gatsby-code-text\">this.state</code> 会立即映射为新的值。如果你需要基于当前的 state 来计算出新的值，那你应该传递一个函数，而不是一个对象（详情见下文）。</p>\n<p>代码<em>不会</em>像预期那样运行的示例：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">incrementCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 注意：这样 *不会* 像预期的那样工作。</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>count<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">handleSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 假设 `this.state.count` 从 0 开始。</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">incrementCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">incrementCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">incrementCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 当 React 重新渲染该组件时，`this.state.count` 会变为 1，而不是你期望的 3。</span>\n\n  <span class=\"token comment\">// 这是因为上面的 `incrementCount()` 函数是从 `this.state.count` 中读取数据的，</span>\n  <span class=\"token comment\">// 但是 React 不会更新 `this.state.count`，直到该组件被重新渲染。</span>\n  <span class=\"token comment\">// 所以最终 `incrementCount()` 每次读取 `this.state.count` 的值都是 0，并将它设为 1。</span>\n\n  <span class=\"token comment\">// 问题的修复参见下面的说明。</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>参见下面的说明来修复这个问题。</p>\n<h3 id=\"how-do-i-update-state-with-values-that-depend-on-the-current-state\"><a href=\"#how-do-i-update-state-with-values-that-depend-on-the-current-state\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>我应该如何更新那些依赖于当前的 state 的 state 呢？ </h3>\n<p>给 <code class=\"gatsby-code-text\">setState</code> 传递一个函数，而不是一个对象，就可以确保每次的调用都是使用最新版的 state（见下面的说明）。</p>\n<h3 id=\"what-is-the-difference-between-passing-an-object-or-a-function-in-setstate\"><a href=\"#what-is-the-difference-between-passing-an-object-or-a-function-in-setstate\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>给 <code class=\"gatsby-code-text\">setState</code> 传递一个对象与传递一个函数的区别是什么？ </h3>\n<p>传递一个函数可以让你在函数内访问到当前的 state 的值。因为 <code class=\"gatsby-code-text\">setState</code> 的调用是分批的，所以你可以链式地进行更新，并确保它们是一个建立在另一个之上的，这样才不会发生冲突：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token function\">incrementCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">state</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 重要：在更新的时候读取 `state`，而不是 `this.state`。</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>count<span class=\"token operator\">:</span> state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">handleSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 假设 `this.state.count` 从 0 开始。</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">incrementCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">incrementCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">incrementCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 如果你现在在这里读取 `this.state.count`，它还是会为 0。</span>\n  <span class=\"token comment\">// 但是，当 React 重新渲染该组件时，它会变为 3。</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><a href=\"/docs/react-component.html#setstate\">学习更多有关 setState 的内容</a></p>\n<h3 id=\"when-is-setstate-asynchronous\"><a href=\"#when-is-setstate-asynchronous\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"gatsby-code-text\">setState</code> 什么时候是异步的？ </h3>\n<p>目前，在事件处理函数内部的 <code class=\"gatsby-code-text\">setState</code> 是异步的。</p>\n<p>例如，如果 <code class=\"gatsby-code-text\">Parent</code> 和 <code class=\"gatsby-code-text\">Child</code> 在同一个 click 事件中都调用了 <code class=\"gatsby-code-text\">setState</code> ，这样就可以确保 <code class=\"gatsby-code-text\">Child</code> 不会被重新渲染两次。取而代之的是，React 会将该 state “冲洗” 到浏览器事件结束的时候，再统一地进行更新。这种机制可以在大型应用中得到很好的性能提升。</p>\n<p>这只是一个实现的细节，所以请不要直接依赖于这种机制。在以后的版本当中，React 会在更多的情况下静默地使用 state 的批更新机制。</p>\n<h3 id=\"why-doesnt-react-update-thisstate-synchronously\"><a href=\"#why-doesnt-react-update-thisstate-synchronously\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>为什么 React 不同步地更新 <code class=\"gatsby-code-text\">this.state</code>？ </h3>\n<p>如前面章节解释的那样，在开始重新渲染之前，React 会有意地进行“等待”，直到所有在组件的事件处理函数内调用的 <code class=\"gatsby-code-text\">setState()</code> 完成之后。这样可以通过避免不必要的重新渲染来提升性能。</p>\n<p>但是，你可能还是会想，为什么 React 不能立即更新 <code class=\"gatsby-code-text\">this.state</code>，而不对组件进行重新渲染呢。</p>\n<p>主要有两个原因：</p>\n<ul>\n<li>这样会破坏掉 <code class=\"gatsby-code-text\">props</code> 和 <code class=\"gatsby-code-text\">state</code> 之间的一致性，造成一些难以 debug 的问题。</li>\n<li>这样会让一些我们正在实现的新功能变得无法实现。</li>\n</ul>\n<p>这个 <a href=\"https://github.com/facebook/react/issues/11527#issuecomment-360199710\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub 评论</a> 深入了该特殊示例。</p>\n<h3 id=\"should-i-use-a-state-management-library-like-redux-or-mobx\"><a href=\"#should-i-use-a-state-management-library-like-redux-or-mobx\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>我应该使用一个像 Redux 或 MobX 那样的 state 管理库吗？ </h3>\n<p><a href=\"https://redux.js.org/faq/general#when-should-i-use-redux\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">或许需要。</a></p>\n<p>在添加额外的库之前，最好先了解清楚 React 能干什么。你也可以只使用 React 来构建出一个比较复杂的应用。</p>","frontmatter":{"title":"组件状态","next":null,"prev":null},"fields":{"path":"content/docs/faq-state.md","slug":"docs/faq-state.html"}}},"pageContext":{"slug":"docs/faq-state.html"}},"staticQueryHashes":[]}