{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/2/basic-types.html","result":{"data":{"allSitePage":{"nodes":[{"path":"/dev-404-page/"},{"path":"/docs/handbook/nightly-builds.html"},{"path":"/pt/docs/handbook/nightly-builds.html"},{"path":"/docs/handbook/declaration-files/consumption.html"},{"path":"/docs/handbook/declaration-files/by-example.html"},{"path":"/docs/handbook/declaration-files/deep-dive.html"},{"path":"/docs/handbook/declaration-files/do-s-and-don-ts.html"},{"path":"/docs/handbook/declaration-files/introduction.html"},{"path":"/docs/handbook/declaration-files/publishing.html"},{"path":"/docs/handbook/declaration-files/library-structures.html"},{"path":"/docs/handbook/declaration-files/templates.html"},{"path":"/docs/handbook/typescript-in-5-minutes.html"},{"path":"/docs/handbook/typescript-in-5-minutes-func.html"},{"path":"/docs/handbook/typescript-in-5-minutes-oop.html"},{"path":"/docs/handbook/typescript-from-scratch.html"},{"path":"/docs/handbook/basic-types.html"},{"path":"/docs/handbook/enums.html"},{"path":"/docs/handbook/classes.html"},{"path":"/docs/handbook/functions.html"},{"path":"/docs/handbook/generics.html"},{"path":"/docs/handbook/literal-types.html"},{"path":"/docs/handbook/intro.html"},{"path":"/docs/handbook/interfaces.html"},{"path":"/docs/handbook/unions-and-intersections.html"},{"path":"/docs/handbook/2/basic-types.html"},{"path":"/docs/handbook/2/classes.html"},{"path":"/docs/handbook/2/everyday-types.html"},{"path":"/docs/handbook/2/modules.html"},{"path":"/docs/handbook/2/narrowing.html"},{"path":"/docs/handbook/2/functions.html"},{"path":"/docs/handbook/2/objects.html"},{"path":"/docs/handbook/2/type-declarations.html"},{"path":"/docs/handbook/declaration-files/dts-from-js.html"},{"path":"/docs/handbook/2/understanding-errors.html"},{"path":"/docs/handbook/intro-to-js-ts.html"},{"path":"/docs/handbook/type-checking-javascript-files.html"},{"path":"/docs/handbook/jsdoc-supported-types.html"},{"path":"/docs/handbook/compiler-options-in-msbuild.html"},{"path":"/docs/handbook/configuring-watch.html"},{"path":"/docs/handbook/integrating-with-build-tools.html"},{"path":"/docs/handbook/compiler-options.html"},{"path":"/docs/handbook/tsconfig-json.html"},{"path":"/docs/handbook/project-references.html"},{"path":"/docs/handbook/declaration-merging.html"},{"path":"/docs/handbook/decorators.html"},{"path":"/docs/handbook/advanced-types.html"},{"path":"/docs/handbook/iterators-and-generators.html"},{"path":"/docs/handbook/mixins.html"},{"path":"/docs/handbook/jsx.html"},{"path":"/docs/handbook/module-resolution.html"},{"path":"/docs/handbook/modules.html"},{"path":"/docs/handbook/namespaces-and-modules.html"},{"path":"/docs/handbook/symbols.html"},{"path":"/docs/handbook/namespaces.html"},{"path":"/docs/handbook/triple-slash-directives.html"},{"path":"/docs/handbook/type-inference.html"},{"path":"/docs/handbook/type-compatibility.html"},{"path":"/docs/handbook/utility-types.html"},{"path":"/docs/handbook/variable-declarations.html"},{"path":"/docs/handbook/release-notes/typescript-1-1.html"},{"path":"/docs/handbook/release-notes/typescript-1-3.html"},{"path":"/docs/handbook/release-notes/typescript-1-4.html"},{"path":"/docs/handbook/release-notes/typescript-1-5.html"},{"path":"/docs/handbook/release-notes/typescript-1-6.html"},{"path":"/docs/handbook/release-notes/typescript-1-7.html"},{"path":"/docs/handbook/release-notes/typescript-1-8.html"},{"path":"/docs/handbook/release-notes/typescript-2-1.html"},{"path":"/docs/handbook/release-notes/typescript-2-0.html"},{"path":"/docs/handbook/release-notes/typescript-2-2.html"},{"path":"/docs/handbook/release-notes/typescript-2-3.html"},{"path":"/docs/handbook/release-notes/typescript-2-5.html"},{"path":"/docs/handbook/release-notes/typescript-2-4.html"},{"path":"/docs/handbook/release-notes/typescript-2-6.html"},{"path":"/docs/handbook/release-notes/typescript-2-7.html"},{"path":"/docs/handbook/release-notes/typescript-2-9.html"},{"path":"/docs/handbook/release-notes/typescript-2-8.html"},{"path":"/docs/handbook/release-notes/typescript-3-1.html"},{"path":"/docs/handbook/release-notes/typescript-3-0.html"},{"path":"/docs/handbook/release-notes/typescript-3-3.html"},{"path":"/docs/handbook/release-notes/typescript-3-2.html"},{"path":"/docs/handbook/release-notes/typescript-3-5.html"},{"path":"/docs/handbook/release-notes/typescript-3-4.html"},{"path":"/docs/handbook/release-notes/typescript-3-6.html"},{"path":"/docs/handbook/release-notes/typescript-3-8.html"},{"path":"/docs/handbook/release-notes/typescript-3-7.html"},{"path":"/docs/handbook/release-notes/typescript-3-9.html"},{"path":"/docs/handbook/asp-net-core.html"},{"path":"/docs/handbook/release-notes/typescript-4-0.html"},{"path":"/docs/handbook/angular.html"},{"path":"/docs/handbook/babel-with-typescript.html"},{"path":"/docs/handbook/dom-manipulation.html"},{"path":"/docs/handbook/gulp.html"},{"path":"/docs/handbook/react.html"},{"path":"/docs/handbook/migrating-from-javascript.html"},{"path":"/docs/handbook/typescript-tooling-in-5-minutes.html"},{"path":"/ko/docs/handbook/babel-with-typescript.html"},{"path":"/ko/docs/handbook/react.html"},{"path":"/pt/docs/handbook/intro-to-js-ts.html"},{"path":"/ko/docs/handbook/typescript-tooling-in-5-minutes.html"},{"path":"/pt/docs/handbook/tsconfig-json.html"},{"path":"/pt/docs/handbook/Decorators.html"},{"path":"/pt/docs/handbook/module-resolution.html"},{"path":"/pt/docs/handbook/namespaces.html"},{"path":"/pt/docs/handbook/react.html"},{"path":"/pt/docs/handbook/babel-with-typescript.html"},{"path":"/pt/docs/handbook/typescript-tooling-in-5-minutes.html"},{"path":"/vo/docs/handbook/basic-types.html"},{"path":"/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/global-plugin-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/global-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-class-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-function-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-plugin-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-d-ts.html"},{"path":"/docs/handbook/2/conditional-types.html"},{"path":"/docs/handbook/2/indexed-access-types.html"},{"path":"/docs/handbook/2/typeof-types.html"},{"path":"/docs/handbook/2/types-from-types.html"},{"path":"/pt/docs/handbook/declaration-files/dts-from-js.html"},{"path":"/pt/docs/handbook/symbols.html"},{"path":"/docs/handbook/release-notes/overview.html"},{"path":"/tsconfig"},{"path":"/es/tsconfig"},{"path":"/id/tsconfig"},{"path":"/ko/tsconfig"},{"path":"/ja/tsconfig"},{"path":"/pt/tsconfig"},{"path":"/vo/tsconfig"},{"path":"/zh/tsconfig"},{"path":"/play"},{"path":"/fa/play"},{"path":"/id/play"},{"path":"/ja/play"},{"path":"/zh/play"},{"path":"/es/play"},{"path":"/ko/play"},{"path":"/pt/play"},{"path":"/vo/play"},{"path":"/play/3-7/fixits/big-number-literals.ts.html"},{"path":"/play/3-7/fixits/const-to-let.ts.html"},{"path":"/play/3-7/fixits/infer-from-usage-changes.ts.html"},{"path":"/play/3-7/syntax-and-messaging/flattened-error-reporting.ts.html"},{"path":"/play/3-7/syntax-and-messaging/nullish-coalescing.ts.html"},{"path":"/play/3-7/syntax-and-messaging/optional-chaining.ts.html"},{"path":"/play/3-7/types-and-code-flow/assertion-functions.ts.html"},{"path":"/play/3-7/types-and-code-flow/recursive-type-references.ts.html"},{"path":"/play/3-7/types-and-code-flow/uncalled-function-checks.ts.html"},{"path":"/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts.html"},{"path":"/play/3-8/jsdoc-improvements/accessibility-modifiers.js.html"},{"path":"/play/3-8/syntax-and-messaging/export-modules-from.ts.html"},{"path":"/play/3-8/syntax-and-messaging/private-class-fields.ts.html"},{"path":"/play/4-0/new-checks/class-constructor-code-flow.ts.html"},{"path":"/play/4-0/new-ts-features/named-tuples.ts.html"},{"path":"/play/4-0/new-ts-features/unknown-in-catch.ts.html"},{"path":"/play/4-0/new-ts-features/variadic-tuples.ts.html"},{"path":"/play/4-0/new-js-features/jsdoc-deprecated.ts.html"},{"path":"/play/4-0/new-js-features/logical-operators-and-assignment.ts.html"},{"path":"/play/4-0/new-js-features/nullish-coalescing.ts.html"},{"path":"/play/javascript/external-apis/typescript-with-deno.ts.html"},{"path":"/play/javascript/external-apis/typescript-with-node.js.html"},{"path":"/play/javascript/external-apis/typescript-with-web.js.html"},{"path":"/play/javascript/external-apis/typescript-with-webgl.js.html"},{"path":"/play/javascript/functions-with-javascript/function-chaining.ts.html"},{"path":"/play/javascript/functions-with-javascript/generic-functions.ts.html"},{"path":"/play/javascript/functions-with-javascript/typing-functions.ts.html"},{"path":"/play/javascript/helping-with-javascript/errors.ts.html"},{"path":"/play/javascript/helping-with-javascript/quick-fixes.ts.html"},{"path":"/play/javascript/javascript-essentials/code-flow.ts.html"},{"path":"/play/javascript/javascript-essentials/functions.ts.html"},{"path":"/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/play/javascript/javascript-essentials/objects-and-arrays.ts.html"},{"path":"/play/javascript/modern-javascript/async-await.ts.html"},{"path":"/play/javascript/modern-javascript/immutability.ts.html"},{"path":"/play/javascript/modern-javascript/import-export.ts.html"},{"path":"/play/javascript/modern-javascript/jsdoc-support.js.html"},{"path":"/play/javascript/working-with-classes/classes-101.ts.html"},{"path":"/play/javascript/working-with-classes/generic-classes.ts.html"},{"path":"/play/javascript/working-with-classes/mixins.ts.html"},{"path":"/play/javascript/working-with-classes/this.ts.html"},{"path":"/play/playground/config/javascript-playgrounds.js.html"},{"path":"/play/playground/config/new-compiler-defaults.ts.html"},{"path":"/play/playground/language/automatic-type-acquisition.ts.html"},{"path":"/play/playground/language/fixits.ts.html"},{"path":"/play/typescript/language/soundness.ts.html"},{"path":"/play/typescript/language/structural-typing.ts.html"},{"path":"/play/typescript/language/type-guards.ts.html"},{"path":"/play/typescript/language/type-widening-and-narrowing.ts.html"},{"path":"/play/playground/tooling/mobile-support.ts.html"},{"path":"/play/playground/tooling/sharable-urls.ts.html"},{"path":"/play/playground/tooling/typescript-versions.ts.html"},{"path":"/play/typescript/language-extensions/enums.ts.html"},{"path":"/play/typescript/language-extensions/nominal-typing.ts.html"},{"path":"/play/typescript/language-extensions/types-vs-interfaces.ts.html"},{"path":"/play/typescript/meta-types/conditional-types.ts.html"},{"path":"/play/typescript/meta-types/discriminate-types.ts.html"},{"path":"/play/typescript/meta-types/indexed-types.ts.html"},{"path":"/play/typescript/meta-types/mapped-types.ts.html"},{"path":"/play/typescript/primitives/any.ts.html"},{"path":"/play/typescript/primitives/literals.ts.html"},{"path":"/play/typescript/primitives/union-and-intersection-types.ts.html"},{"path":"/play/typescript/primitives/unknown-and-never.ts.html"},{"path":"/play/typescript/type-primitives/built-in-utility-types.ts.html"},{"path":"/play/typescript/type-primitives/nullable-types.ts.html"},{"path":"/play/typescript/type-primitives/tuples.ts.html"},{"path":"/es/play/javascript/external-apis/typescript-with-deno.ts.html"},{"path":"/es/play/javascript/external-apis/typescript-with-node.js.html"},{"path":"/es/play/javascript/external-apis/typescript-with-web.js.html"},{"path":"/es/play/javascript/functions-with-javascript/function-chaining.ts.html"},{"path":"/es/play/javascript/functions-with-javascript/generic-functions.ts.html"},{"path":"/es/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/es/play/javascript/javascript-essentials/objects-and-arrays.ts.html"},{"path":"/es/play/typescript/language/soundness.ts.html"},{"path":"/es/play/typescript/language/structural-typing.ts.html"},{"path":"/es/play/typescript/language/type-guards.ts.html"},{"path":"/es/play/typescript/language/type-widening-and-narrowing.ts.html"},{"path":"/es/play/typescript/meta-types/conditional-types.ts.html"},{"path":"/es/play/typescript/meta-types/discriminate-types.ts.html"},{"path":"/es/play/typescript/meta-types/indexed-types.ts.html"},{"path":"/es/play/typescript/meta-types/mapped-types.ts.html"},{"path":"/es/play/typescript/primitives/any.ts.html"},{"path":"/es/play/typescript/primitives/literals.ts.html"},{"path":"/es/play/typescript/primitives/union-and-intersection-types.ts.html"},{"path":"/es/play/typescript/primitives/unknown-and-never.ts.html"},{"path":"/es/play/typescript/type-primitives/built-in-utility-types.ts.html"},{"path":"/es/play/typescript/type-primitives/nullable-types.ts.html"},{"path":"/es/play/typescript/type-primitives/tuples.ts.html"},{"path":"/fa/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/id/play/3-7/fixits/big-number-literals.ts.html"},{"path":"/id/play/3-7/fixits/const-to-let.ts.html"},{"path":"/id/play/3-7/fixits/infer-from-usage-changes.ts.html"},{"path":"/id/play/3-7/syntax-and-messaging/flattened-error-reporting.ts.html"},{"path":"/id/play/3-7/syntax-and-messaging/nullish-coalescing.ts.html"},{"path":"/id/play/3-7/syntax-and-messaging/optional-chaining.ts.html"},{"path":"/id/play/3-7/types-and-code-flow/assertion-functions.ts.html"},{"path":"/id/play/3-7/types-and-code-flow/recursive-type-reference.ts.html"},{"path":"/id/play/3-7/types-and-code-flow/uncalled-function-checks.ts.html"},{"path":"/id/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts.html"},{"path":"/id/play/3-8/jsdoc-improvements/accessibility-modifiers.js.html"},{"path":"/id/play/3-8/syntax-and-messaging/export-modules-from.ts.html"},{"path":"/id/play/3-8/syntax-and-messaging/private-class-fields.ts.html"},{"path":"/id/play/4-0/new-checks/class-constructor-code-flow.ts.html"},{"path":"/id/play/4-0/new-js-features/jsdoc-deprecated.ts.html"},{"path":"/id/play/4-0/new-js-features/logical-operators-and-assignment.ts.html"},{"path":"/id/play/4-0/new-js-features/nullish-coalescing.ts.html"},{"path":"/id/play/4-0/new-ts-features/named-tuples.ts.html"},{"path":"/id/play/4-0/new-ts-features/unknown-in-catch.ts.html"},{"path":"/id/play/4-0/new-ts-features/variadic-tuples.ts.html"},{"path":"/id/play/javascript/external-apis/typescript-with-deno.ts.html"},{"path":"/id/play/javascript/external-apis/typescript-with-node.js.html"},{"path":"/id/play/javascript/external-apis/typescript-with-web.js.html"},{"path":"/id/play/javascript/external-apis/typescript-with-webgl.js.html"},{"path":"/id/play/javascript/helping-with-javascript/errors.ts.html"},{"path":"/id/play/javascript/helping-with-javascript/quick-fixes.ts.html"},{"path":"/id/play/javascript/javascript-essentials/code-flow.ts.html"},{"path":"/id/play/javascript/javascript-essentials/functions.ts.html"},{"path":"/id/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/id/play/javascript/javascript-essentials/objects-and-arrays.ts.html"},{"path":"/ja/play/3-7/fixits/big-number-literals.ts.html"},{"path":"/ja/play/3-7/fixits/const-to-let.ts.html"},{"path":"/ja/play/3-7/fixits/infer-from-usage-changes.ts.html"},{"path":"/ja/play/3-7/syntax-and-messaging/flattened-error-reporting.ts.html"},{"path":"/ja/play/3-7/syntax-and-messaging/nullish-coalescing.ts.html"},{"path":"/ja/play/3-7/syntax-and-messaging/optional-chaining.ts.html"},{"path":"/ja/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts.html"},{"path":"/ja/play/javascript/external-apis/typescript-with-deno.ts.html"},{"path":"/ja/play/typescript/language-extensions/enums.ts.html"},{"path":"/ja/play/typescript/language-extensions/nominal-typing.ts.html"},{"path":"/ja/play/typescript/language-extensions/types-vs-interfaces.ts.html"},{"path":"/ja/play/typescript/meta-types/conditional-types.ts.html"},{"path":"/ja/play/typescript/meta-types/discriminate-types.ts.html"},{"path":"/ja/play/typescript/meta-types/indexed-types.ts.html"},{"path":"/ja/play/typescript/meta-types/mapped-types.ts.html"},{"path":"/ja/play/typescript/primitives/any.ts.html"},{"path":"/ja/play/typescript/primitives/literals.ts.html"},{"path":"/ja/play/typescript/primitives/union-and-intersection-types.ts.html"},{"path":"/ja/play/typescript/primitives/unknown-and-never.ts.html"},{"path":"/ja/play/typescript/type-primitives/built-in-utility-types.ts.html"},{"path":"/ja/play/typescript/type-primitives/nullable-types.ts.html"},{"path":"/ja/play/typescript/type-primitives/tuples.ts.html"},{"path":"/ko/play/3-7/fixits/big-number-literals.ts.html"},{"path":"/ko/play/3-7/fixits/const-to-let.ts.html"},{"path":"/ko/play/3-7/syntax-and-messaging/optional-chaining.ts.html"},{"path":"/ko/play/3-8/syntax-and-messaging/export-modules-from.ts.html"},{"path":"/ko/play/javascript/external-apis/typescript-with-node.js.html"},{"path":"/ko/play/javascript/javascript-essentials/functions.ts.html"},{"path":"/ko/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/ko/play/javascript/modern-javascript/async-await.ts.html"},{"path":"/ko/play/javascript/modern-javascript/immutability.ts.html"},{"path":"/ko/play/javascript/modern-javascript/import-export.ts.html"},{"path":"/ko/play/typescript/language-extensions/enums.ts.html"},{"path":"/ko/play/typescript/language-extensions/types-vs-interfaces.ts.html"},{"path":"/ko/play/typescript/primitives/any.ts.html"},{"path":"/ko/play/typescript/primitives/literals.ts.html"},{"path":"/pt/play/3-7/fixits/big-number-literals.ts.html"},{"path":"/pt/play/3-7/fixits/const-to-let.ts.html"},{"path":"/pt/play/3-7/fixits/infer-from-usage-changes.ts.html"},{"path":"/pt/play/3-7/syntax-and-messaging/nullish-coalescing.ts.html"},{"path":"/pt/play/3-7/syntax-and-messaging/flattened-error-reporting.ts.html"},{"path":"/pt/play/3-7/syntax-and-messaging/optional-chaining.ts.html"},{"path":"/pt/play/3-7/types-and-code-flow/assertion-functions.ts.html"},{"path":"/pt/play/3-7/types-and-code-flow/recursive-type-references.ts.html"},{"path":"/pt/play/3-7/types-and-code-flow/uncalled-function-checks.ts.html"},{"path":"/pt/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts.html"},{"path":"/pt/play/3-8/jsdoc-improvements/accessibility-modifiers.js.html"},{"path":"/pt/play/3-8/syntax-and-messaging/export-modules-from.ts.html"},{"path":"/pt/play/3-8/syntax-and-messaging/private-class-fields.ts.html"},{"path":"/pt/play/4-0/new-checks/class-constructor-code-flow.ts.html"},{"path":"/pt/play/4-0/new-js-features/jsdoc-deprecated.ts.html"},{"path":"/pt/play/4-0/new-js-features/logical-operators-and-assignment.ts.html"},{"path":"/pt/play/4-0/new-js-features/nullish-coalescing.ts.html"},{"path":"/pt/play/4-0/new-ts-features/named-tuples.ts.html"},{"path":"/pt/play/4-0/new-ts-features/unknown-in-catch.ts.html"},{"path":"/pt/play/javascript/external-apis/typescript-with-deno.ts.html"},{"path":"/pt/play/javascript/external-apis/typescript-with-node.js.html"},{"path":"/pt/play/javascript/external-apis/typescript-with-web.js.html"},{"path":"/pt/play/javascript/external-apis/typescript-with-webgl.js.html"},{"path":"/pt/play/javascript/functions-with-javascript/function-chaining.ts.html"},{"path":"/pt/play/javascript/functions-with-javascript/generic-functions.ts.html"},{"path":"/pt/play/javascript/functions-with-javascript/typing-functions.ts.html"},{"path":"/pt/play/javascript/helping-with-javascript/quick-fixes.ts.html"},{"path":"/pt/play/javascript/javascript-essentials/code-flow.ts.html"},{"path":"/pt/play/javascript/javascript-essentials/functions.ts.html"},{"path":"/pt/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/pt/play/javascript/javascript-essentials/objects-and-arrays.ts.html"},{"path":"/pt/play/javascript/modern-javascript/async-await.ts.html"},{"path":"/pt/play/javascript/modern-javascript/immutability.ts.html"},{"path":"/pt/play/javascript/modern-javascript/import-export.ts.html"},{"path":"/pt/play/javascript/modern-javascript/jsdoc-support.js.html"},{"path":"/pt/play/javascript/working-with-classes/classes-101.ts.html"},{"path":"/pt/play/javascript/working-with-classes/generic-classes.ts.html"},{"path":"/pt/play/javascript/working-with-classes/mixins.ts.html"},{"path":"/pt/play/javascript/working-with-classes/this.ts.html"},{"path":"/pt/play/playground/config/javascript-playgrounds.js.html"},{"path":"/pt/play/playground/config/new-compiler-defaults.ts.html"},{"path":"/pt/play/playground/language/automatic-type-acquisition.ts.html"},{"path":"/pt/play/playground/language/fixits.ts.html"},{"path":"/pt/play/playground/tooling/mobile-support.ts.html"},{"path":"/pt/play/playground/tooling/sharable-urls.ts.html"},{"path":"/pt/play/playground/tooling/typescript-versions.ts.html"},{"path":"/pt/play/typescript/language-extensions/enums.ts.html"},{"path":"/pt/play/typescript/meta-types/conditional-types.ts.html"},{"path":"/pt/play/typescript/meta-types/discriminate-types.ts.html"},{"path":"/pt/play/typescript/language-extensions/nominal-typing.ts.html"},{"path":"/pt/play/typescript/meta-types/indexed-types.ts.html"},{"path":"/pt/play/typescript/meta-types/mapped-types.ts.html"},{"path":"/pt/play/typescript/primitives/any.ts.html"},{"path":"/pt/play/typescript/type-primitives/nullable-types.ts.html"},{"path":"/pt/play/typescript/type-primitives/tuples.ts.html"},{"path":"/pt/play/typescript/language/structural-typing.ts.html"},{"path":"/pt/play/typescript/language/type-guards.ts.html"},{"path":"/pt/play/typescript/language/type-widening-and-narrowing.ts.html"},{"path":"/pt/play/typescript/language-extensions/types-vs-interfaces.ts.html"},{"path":"/pt/play/typescript/primitives/literals.ts.html"},{"path":"/vo/play/javascript/javascript-essentials/code-flow.ts.html"},{"path":"/vo/play/javascript/javascript-essentials/functions.ts.html"},{"path":"/vo/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/vo/play/javascript/javascript-essentials/objects-and-arrays.ts.html"},{"path":"/zh/play/javascript/external-apis/typescript-with-deno.ts.html"},{"path":"/zh/play/javascript/external-apis/typescript-with-node.js.html"},{"path":"/zh/play/javascript/external-apis/typescript-with-web.js.html"},{"path":"/zh/play/javascript/external-apis/typescript-with-webgl.js.html"},{"path":"/zh/play/javascript/functions-with-javascript/function-chaining.ts.html"},{"path":"/zh/play/javascript/functions-with-javascript/generic-functions.ts.html"},{"path":"/zh/play/javascript/functions-with-javascript/typing-functions.ts.html"},{"path":"/zh/play/javascript/helping-with-javascript/errors.ts.html"},{"path":"/zh/play/javascript/helping-with-javascript/quick-fixes.ts.html"},{"path":"/zh/play/javascript/javascript-essentials/code-flow.ts.html"},{"path":"/zh/play/javascript/javascript-essentials/functions.ts.html"},{"path":"/zh/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/zh/play/javascript/javascript-essentials/objects-and-arrays.ts.html"},{"path":"/zh/play/javascript/modern-javascript/async-await.ts.html"},{"path":"/zh/play/javascript/modern-javascript/immutability.ts.html"},{"path":"/zh/play/javascript/modern-javascript/import-export.ts.html"},{"path":"/zh/play/javascript/modern-javascript/jsdoc-support.js.html"},{"path":"/zh/play/javascript/working-with-classes/classes-101.ts.html"},{"path":"/zh/play/javascript/working-with-classes/generic-classes.ts.html"},{"path":"/zh/play/javascript/working-with-classes/mixins.ts.html"},{"path":"/zh/play/javascript/working-with-classes/this.ts.html"},{"path":"/zh/play/playground/config/javascript-playgrounds.js.html"},{"path":"/zh/play/playground/config/new-compiler-defaults.ts.html"},{"path":"/zh/play/playground/language/automatic-type-acquisition.ts.html"},{"path":"/zh/play/playground/language/fixits.ts.html"},{"path":"/zh/play/playground/tooling/mobile-support.ts.html"},{"path":"/zh/play/playground/tooling/sharable-urls.ts.html"},{"path":"/zh/play/playground/tooling/typescript-versions.ts.html"},{"path":"/zh/play/typescript/language/soundness.ts.html"},{"path":"/zh/play/typescript/language/structural-typing.ts.html"},{"path":"/zh/play/typescript/language/type-guards.ts.html"},{"path":"/zh/play/typescript/language/type-widening-and-narrowing.ts.html"},{"path":"/zh/play/typescript/language-extensions/enums.ts.html"},{"path":"/zh/play/typescript/language-extensions/nominal-typing.ts.html"},{"path":"/zh/play/typescript/language-extensions/types-vs-interfaces.ts.html"},{"path":"/zh/play/typescript/meta-types/conditional-types.ts.html"},{"path":"/zh/play/typescript/meta-types/discriminate-types.ts.html"},{"path":"/zh/play/typescript/meta-types/indexed-types.ts.html"},{"path":"/zh/play/typescript/meta-types/mapped-types.ts.html"},{"path":"/zh/play/typescript/primitives/any.ts.html"},{"path":"/zh/play/typescript/primitives/literals.ts.html"},{"path":"/zh/play/typescript/primitives/union-and-intersection-types.ts.html"},{"path":"/zh/play/typescript/primitives/unknown-and-never.ts.html"},{"path":"/zh/play/typescript/type-primitives/built-in-utility-types.ts.html"},{"path":"/zh/play/typescript/type-primitives/nullable-types.ts.html"},{"path":"/zh/play/typescript/type-primitives/tuples.ts.html"},{"path":"/pt/play/typescript/type-primitives/built-in-utility-types.ts.html"},{"path":"/pt/play/typescript/primitives/unknown-and-never.ts.html"},{"path":"/pt/play/typescript/primitives/union-and-intersection-types.ts.html"},{"path":"/community"},{"path":"/es/community"},{"path":"/id/community"},{"path":"/ja/community"},{"path":"/pl/community"},{"path":"/pt/community"},{"path":"/vo/community"},{"path":"/zh/community"},{"path":"/download"},{"path":"/es/download"},{"path":"/id/download"},{"path":"/ja/download"},{"path":"/pl/download"},{"path":"/pt/download"},{"path":"/vo/download"},{"path":"/zh/download"},{"path":"/empty"},{"path":"/es/empty"},{"path":"/id/empty"},{"path":"/ja/empty"},{"path":"/pl/empty"},{"path":"/pt/empty"},{"path":"/vo/empty"},{"path":"/zh/empty"},{"path":"/"},{"path":"/es/"},{"path":"/id/"},{"path":"/ja/"},{"path":"/pl/"},{"path":"/pt/"},{"path":"/vo/"},{"path":"/zh/"},{"path":"/tools"},{"path":"/es/tools"},{"path":"/id/tools"},{"path":"/ja/tools"},{"path":"/pl/tools"},{"path":"/pt/tools"},{"path":"/vo/tools"},{"path":"/zh/tools"},{"path":"/why-create-typescript"},{"path":"/es/why-create-typescript"},{"path":"/id/why-create-typescript"},{"path":"/ja/why-create-typescript"},{"path":"/pl/why-create-typescript"},{"path":"/pt/why-create-typescript"},{"path":"/vo/why-create-typescript"},{"path":"/zh/why-create-typescript"},{"path":"/docs/bootstrap"},{"path":"/es/docs/bootstrap"},{"path":"/id/docs/bootstrap"},{"path":"/ja/docs/bootstrap"},{"path":"/pl/docs/bootstrap"},{"path":"/pt/docs/bootstrap"},{"path":"/vo/docs/bootstrap"},{"path":"/zh/docs/bootstrap"},{"path":"/docs/"},{"path":"/es/docs/"},{"path":"/id/docs/"},{"path":"/ja/docs/"},{"path":"/pl/docs/"},{"path":"/pt/docs/"},{"path":"/vo/docs/"},{"path":"/zh/docs/"},{"path":"/docs/handbook/"},{"path":"/es/docs/handbook/"},{"path":"/id/docs/handbook/"},{"path":"/ja/docs/handbook/"},{"path":"/pl/docs/handbook/"},{"path":"/pt/docs/handbook/"},{"path":"/vo/docs/handbook/"},{"path":"/zh/docs/handbook/"},{"path":"/dt/search"},{"path":"/es/dt/search"},{"path":"/id/dt/search"},{"path":"/ja/dt/search"},{"path":"/pl/dt/search"},{"path":"/pt/dt/search"},{"path":"/vo/dt/search"},{"path":"/zh/dt/search"},{"path":"/branding/"},{"path":"/upcoming/"},{"path":"/dev/bug-workbench/"},{"path":"/dev/playground-plugins/"},{"path":"/dev/sandbox/"},{"path":"/dev/twoslash/"},{"path":"/dev/typescript-vfs/"}]},"markdownRemark":{"id":"da10b94d-5e19-5118-b9bc-88396019a723","excerpt":"Each and every value in JavaScript has a set of behaviors you can observe from running different operations.\nThat sounds abstract, but as a quick example…","html":"<p>Each and every value in JavaScript has a set of behaviors you can observe from running different operations.\nThat sounds abstract, but as a quick example, consider some operations we might run on a variable named <code>foo</code>.</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #008000\">// accessing the property 'toLowerCase'</span>\n<span style=\"color: #008000\">// on 'foo' and then calling it</span>\n<span style=\"color: #1A1A1A\">foo</span><span style=\"color: #000000\">.toLowerCase();</span>\n\n<span style=\"color: #008000\">// calling 'foo'</span>\n<span style=\"color: #000000\">foo();</span></code></div></pre>\n<p>If we break this down, the first runnable line of code accesses a property called <code>toLowerCase</code> and then calls it.\nThe second one tries to call <code>foo</code> directly.</p>\n<p>But assuming we don’t know the value of <code>foo</code> - and that’s pretty common - we can’t reliably say what results we’ll get from trying to run any of this code.\nThe behavior of each operation depends entirely on what value we had in the first place.\nIs <code>foo</code> callable?\nDoes it have a property called <code>toLowerCase</code> on it?\nAnd if it does, is <code>toLowerCase</code> callable?\nIf all of these values are callable, what do they return?\nThe answers to these questions are usually things we keep in our heads when we write JavaScript, and we have to hope we got all the details right.</p>\n<p>Let’s say <code>foo</code> was defined in the following way.</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">foo</span><span style=\"color: #000000\"> = </span><span style=\"color: #A31515\">\"Hello World!\"</span><span style=\"color: #000000\">;</span></code></div></pre>\n<p>As you can probably guess, if we try to run <code>foo.toLowerCase()</code>, we’ll get the same string only in lower-case.</p>\n<p>What about that second line of code?\nIf you’re familiar with JavaScript, you’ll know this fails with an exception:</p>\n<pre class=\"shiki\"><div class='code-container'><code>TypeError: foo is not a function</code></div></pre>\n<p>It’d be great if we could avoid mistakes like this.\nWhen we run our code, the way that our JavaScript runtime chooses what to do is by figuring out the <em>type</em> of the value - what sorts of behaviors and capabilities it has.\nThat’s part of what that <code>TypeError</code> is alluding to - it’s saying that the string <code>\"Hello World\"</code> cannot be called as a function.</p>\n<p>For some values, such as the primitives <code>string</code> and <code>number</code>, we can identify their type at runtime using the <code>typeof</code> operator.\nBut for other things like functions, there’s no corresponding runtime mechanism to identify their types.\nFor example, consider this function:</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> fn(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">.flip();</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>We can <em>observe</em> by reading the code that this function will only work if given an object with a callable <code>flip</code> property, but JavaScript doesn’t surface this information in a way that we can check while the code is running.\nThe only way in pure JavaScript to tell what <code>fn</code> does with a particular value is to call it and see what happens.\nThis kind of behavior makes it hard to predict what code will do before it runs, which means it’s harder to know what your code is going to do while you’re writing it.</p>\n<p>Seen in this way, a <em>type</em> is the concept of describing which values are legal to pass to <code>fn</code> and which aren’t legal.\nJavaScript only truly provides <em>dynamic</em> typing - running the code to see what happens.</p>\n<p>The alternative is to use a <em>static</em> type system to make predictions about what code is legal <em>before</em> it runs.</p>\n<h2 id=\"static-type-checking\" style=\"position:relative;\"><a href=\"#static-type-checking\" aria-label=\"static type checking permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Static type-checking</h2>\n<p>Think back to that <code>TypeError</code> we got earlier from trying to call a <code>string</code> as a function.\n<em>Most people</em> don’t like to get any sorts of errors when running their code - those are considered bugs!\nAnd when we write new code, we try our best to avoid introducing new bugs.</p>\n<p>If we add just a bit of code, save our file, refresh our app, and immediately see the error, we might be able to isolate the problem quickly; but that’s not always the case.\nWe might not have tested the feature thoroughly enough, so we might never actually run into a potential error that would be thrown!\nOr if we were lucky enough to witness the error, we might have ended up doing large refactorings and adding a lot of different code that we’re forced to dig through.</p>\n<p>Ideally, we could have a tool that helps us find these bugs <em>before</em> our code runs.\nThat’s what a static type-checker like TypeScript does.\n<em>Static types systems</em> describe the shapes and behaviors of what our values will be when we run our programs.\nA type-checker like TypeScript uses that information and tells us when things might be going off the rails.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let foo: string'>foo</data-lsp> </span><span style=\"color: #000000\">= </span><span style=\"color: #A31515\">\"hello!\"</span><span style=\"color: #000000\">;</span>\n\n<span style=\"color: #000000\"><data-err><data-lsp lsp='let foo: string'>foo</data-lsp>();</data-err></span>\n<span class=\"error\"><span>This expression is not callable.\n  Type 'String' has no call signatures.</span><span class=\"code\">2349</span></span><span class=\"error-behind\">This expression is not callable.\n  Type 'String' has no call signatures.</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBOAUADaQAuoAZnHKALygBEAFpAQXAIR0DceeFcAFAEpOQA'>Try</a></div></pre>\n<p>Running that last sample with TypeScript will give us an error message before we run the code in the first place.</p>\n<h2 id=\"non-exception-failures\" style=\"position:relative;\"><a href=\"#non-exception-failures\" aria-label=\"non exception failures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Non-exception Failures</h2>\n<p>So far we’ve been discussing certain things like runtime errors - cases where the JavaScript runtime throws its hands up and tells us that it thinks something is nonsensical.\nThose cases come up because <a href=\"https://tc39.github.io/ecma262/\">the ECMAScript specification</a> has explicit instructions on how the language should behave when it runs into something unexpected.</p>\n<p>For example, the specification says that trying to call something that isn’t callable should throw an error.\nMaybe that sounds like “obvious behavior”, but you could imagine that accessing a property that doesn’t exist on an object should throw an error too.\nInstead, JavaScript gives us different behavior and returns the value <code>undefined</code>:</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">foo</span><span style=\"color: #000000\"> = {</span>\n<span style=\"color: #000000\">  name: </span><span style=\"color: #A31515\">\"Daniel\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  age: </span><span style=\"color: #09835A\">26</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">};</span>\n\n<span style=\"color: #1A1A1A\">foo</span><span style=\"color: #000000\">.location; </span><span style=\"color: #008000\">// returns undefined</span></code></div></pre>\n<p>Ultimately, a static type system has to make the call over what code should be flagged as an error in its system, even if it’s “valid” JavaScript that won’t immediately throw an error.\nIn TypeScript, the following code produces an error about <code>location</code> not being defined:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let foo: {&amp;#13;    name: string;&amp;#13;    age: number;&amp;#13;}'>foo</data-lsp> </span><span style=\"color: #000000\">= {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='(property) name: string'>name</data-lsp>: </span><span style=\"color: #A31515\">\"Daniel\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  <data-lsp lsp='(property) age: number'>age</data-lsp>: </span><span style=\"color: #09835A\">26</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">};</span>\n\n<span style=\"color: #1A1A1A\"><data-lsp lsp='let foo: {&amp;#13;    name: string;&amp;#13;    age: number;&amp;#13;}'>foo</data-lsp></span><span style=\"color: #000000\"><data-err>.<data-lsp lsp='any'>location</data-lsp>;</data-err></span>\n<span class=\"error\"><span>Property 'location' does not exist on type '{ name: string; age: number; }'.</span><span class=\"code\">2339</span></span><span class=\"error-behind\">Property 'location' does not exist on type '{ name: string; age: number; }'.</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYME4BQAbSAF1ADM45QBeUAb11FADsBDAW0lQCIARFpgJaR8XADQNQLAOad0ANnEBfANy5c5OADp8cAMYsiAuE2VA'>Try</a></div></pre>\n<p>While sometimes that implies a trade-off in what you can express, the intent is to catch legitimate bugs in our programs.\nAnd TypeScript catches <em>a lot</em> of legitimate bugs.</p>\n<p>For example: typos,</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let someString: string'>someString</data-lsp> </span><span style=\"color: #000000\">= </span><span style=\"color: #A31515\">\"Hello World!\"</span><span style=\"color: #000000\">;</span>\n\n<span style=\"color: #008000\">// How quickly can you spot the typos?</span>\n<span style=\"color: #1A1A1A\"><data-lsp lsp='let someString: string'>someString</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='any'>toLocaleLowercase</data-lsp>();</span>\n<span style=\"color: #1A1A1A\"><data-lsp lsp='let someString: string'>someString</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='any'>toLocalLowerCase</data-lsp>();</span>\n\n<span style=\"color: #008000\">// We probably meant to write this...</span>\n<span style=\"color: #1A1A1A\"><data-lsp lsp='let someString: string'>someString</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) String.toLocaleLowerCase(locales?: string | string[] | undefined): string'>toLocaleLowerCase</data-lsp>();</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFABsCmAXULoBbLAZR3gEtIBzUAXlACIAJLDDaUAdWQwBMAhIwDcaNCFDNoAd1ABHAK4UAxgGsMAT1DKAhpFAboC-AAdoeHAAssoHBrMoA-GgLEylGgDoc0ADLRdbH9pLHhdFCwACgBKUVdScipqbz8AnQxg0IBhHQiY0XEwLhsTJAAjHTLNUGI9C05pShwbKwoUTw6XIgSPZJ9-QKxM+By82KA'>Try</a></div></pre>\n<p>uncalled functions,</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function flipCoin(): boolean'>flipCoin</data-lsp>() {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> <data-lsp lsp='var Math: Math'>Math</data-lsp>.<data-lsp lsp='(method) Math.random(): number'>random</data-lsp> &lt; </span><span style=\"color: #09835A\">0.5</span><span style=\"color: #000000\">;</span>\n<span class=\"error\"><span>Operator '&lt;' cannot be applied to types '() =&gt; number' and 'number'.</span><span class=\"code\">2365</span></span><span class=\"error-behind\">Operator '&lt;' cannot be applied to types '() =&gt; number' and 'number'.</span><span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEDsHsFVIK4GcCmATAMtAxgQwDZIBQIEKATudOUgFygBMAzAGwCsRAZgpNgC4BLaJFCd8AgA4BhaAMgAKAJSgA3kVChyKPgnIiAsrj4ALAHTlckNNAC2oADygADKbYBuIgF8gA'>Try</a></div></pre>\n<p>or basic logic errors.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const value: &amp;quot;a&amp;quot; | &amp;quot;b&amp;quot;'>value</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='var Math: Math'>Math</data-lsp>.<data-lsp lsp='(method) Math.random(): number'>random</data-lsp>() &lt; </span><span style=\"color: #09835A\">0.5</span><span style=\"color: #000000\"> ? </span><span style=\"color: #A31515\">\"a\"</span><span style=\"color: #000000\"> : </span><span style=\"color: #A31515\">\"b\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const value: &amp;quot;a&amp;quot; | &amp;quot;b&amp;quot;'>value</data-lsp></span><span style=\"color: #000000\"> !== </span><span style=\"color: #A31515\">\"a\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">} </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const value: &amp;quot;a&amp;quot;'>value</data-lsp></span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"b\"</span><span style=\"color: #000000\">) {</span>\n<span class=\"error\"><span>This condition will always return 'false' since the types '\"a\"' and '\"b\"' have no overlap.</span><span class=\"code\">2367</span></span><span class=\"error-behind\">This condition will always return 'false' since the types '\"a\"' and '\"b\"' have no overlap.</span><span style=\"color: #000000\">  </span><span style=\"color: #008000\">// Oops, unreachable</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYBsB2AUAMZwB2iALqAG4CGANgK6SgC8oAstWQBYB001xACZwAtgAoAlKAA8oAAw8ArKAD8oAETV1oVOoBG6gNx4AlgDNQYmgyYBCZq03qpAbzyhQIUDx94AvqCQtIhM5pbWjCwOGgau7p5gAPJwAA6IADSg9MTQkNQEXNR6tJD+QA'>Try</a></div></pre>\n<h2 id=\"types-for-tooling\" style=\"position:relative;\"><a href=\"#types-for-tooling\" aria-label=\"types for tooling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Types for Tooling</h2>\n<p>TypeScript can catch bugs when we make mistakes in our code.\nThat’s great, but TypeScript can <em>also</em> prevent us from making those mistakes in the first place.</p>\n<p>The type-checker has information to check things like whether we’re accessing the right properties on variables and other properties.\nOnce it has that information, it can also start <em>suggesting</em> which properties you might want to use.</p>\n<p>That means TypeScript can be leveraged for editing code too, and the core type-checker can provide error messages and code completion as you type in the editor.\nThat’s part of what people often refer to when they talk about tooling in TypeScript.</p>\n<!-- prettier-ignore -->\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(alias) function express(): core.Express&amp;#13;(alias) namespace express&amp;#13;import express'>express</data-lsp></span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"express\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const app: Express'>app</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='(alias) express(): Express&amp;#13;import express'>express</data-lsp>();</span>\n\n<span style=\"color: #1A1A1A\"><data-lsp lsp='const app: Express'>app</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(property) Application.get: &amp;lt;ParamsDictionary, any, any, QueryString.ParsedQs>(path: PathParams, ...handlers: RequestHandler&amp;lt;ParamsDictionary, any, any, QueryString.ParsedQs>[]) => Express (+3 overloads)'>get</data-lsp>(</span><span style=\"color: #A31515\">\"/\"</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) req: Request&amp;lt;ParamsDictionary, any, any, QueryString.ParsedQs>'>req</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) res: Response&amp;lt;any>'>res</data-lsp></span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) res: Response&amp;lt;any>'>res</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='any'>sen</data-lsp></span>\n         <span class='inline-completions'><ul class='dropdown'><li class=''><span><span class='result-found'>sen</span>d<span></li><li class=''><span><span class='result-found'>sen</span>dDate<span></li><li class='deprecated'><span><span class='result-found'>sen</span>dfile<span></li><li class=''><span><span class='result-found'>sen</span>dFile<span></li><li class=''><span><span class='result-found'>sen</span>dStatus<span></li></ul></span>\n<span style=\"color: #000000\">});</span>\n\n<span style=\"color: #1A1A1A\"><data-lsp lsp='const app: Express'>app</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Application.listen(port: number, callback?: ((...args: any[]) => void) | undefined): Server (+5 overloads)'>listen</data-lsp>(</span><span style=\"color: #09835A\">3000</span><span style=\"color: #000000\">);</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAggUxQWWgCYCuANlgJKQAuWSADmgJYC2dyVoWAHnfDiqABmSZqABE3XvzEBuNAGNokFBwCGdOqAC8nHnxQoAFAEo5adXQB0AcyxVDY4GIA0QopHlVGS0Ib4BHV31jUABvNFBQfUsULEgMMEik0AA9AB80AF9TNHMNSxJGFTjDAGYABkrTIA'>Try</a></div></pre>\n<p>TypeScript takes tooling seriously, and that goes beyond completions and errors as you type.\nAn editor that supports TypeScript can deliver “quick fixes” to automatically fix errors, refactorings to easily re-organize code, and useful navigation features for jumping to definitions of a variable, or finding all references to a given variable.\nAll of this is built on top of the type-checker and fully cross-platform, so it’s likely that <a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support\">your favorite editor has TypeScript support available</a>.</p>\n<h2 id=\"tsc-the-typescript-compiler\" style=\"position:relative;\"><a href=\"#tsc-the-typescript-compiler\" aria-label=\"tsc the typescript compiler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>tsc</code>, the TypeScript compiler</h2>\n<p>We’ve been talking about type-checking, but we haven’t yet used our type-<em>checker</em>.\nLet’s get acquainted with our new friend <code>tsc</code>, the TypeScript compiler.\nFirst we’ll need to grab it via npm.</p>\n<pre class=\"shiki\"><div class=\"language-id\">sh</div><div class='code-container'><code><span style=\"color: #000000\">npm install -g typescript</span></code></div></pre>\n<blockquote>\n<p>This installs the TypeScript Compiler <code>tsc</code> globally.\nYou can use <code>npx</code> or similar tools if you’d prefer to run <code>tsc</code> from a local <code>node_modules</code> package instead.</p>\n</blockquote>\n<p>Now let’s move to an empty folder and try writing our first TypeScript program: <code>hello.ts</code>:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #008000\">// Greets the world.</span>\n<span style=\"color: #000000\"><data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #A31515\">\"Hello world!\"</span><span style=\"color: #000000\">);</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEHECcFNoFwM6jgC2qA7ge0gGwCYB0AUAMZYB2CWu0huWA5gBQBEAEtLg5jgQISsAlAG4gA'>Try</a></div></pre>\n<p>Notice there are no frills here; this “hello world” program looks identical to what you’d write for a “hello world” program in JavaScript.\nAnd now let’s type-check it by running the command <code>tsc</code> which was installed for us by the <code>typescript</code> package.</p>\n<pre class=\"shiki\"><div class=\"language-id\">sh</div><div class='code-container'><code><span style=\"color: #000000\">tsc hello.ts</span></code></div></pre>\n<p>Tada!</p>\n<p>Wait, “tada” <em>what</em> exactly?\nWe ran <code>tsc</code> and nothing happened!\nWell, there were no type errors, so we didn’t get any output in our console since there was nothing to report.</p>\n<p>But check again - we got some <em>file</em> output instead.\nIf we look in our current directory, we’ll see a <code>hello.js</code> file next to <code>hello.ts</code>.\nThat’s the output from our <code>hello.ts</code> file after <code>tsc</code> <em>compiles</em> or <em>transforms</em> it into a plain JavaScript file.\nAnd if we check the contents, we’ll see what TypeScript spits out after it processes a <code>.ts</code> file:</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #008000\">// Greets the world.</span>\n<span style=\"color: #000000\">console.log(</span><span style=\"color: #A31515\">\"Hello world!\"</span><span style=\"color: #000000\">);</span></code></div></pre>\n<p>In this case, there was very little for TypeScript to transform, so it looks identical to what we wrote.\nThe compiler tries to emit clean readable code that looks like something a person would write.\nWhile that’s not always so easy, TypeScript indents consistently, is mindful of when our code spans across different lines of code, and tries to keep comments around.</p>\n<p>What about if we <em>did</em> introduce a type-checking error?\nLet’s rewrite <code>hello.ts</code>:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #008000\">// This is an industrial-grade general-purpose greeter function:</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function greet(person: any, date: any): void'>greet</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) person: any'>person</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) date: any'>date</data-lsp></span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #A31515\">`Hello </span><span style=\"color: #0000FF\">${</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) person: any'>person</data-lsp></span><span style=\"color: #0000FF\">}</span><span style=\"color: #A31515\">, today is </span><span style=\"color: #0000FF\">${</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) date: any'>date</data-lsp></span><span style=\"color: #0000FF\">}</span><span style=\"color: #A31515\">!`</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #000000\"><data-lsp lsp='function greet(person: any, date: any): void'>greet</data-lsp>(</span><span style=\"color: #A31515\">\"Brendan\"</span><span style=\"color: #000000\">);</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAlAFQBYEsVQDQBDSIyAEwFcUAXePEgGwFoBzeEygU1HZ6QeXNgAdq8UdBR9OPHnWGgAZtUgBjOnmiQAXGlUatO-vHl0AFKOEodAGlCUSigJSgA3mlCh1O28x4AOmZodgsAAwAJHmYQ0AASd2tUHQBfBzpoJwBPIkJEp0VUgEJwlwBuNFS0NDkFCwAiACEzKjIGiqA'>Try</a></div></pre>\n<p>If we run <code>tsc hello.ts</code> again, notice that we get an error on the command line!</p>\n<pre class=\"shiki\"><div class='code-container'><code>Expected 2 arguments, but got 1.</code></div></pre>\n<p>TypeScript is telling us we forgot to pass an argument to the <code>greet</code> function, and rightfully so.\nSo far we’ve only written standard JavaScript, and yet type-checking was still able to find problems with our code.\nThanks TypeScript!</p>\n<h3 id=\"emitting-with-errors\" style=\"position:relative;\"><a href=\"#emitting-with-errors\" aria-label=\"emitting with errors permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Emitting with Errors</h3>\n<p>One thing you might not have noticed from the last example was that our <code>hello.js</code> file changed again.\nIf we open that file up then we’ll see that the contents still basically look the same as our input file.\nThat might be a bit surprising given the fact that <code>tsc</code> reported an error about our code, but this based on one of TypeScript’s core values: much of the time, <em>you</em> will know better than TypeScript.</p>\n<p>To reiterate from earlier, type-checking code limits the sorts of programs you can run, and so there’s a tradeoff on what sorts of things a type-checker finds acceptable.\nMost of the time that’s okay, but there are scenarios where those checks get in the way.\nFor example, imagine yourself migrating JavaScript code over to TypeScript and introducing type-checking errors.\nEventually you’ll get around to cleaning things up for the type-checker, but that original JavaScript code was already working!\nWhy should converting it over to TypeScript stop you from running it?</p>\n<p>So TypeScript doesn’t get in your way.\nOf course, over time, you may want to be a bit more defensive against mistakes, and make TypeScript act a bit more strictly.\nIn that case, you can use the <code>--noEmitOnError</code> compiler option.\nTry changing your <code>hello.ts</code> file and running <code>tsc</code> with that flag:</p>\n<pre class=\"shiki\"><div class=\"language-id\">sh</div><div class='code-container'><code><span style=\"color: #000000\">tsc --noEmitOnError hello.ts</span></code></div></pre>\n<p>You’ll notice that <code>hello.js</code> never gets updated.</p>\n<h2 id=\"explicit-types\" style=\"position:relative;\"><a href=\"#explicit-types\" aria-label=\"explicit types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Explicit Types</h2>\n<p>Up until now, we haven’t told TypeScript what <code>person</code> or <code>date</code> are.\nLet’s change up our code a little bit so that we tell TypeScript that <code>person</code> is a <code>string</code>, and that <code>date</code> should be a <code>Date</code> object.\nWe’ll also use the <code>toDateString()</code> method on <code>date</code>.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function greet(person: string, date: Date): void'>greet</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) person: string'>person</data-lsp></span><span style=\"color: #000000\">: string, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) date: Date'>date</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='interface Date'>Date</data-lsp>) {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #A31515\">`Hello </span><span style=\"color: #0000FF\">${</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) person: string'>person</data-lsp></span><span style=\"color: #0000FF\">}</span><span style=\"color: #A31515\">, today is </span><span style=\"color: #0000FF\">${</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) date: Date'>date</data-lsp></span><span style=\"color: #A31515\">.<data-lsp lsp='(method) Date.toDateString(): string'>toDateString</data-lsp>()</span><span style=\"color: #0000FF\">}</span><span style=\"color: #A31515\">!`</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6gA'>Try</a></div></pre>\n<p>What we did was add <em>type annotations</em> on <code>person</code> and <code>date</code> to describe what types of values <code>greet</code> can be called with.\nYou can read that signature as ”<code>greet</code> takes a <code>person</code> of type <code>string</code>, and a <code>date</code> of type <code>Date</code>“.</p>\n<p>With this, TypeScript can tell us about other cases where we might have been called incorrectly.\nFor example…</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function greet(person: string, date: Date): void'>greet</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) person: string'>person</data-lsp></span><span style=\"color: #000000\">: string, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) date: Date'>date</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='interface Date'>Date</data-lsp>) {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #A31515\">`Hello </span><span style=\"color: #0000FF\">${</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) person: string'>person</data-lsp></span><span style=\"color: #0000FF\">}</span><span style=\"color: #A31515\">, today is </span><span style=\"color: #0000FF\">${</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) date: Date'>date</data-lsp></span><span style=\"color: #A31515\">.<data-lsp lsp='(method) Date.toDateString(): string'>toDateString</data-lsp>()</span><span style=\"color: #0000FF\">}</span><span style=\"color: #A31515\">!`</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #000000\"><data-lsp lsp='function greet(person: string, date: Date): void'>greet</data-lsp>(</span><span style=\"color: #A31515\">\"Maddison\"</span><span style=\"color: #000000\"><data-err>, <data-lsp lsp='var Date: DateConstructor&amp;#13;() => string'>Date</data-lsp>());</data-err></span>\n<span class=\"error\"><span>Argument of type 'string' is not assignable to parameter of type 'Date'.</span><span class=\"code\">2345</span></span><span class=\"error-behind\">Argument of type 'string' is not assignable to parameter of type 'Date'.</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUAGYCuAdgMYAuAlnCaAObSSQUAUADjIraohdFRL0ANKAAmAQwqRUAESmQAlKADeeUKDK1uAG0gA6HXHqsABgAlIOo6AAkKzkloBfURTiSAnqCqI7KyWl9d3lpAGV+QRNFZwBCU0UAbjxnPDxGZjYAIgBZCTExX1os0VDIVkUkoA'>Try</a></div></pre>\n<p>Huh?\nTypeScript reported an error on our second argument, but why?</p>\n<p>Perhaps surprisingly, calling <code>Date()</code> in JavaScript returns a <code>string</code>.\nOn the other hand, constructing a <code>Date</code> with <code>new Date()</code> actually gives us what we were expecting.</p>\n<p>Anyway, we can quickly fix up the error:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function greet(person: string, date: Date): void'>greet</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) person: string'>person</data-lsp></span><span style=\"color: #000000\">: string, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) date: Date'>date</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='interface Date'>Date</data-lsp>) {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #A31515\">`Hello </span><span style=\"color: #0000FF\">${</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) person: string'>person</data-lsp></span><span style=\"color: #0000FF\">}</span><span style=\"color: #A31515\">, today is </span><span style=\"color: #0000FF\">${</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) date: Date'>date</data-lsp></span><span style=\"color: #A31515\">.<data-lsp lsp='(method) Date.toDateString(): string'>toDateString</data-lsp>()</span><span style=\"color: #0000FF\">}</span><span style=\"color: #A31515\">!`</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #000000\"><data-lsp lsp='function greet(person: string, date: Date): void'>greet</data-lsp>(</span><span style=\"color: #A31515\">\"Maddison\"</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> <data-lsp lsp='var Date: DateConstructor&amp;#13;new () => Date (+4 overloads)'>Date</data-lsp>());</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQAd2oDOCAXIoVKjGMgDSIAmAhlOmQCIvoCUiA3gChEiCAmIAbdADpxcZNgAGACXTjZiACR98RBAF96UOMwCeiGIU19mrKUc6sAypWrzuegIQLuAbgF6BATRMHAAiAFkmBgYLBFD6MHQAd0QHdGxuXwEAemzhfILC4QA9UrLyoA'>Try</a></div></pre>\n<p>Keep in mind, we don’t always have to write explicit type annotations.\nIn many cases, TypeScript can even just <em>infer</em> (or “figure out”) the types for us even if we omit them.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let foo: string'>foo</data-lsp> </span><span style=\"color: #000000\">= </span><span style=\"color: #A31515\">\"hello there!\"</span><span style=\"color: #000000\">;</span>\n<span class='query'>//  ^ = let foo: string</span></code><a href='https://www.typescriptlang.org/play/#code/DYUwLgBAZg9jEF4ICIAWJjHmdAnEAhMgNwBQA9ORBAHoD8QA'>Try</a></div></pre>\n<p>Even though we didn’t tell TypeScript that <code>foo</code> had the type <code>string</code> it was able to figure that out.\nThat’s a feature, and it’s best not to add annotations when the type system would end up inferring the same type anyway.</p>\n<h2 id=\"erased-types\" style=\"position:relative;\"><a href=\"#erased-types\" aria-label=\"erased types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Erased Types</h2>\n<p>Let’s take a look at what happens when we compile with <code>tsc</code>:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #A31515\">\"use strict\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> greet(</span><span style=\"color: #1A1A1A\">person</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">date</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    console.log(</span><span style=\"color: #A31515\">\"Hello \"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">person</span><span style=\"color: #000000\"> + </span><span style=\"color: #A31515\">\", today is \"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">date</span><span style=\"color: #000000\">.toDateString() + </span><span style=\"color: #A31515\">\"!\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #000000\">greet(</span><span style=\"color: #A31515\">\"Maddison\"</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> Date());</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEGcAsHsHcCiBbAlgFwFAgughgE4DmApugFygmQCsmAZgK4B2AxuqrM6EQSWQAoADiQKQulSOgKpmRADSgAJnnQlKAEVUkAlKADemUKFZdxAGxIA6c7CICABgAkS526AAk+kWK4BfRXRYFQBPUFRIT30VNSsgrTUAZWlZex0-AEIHHQBuTD9MTF5+dAEAIgBZPCUlCK4yxWYSeFAEkgEdXKA'>Try</a></div></pre>\n<p>Notice two things here:</p>\n<ol>\n<li>Our <code>person</code> and <code>date</code> parameters no longer have type annotations.</li>\n<li>Our “template string” - that string that used backticks (the <code>`</code> character) - was converted to plain strings with concatenations (<code>+</code>).</li>\n</ol>\n<p>More on that second point later, but let’s now focus on that first point.\nType annotations aren’t part of JavaScript (or ECMAScript to be pedantic), so there really aren’t any browsers or other runtimes that can just run TypeScript unmodified.\nThat’s why TypeScript needs a compiler in the first place - it needs some way to strip out or transform any TypeScript-specific code so that you can run it.\nMost TypeScript-specific code gets erased away, and likewise, here our type annotations were completely erased.</p>\n<blockquote>\n<p><strong>Remember</strong>: Type annotations never change the runtime behavior of your program.</p>\n</blockquote>\n<h2 id=\"downleveling\" style=\"position:relative;\"><a href=\"#downleveling\" aria-label=\"downleveling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Downleveling</h2>\n<p>One other difference from the above was that our template string was rewritten from</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #A31515\">`Hello ${</span><span style=\"color: #1A1A1A\">person</span><span style=\"color: #A31515\">}, today is ${</span><span style=\"color: #1A1A1A\">date</span><span style=\"color: #A31515\">.toDateString()}!`</span><span style=\"color: #000000\">;</span></code></div></pre>\n<p>to</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #A31515\">\"Hello \"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">person</span><span style=\"color: #000000\"> + </span><span style=\"color: #A31515\">\", today is \"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">date</span><span style=\"color: #000000\">.toDateString() + </span><span style=\"color: #A31515\">\"!\"</span><span style=\"color: #000000\">;</span></code></div></pre>\n<p>Why did this happen?</p>\n<p>Template strings are a feature from a version of ECMAScript called ECMAScript 2015 (a.k.a. ECMAScript 6, ES2015, ES6, etc. - <em>don’t ask</em>).\nTypeScript has the ability to rewrite code from newer versions of ECMAScript to older ones such as ECMAScript 3 or ECMAScript 5 (a.k.a. ES3 and ES5).\nThis process of moving from a newer or “higher” version of ECMAScript down to an older or “lower” one is sometimes called <em>downleveling</em>.</p>\n<p>By default TypeScript targets ES3, an extremely old version of ECMAScript.\nWe could have chosen something a little bit more recent by using the <code>--target</code> flag.\nRunning with <code>--target es2015</code> changes TypeScript to target ECMAScript 2015, meaning code should be able to run wherever ECMAScript 2015 is supported.\nSo running <code>tsc --target es2015 input.ts</code> gives us the following output:</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> greet(</span><span style=\"color: #1A1A1A\">person</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">date</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  console.log(</span><span style=\"color: #A31515\">`Hello ${</span><span style=\"color: #1A1A1A\">person</span><span style=\"color: #A31515\">}, today is ${</span><span style=\"color: #1A1A1A\">date</span><span style=\"color: #A31515\">.toDateString()}!`</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #000000\">greet(</span><span style=\"color: #A31515\">\"Maddison\"</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> Date());</span></code></div></pre>\n<blockquote>\n<p>While the default target is ES3, the great majority of current browsers support ES2015.\nMost developers can therefore safely specify ES2015 or above as a target, unless compatibility with certain ancient browsers is important.</p>\n</blockquote>\n<h2 id=\"strictness\" style=\"position:relative;\"><a href=\"#strictness\" aria-label=\"strictness permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Strictness</h2>\n<p>Different users come to TypeScript looking for different things in a type-checker.\nSome people are looking for a more loose opt-in experience which can help validate only some parts of their program, and still have decent tooling.\nThis is the default experience with TypeScript, where types are optional, inference takes the most lenient types, and there’s no checking for potentially <code>null</code>/<code>undefined</code> values.\nMuch like how <code>tsc</code> emits in the face of errors, these defaults are put in place to stay out of your way.\nIf you’re migrating existing JavaScript, that might be a desirable first step.</p>\n<p>In contrast, a lot of users prefer to have TypeScript validate as much as it can straight away, and that’s why the language provides strictness settings as well.\nThese strictness settings turn static type-checking from a switch (either your code is checked or not) into something closer to a dial.\nThe farther you turn this dial up, the more TypeScript will check for you.\nThis can require a little extra work, but generally speaking it pays for itself in the long run, and enables more thorough checks and more accurate tooling.\nWhen possible, a new codebase should always turn these strictness checks on.</p>\n<p>TypeScript has several type-checking strictness flags that can be turned on or off, and all of our examples will be written with all of them enabled unless otherwise stated.\nThe <code>--strict</code> flag toggles them all on simultaneously, but we can opt out of them individually.\nThe two biggest ones you should know about are <code>noImplicitAny</code> and <code>strictNullChecks</code>.</p>\n<h3 id=\"noimplicitany\" style=\"position:relative;\"><a href=\"#noimplicitany\" aria-label=\"noimplicitany permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>noImplicitAny</code></h3>\n<p>Recall that in some places, TypeScript doesn’t try to infer any types for us and instead falls back to the most lenient type: <code>any</code>.\nThis isn’t the worst thing that can happen - after all, falling back to <code>any</code> is just the plain JavaScript experience anyway.</p>\n<p>However, using <code>any</code> often defeats the purpose of using TypeScript in the first place.\nThe more typed your program is, the more validation and tooling you’ll get, meaning you’ll run into fewer bugs as you code.\nTurning on the <code>noImplicitAny</code> flag will issue an error on any variables whose type is implicitly inferred as <code>any</code>.</p>\n<h3 id=\"strictnullchecks\" style=\"position:relative;\"><a href=\"#strictnullchecks\" aria-label=\"strictnullchecks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>strictNullChecks</code></h3>\n<p>By default, values like <code>null</code> and <code>undefined</code> are assignable to any other type.\nThis can make writing some code easier, but forgetting to handle <code>null</code> and <code>undefined</code> is the cause of countless bugs in the world - some consider it a <a href=\"https://www.youtube.com/watch?v=ybrQvs4x0Ps\">billion dollar mistake</a>!\nThe <code>strictNullChecks</code> flag makes handling <code>null</code> and <code>undefined</code> more explicit, and <em>spares</em> us from worrying about whether we <em>forgot</em> to handle <code>null</code> and <code>undefined</code>.</p>","headings":[{"value":"Static type-checking","depth":2},{"value":"Non-exception Failures","depth":2},{"value":"Types for Tooling","depth":2},{"value":"tsc, the TypeScript compiler","depth":2},{"value":"Emitting with Errors","depth":3},{"value":"Explicit Types","depth":2},{"value":"Erased Types","depth":2},{"value":"Downleveling","depth":2},{"value":"Strictness","depth":2},{"value":"noImplicitAny","depth":3},{"value":"strictNullChecks","depth":3}],"frontmatter":{"permalink":"/docs/handbook/2/basic-types.html","title":"The Basics","disable_toc":null,"oneline":"Step one in learning TypeScript: The basic types.","beta":true}},"prev":null,"next":{"childMarkdownRemark":{"frontmatter":{"title":"Everyday Types","oneline":"Step one in learning TypeScript: The basics types.","permalink":"/docs/handbook/2/everyday-types.html"}}}},"pageContext":{"id":"8the-basics","slug":"/docs/handbook/2/basic-types.html","repoPath":"/packages/documentation/copy/en/handbook-v2/Basics.md","nextID":"d5647caf-d7a8-5538-921a-773271846c49","lang":"en","modifiedTime":"2020-10-29T11:50:57.702Z"}},"staticQueryHashes":[]}