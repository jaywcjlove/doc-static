{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/2/functions.html","result":{"data":{"allSitePage":{"nodes":[{"path":"/dev-404-page/"},{"path":"/docs/handbook/nightly-builds.html"},{"path":"/pt/docs/handbook/nightly-builds.html"},{"path":"/docs/handbook/declaration-files/consumption.html"},{"path":"/docs/handbook/declaration-files/by-example.html"},{"path":"/docs/handbook/declaration-files/deep-dive.html"},{"path":"/docs/handbook/declaration-files/do-s-and-don-ts.html"},{"path":"/docs/handbook/declaration-files/introduction.html"},{"path":"/docs/handbook/declaration-files/publishing.html"},{"path":"/docs/handbook/declaration-files/library-structures.html"},{"path":"/docs/handbook/declaration-files/templates.html"},{"path":"/docs/handbook/typescript-in-5-minutes.html"},{"path":"/docs/handbook/typescript-in-5-minutes-func.html"},{"path":"/docs/handbook/typescript-in-5-minutes-oop.html"},{"path":"/docs/handbook/typescript-from-scratch.html"},{"path":"/docs/handbook/basic-types.html"},{"path":"/docs/handbook/enums.html"},{"path":"/docs/handbook/classes.html"},{"path":"/docs/handbook/functions.html"},{"path":"/docs/handbook/generics.html"},{"path":"/docs/handbook/literal-types.html"},{"path":"/docs/handbook/intro.html"},{"path":"/docs/handbook/interfaces.html"},{"path":"/docs/handbook/unions-and-intersections.html"},{"path":"/docs/handbook/2/basic-types.html"},{"path":"/docs/handbook/2/classes.html"},{"path":"/docs/handbook/2/everyday-types.html"},{"path":"/docs/handbook/2/modules.html"},{"path":"/docs/handbook/2/narrowing.html"},{"path":"/docs/handbook/2/functions.html"},{"path":"/docs/handbook/2/objects.html"},{"path":"/docs/handbook/2/type-declarations.html"},{"path":"/docs/handbook/declaration-files/dts-from-js.html"},{"path":"/docs/handbook/2/understanding-errors.html"},{"path":"/docs/handbook/intro-to-js-ts.html"},{"path":"/docs/handbook/type-checking-javascript-files.html"},{"path":"/docs/handbook/jsdoc-supported-types.html"},{"path":"/docs/handbook/compiler-options-in-msbuild.html"},{"path":"/docs/handbook/configuring-watch.html"},{"path":"/docs/handbook/integrating-with-build-tools.html"},{"path":"/docs/handbook/compiler-options.html"},{"path":"/docs/handbook/tsconfig-json.html"},{"path":"/docs/handbook/project-references.html"},{"path":"/docs/handbook/declaration-merging.html"},{"path":"/docs/handbook/decorators.html"},{"path":"/docs/handbook/advanced-types.html"},{"path":"/docs/handbook/iterators-and-generators.html"},{"path":"/docs/handbook/mixins.html"},{"path":"/docs/handbook/jsx.html"},{"path":"/docs/handbook/module-resolution.html"},{"path":"/docs/handbook/modules.html"},{"path":"/docs/handbook/namespaces-and-modules.html"},{"path":"/docs/handbook/symbols.html"},{"path":"/docs/handbook/namespaces.html"},{"path":"/docs/handbook/triple-slash-directives.html"},{"path":"/docs/handbook/type-inference.html"},{"path":"/docs/handbook/type-compatibility.html"},{"path":"/docs/handbook/utility-types.html"},{"path":"/docs/handbook/variable-declarations.html"},{"path":"/docs/handbook/release-notes/typescript-1-1.html"},{"path":"/docs/handbook/release-notes/typescript-1-3.html"},{"path":"/docs/handbook/release-notes/typescript-1-4.html"},{"path":"/docs/handbook/release-notes/typescript-1-5.html"},{"path":"/docs/handbook/release-notes/typescript-1-6.html"},{"path":"/docs/handbook/release-notes/typescript-1-7.html"},{"path":"/docs/handbook/release-notes/typescript-1-8.html"},{"path":"/docs/handbook/release-notes/typescript-2-1.html"},{"path":"/docs/handbook/release-notes/typescript-2-0.html"},{"path":"/docs/handbook/release-notes/typescript-2-2.html"},{"path":"/docs/handbook/release-notes/typescript-2-3.html"},{"path":"/docs/handbook/release-notes/typescript-2-5.html"},{"path":"/docs/handbook/release-notes/typescript-2-4.html"},{"path":"/docs/handbook/release-notes/typescript-2-6.html"},{"path":"/docs/handbook/release-notes/typescript-2-7.html"},{"path":"/docs/handbook/release-notes/typescript-2-9.html"},{"path":"/docs/handbook/release-notes/typescript-2-8.html"},{"path":"/docs/handbook/release-notes/typescript-3-1.html"},{"path":"/docs/handbook/release-notes/typescript-3-0.html"},{"path":"/docs/handbook/release-notes/typescript-3-3.html"},{"path":"/docs/handbook/release-notes/typescript-3-2.html"},{"path":"/docs/handbook/release-notes/typescript-3-5.html"},{"path":"/docs/handbook/release-notes/typescript-3-4.html"},{"path":"/docs/handbook/release-notes/typescript-3-6.html"},{"path":"/docs/handbook/release-notes/typescript-3-8.html"},{"path":"/docs/handbook/release-notes/typescript-3-7.html"},{"path":"/docs/handbook/release-notes/typescript-3-9.html"},{"path":"/docs/handbook/asp-net-core.html"},{"path":"/docs/handbook/release-notes/typescript-4-0.html"},{"path":"/docs/handbook/angular.html"},{"path":"/docs/handbook/babel-with-typescript.html"},{"path":"/docs/handbook/dom-manipulation.html"},{"path":"/docs/handbook/gulp.html"},{"path":"/docs/handbook/react.html"},{"path":"/docs/handbook/migrating-from-javascript.html"},{"path":"/docs/handbook/typescript-tooling-in-5-minutes.html"},{"path":"/ko/docs/handbook/babel-with-typescript.html"},{"path":"/ko/docs/handbook/react.html"},{"path":"/pt/docs/handbook/intro-to-js-ts.html"},{"path":"/ko/docs/handbook/typescript-tooling-in-5-minutes.html"},{"path":"/pt/docs/handbook/tsconfig-json.html"},{"path":"/pt/docs/handbook/Decorators.html"},{"path":"/pt/docs/handbook/module-resolution.html"},{"path":"/pt/docs/handbook/namespaces.html"},{"path":"/pt/docs/handbook/react.html"},{"path":"/pt/docs/handbook/babel-with-typescript.html"},{"path":"/pt/docs/handbook/typescript-tooling-in-5-minutes.html"},{"path":"/vo/docs/handbook/basic-types.html"},{"path":"/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/global-plugin-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/global-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-class-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-function-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-plugin-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-d-ts.html"},{"path":"/docs/handbook/2/conditional-types.html"},{"path":"/docs/handbook/2/indexed-access-types.html"},{"path":"/docs/handbook/2/typeof-types.html"},{"path":"/docs/handbook/2/types-from-types.html"},{"path":"/pt/docs/handbook/declaration-files/dts-from-js.html"},{"path":"/pt/docs/handbook/symbols.html"},{"path":"/docs/handbook/release-notes/overview.html"},{"path":"/tsconfig"},{"path":"/es/tsconfig"},{"path":"/id/tsconfig"},{"path":"/ko/tsconfig"},{"path":"/ja/tsconfig"},{"path":"/pt/tsconfig"},{"path":"/vo/tsconfig"},{"path":"/zh/tsconfig"},{"path":"/play"},{"path":"/fa/play"},{"path":"/id/play"},{"path":"/ja/play"},{"path":"/zh/play"},{"path":"/es/play"},{"path":"/ko/play"},{"path":"/pt/play"},{"path":"/vo/play"},{"path":"/play/3-7/fixits/big-number-literals.ts.html"},{"path":"/play/3-7/fixits/const-to-let.ts.html"},{"path":"/play/3-7/fixits/infer-from-usage-changes.ts.html"},{"path":"/play/3-7/syntax-and-messaging/flattened-error-reporting.ts.html"},{"path":"/play/3-7/syntax-and-messaging/nullish-coalescing.ts.html"},{"path":"/play/3-7/syntax-and-messaging/optional-chaining.ts.html"},{"path":"/play/3-7/types-and-code-flow/assertion-functions.ts.html"},{"path":"/play/3-7/types-and-code-flow/recursive-type-references.ts.html"},{"path":"/play/3-7/types-and-code-flow/uncalled-function-checks.ts.html"},{"path":"/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts.html"},{"path":"/play/3-8/jsdoc-improvements/accessibility-modifiers.js.html"},{"path":"/play/3-8/syntax-and-messaging/export-modules-from.ts.html"},{"path":"/play/3-8/syntax-and-messaging/private-class-fields.ts.html"},{"path":"/play/4-0/new-checks/class-constructor-code-flow.ts.html"},{"path":"/play/4-0/new-ts-features/named-tuples.ts.html"},{"path":"/play/4-0/new-ts-features/unknown-in-catch.ts.html"},{"path":"/play/4-0/new-ts-features/variadic-tuples.ts.html"},{"path":"/play/4-0/new-js-features/jsdoc-deprecated.ts.html"},{"path":"/play/4-0/new-js-features/logical-operators-and-assignment.ts.html"},{"path":"/play/4-0/new-js-features/nullish-coalescing.ts.html"},{"path":"/play/javascript/external-apis/typescript-with-deno.ts.html"},{"path":"/play/javascript/external-apis/typescript-with-node.js.html"},{"path":"/play/javascript/external-apis/typescript-with-web.js.html"},{"path":"/play/javascript/external-apis/typescript-with-webgl.js.html"},{"path":"/play/javascript/functions-with-javascript/function-chaining.ts.html"},{"path":"/play/javascript/functions-with-javascript/generic-functions.ts.html"},{"path":"/play/javascript/functions-with-javascript/typing-functions.ts.html"},{"path":"/play/javascript/helping-with-javascript/errors.ts.html"},{"path":"/play/javascript/helping-with-javascript/quick-fixes.ts.html"},{"path":"/play/javascript/javascript-essentials/code-flow.ts.html"},{"path":"/play/javascript/javascript-essentials/functions.ts.html"},{"path":"/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/play/javascript/javascript-essentials/objects-and-arrays.ts.html"},{"path":"/play/javascript/modern-javascript/async-await.ts.html"},{"path":"/play/javascript/modern-javascript/immutability.ts.html"},{"path":"/play/javascript/modern-javascript/import-export.ts.html"},{"path":"/play/javascript/modern-javascript/jsdoc-support.js.html"},{"path":"/play/javascript/working-with-classes/classes-101.ts.html"},{"path":"/play/javascript/working-with-classes/generic-classes.ts.html"},{"path":"/play/javascript/working-with-classes/mixins.ts.html"},{"path":"/play/javascript/working-with-classes/this.ts.html"},{"path":"/play/playground/config/javascript-playgrounds.js.html"},{"path":"/play/playground/config/new-compiler-defaults.ts.html"},{"path":"/play/playground/language/automatic-type-acquisition.ts.html"},{"path":"/play/playground/language/fixits.ts.html"},{"path":"/play/typescript/language/soundness.ts.html"},{"path":"/play/typescript/language/structural-typing.ts.html"},{"path":"/play/typescript/language/type-guards.ts.html"},{"path":"/play/typescript/language/type-widening-and-narrowing.ts.html"},{"path":"/play/playground/tooling/mobile-support.ts.html"},{"path":"/play/playground/tooling/sharable-urls.ts.html"},{"path":"/play/playground/tooling/typescript-versions.ts.html"},{"path":"/play/typescript/language-extensions/enums.ts.html"},{"path":"/play/typescript/language-extensions/nominal-typing.ts.html"},{"path":"/play/typescript/language-extensions/types-vs-interfaces.ts.html"},{"path":"/play/typescript/meta-types/conditional-types.ts.html"},{"path":"/play/typescript/meta-types/discriminate-types.ts.html"},{"path":"/play/typescript/meta-types/indexed-types.ts.html"},{"path":"/play/typescript/meta-types/mapped-types.ts.html"},{"path":"/play/typescript/primitives/any.ts.html"},{"path":"/play/typescript/primitives/literals.ts.html"},{"path":"/play/typescript/primitives/union-and-intersection-types.ts.html"},{"path":"/play/typescript/primitives/unknown-and-never.ts.html"},{"path":"/play/typescript/type-primitives/built-in-utility-types.ts.html"},{"path":"/play/typescript/type-primitives/nullable-types.ts.html"},{"path":"/play/typescript/type-primitives/tuples.ts.html"},{"path":"/es/play/javascript/external-apis/typescript-with-deno.ts.html"},{"path":"/es/play/javascript/external-apis/typescript-with-node.js.html"},{"path":"/es/play/javascript/external-apis/typescript-with-web.js.html"},{"path":"/es/play/javascript/functions-with-javascript/function-chaining.ts.html"},{"path":"/es/play/javascript/functions-with-javascript/generic-functions.ts.html"},{"path":"/es/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/es/play/javascript/javascript-essentials/objects-and-arrays.ts.html"},{"path":"/es/play/typescript/language/soundness.ts.html"},{"path":"/es/play/typescript/language/structural-typing.ts.html"},{"path":"/es/play/typescript/language/type-guards.ts.html"},{"path":"/es/play/typescript/language/type-widening-and-narrowing.ts.html"},{"path":"/es/play/typescript/meta-types/conditional-types.ts.html"},{"path":"/es/play/typescript/meta-types/discriminate-types.ts.html"},{"path":"/es/play/typescript/meta-types/indexed-types.ts.html"},{"path":"/es/play/typescript/meta-types/mapped-types.ts.html"},{"path":"/es/play/typescript/primitives/any.ts.html"},{"path":"/es/play/typescript/primitives/literals.ts.html"},{"path":"/es/play/typescript/primitives/union-and-intersection-types.ts.html"},{"path":"/es/play/typescript/primitives/unknown-and-never.ts.html"},{"path":"/es/play/typescript/type-primitives/built-in-utility-types.ts.html"},{"path":"/es/play/typescript/type-primitives/nullable-types.ts.html"},{"path":"/es/play/typescript/type-primitives/tuples.ts.html"},{"path":"/fa/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/id/play/3-7/fixits/big-number-literals.ts.html"},{"path":"/id/play/3-7/fixits/const-to-let.ts.html"},{"path":"/id/play/3-7/fixits/infer-from-usage-changes.ts.html"},{"path":"/id/play/3-7/syntax-and-messaging/flattened-error-reporting.ts.html"},{"path":"/id/play/3-7/syntax-and-messaging/nullish-coalescing.ts.html"},{"path":"/id/play/3-7/syntax-and-messaging/optional-chaining.ts.html"},{"path":"/id/play/3-7/types-and-code-flow/assertion-functions.ts.html"},{"path":"/id/play/3-7/types-and-code-flow/recursive-type-reference.ts.html"},{"path":"/id/play/3-7/types-and-code-flow/uncalled-function-checks.ts.html"},{"path":"/id/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts.html"},{"path":"/id/play/3-8/jsdoc-improvements/accessibility-modifiers.js.html"},{"path":"/id/play/3-8/syntax-and-messaging/export-modules-from.ts.html"},{"path":"/id/play/3-8/syntax-and-messaging/private-class-fields.ts.html"},{"path":"/id/play/4-0/new-checks/class-constructor-code-flow.ts.html"},{"path":"/id/play/4-0/new-js-features/jsdoc-deprecated.ts.html"},{"path":"/id/play/4-0/new-js-features/logical-operators-and-assignment.ts.html"},{"path":"/id/play/4-0/new-js-features/nullish-coalescing.ts.html"},{"path":"/id/play/4-0/new-ts-features/named-tuples.ts.html"},{"path":"/id/play/4-0/new-ts-features/unknown-in-catch.ts.html"},{"path":"/id/play/4-0/new-ts-features/variadic-tuples.ts.html"},{"path":"/id/play/javascript/external-apis/typescript-with-deno.ts.html"},{"path":"/id/play/javascript/external-apis/typescript-with-node.js.html"},{"path":"/id/play/javascript/external-apis/typescript-with-web.js.html"},{"path":"/id/play/javascript/external-apis/typescript-with-webgl.js.html"},{"path":"/id/play/javascript/helping-with-javascript/errors.ts.html"},{"path":"/id/play/javascript/helping-with-javascript/quick-fixes.ts.html"},{"path":"/id/play/javascript/javascript-essentials/code-flow.ts.html"},{"path":"/id/play/javascript/javascript-essentials/functions.ts.html"},{"path":"/id/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/id/play/javascript/javascript-essentials/objects-and-arrays.ts.html"},{"path":"/ja/play/3-7/fixits/big-number-literals.ts.html"},{"path":"/ja/play/3-7/fixits/const-to-let.ts.html"},{"path":"/ja/play/3-7/fixits/infer-from-usage-changes.ts.html"},{"path":"/ja/play/3-7/syntax-and-messaging/flattened-error-reporting.ts.html"},{"path":"/ja/play/3-7/syntax-and-messaging/nullish-coalescing.ts.html"},{"path":"/ja/play/3-7/syntax-and-messaging/optional-chaining.ts.html"},{"path":"/ja/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts.html"},{"path":"/ja/play/javascript/external-apis/typescript-with-deno.ts.html"},{"path":"/ja/play/typescript/language-extensions/enums.ts.html"},{"path":"/ja/play/typescript/language-extensions/nominal-typing.ts.html"},{"path":"/ja/play/typescript/language-extensions/types-vs-interfaces.ts.html"},{"path":"/ja/play/typescript/meta-types/conditional-types.ts.html"},{"path":"/ja/play/typescript/meta-types/discriminate-types.ts.html"},{"path":"/ja/play/typescript/meta-types/indexed-types.ts.html"},{"path":"/ja/play/typescript/meta-types/mapped-types.ts.html"},{"path":"/ja/play/typescript/primitives/any.ts.html"},{"path":"/ja/play/typescript/primitives/literals.ts.html"},{"path":"/ja/play/typescript/primitives/union-and-intersection-types.ts.html"},{"path":"/ja/play/typescript/primitives/unknown-and-never.ts.html"},{"path":"/ja/play/typescript/type-primitives/built-in-utility-types.ts.html"},{"path":"/ja/play/typescript/type-primitives/nullable-types.ts.html"},{"path":"/ja/play/typescript/type-primitives/tuples.ts.html"},{"path":"/ko/play/3-7/fixits/big-number-literals.ts.html"},{"path":"/ko/play/3-7/fixits/const-to-let.ts.html"},{"path":"/ko/play/3-7/syntax-and-messaging/optional-chaining.ts.html"},{"path":"/ko/play/3-8/syntax-and-messaging/export-modules-from.ts.html"},{"path":"/ko/play/javascript/external-apis/typescript-with-node.js.html"},{"path":"/ko/play/javascript/javascript-essentials/functions.ts.html"},{"path":"/ko/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/ko/play/javascript/modern-javascript/async-await.ts.html"},{"path":"/ko/play/javascript/modern-javascript/immutability.ts.html"},{"path":"/ko/play/javascript/modern-javascript/import-export.ts.html"},{"path":"/ko/play/typescript/language-extensions/enums.ts.html"},{"path":"/ko/play/typescript/language-extensions/types-vs-interfaces.ts.html"},{"path":"/ko/play/typescript/primitives/any.ts.html"},{"path":"/ko/play/typescript/primitives/literals.ts.html"},{"path":"/pt/play/3-7/fixits/big-number-literals.ts.html"},{"path":"/pt/play/3-7/fixits/const-to-let.ts.html"},{"path":"/pt/play/3-7/fixits/infer-from-usage-changes.ts.html"},{"path":"/pt/play/3-7/syntax-and-messaging/nullish-coalescing.ts.html"},{"path":"/pt/play/3-7/syntax-and-messaging/flattened-error-reporting.ts.html"},{"path":"/pt/play/3-7/syntax-and-messaging/optional-chaining.ts.html"},{"path":"/pt/play/3-7/types-and-code-flow/assertion-functions.ts.html"},{"path":"/pt/play/3-7/types-and-code-flow/recursive-type-references.ts.html"},{"path":"/pt/play/3-7/types-and-code-flow/uncalled-function-checks.ts.html"},{"path":"/pt/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts.html"},{"path":"/pt/play/3-8/jsdoc-improvements/accessibility-modifiers.js.html"},{"path":"/pt/play/3-8/syntax-and-messaging/export-modules-from.ts.html"},{"path":"/pt/play/3-8/syntax-and-messaging/private-class-fields.ts.html"},{"path":"/pt/play/4-0/new-checks/class-constructor-code-flow.ts.html"},{"path":"/pt/play/4-0/new-js-features/jsdoc-deprecated.ts.html"},{"path":"/pt/play/4-0/new-js-features/logical-operators-and-assignment.ts.html"},{"path":"/pt/play/4-0/new-js-features/nullish-coalescing.ts.html"},{"path":"/pt/play/4-0/new-ts-features/named-tuples.ts.html"},{"path":"/pt/play/4-0/new-ts-features/unknown-in-catch.ts.html"},{"path":"/pt/play/javascript/external-apis/typescript-with-deno.ts.html"},{"path":"/pt/play/javascript/external-apis/typescript-with-node.js.html"},{"path":"/pt/play/javascript/external-apis/typescript-with-web.js.html"},{"path":"/pt/play/javascript/external-apis/typescript-with-webgl.js.html"},{"path":"/pt/play/javascript/functions-with-javascript/function-chaining.ts.html"},{"path":"/pt/play/javascript/functions-with-javascript/generic-functions.ts.html"},{"path":"/pt/play/javascript/functions-with-javascript/typing-functions.ts.html"},{"path":"/pt/play/javascript/helping-with-javascript/quick-fixes.ts.html"},{"path":"/pt/play/javascript/javascript-essentials/code-flow.ts.html"},{"path":"/pt/play/javascript/javascript-essentials/functions.ts.html"},{"path":"/pt/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/pt/play/javascript/javascript-essentials/objects-and-arrays.ts.html"},{"path":"/pt/play/javascript/modern-javascript/async-await.ts.html"},{"path":"/pt/play/javascript/modern-javascript/immutability.ts.html"},{"path":"/pt/play/javascript/modern-javascript/import-export.ts.html"},{"path":"/pt/play/javascript/modern-javascript/jsdoc-support.js.html"},{"path":"/pt/play/javascript/working-with-classes/classes-101.ts.html"},{"path":"/pt/play/javascript/working-with-classes/generic-classes.ts.html"},{"path":"/pt/play/javascript/working-with-classes/mixins.ts.html"},{"path":"/pt/play/javascript/working-with-classes/this.ts.html"},{"path":"/pt/play/playground/config/javascript-playgrounds.js.html"},{"path":"/pt/play/playground/config/new-compiler-defaults.ts.html"},{"path":"/pt/play/playground/language/automatic-type-acquisition.ts.html"},{"path":"/pt/play/playground/language/fixits.ts.html"},{"path":"/pt/play/playground/tooling/mobile-support.ts.html"},{"path":"/pt/play/playground/tooling/sharable-urls.ts.html"},{"path":"/pt/play/playground/tooling/typescript-versions.ts.html"},{"path":"/pt/play/typescript/language-extensions/enums.ts.html"},{"path":"/pt/play/typescript/meta-types/conditional-types.ts.html"},{"path":"/pt/play/typescript/meta-types/discriminate-types.ts.html"},{"path":"/pt/play/typescript/language-extensions/nominal-typing.ts.html"},{"path":"/pt/play/typescript/meta-types/indexed-types.ts.html"},{"path":"/pt/play/typescript/meta-types/mapped-types.ts.html"},{"path":"/pt/play/typescript/primitives/any.ts.html"},{"path":"/pt/play/typescript/type-primitives/nullable-types.ts.html"},{"path":"/pt/play/typescript/type-primitives/tuples.ts.html"},{"path":"/pt/play/typescript/language/structural-typing.ts.html"},{"path":"/pt/play/typescript/language/type-guards.ts.html"},{"path":"/pt/play/typescript/language/type-widening-and-narrowing.ts.html"},{"path":"/pt/play/typescript/language-extensions/types-vs-interfaces.ts.html"},{"path":"/pt/play/typescript/primitives/literals.ts.html"},{"path":"/vo/play/javascript/javascript-essentials/code-flow.ts.html"},{"path":"/vo/play/javascript/javascript-essentials/functions.ts.html"},{"path":"/vo/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/vo/play/javascript/javascript-essentials/objects-and-arrays.ts.html"},{"path":"/zh/play/javascript/external-apis/typescript-with-deno.ts.html"},{"path":"/zh/play/javascript/external-apis/typescript-with-node.js.html"},{"path":"/zh/play/javascript/external-apis/typescript-with-web.js.html"},{"path":"/zh/play/javascript/external-apis/typescript-with-webgl.js.html"},{"path":"/zh/play/javascript/functions-with-javascript/function-chaining.ts.html"},{"path":"/zh/play/javascript/functions-with-javascript/generic-functions.ts.html"},{"path":"/zh/play/javascript/functions-with-javascript/typing-functions.ts.html"},{"path":"/zh/play/javascript/helping-with-javascript/errors.ts.html"},{"path":"/zh/play/javascript/helping-with-javascript/quick-fixes.ts.html"},{"path":"/zh/play/javascript/javascript-essentials/code-flow.ts.html"},{"path":"/zh/play/javascript/javascript-essentials/functions.ts.html"},{"path":"/zh/play/javascript/javascript-essentials/hello-world.ts.html"},{"path":"/zh/play/javascript/javascript-essentials/objects-and-arrays.ts.html"},{"path":"/zh/play/javascript/modern-javascript/async-await.ts.html"},{"path":"/zh/play/javascript/modern-javascript/immutability.ts.html"},{"path":"/zh/play/javascript/modern-javascript/import-export.ts.html"},{"path":"/zh/play/javascript/modern-javascript/jsdoc-support.js.html"},{"path":"/zh/play/javascript/working-with-classes/classes-101.ts.html"},{"path":"/zh/play/javascript/working-with-classes/generic-classes.ts.html"},{"path":"/zh/play/javascript/working-with-classes/mixins.ts.html"},{"path":"/zh/play/javascript/working-with-classes/this.ts.html"},{"path":"/zh/play/playground/config/javascript-playgrounds.js.html"},{"path":"/zh/play/playground/config/new-compiler-defaults.ts.html"},{"path":"/zh/play/playground/language/automatic-type-acquisition.ts.html"},{"path":"/zh/play/playground/language/fixits.ts.html"},{"path":"/zh/play/playground/tooling/mobile-support.ts.html"},{"path":"/zh/play/playground/tooling/sharable-urls.ts.html"},{"path":"/zh/play/playground/tooling/typescript-versions.ts.html"},{"path":"/zh/play/typescript/language/soundness.ts.html"},{"path":"/zh/play/typescript/language/structural-typing.ts.html"},{"path":"/zh/play/typescript/language/type-guards.ts.html"},{"path":"/zh/play/typescript/language/type-widening-and-narrowing.ts.html"},{"path":"/zh/play/typescript/language-extensions/enums.ts.html"},{"path":"/zh/play/typescript/language-extensions/nominal-typing.ts.html"},{"path":"/zh/play/typescript/language-extensions/types-vs-interfaces.ts.html"},{"path":"/zh/play/typescript/meta-types/conditional-types.ts.html"},{"path":"/zh/play/typescript/meta-types/discriminate-types.ts.html"},{"path":"/zh/play/typescript/meta-types/indexed-types.ts.html"},{"path":"/zh/play/typescript/meta-types/mapped-types.ts.html"},{"path":"/zh/play/typescript/primitives/any.ts.html"},{"path":"/zh/play/typescript/primitives/literals.ts.html"},{"path":"/zh/play/typescript/primitives/union-and-intersection-types.ts.html"},{"path":"/zh/play/typescript/primitives/unknown-and-never.ts.html"},{"path":"/zh/play/typescript/type-primitives/built-in-utility-types.ts.html"},{"path":"/zh/play/typescript/type-primitives/nullable-types.ts.html"},{"path":"/zh/play/typescript/type-primitives/tuples.ts.html"},{"path":"/pt/play/typescript/type-primitives/built-in-utility-types.ts.html"},{"path":"/pt/play/typescript/primitives/unknown-and-never.ts.html"},{"path":"/pt/play/typescript/primitives/union-and-intersection-types.ts.html"},{"path":"/community"},{"path":"/es/community"},{"path":"/id/community"},{"path":"/ja/community"},{"path":"/pl/community"},{"path":"/pt/community"},{"path":"/vo/community"},{"path":"/zh/community"},{"path":"/download"},{"path":"/es/download"},{"path":"/id/download"},{"path":"/ja/download"},{"path":"/pl/download"},{"path":"/pt/download"},{"path":"/vo/download"},{"path":"/zh/download"},{"path":"/empty"},{"path":"/es/empty"},{"path":"/id/empty"},{"path":"/ja/empty"},{"path":"/pl/empty"},{"path":"/pt/empty"},{"path":"/vo/empty"},{"path":"/zh/empty"},{"path":"/"},{"path":"/es/"},{"path":"/id/"},{"path":"/ja/"},{"path":"/pl/"},{"path":"/pt/"},{"path":"/vo/"},{"path":"/zh/"},{"path":"/tools"},{"path":"/es/tools"},{"path":"/id/tools"},{"path":"/ja/tools"},{"path":"/pl/tools"},{"path":"/pt/tools"},{"path":"/vo/tools"},{"path":"/zh/tools"},{"path":"/why-create-typescript"},{"path":"/es/why-create-typescript"},{"path":"/id/why-create-typescript"},{"path":"/ja/why-create-typescript"},{"path":"/pl/why-create-typescript"},{"path":"/pt/why-create-typescript"},{"path":"/vo/why-create-typescript"},{"path":"/zh/why-create-typescript"},{"path":"/docs/bootstrap"},{"path":"/es/docs/bootstrap"},{"path":"/id/docs/bootstrap"},{"path":"/ja/docs/bootstrap"},{"path":"/pl/docs/bootstrap"},{"path":"/pt/docs/bootstrap"},{"path":"/vo/docs/bootstrap"},{"path":"/zh/docs/bootstrap"},{"path":"/docs/"},{"path":"/es/docs/"},{"path":"/id/docs/"},{"path":"/ja/docs/"},{"path":"/pl/docs/"},{"path":"/pt/docs/"},{"path":"/vo/docs/"},{"path":"/zh/docs/"},{"path":"/docs/handbook/"},{"path":"/es/docs/handbook/"},{"path":"/id/docs/handbook/"},{"path":"/ja/docs/handbook/"},{"path":"/pl/docs/handbook/"},{"path":"/pt/docs/handbook/"},{"path":"/vo/docs/handbook/"},{"path":"/zh/docs/handbook/"},{"path":"/dt/search"},{"path":"/es/dt/search"},{"path":"/id/dt/search"},{"path":"/ja/dt/search"},{"path":"/pl/dt/search"},{"path":"/pt/dt/search"},{"path":"/vo/dt/search"},{"path":"/zh/dt/search"},{"path":"/branding/"},{"path":"/upcoming/"},{"path":"/dev/bug-workbench/"},{"path":"/dev/playground-plugins/"},{"path":"/dev/sandbox/"},{"path":"/dev/twoslash/"},{"path":"/dev/typescript-vfs/"}]},"markdownRemark":{"id":"a44637f5-bb8c-5222-9f51-86cd0a8798ab","excerpt":"Functions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class.\nThey’re also…","html":"<p>Functions are the basic building block of any application, whether they’re local functions, imported from another module, or methods on a class.\nThey’re also values, and just like other values, TypeScript has many ways to describe how functions can be called.\nLet’s learn about how to write types that describe functions.</p>\n<h2 id=\"function-type-expressions\" style=\"position:relative;\"><a href=\"#function-type-expressions\" aria-label=\"function type expressions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Function Type Expressions</h2>\n<p>The simplest way to describe a function is with a <em>function type expression</em>.\nThese types are syntactically similar to arrow functions:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function greeter(fn: (a: string) => void): void'>greeter</data-lsp>(<data-lsp lsp='(parameter) fn: (a: string) => void'>fn</data-lsp>: (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) a: string'>a</data-lsp></span><span style=\"color: #000000\">: string) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void) {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='(parameter) fn: (a: string) => void'>fn</data-lsp>(</span><span style=\"color: #A31515\">\"Hello, World\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function printToConsole(s: string): void'>printToConsole</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: string'>s</data-lsp></span><span style=\"color: #000000\">: string) {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: string'>s</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #000000\"><data-lsp lsp='function greeter(fn: (a: string) => void): void'>greeter</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='function printToConsole(s: string): void'>printToConsole</data-lsp></span><span style=\"color: #000000\">);</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1XagFMMALkVwENiBnKVGMZASkQF4A+RANzhgBNGBvAFCJEBXACIAEugA20uABpEAdTipp3MfQDcAgL4CBoSLASIADjTBQAKnADCCCnGnpcFStVoNEg4REfO6AB0cshu2noGaJjYeBa0NvYBLtpAA'>Try</a></div></pre>\n<p>The syntax <code>(a: string) => void</code> means “a function with one parameter, named <code>a</code>, of type string, that doesn’t have a return value”.\nJust like with function declarations, if a parameter type isn’t specified, it’s implicitly <code>any</code>.</p>\n<blockquote>\n<p>Note that the parameter name is <strong>required</strong>. The function type <code>(string) => void</code> means “a function with a parameter named <code>string</code> of type <code>any</code>“!</p>\n</blockquote>\n<p>Of course, we can use a type alias to name a function type:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> <data-lsp lsp='type GreetFunction = (a: string) => void'>GreetFunction</data-lsp> = (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) a: string'>a</data-lsp></span><span style=\"color: #000000\">: string) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void;</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function greeter(fn: GreetFunction): void'>greeter</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) fn: GreetFunction'>fn</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='type GreetFunction = (a: string) => void'>GreetFunction</data-lsp>) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/C4TwDgpgBA4gThCwBiBXAdgY2ASwPbpQC8UAFAIYBcUAzsHDugOYCUxAfFAG544AmAbgBQAMwzZ8hJgiQQ4pEemrxEKcbgJsA3kKhQA9PqgA6U0IC+QA'>Try</a></div></pre>\n<h2 id=\"call-signatures\" style=\"position:relative;\"><a href=\"#call-signatures\" aria-label=\"call signatures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Call Signatures</h2>\n<p>In JavaScript, functions can have properties in addition to being callable.\nHowever, the function type expression syntax doesn’t allow for declaring properties.\nIf we want to describe something callable with properties, we can write a <em>call signature</em> in an object type:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> <data-lsp lsp='type DescribableFunction = {&amp;#13;    (someArg: number): boolean;&amp;#13;    description: string;&amp;#13;}'>DescribableFunction</data-lsp> = {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) description: string'>description</data-lsp></span><span style=\"color: #000000\">: string;</span>\n<span style=\"color: #000000\">  (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) someArg: number'>someArg</data-lsp></span><span style=\"color: #000000\">: number): boolean;</span>\n<span style=\"color: #000000\">};</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function doSomething(fn: DescribableFunction): void'>doSomething</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) fn: DescribableFunction'>fn</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='type DescribableFunction = {&amp;#13;    (someArg: number): boolean;&amp;#13;    description: string;&amp;#13;}'>DescribableFunction</data-lsp>) {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) fn: DescribableFunction'>fn</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(property) description: string'>description</data-lsp> + </span><span style=\"color: #A31515\">\" returned \"</span><span style=\"color: #000000\"> + <data-lsp lsp='(parameter) fn: (someArg: number) => boolean'>fn</data-lsp>(</span><span style=\"color: #09835A\">6</span><span style=\"color: #000000\">));</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/C4TwDgpgBAIhDOBjATgSwEYEN0BsIDEBXAO0WFQHtioBeKAbwCgooATBFVMcqgLinjA0xAOYBuZlAAU8CgFsIAQWQj+xQnPQRkASn7oKFPJmISAvhIBmJMpWqsKAZXkRgAC1Sipl4vzhI0LFwCGx5iHQZJRCpZPAA6HAoRb2I49gCuMKgAaigAIihkV0JkYghWfJyoHykANh0dcyA'>Try</a></div></pre>\n<p>Note that the syntax is slightly different compared to a function type expression - use <code>:</code> between the parameter list and the return type rather than <code>=></code>.</p>\n<h2 id=\"construct-signatures\" style=\"position:relative;\"><a href=\"#construct-signatures\" aria-label=\"construct signatures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Construct Signatures</h2>\n<p>JavaScript functions can also be invoked with the <code>new</code> operator.\nTypeScript refers to these as <em>constructors</em> because they usually create a new object.\nYou can write a <em>construct signature</em> by adding the <code>new</code> keyword in front of a call signature:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> <data-lsp lsp='type SomeConstructor = new (s: string) => SomeObject'>SomeConstructor</data-lsp> = {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: string'>s</data-lsp></span><span style=\"color: #000000\">: string): <data-lsp lsp='type SomeObject = any'>SomeObject</data-lsp>;</span>\n<span style=\"color: #000000\">};</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function fn(ctor: SomeConstructor): any'>fn</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) ctor: SomeConstructor'>ctor</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='type SomeConstructor = new (s: string) => any'>SomeConstructor</data-lsp>) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> <data-lsp lsp='(parameter) ctor: new (s: string) => any'>ctor</data-lsp>(</span><span style=\"color: #A31515\">\"hello\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/C4TwDgpgBAyg9gWwgeQEYCsIGNhQLxQCGAdiANwBQA9FVALQNYCuwDdFoksiEAwnMQDOwAE5MccEfigBvClCjEIAdygAKQQC4owkQEtiAcwCU2+EjSYclAL6UAZk2I49AqPeJqJIsz35DRcWBJY1l5KBEIYCYRYkUVKG81ACIACwgAGwy4ZONbIA'>Try</a></div></pre>\n<p>Some objects, like JavaScript’s <code>Date</code> object, can be called with or without <code>new</code>.\nYou can combine call and construct signatures in the same type arbitrarily:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> <data-lsp lsp='interface CallOrConstruct'>CallOrConstruct</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: string'>s</data-lsp></span><span style=\"color: #000000\">: string): <data-lsp lsp='interface Date'>Date</data-lsp>;</span>\n<span style=\"color: #000000\">  (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) n: number | undefined'>n</data-lsp></span><span style=\"color: #000000\">?: number): number;</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgMJwDYYPJVQexAGcwoBXBMZAbwChlkQIB3ZACiIC5kSpQBzAJTcAInEgBueuxAB+biDIBbAEbRhjZWqhSAvkA'>Try</a></div></pre>\n<h2 id=\"generic-functions\" style=\"position:relative;\"><a href=\"#generic-functions\" aria-label=\"generic functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generic Functions</h2>\n<p>It’s common to write a function where the types of the input relate to the type of the output, or where the types of two inputs are related in some way.\nLet’s consider for a moment a function that returns the first element of an array:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function firstElement(arr: any[]): any'>firstElement</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: any[]'>arr</data-lsp></span><span style=\"color: #000000\">: any[]) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: any[]'>arr</data-lsp></span><span style=\"color: #000000\">[</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">];</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAFAIaqoBci5YAngNoC6AlIgN4BQiiqeKCFRJKqJgAYWAbm4BfIA'>Try</a></div></pre>\n<p>This function does its job, but unfortunately has the return type <code>any</code>.\nIt’d be better if the function returned the type of the array element.</p>\n<p>In TypeScript, <em>generics</em> are used when we want to describe a correspondence between two values.\nWe do this by declaring a <em>type parameter</em> in the function signature:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function firstElement&amp;lt;T>(arr: T[]): T'>firstElement</data-lsp>&lt;<data-lsp lsp='(type parameter) T in firstElement&amp;lt;T>(arr: T[]): T'>T</data-lsp>>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: T[]'>arr</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in firstElement&amp;lt;T>(arr: T[]): T'>T</data-lsp>[]): <data-lsp lsp='(type parameter) T in firstElement&amp;lt;T>(arr: T[]): T'>T</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: T[]'>arr</data-lsp></span><span style=\"color: #000000\">[</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">];</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAPACoB8AFAIaqoBci5A2gLoCUz5iA3gChEiVHighUSeqlYAGdgG4BAXyA'>Try</a></div></pre>\n<p>By adding a type parameter <code>T</code> to this function and using it in two places, we’ve created a link between the input of the function (the array) and the output (the return value).\nNow when we call it, a more specific type comes out:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #008000\">// s is of type &apos;string&apos;</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const s: string'>s</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function firstElement&amp;lt;string>(arr: string[]): string'>firstElement</data-lsp>([</span><span style=\"color: #A31515\">\"a\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"b\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"c\"</span><span style=\"color: #000000\">]);</span>\n<span style=\"color: #008000\">// n is of type &apos;number&apos;</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const n: number'>n</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function firstElement&amp;lt;number>(arr: number[]): number'>firstElement</data-lsp>([</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">]);</span></code><a href='https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVKxgGcMBRCEAWxFQwB4AVAPgApYYAueBgbQF0AlFwYBuAFAB6CfAC0csMgxyZk6UXhZ1ORPAwBPAA4IA5CRhZUAc2NiweEvHUBeAsTIVqtFjwBEUHwA08D4ARoHBYD6C4lLw+Jrw2rqGJqjIlCEgMDZ2qA74LoiEJORUNBjeAIxBAExBAMzRQA'>Try</a></div></pre>\n<h3 id=\"inference\" style=\"position:relative;\"><a href=\"#inference\" aria-label=\"inference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Inference</h3>\n<p>Note that we didn’t have to specify <code>T</code> in this sample.\nThe type was <em>inferred</em> - chosen automatically - by TypeScript.</p>\n<p>We can use multiple type parameters as well.\nFor example, a standalone version of <code>map</code> would look like this:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function map&amp;lt;E, O>(arr: E[], func: (arg: E) => O): O[]'>map</data-lsp>&lt;<data-lsp lsp='(type parameter) E in map&amp;lt;E, O>(arr: E[], func: (arg: E) => O): O[]'>E</data-lsp>, <data-lsp lsp='(type parameter) O in map&amp;lt;E, O>(arr: E[], func: (arg: E) => O): O[]'>O</data-lsp>>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: E[]'>arr</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) E in map&amp;lt;E, O>(arr: E[], func: (arg: E) => O): O[]'>E</data-lsp>[], <data-lsp lsp='(parameter) func: (arg: E) => O'>func</data-lsp>: (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arg: E'>arg</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) E in map&amp;lt;E, O>(arr: E[], func: (arg: E) => O): O[]'>E</data-lsp>) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> <data-lsp lsp='(type parameter) O in map&amp;lt;E, O>(arr: E[], func: (arg: E) => O): O[]'>O</data-lsp>): <data-lsp lsp='(type parameter) O in map&amp;lt;E, O>(arr: E[], func: (arg: E) => O): O[]'>O</data-lsp>[] {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: E[]'>arr</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Array&amp;lt;E>.map&amp;lt;O>(callbackfn: (value: E, index: number, array: E[]) => O, thisArg?: any): O[]'>map</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) func: (arg: E) => O'>func</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #008000\">// Parameter &apos;n&apos; is of type &apos;number&apos;</span>\n<span style=\"color: #008000\">// &apos;parsed&apos; is of type &apos;number[]&apos;</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const parsed: number[]'>parsed</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function map&amp;lt;string, number>(arr: string[], func: (arg: string) => number): number[]'>map</data-lsp>([</span><span style=\"color: #A31515\">\"1\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"2\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"3\"</span><span style=\"color: #000000\">], (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) n: string'>n</data-lsp></span><span style=\"color: #000000\">) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> <data-lsp lsp='function parseInt(s: string, radix?: number | undefined): number'>parseInt</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) n: string'>n</data-lsp></span><span style=\"color: #000000\">));</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWwIYAcA8BRANIgeQD4AKVAJ3IC5FsBtAXX1EhrPIHMbsBKRAXiKEeNAo0QBvAFCJE5AKZQQ5JBXIA6NOhIsIPANxSAvlKkB6M4gAKFVMkXzyiAORhniGAGdEcYIigAnujyLmAgyABGjs7mls7oFJ7yACbuXj5+gcGh4VHkjDEQCJ5QiAnkSckCKBgkdABEAIz1+PUATC2I9QDM9UyIJGB8gmWJ8gCSYFCDPAZAA'>Try</a></div></pre>\n<p>Note that in this example, TypeScript could infer both the type of the <code>E</code> type parameter (from the given <code>string</code> array), as well as the type <code>O</code> based on the return value of the function expression.</p>\n<h3 id=\"constraints\" style=\"position:relative;\"><a href=\"#constraints\" aria-label=\"constraints permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Constraints</h3>\n<p>We’ve written some generic functions that can work on <em>any</em> kind of value.\nSometimes we want to relate two values, but can only operate on a certain subset of values.\nIn this case, we can use a <em>constraint</em> to limit the kinds of types that a type parameter can accept.</p>\n<p>Let’s write a function that returns the longer of two values.\nTo do this, we need a <code>length</code> property that’s a number.\nWe <em>constrain</em> the type parameter to that type by writing an <code>extends</code> clause:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function longest&amp;lt;T extends {&amp;#13;    length: number;&amp;#13;}>(a: T, b: T): T'>longest</data-lsp>&lt;<data-lsp lsp='(type parameter) T in longest&amp;lt;T extends {&amp;#13;    length: number;&amp;#13;}>(a: T, b: T): T'>T</data-lsp> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) length: number'>length</data-lsp></span><span style=\"color: #000000\">: number }&gt;(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) a: T extends { length: number; }'>a</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in longest&amp;lt;T extends {&amp;#13;    length: number;&amp;#13;}>(a: T, b: T): T'>T</data-lsp>, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) b: T extends { length: number; }'>b</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in longest&amp;lt;T extends {&amp;#13;    length: number;&amp;#13;}>(a: T, b: T): T'>T</data-lsp>) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) a: T extends { length: number; }'>a</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(property) length: number'>length</data-lsp> >= </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) b: T extends { length: number; }'>b</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(property) length: number'>length</data-lsp>) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) a: T extends { length: number; }'>a</data-lsp></span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) b: T extends { length: number; }'>b</data-lsp></span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #008000\">// longerArray is of type &apos;number[]&apos;</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const longerArray: number[]'>longerArray</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function longest&amp;lt;number[]>(a: number[], b: number[]): number[]'>longest</data-lsp>([</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">], [</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">]);</span>\n<span style=\"color: #008000\">// longerString is of type &apos;string&apos;</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const longerString: &amp;quot;alice&amp;quot; | &amp;quot;bob&amp;quot;'>longerString</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function longest&amp;lt;&amp;quot;alice&amp;quot; | &amp;quot;bob&amp;quot;>(a: &amp;quot;alice&amp;quot; | &amp;quot;bob&amp;quot;, b: &amp;quot;alice&amp;quot; | &amp;quot;bob&amp;quot;): &amp;quot;alice&amp;quot; | &amp;quot;bob&amp;quot;'>longest</data-lsp>(</span><span style=\"color: #A31515\">\"alice\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"bob\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #008000\">// Error! Numbers don&apos;t have a &apos;length&apos; property</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const notOK: {&amp;#13;    length: number;&amp;#13;}'>notOK</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function longest&amp;lt;{&amp;#13;    length: number;&amp;#13;}>(a: {&amp;#13;    length: number;&amp;#13;}, b: {&amp;#13;    length: number;&amp;#13;}): {&amp;#13;    length: number;&amp;#13;}'>longest</data-lsp>(</span><span style=\"color: #09835A\"><data-err>10</data-err></span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">100</span><span style=\"color: #000000\">);</span>\n<span class=\"error\"><span>Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.</span><span class=\"code\">2345</span></span><span class=\"error-behind\">Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdG00AoAMwFcA7AYwBcBLOC0AG0YHNJEaAeAFVEgAPGpAoATRKADeLUWxoALVBTIBbAEYxQAXwB8ACgCGqXgBpQ6kwEppRUKDolQRgHTM5i0LoC8Ftx4UbKTt7UGhIGjJoJkMAbhDtAWZESFtQsIiopnV4+20ifKIQFnYYAEFYQwBPB0k4JxoqgAdUgHIVDRgAbQBdVqIqRi4Sig5oCuhq0F9WUc4afS6ARnM0HvNl1fMMHqt44tmxgGUaaDpR2tB60EaW0FauM9H+wYphw5gTp7ZpkY4ufQAIkMzDoVEggPMgPUcHUgL2RTAAFFYAgAISgAByak0SFAYkYrRooAUhgAbqlDPd3KNFK1QE14C1oI0BkNiRQ4DQAPIAaV+HwBSwADOYRcK9kA'>Try</a></div></pre>\n<p>There are a interesting few things to note in this example.\nWe allowed TypeScript to <em>infer</em> the return type of <code>longest</code>.\nReturn type inference also works on generic functions.</p>\n<p>Because we constrained <code>T</code> to <code>{ length: number }</code>, we were allowed to access the <code>.length</code> property of the <code>a</code> and <code>b</code> parameters.\nWithout the type constraint, we wouldn’t be able to access those properties because the values might have been some other type without a length property.</p>\n<p>The types of <code>longerArray</code> and <code>longerString</code> were inferred based on the arguments.\nRemember, generics are all about relating two or more values with the same type!</p>\n<p>Finally, just as we’d like, the call to <code>longest(10, 100)</code> is rejected because the <code>number</code> type doesn’t have a <code>.length</code> property.</p>\n<h3 id=\"working-with-constrained-values\" style=\"position:relative;\"><a href=\"#working-with-constrained-values\" aria-label=\"working with constrained values permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Working with Constrained Values</h3>\n<p>Here’s a common error when working with generic constraints:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function minimumLength&amp;lt;T extends {&amp;#13;    length: number;&amp;#13;}>(obj: T, minimum: number): T'>minimumLength</data-lsp>&lt;<data-lsp lsp='(type parameter) T in minimumLength&amp;lt;T extends {&amp;#13;    length: number;&amp;#13;}>(obj: T, minimum: number): T'>T</data-lsp> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) length: number'>length</data-lsp></span><span style=\"color: #000000\">: number }&gt;(</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) obj: T extends { length: number; }'>obj</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in minimumLength&amp;lt;T extends {&amp;#13;    length: number;&amp;#13;}>(obj: T, minimum: number): T'>T</data-lsp>,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) minimum: number'>minimum</data-lsp></span><span style=\"color: #000000\">: number</span>\n<span style=\"color: #000000\">): <data-lsp lsp='(type parameter) T in minimumLength&amp;lt;T extends {&amp;#13;    length: number;&amp;#13;}>(obj: T, minimum: number): T'>T</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) obj: T extends { length: number; }'>obj</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(property) length: number'>length</data-lsp> >= </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) minimum: number'>minimum</data-lsp></span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) obj: T extends { length: number; }'>obj</data-lsp></span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> { <data-lsp lsp='(property) length: number'>length</data-lsp>: </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) minimum: number'>minimum</data-lsp></span><span style=\"color: #000000\"> };</span>\n<span class=\"error\"><span>Type '{ length: number; }' is not assignable to type 'T'.\n  '{ length: number; }' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint '{ length: number; }'.</span><span class=\"code\">2322</span></span><span class=\"error-behind\">Type '{ length: number; }' is not assignable to type 'T'.\n  '{ length: number; }' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint '{ length: number; }'.</span><span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFADMBXAOwGMAXASziNAFsKiLaDaAZSIgczIAsAeACqhIADzIcAJolABvUABsO3HqiIsARjFABfAHwAKHKFBx1AK1QCANEboMmLVRpg4AlJdm2KeUPtNmAOkUuXlBdAF47RmZaV09jY2hIMgJoGn8AblttYXlESHiEpJS02QUlXlR6aJYdLONtHG0gA'>Try</a></div></pre>\n<p>It might look like this function is OK - <code>T</code> is constrained to <code>{ length: number }</code>, and the function either returns <code>T</code> or a value matching that constraint.\nThe problem is that the function promises to return the <em>same</em> kind of object as was passed in, not just <em>some</em> object matching the constraint.\nIf this code were legal, you could write code that definitely wouldn’t work:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #008000\">// &apos;arr&apos; gets value { length: 6 }</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const arr: number[]'>arr</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function minimumLength&amp;lt;number[]>(obj: number[], minimum: number): number[]'>minimumLength</data-lsp>([</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">], </span><span style=\"color: #09835A\">6</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #008000\">// and crashes here because arrays have</span>\n<span style=\"color: #008000\">// a &apos;slice&apos; method, but not the returned object!</span>\n<span style=\"color: #000000\"><data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const arr: number[]'>arr</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Array&amp;lt;number>.slice(start?: number | undefined, end?: number | undefined): number[]'>slice</data-lsp>(</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">));</span></code><a href='https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFstUsDkCAZEVAcwwAsAeAFXhAA8NrgBneAb3gRqdegC54qcgCMQMeAF8AfAAoAUPHg5pAKwnMANBsLFS5CVIKyYagJT6A3GoD0z+AFpPYZBk-uXbgDksDCB8DQgGHwAblAQyAiCwrQMEgBsimpgeDwY8CHwALwmJGSUIgwqANoAjAbwAEz1AMwAuvVptk6u+ajA8GAwUDz0IHyjcPCyYFDIPAghUACe41DRIAH58IE8EFhgIGEEkfQ4wPXSPpI4eQwIcBjIMKgg-do64BgAhFk5OMIAOggOBoKhCAN2+xAKgADLYukA'>Try</a></div></pre>\n<h3 id=\"specifying-type-arguments\" style=\"position:relative;\"><a href=\"#specifying-type-arguments\" aria-label=\"specifying type arguments permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Specifying Type Arguments</h3>\n<p>TypeScript can usually infer the intended type arguments in a generic call, but not always.\nFor example, let’s say you wrote a function to combine two arrays:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function combine&amp;lt;T>(arr1: T[], arr2: T[]): T[]'>combine</data-lsp>&lt;<data-lsp lsp='(type parameter) T in combine&amp;lt;T>(arr1: T[], arr2: T[]): T[]'>T</data-lsp>>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr1: T[]'>arr1</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in combine&amp;lt;T>(arr1: T[], arr2: T[]): T[]'>T</data-lsp>[], </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr2: T[]'>arr2</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in combine&amp;lt;T>(arr1: T[], arr2: T[]): T[]'>T</data-lsp>[]): <data-lsp lsp='(type parameter) T in combine&amp;lt;T>(arr1: T[], arr2: T[]): T[]'>T</data-lsp>[] {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr1: T[]'>arr1</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Array&amp;lt;T>.concat(...items: ConcatArray&amp;lt;T>[]): T[] (+1 overload)'>concat</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr2: T[]'>arr2</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABBOBbARjMBTAPAFQD4AKAQwCdyBGALkXwG0BdAGkQvICY7GmBKHs0QBvAFCJE5bFBDkkHKgDoUkUlDKVOfANyiAvkA'>Try</a></div></pre>\n<p>Normally it would be an error to call this function with mismatched arrays:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const arr: number[]'>arr</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function combine&amp;lt;number>(arr1: number[], arr2: number[]): number[]'>combine</data-lsp>([</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">], [</span><span style=\"color: #A31515\"><data-err>&quot;hello&quot;</data-err></span><span style=\"color: #000000\">]);</span>\n<span class=\"error\"><span>Type 'string' is not assignable to type 'number'.</span><span class=\"code\">2322</span></span><span class=\"error-behind\">Type 'string' is not assignable to type 'number'.</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABNIBjAGwENpJQAzAVwDtCAXASzjtELgFsAjZuyAB4AKgD4AFOWgBGVMIDaAXQA0oKWjlKAlJsUBuHCFABaU4RqNTxnJzqJGa2KAC8HbnwHj501WlUYVUHkAIgALSGJiOGDFLT0gA'>Try</a></div></pre>\n<p>If you intended to do this, however, you could manually specify <code>T</code>:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const arr: (string | number)[]'>arr</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function combine&amp;lt;string | number>(arr1: (string | number)[], arr2: (string | number)[]): (string | number)[]'>combine</data-lsp>&lt;string | number>([</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">], [</span><span style=\"color: #A31515\">\"hello\"</span><span style=\"color: #000000\">]);</span></code><a href='https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXzBwFsAjLVEAHgBUA+AClhgEYAueagbQF0AaeJgCZ2XbgEoRPANwAoAPRz4AWhVhkGFUpmFUAZwwCYMeAF4CxMhUr6Y5AObwAPvFTJSIGA07N+g-gGY+eE4AIgALEAgIHBDxKSA'>Try</a></div></pre>\n<h3 id=\"guidelines-for-writing-good-generic-functions\" style=\"position:relative;\"><a href=\"#guidelines-for-writing-good-generic-functions\" aria-label=\"guidelines for writing good generic functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Guidelines for Writing Good Generic Functions</h3>\n<p>Writing generic functions is fun, and it can be easy to get carried away with type parameters.\nHaving too many type parameters or using constraints where they aren’t needed can make inference less successful, frustrating callers of your function.</p>\n<h4 id=\"push-type-parameters-down\" style=\"position:relative;\"><a href=\"#push-type-parameters-down\" aria-label=\"push type parameters down permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Push Type Parameters Down</h4>\n<p>Here are two ways of writing a function that appear similar:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function firstElement1&amp;lt;T>(arr: T[]): T'>firstElement1</data-lsp>&lt;<data-lsp lsp='(type parameter) T in firstElement1&amp;lt;T>(arr: T[]): T'>T</data-lsp>>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: T[]'>arr</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in firstElement1&amp;lt;T>(arr: T[]): T'>T</data-lsp>[]) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: T[]'>arr</data-lsp></span><span style=\"color: #000000\">[</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">];</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function firstElement2&amp;lt;T extends any[]>(arr: T): any'>firstElement2</data-lsp>&lt;<data-lsp lsp='(type parameter) T in firstElement2&amp;lt;T extends any[]>(arr: T): any'>T</data-lsp> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> any[]&gt;(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: T extends any[]'>arr</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in firstElement2&amp;lt;T extends any[]>(arr: T): any'>T</data-lsp>) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: T extends any[]'>arr</data-lsp></span><span style=\"color: #000000\">[</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">];</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #008000\">// a: number (good)</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const a: number'>a</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function firstElement1&amp;lt;number>(arr: number[]): number'>firstElement1</data-lsp>([</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">]);</span>\n<span style=\"color: #008000\">// b: any (bad)</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const b: any'>b</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function firstElement2&amp;lt;number[]>(arr: number[]): any'>firstElement2</data-lsp>([</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">]);</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAnAzlAogGwKYC2eYUAjADwAqAfABQCGqqAXIpQNoC6AlIgN4AoRIlR4oIVEkap2ABk4BuAQF8BA0JFgJkaTLkLEoAJiqI8ADyjEAJukT0wATy51prSr0HDR4yfaZyiipqAPQh9qxgIAQARnioiLQA5nBw1twCEAiY9ogAvDoY2PhEJKS07KQANIhGNQDMPEphiDGsDo6JMfTpmdlQrfmFeiWGRhXVtQ1NQA'>Try</a></div></pre>\n<p>These might seem identical at first glance, but <code>firstElement1</code> is a much better way to write this function.\nIts inferred return type is <code>T</code>, but <code>firstElement2</code>’s inferred return type is <code>any</code> because TypeScript has to resolve the <code>arr[0]</code> expression using the constraint type, rather than “waiting” to resolve the element during a call.</p>\n<blockquote>\n<p><strong>Rule</strong>: When possible, use the type parameter itself rather than constraining it</p>\n</blockquote>\n<h4 id=\"use-fewer-type-parameters\" style=\"position:relative;\"><a href=\"#use-fewer-type-parameters\" aria-label=\"use fewer type parameters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Use Fewer Type Parameters</h4>\n<p>Here’s another pair of similar functions:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function filter1&amp;lt;T>(arr: T[], func: (arg: T) => boolean): T[]'>filter1</data-lsp>&lt;<data-lsp lsp='(type parameter) T in filter1&amp;lt;T>(arr: T[], func: (arg: T) => boolean): T[]'>T</data-lsp>>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: T[]'>arr</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in filter1&amp;lt;T>(arr: T[], func: (arg: T) => boolean): T[]'>T</data-lsp>[], <data-lsp lsp='(parameter) func: (arg: T) => boolean'>func</data-lsp>: (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arg: T'>arg</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in filter1&amp;lt;T>(arr: T[], func: (arg: T) => boolean): T[]'>T</data-lsp>) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> boolean): <data-lsp lsp='(type parameter) T in filter1&amp;lt;T>(arr: T[], func: (arg: T) => boolean): T[]'>T</data-lsp>[] {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: T[]'>arr</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Array&amp;lt;T>.filter(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[] (+1 overload)'>filter</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) func: (arg: T) => boolean'>func</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function filter2&amp;lt;T, F extends (arg: T) => boolean>(arr: T[], func: F): T[]'>filter2</data-lsp>&lt;<data-lsp lsp='(type parameter) T in filter2&amp;lt;T, F extends (arg: T) => boolean>(arr: T[], func: F): T[]'>T</data-lsp>, <data-lsp lsp='(type parameter) F in filter2&amp;lt;T, F extends (arg: T) => boolean>(arr: T[], func: F): T[]'>F</data-lsp> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arg: T'>arg</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in filter2&amp;lt;T, F extends (arg: T) => boolean>(arr: T[], func: F): T[]'>T</data-lsp>) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> boolean&gt;(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: T[]'>arr</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in filter2&amp;lt;T, F extends (arg: T) => boolean>(arr: T[], func: F): T[]'>T</data-lsp>[], </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) func: F extends (arg: T) => boolean'>func</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) F in filter2&amp;lt;T, F extends (arg: T) => boolean>(arr: T[], func: F): T[]'>F</data-lsp>): <data-lsp lsp='(type parameter) T in filter2&amp;lt;T, F extends (arg: T) => boolean>(arr: T[], func: F): T[]'>T</data-lsp>[] {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: T[]'>arr</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Array&amp;lt;T>.filter(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[] (+1 overload)'>filter</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) func: F extends (arg: T) => boolean'>func</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMGAbKBTATgRgDwAqAfABQCGWWAXIgQNoC6ANMuBDeVgOY0ECUiALxFEAIzhxUGMmD69GiAN4AoRIiwYoILEgpYAdCnTYSoSHwDcygL7LlZ6PCRHMWAEyEWAMUQYAHphgACYAzoicPLQCwmISUjKkevLMrJA0XnK0CipqGlo6iHqGaK6mbJY2QA'>Try</a></div></pre>\n<p>We’ve created a type parameter <code>F</code> that <em>doesn’t relate two values</em>.\nThat’s always a red flag, because it means callers wanting to specify type arguments have to manually specify an extra type argument for no reason.\n<code>F</code> doesn’t do anything but make the function harder to read and reason about!</p>\n<blockquote>\n<p><strong>Rule</strong>: Always use as few type parameters as possible</p>\n</blockquote>\n<h4 id=\"type-parameters-should-appear-twice\" style=\"position:relative;\"><a href=\"#type-parameters-should-appear-twice\" aria-label=\"type parameters should appear twice permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Parameters Should Appear Twice</h4>\n<p>Sometimes we forget that function doesn’t need to be generic:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function greet&amp;lt;S extends string>(s: S): void'>greet</data-lsp>&lt;<data-lsp lsp='(type parameter) S in greet&amp;lt;S extends string>(s: S): void'>S</data-lsp> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> string&gt;(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: S extends string'>s</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) S in greet&amp;lt;S extends string>(s: S): void'>S</data-lsp>) {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #A31515\">\"Hello, \"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: S extends string'>s</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #000000\"><data-lsp lsp='function greet&amp;lt;&amp;quot;world&amp;quot;>(s: &amp;quot;world&amp;quot;): void'>greet</data-lsp>(</span><span style=\"color: #A31515\">\"world\"</span><span style=\"color: #000000\">);</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QDwGVHoAeU6YAJgM6IVSoxjIB8AFBQFyK4CUiA3gFCJEEBBTgAbdADpxcZMwBEACXTjZAGkQLEAampcA3PwC+-fmkxRFAdzipxZBYaA'>Try</a></div></pre>\n<p>We could just as easily have written a simpler version:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function greet(s: string): void'>greet</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: string'>s</data-lsp></span><span style=\"color: #000000\">: string) {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #A31515\">\"Hello, \"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: string'>s</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAcwE4FN1QBQGcBciuUqMYyAlIgN4BQiiECucANugHStzLYBEACXStuAGkR9EAaiIUA3LQC+QA'>Try</a></div></pre>\n<p>Remember, type parameters are for <em>relating the types of multiple values</em>.\nIf a type parameter is only used once in the function signature, it’s not relating anything.</p>\n<blockquote>\n<p><strong>Rule</strong>: If a type parameter only appears in one location, strongly reconsider if you actually need it</p>\n</blockquote>\n<h2 id=\"optional-parameters\" style=\"position:relative;\"><a href=\"#optional-parameters\" aria-label=\"optional parameters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optional Parameters</h2>\n<p>Functions in JavaScript often take a variable number of arguments.\nFor example, the <code>toFixed</code> method of <code>number</code> takes an optional digit count:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function f(n: number): void'>f</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) n: number'>n</data-lsp></span><span style=\"color: #000000\">: number) {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) n: number'>n</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Number.toFixed(fractionDigits?: number | undefined): string'>toFixed</data-lsp>()); </span><span style=\"color: #008000\">// 0 arguments</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) n: number'>n</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Number.toFixed(fractionDigits?: number | undefined): string'>toFixed</data-lsp>(</span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">)); </span><span style=\"color: #008000\">// 1 argument</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFGAXIsIC2AjAUwCcBKRAbwChFEIEBnOAGwIDom4BzNVqOAMRgAPAgBMUJEgG5EAelmIADIgCGRTrgJgo9arQbM2HbmF4DhYlAGZJM+YgCMq9Zu2UAvkA'>Try</a></div></pre>\n<p>We can model this in TypeScript by marking the parameter as <em>optional</em> with <code>?</code>:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function f(x?: number | undefined): void'>f</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: number | undefined'>x</data-lsp></span><span style=\"color: #000000\">?: number) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #000000\"><data-lsp lsp='function f(x?: number | undefined): void'>f</data-lsp>(); </span><span style=\"color: #008000\">// OK</span>\n<span style=\"color: #000000\"><data-lsp lsp='function f(x?: number | undefined): void'>f</data-lsp>(</span><span style=\"color: #09835A\">10</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// OK</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFADwPwC5FhAWwCMBTAJwEpEBvAKEUQHoHEA6NmgXxtXIG5HmAeQDS3FAEYADHwGIRQA'>Try</a></div></pre>\n<p>Although the parameter is specified as type <code>number</code>, the <code>x</code> parameter will actually have the type <code>number | undefined</code> because unspecified parameters in JavaScript get the value <code>undefined</code>.</p>\n<p>You can also provide a parameter <em>default</em>:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function f(x?: number): void'>f</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: number'>x</data-lsp></span><span style=\"color: #000000\"> = </span><span style=\"color: #09835A\">10</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAFAD0QXkQRgAwCUiA3gFCKID0liAdPaQL5A'>Try</a></div></pre>\n<p>Now in the body of <code>f</code>, <code>x</code> will have type <code>number</code> because any <code>undefined</code> argument will be replaced with <code>10</code>.\nNote that when a parameter is optional, callers can always pass <code>undefined</code>, as this simply simualtes a “missing” argument:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function f(x?: number | undefined): void'>f</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: number | undefined'>x</data-lsp></span><span style=\"color: #000000\">?: number): void;</span>\n<span style=\"color: #008000\">// cut</span>\n<span style=\"color: #008000\">// All OK</span>\n<span style=\"color: #000000\"><data-lsp lsp='function f(x?: number | undefined): void'>f</data-lsp>();</span>\n<span style=\"color: #000000\"><data-lsp lsp='function f(x?: number | undefined): void'>f</data-lsp>(</span><span style=\"color: #09835A\">10</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\"><data-lsp lsp='function f(x?: number | undefined): void'>f</data-lsp>(</span><span style=\"color: #0000FF\"><data-lsp lsp='var undefined'>undefined</data-lsp></span><span style=\"color: #000000\">);</span></code><a href='https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtVIAoAPAfgC55VkBbAIxBgEoKA3HLYAbgCgB6X+GGQY+AgIIQI8APIBpbogKMeigIwAGZQoJpQiLKhDBlQA'>Try</a></div></pre>\n<h3 id=\"optional-parameters-in-callbacks\" style=\"position:relative;\"><a href=\"#optional-parameters-in-callbacks\" aria-label=\"optional parameters in callbacks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optional Parameters in Callbacks</h3>\n<p>Once you’ve learned about optional parameters and function type expressions, it’s very easy to make the following mistakes when writing functions that invoke callbacks:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function myForEach(arr: any[], callback: (arg: any, index?: number | undefined) => void): void'>myForEach</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: any[]'>arr</data-lsp></span><span style=\"color: #000000\">: any[], <data-lsp lsp='(parameter) callback: (arg: any, index?: number | undefined) => void'>callback</data-lsp>: (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arg: any'>arg</data-lsp></span><span style=\"color: #000000\">: any, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) index: number | undefined'>index</data-lsp></span><span style=\"color: #000000\">?: number) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">for</span><span style=\"color: #000000\"> (</span><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let i: number'>i</data-lsp> </span><span style=\"color: #000000\">= </span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let i: number'>i</data-lsp></span><span style=\"color: #000000\"> &lt; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: any[]'>arr</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(property) Array&amp;lt;any>.length: number'>length</data-lsp>; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let i: number'>i</data-lsp></span><span style=\"color: #000000\">++) {</span>\n<span style=\"color: #000000\">    <data-lsp lsp='(parameter) callback: (arg: any, index?: number | undefined) => void'>callback</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: any[]'>arr</data-lsp></span><span style=\"color: #000000\">[</span><span style=\"color: #1A1A1A\"><data-lsp lsp='let i: number'>i</data-lsp></span><span style=\"color: #000000\">], </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let i: number'>i</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWwJ4DE4CcCiBDCACwAo8ssAuRPMVAbQF0AaRCPAG3YCMCBrK0lgDmVGqhYwwAEwCmADwD8VMCGRcZWAJSIAvAD5EANzgwp2gN4AoRImDZExdjKiIYuxAAYA3K8QAeanIAOicwIShCHxgAamiLaxtWDm4+QSw6GGZXTS8EgF9LPKA'>Try</a></div></pre>\n<p>What people usually <em>intend</em> when writing <code>index?</code> as an optional parameter is that they want both of these calls to be legal:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #000000\"><data-lsp lsp='function myForEach(arr: any[], callback: (arg: any, index?: number | undefined) => void): void'>myForEach</data-lsp>([</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">], (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) a: any'>a</data-lsp></span><span style=\"color: #000000\">) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) a: any'>a</data-lsp></span><span style=\"color: #000000\">));</span>\n<span style=\"color: #000000\"><data-lsp lsp='function myForEach(arr: any[], callback: (arg: any, index?: number | undefined) => void): void'>myForEach</data-lsp>([</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">], (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) a: any'>a</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) i: number | undefined'>i</data-lsp></span><span style=\"color: #000000\">) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) a: any'>a</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) i: number | undefined'>i</data-lsp></span><span style=\"color: #000000\">));</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMaBQATSAYwBsBDaSUAMwFcA7IgFwEs57QBbATwDEEAomSIALABS5QoCtFRl63ANoBdADSTQRMiRIAjYQGtUYigHM5C1aBb1CADwD8qerU66YASlABeAHygANzgWfFwPVCCQgG5cEFAAWkSiWiZE+NwefmghUTFFAEYrNCssNVATLz9NdkQ4EkgAOhI4UwqPGMzBYXECopKykysWSv8iGrrG5tayIY92oA'>Try</a></div></pre>\n<p>What this <em>actually</em> means is that <em><code>callback</code> might get invoked with one argument</em>.\nIn other words, the function definition says that the implementation might look like this:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function myForEach(arr: any[], callback: (arg: any, index?: number | undefined) => void): void'>myForEach</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: any[]'>arr</data-lsp></span><span style=\"color: #000000\">: any[], <data-lsp lsp='(parameter) callback: (arg: any, index?: number | undefined) => void'>callback</data-lsp>: (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arg: any'>arg</data-lsp></span><span style=\"color: #000000\">: any, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) index: number | undefined'>index</data-lsp></span><span style=\"color: #000000\">?: number) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">for</span><span style=\"color: #000000\"> (</span><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let i: number'>i</data-lsp> </span><span style=\"color: #000000\">= </span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let i: number'>i</data-lsp></span><span style=\"color: #000000\"> &lt; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: any[]'>arr</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(property) Array&amp;lt;any>.length: number'>length</data-lsp>; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let i: number'>i</data-lsp></span><span style=\"color: #000000\">++) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #008000\">// I don&apos;t feel like providing the index today</span>\n<span style=\"color: #000000\">    <data-lsp lsp='(parameter) callback: (arg: any, index?: number | undefined) => void'>callback</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: any[]'>arr</data-lsp></span><span style=\"color: #000000\">[</span><span style=\"color: #1A1A1A\"><data-lsp lsp='let i: number'>i</data-lsp></span><span style=\"color: #000000\">]);</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMaBQAzAVwDsBjAFwEs5jQBbATwDEEBRAQ1IAsAKd2VO2IMA2gF0ANKFLsANrIBGnANao+0AOaDhUysQAmkAB4B+VMUJ0FMAJSgAvAD5QANziV9dgN65QofAigPLKQ5KCUDqAADADc4aAAPKD80AB0IcQa5FxxlADUed6+fqAgoACSoPo0AORh+JCQsqCylMqQoAAO8C4eehqg2R16hkaDcPrsDMV+MvJKpMrq0CKUYjYxxQC+uFtAA'>Try</a></div></pre>\n<p>In turn, TypeScript will enforce this meaning and issue errors that aren’t really possible:</p>\n<!-- prettier-ignore -->\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #000000\"><data-lsp lsp='function myForEach(arr: any[], callback: (arg: any, index?: number | undefined) => void): void'>myForEach</data-lsp>([</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">], (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) a: any'>a</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) i: number | undefined'>i</data-lsp></span><span style=\"color: #000000\">) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-err><data-lsp lsp='(parameter) i: number | undefined'>i</data-lsp></data-err></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Number.toFixed(fractionDigits?: number | undefined): string'>toFixed</data-lsp>());</span>\n<span class=\"error\"><span>Object is possibly 'undefined'.</span><span class=\"code\">2532</span></span><span class=\"error-behind\">Object is possibly 'undefined'.</span><span style=\"color: #000000\">});</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMaBQATSAYwBsBDaSUAMwFcA7IgFwEs57QBbATwDEEAomSIALABS5QoCtFRl63ANoBdADSTQRMiRIAjYQGtUYigHM5C1aBb1CADwD8qerU66YASlABeAHygANzgWfFwPVCCQgG5cEFAAWkSiWiZE+NwefmghUTFFAEYrNCssNVATKxYvP1AAbw0idkQ4EkgAOhI4UzEWNqY4XhY7SHwxDw8YgF8JoA'>Try</a></div></pre>\n<p>In JavaScript, if you call a function with more arguments than there are parameters, the extra arguments are simply ignored.\nTypeScript behaves the same way.\nFunctions with fewer parameters (of the same types) can always take the place of functions with more parameters.</p>\n<blockquote>\n<p>When writing a function type for a callback, <em>never</em> write an optional parameter unless you intend to <em>call</em> the function without passing that argument</p>\n</blockquote>\n<h2 id=\"function-overloads\" style=\"position:relative;\"><a href=\"#function-overloads\" aria-label=\"function overloads permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Function Overloads</h2>\n<p>Some JavaScript functions can be called in a variety of argument counts and types.\nFor example, you might write a function to produce a <code>Date</code> that takes either a timestamp (one argument) or a month/day/year specification (three arguments).</p>\n<p>In TypeScript, we can specify a function that can be called in different ways by writing <em>overload signatures</em>.\nTo do this, write some number of function signatures (usually two or more), followed by the body of the function:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function makeDate(timestamp: number): Date (+1 overload)'>makeDate</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) timestamp: number'>timestamp</data-lsp></span><span style=\"color: #000000\">: number): <data-lsp lsp='interface Date'>Date</data-lsp>;</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function makeDate(m: number, d: number, y: number): Date (+1 overload)'>makeDate</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) m: number'>m</data-lsp></span><span style=\"color: #000000\">: number, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) d: number'>d</data-lsp></span><span style=\"color: #000000\">: number, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) y: number'>y</data-lsp></span><span style=\"color: #000000\">: number): <data-lsp lsp='interface Date'>Date</data-lsp>;</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function makeDate(timestamp: number): Date (+1 overload)'>makeDate</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) mOrTimestamp: number'>mOrTimestamp</data-lsp></span><span style=\"color: #000000\">: number, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) d: number | undefined'>d</data-lsp></span><span style=\"color: #000000\">?: number, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) y: number | undefined'>y</data-lsp></span><span style=\"color: #000000\">?: number): <data-lsp lsp='interface Date'>Date</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) d: number | undefined'>d</data-lsp></span><span style=\"color: #000000\"> !== </span><span style=\"color: #0000FF\"><data-lsp lsp='var undefined'>undefined</data-lsp></span><span style=\"color: #000000\"> && </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) y: number | undefined'>y</data-lsp></span><span style=\"color: #000000\"> !== </span><span style=\"color: #0000FF\"><data-lsp lsp='var undefined'>undefined</data-lsp></span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> <data-lsp lsp='var Date: DateConstructor&amp;#13;new (year: number, month: number, date?: number | undefined, hours?: number | undefined, minutes?: number | undefined, seconds?: number | undefined, ms?: number | undefined) => Date (+4 overloads)'>Date</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) y: number'>y</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) mOrTimestamp: number'>mOrTimestamp</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) d: number'>d</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">  } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> <data-lsp lsp='var Date: DateConstructor&amp;#13;new (value: string | number | Date) => Date (+4 overloads)'>Date</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) mOrTimestamp: number'>mOrTimestamp</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const d1: Date'>d1</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function makeDate(timestamp: number): Date (+1 overload)'>makeDate</data-lsp>(</span><span style=\"color: #09835A\">12345678</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const d2: Date'>d2</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function makeDate(m: number, d: number, y: number): Date (+1 overload)'>makeDate</data-lsp>(</span><span style=\"color: #09835A\">5</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">5</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">5</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const d3: Date'>d3</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function makeDate(timestamp: number): Date (+1 overload)'>makeDate</data-lsp>(</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">);</span>\n<span class=\"error\"><span>No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.</span><span class=\"code\">2575</span></span><span class=\"error-behind\">No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsGBQAzAVwDsBjAFwEs5jQBbAQwGtIARB8yACirskXIM6AB1TFCdAEYwAlKnacA3ARIVqtRiwXc6YidOgAaUABM9UmMYCe5g3NDblRMlRr1mbDjoDy0ACqUfAJCoqDiFkamAPy2lqBWMWH6svJeoADeuKCglPigXCagAIQAvCWgJCaQ+JTEkIUAZA3xxWUVxFU1dSYyGVnZoNCQ5ITQtHUA7g5eXFbGdL4BQYIixj3K2QC+oJAANoiQfQODw6PjkFPaXAv+gfwrwjIboJu4r6Q0AqYAjKDlmp5OFxvmgAMwAFgwADYsAAOJ64D7EL4mNB-dxaGYYYzY0AYBFIlGg9EAq7fYygp5AA'>Try</a></div></pre>\n<p>In this example, we wrote two overloads: one accepting one argument, and another accepting three arguments.\nThese first two signatures are called the <em>overload signatures</em>.</p>\n<p>Then, we wrote a function implementation with a compatible signature.\nFunctions have an <em>implementation</em> signature, but this signature can’t be called directly.\nEven though we wrote a function with two optional parameters after the required one, it can’t be called with two parameters!</p>\n<h3 id=\"overload-signatures-and-the-implementation-signature\" style=\"position:relative;\"><a href=\"#overload-signatures-and-the-implementation-signature\" aria-label=\"overload signatures and the implementation signature permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overload Signatures and the Implementation Signature</h3>\n<p>This is a common source of confusion.\nOften people will write code like this and not understand why there is an error:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function fn(x: string): void'>fn</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: string'>x</data-lsp></span><span style=\"color: #000000\">: string): void;</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function fn(x: string): void'>fn</data-lsp>() {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #008000\">// Expected to be able to call with zero arguments</span>\n<span style=\"color: #000000\"><data-err><data-lsp lsp='function fn(x: string): void'>fn</data-lsp>();</data-err></span>\n<span class=\"error\"><span>Expected 1 arguments, but got 0.</span><span class=\"code\">2554</span></span><span class=\"error-behind\">Expected 1 arguments, but got 0.</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYBQAzAVwDsBjAFwEs5jR9iAKAD1UXOkuIHMBKVANziUAJgG4CJCtVr0GPUAG9coUCFAA6TbgC+uNQFEmAB0gVIw0OTigARpFABDGwBt7V0KQfPnoAO6VyAAtQAC8YawdoLkIAW0hickQCRh5RIA'>Try</a></div></pre>\n<p>Again, the signature used to write the function body can’t be “seen” from the outside.</p>\n<blockquote>\n<p>The signature of the <em>implementation</em> is not visible from the outside.\nWhen writing an overloaded function, you should always have <em>two</em> or more signatures above the implementation of the function.</p>\n</blockquote>\n<p>The implementation signature must also be <em>compatible</em> with the overload signatures.\nFor example, these functions have errors because the implementation signature doesn’t match the overloads in a correct way:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function fn(x: boolean): void (+1 overload)'>fn</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: boolean'>x</data-lsp></span><span style=\"color: #000000\">: boolean): void;</span>\n<span style=\"color: #008000\">// Argument type isn&apos;t right</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"><data-err> <data-lsp lsp='function fn(x: string): void (+1 overload)'>fn</data-lsp>(</data-err></span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: string'>x</data-lsp></span><span style=\"color: #000000\">: string): void;</span>\n<span class=\"error\"><span>This overload signature is not compatible with its implementation signature.</span><span class=\"code\">2394</span></span><span class=\"error-behind\">This overload signature is not compatible with its implementation signature.</span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function fn(x: boolean): void (+1 overload)'>fn</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: boolean'>x</data-lsp></span><span style=\"color: #000000\">: boolean) {}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAUAGYCuAdgMYAuAlnCaASQBQAeqARnHADaQCGJASlQA3OFQAmAbjwhQAQWgBzIgFtIJCqAoBPAA6RQVRCQDkm6FUUALCoVKUadBi1SIKFkoqGhRE6cXJqWnomVlAObj5BUABvAF8gA'>Try</a></div></pre>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function fn(x: string): string (+1 overload)'>fn</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: string'>x</data-lsp></span><span style=\"color: #000000\">: string): string;</span>\n<span style=\"color: #008000\">// Return type isn&apos;t right</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"><data-err> <data-lsp lsp='function fn(x: number): boolean (+1 overload)'>fn</data-lsp>(</data-err></span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: number'>x</data-lsp></span><span style=\"color: #000000\">: number): boolean;</span>\n<span class=\"error\"><span>This overload signature is not compatible with its implementation signature.</span><span class=\"code\">2394</span></span><span class=\"error-behind\">This overload signature is not compatible with its implementation signature.</span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function fn(x: string): string (+1 overload)'>fn</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: string | number'>x</data-lsp></span><span style=\"color: #000000\">: string | number) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"oops\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYCcAWAUAGYCuAdgMYAuAlnCaASQBQAeqiF0VJA5gJRscu3ANx4QoAEqQKRaHQoBPAA6RQVRCQDkFUJ24ALCoVKUadBi1QkiAWwBGMfqDtw4AG0gBDEqOLlqtPRMrKDsnDygAD6g1vaOoADeeKC60rJ0AESuSogZogC+QA'>Try</a></div></pre>\n<h3 id=\"writing-good-overloads\" style=\"position:relative;\"><a href=\"#writing-good-overloads\" aria-label=\"writing good overloads permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Writing Good Overloads</h3>\n<p>Like generics, there are a few guidelines you should follow when using function overloads.\nFollowing these principles will make your function easier to call, easier to understand, and easier to implement.</p>\n<p>Let’s consider a function that returns the length of a string or an array:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function len(s: string): number (+1 overload)'>len</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: string'>s</data-lsp></span><span style=\"color: #000000\">: string): number;</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function len(arr: any[]): number (+1 overload)'>len</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: any[]'>arr</data-lsp></span><span style=\"color: #000000\">: any[]): number;</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function len(s: string): number (+1 overload)'>len</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: any'>x</data-lsp></span><span style=\"color: #000000\">: any) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: any'>x</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='any'>length</data-lsp>;</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQGcBcitQBOMYA5gJR5ggC2ARqoQNwBQoksCK6GAhoYTy8wATwDaAXUqJq9Rq3bR4SNJgAeQ0eUQBvFokSFUUEISRqAdKtJQAFqwC+QA'>Try</a></div></pre>\n<p>This function is fine; we can invoke it with strings or arrays.\nHowever, we can’t invoke it with a value that might be a string <em>or</em> an array, because TypeScript can only resolve a function call to a single overload:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #000000\"><data-lsp lsp='function len(s: string): number (+1 overload)'>len</data-lsp>(</span><span style=\"color: #A31515\">\"\"</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// OK</span>\n<span style=\"color: #000000\"><data-lsp lsp='function len(arr: any[]): number (+1 overload)'>len</data-lsp>([</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">]); </span><span style=\"color: #008000\">// OK</span>\n<span style=\"color: #000000\"><data-lsp lsp='function len(s: string): number (+1 overload)'>len</data-lsp>(<data-lsp lsp='var Math: Math'>Math</data-lsp>.<data-lsp lsp='(method) Math.random(): number'>random</data-lsp>() > </span><span style=\"color: #09835A\">0.5</span><span style=\"color: #000000\"> ? </span><span style=\"color: #A31515\">\"hello\"</span><span style=\"color: #000000\"> : [</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">]);</span>\n<span class=\"error\"><span>No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'.</span><span class=\"code\">2769</span></span><span class=\"error-behind\">No overload matches this call.\n  Overload 1 of 2, '(s: string): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'string'.\n      Type 'number[]' is not assignable to type 'string'.\n  Overload 2 of 2, '(arr: any[]): number', gave the following error.\n    Argument of type 'number[] | \"hello\"' is not assignable to parameter of type 'any[]'.\n      Type 'string' is not assignable to type 'any[]'.</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYBsBOAUACaQDGANgIbSSgBmArgHbEAuAlnA6KZAwBQqhEzaKwYBzAJSoGdALYAjGAG5CJClVqMW7Ttz6VoqcgwCeAbQC6U0DIXK8IUAFoXxOsxdO8e3gCJfEkqgjgDyANLePLxmAAxWQaERPgCy5MwAFgB00MYEcLK8EqAAfKAxmQCsoAD8oL7pkKSkcL6gqLHxQA'>Try</a></div></pre>\n<p>Because both overloads have the same argument count and same return type, we can instead write a non-overloaded version of the function:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function len(x: any[] | string): number'>len</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: string | any[]'>x</data-lsp></span><span style=\"color: #000000\">: any[] | string) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: string | any[]'>x</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(property) length: number'>length</data-lsp>;</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAGwKZgBQA8BciCGYAngNoC6iAPogM5QBOMYA5gJSIDeAUIovalBD0kWAHRoWUABYBuLgF8gA'>Try</a></div></pre>\n<p>This is much better!\nCallers can invoke this with either sort of value, and as an added bonus, we don’t have to figure out a correct implementation signature.</p>\n<blockquote>\n<p>Always prefer parameters with union types instead of overloads when possible</p>\n</blockquote>\n<h2 id=\"other-types-to-know-about\" style=\"position:relative;\"><a href=\"#other-types-to-know-about\" aria-label=\"other types to know about permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Other Types to Know About</h2>\n<p>There are some additional types you’ll want to recognize that appear often when working with function types.\nLike all types, you can use them everywhere, but these are especially relevant in the context of functions.</p>\n<h3 id=\"void\" style=\"position:relative;\"><a href=\"#void\" aria-label=\"void permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>void</code></h3>\n<p><code>void</code> represents the return value of functions which don’t return a value.\nIt’s the inferred type any time a function doesn’t have any <code>return</code> statements, or doesn’t return any explicit value from those return statements:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #008000\">// The inferred return type is void</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function noop(): void'>noop</data-lsp>() {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEBUAsFNQSwHYDNoCdXQCagwFwK6oKi4CeADrHAM6gBuA9nJgFBL4IDGucDxCDBuQAUASlABvFqBzQCRANwsAvkA'>Try</a></div></pre>\n<p>In JavaScript, a function that doesn’t return any value will implicitly return the value <code>undefined</code>.\nHowever, <code>void</code> and <code>undefined</code> are not the same thing in TypeScript.\nSee the reference page [[Why void is a special type]] for a longer discussion about this.</p>\n<blockquote>\n<p><code>void</code> is not the same as <code>undefined</code>.</p>\n</blockquote>\n<h3 id=\"object\" style=\"position:relative;\"><a href=\"#object\" aria-label=\"object permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>object</code></h3>\n<p>The special type <code>object</code> refers to any value that isn’t a primitive (<code>string</code>, <code>number</code>, <code>boolean</code>, <code>symbol</code>, <code>null</code>, or <code>undefined</code>).\nThis is different from the <em>empty object type</em> <code>{ }</code>, and also different from the global type <code>Object</code>.\nYou can read the reference page about [[The global types]] for information on what <code>Object</code> is for - long story short, don’t ever use <code>Object</code>.</p>\n<blockquote>\n<p><code>object</code> is not <code>Object</code>. <strong>Always</strong> use <code>object</code>!</p>\n</blockquote>\n<p>Note that in JavaScript, function values are objects: They have properties, have <code>Object.prototype</code> in their prototype chain, are <code>instanceof Object</code>, you can call <code>Object.keys</code> on them, and so on.\nFor this reason, function types are considered to be <code>object</code>s in TypeScript.</p>\n<h3 id=\"unknown\" style=\"position:relative;\"><a href=\"#unknown\" aria-label=\"unknown permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>unknown</code></h3>\n<p>The <code>unknown</code> type represents <em>any</em> value.\nThis is similar to the <code>any</code> type, but is safer because it’s not legal to do anything with an <code>unknown</code> value:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function f1(a: any): void'>f1</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) a: any'>a</data-lsp></span><span style=\"color: #000000\">: any) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) a: any'>a</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='any'>b</data-lsp>(); </span><span style=\"color: #008000\">// OK</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function f2(a: unknown): void'>f2</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) a: unknown'>a</data-lsp></span><span style=\"color: #000000\">: unknown) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-err><data-lsp lsp='(parameter) a: unknown'>a</data-lsp></data-err></span><span style=\"color: #000000\">.<data-lsp lsp='any'>b</data-lsp>();</span>\n<span class=\"error\"><span>Object is of type 'unknown'.</span><span class=\"code\">2571</span></span><span class=\"error-behind\">Object is of type 'unknown'.</span><span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGAUAGYCuAdgMYAuAlnCaATgBQCGqzJAngJSgDeeoUMwB0AI0ZcA3KBCgA8gGk8AX0KlKNOgTQtUpANYk4AdxI9+gkeKkqgA'>Try</a></div></pre>\n<p>This is useful when describing function types because you can describe functions that accept any value without having <code>any</code> values in your function body.</p>\n<p>Conversely, you can describe a function that returns a value of unknown type:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function safeParse(s: string): unknown'>safeParse</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: string'>s</data-lsp></span><span style=\"color: #000000\">: string): unknown {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> <data-lsp lsp='var JSON: JSON'>JSON</data-lsp>.<data-lsp lsp='(method) JSON.parse(text: string, reviver?: ((this: any, key: string, value: any) => any) | undefined): any'>parse</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: string'>s</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #008000\">// Need to be careful with &apos;obj&apos;!</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const obj: unknown'>obj</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function safeParse(s: string): unknown'>safeParse</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const someRandomString: string'>someRandomString</data-lsp></span><span style=\"color: #000000\">);</span></code><a href='https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEYD2A7AzgF3mpBbEASlCsHgMoYwCWKA5gFzaU20DcAUAPSfwC0-YAK4Z+vdgDNBKMBiqpsUcSAAKsNCAAUaRpmp0AlIykBrFEgDuKeAG928eHAyCYVgFJkA8gDkAdAAc1TTR9DgBfdi4eLxAQYHgMJHgAIwQwWBBJCHhzKgwAC3gAciQkgCtCgEJ2ZHQsEtL4AF4FJVUYdS08QmJSXAo9WhCgA'>Try</a></div></pre>\n<h3 id=\"never\" style=\"position:relative;\"><a href=\"#never\" aria-label=\"never permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>never</code></h3>\n<p>Some functions <em>never</em> return a value:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function fail(msg: string): never'>fail</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) msg: string'>msg</data-lsp></span><span style=\"color: #000000\">: string): never {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">throw</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> <data-lsp lsp='var Error: ErrorConstructor&amp;#13;new (message?: string | undefined) => Error'>Error</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) msg: string'>msg</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMAhjANgCgLYGcDmAXIrlAE4xj4CUxYApgG71mIDeAUIolABZlwA7ogbCAomQFkcBagG4OAXyA'>Try</a></div></pre>\n<p>The <code>never</code> type represents values which are <em>never</em> observed.\nIn a return type, this means that the function throws an exception or terminates execution of the program.</p>\n<p><code>never</code> also appears when TypeScript determines there’s nothing left in a union.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function fn(x: string | number): void'>fn</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: string | number'>x</data-lsp></span><span style=\"color: #000000\">: string | number) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #0000FF\">typeof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: string | number'>x</data-lsp></span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"string\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #008000\">// do something</span>\n<span style=\"color: #000000\">  } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #0000FF\">typeof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: number'>x</data-lsp></span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"number\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #008000\">// do something else</span>\n<span style=\"color: #000000\">  } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: never'>x</data-lsp></span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// has type &apos;never&apos;!</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMMAKAHgLkQZygJxjAHNEAfRMEAWwCMBTfASkQG8AoRRGYRVKAJ4AHenF7pEAXmmIARHkIlZLDly4B6dYgAmcXHGr0oACyLFOiAL6J6AGxz1uvfsNHipM2VTqNlbCxpauvqGJmY29vQW1nYO-mqI6ADciJqIxgCGOIiCIogA5GD0AG6M+QCE0eyWQA'>Try</a></div></pre>\n<h3 id=\"function\" style=\"position:relative;\"><a href=\"#function\" aria-label=\"function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>Function</code></h3>\n<p>The global type <code>Function</code> describes properties like <code>bind</code>, <code>call</code>, <code>apply</code>, and others present on all function values in JavaScript.\nIt also has the special property that values of type <code>Function</code> can always be called; these calls return <code>any</code>:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function doSomething(f: Function): void'>doSomething</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) f: Function'>f</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='interface Function'>Function</data-lsp>) {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='(parameter) f: Function'>f</data-lsp>(</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAEzgZTgWwKZQBYxgDmAFMAFyIBi408YAlIgN4BQiiwJAjADSIAmfgGYGAblYBfIA'>Try</a></div></pre>\n<p>This is an <em>untyped function call</em> and is generally best avoided because of the unsafe <code>any</code> return type.</p>\n<p>If need to accept an arbitrary function but don’t intend to call it, the type <code>() => void</code> is generally safer.</p>\n<h2 id=\"rest-parameters-and-arguments\" style=\"position:relative;\"><a href=\"#rest-parameters-and-arguments\" aria-label=\"rest parameters and arguments permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rest Parameters and Arguments</h2>\n<p><strong>Background reading</strong>: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters\">Rest Parameters</a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\">Spread Syntax</a></p>\n<h3 id=\"rest-parameters\" style=\"position:relative;\"><a href=\"#rest-parameters\" aria-label=\"rest parameters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rest Parameters</h3>\n<p>In addition to using optional parameters or overloads to make functions that can accept a variety of fixed argument counts, we can also define functions that take an <em>unbounded</em> number of arguments using <em>rest parameters</em>.</p>\n<p>A rest parameter appears after all other parameters, and uses the <code>...</code> syntax:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function multiply(n: number, ...m: number[]): number[]'>multiply</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) n: number'>n</data-lsp></span><span style=\"color: #000000\">: number, ...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) m: number[]'>m</data-lsp></span><span style=\"color: #000000\">: number[]) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) m: number[]'>m</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Array&amp;lt;number>.map&amp;lt;number>(callbackfn: (value: number, index: number, array: number[]) => number, thisArg?: any): number[]'>map</data-lsp>((</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: number'>x</data-lsp></span><span style=\"color: #000000\">) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) n: number'>n</data-lsp></span><span style=\"color: #000000\"> * </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: number'>x</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #008000\">// &apos;a&apos; gets value [10, 20, 30, 40]</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const a: number[]'>a</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function multiply(n: number, ...m: number[]): number[]'>multiply</data-lsp>(</span><span style=\"color: #09835A\">10</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">4</span><span style=\"color: #000000\">);</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAWxAG1gBzQTwBRgBciYIyARgKYBOANIgHRPLGkU0DaAugJSIDeAKESJqlKCGpJkDZAENMePAA8+AXgB8JRACpEqgNyCAvoID0ZxAHI5VxAHNxAZ0QA3OWhCVEHAIwAGegAmQMQAZlCAFn8uQQgEJyhEOUQ1FHQsXDwA+l9g+jD6SJ4DIA'>Try</a></div></pre>\n<p>In TypeScript, the type annotation on these parameters is implicitly <code>any[]</code> instead of <code>any</code>, and any type annotation given must be of the form <code>Array&#x3C;T></code>or <code>T[]</code>, or a tuple type (which we’ll learn about later).</p>\n<h3 id=\"rest-arguments\" style=\"position:relative;\"><a href=\"#rest-arguments\" aria-label=\"rest arguments permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rest Arguments</h3>\n<p>Conversely, we can <em>provide</em> a variable number of arguments from an array using the spread syntax.\nFor example, the <code>push</code> method of arrays takes any number of arguments:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const arr1: number[]'>arr1</data-lsp> </span><span style=\"color: #000000\">= [</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">];</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const arr2: number[]'>arr2</data-lsp> </span><span style=\"color: #000000\">= [</span><span style=\"color: #09835A\">4</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">5</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">6</span><span style=\"color: #000000\">];</span>\n<span style=\"color: #1A1A1A\"><data-lsp lsp='const arr1: number[]'>arr1</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Array&amp;lt;number>.push(...items: number[]): number'>push</data-lsp>(...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const arr2: number[]'>arr2</data-lsp></span><span style=\"color: #000000\">);</span></code><a href='https://www.typescriptlang.org/play/#code/MYewdgzgLgBAhgJwQRhgXhgbWQGhgJjwGYBdAbgChRJZEF90sAWPAVjwDZyK7kA6AA4BXCAAsAFHyl18ASjJA'>Try</a></div></pre>\n<p>Note that in general, TypeScript does not assume that arrays are immutable.\nThis can lead to some surprising behavior:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #008000\">// Inferred type is number[] -- \"an array with zero or more numbers\",</span>\n<span style=\"color: #008000\">// not specfically two numbers</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const args: number[]'>args</data-lsp> </span><span style=\"color: #000000\">= [</span><span style=\"color: #09835A\">8</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">5</span><span style=\"color: #000000\">];</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const angle: number'>angle</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='var Math: Math'>Math</data-lsp>.<data-lsp lsp='(method) Math.atan2(y: number, x: number): number'>atan2</data-lsp>(...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const args: number[]'>args</data-lsp></span><span style=\"color: #000000\">);</span>\n<span class=\"error\"><span>Expected 2 arguments, but got 0 or more.</span><span class=\"code\">2556</span></span><span class=\"error-behind\">Expected 2 arguments, but got 0 or more.</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMDYBQJQBJAOwDMZpIATUAFwE8AHSUAS0VGIFcBbAIxgBtALqgAtGNAAiAIbFQM2DPqgA7q1oALUAC8YcUAlA8ELbvxiIpAGnxhicWqETMAxqVauZAG28raqgbmAki4rnDEiE6KAOYcALygggAc1qAYwgDcYRFRCsQx3iyJALIyWgB05XJoABQVDbGIAJSZQA'>Try</a></div></pre>\n<p>The best fix for this situation depends a bit on your code, but in general a <code>const</code> context is the most straightforward solution:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #008000\">// Inferred as 2-length tuple</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const args: readonly [8, 5]'>args</data-lsp> </span><span style=\"color: #000000\">= [</span><span style=\"color: #09835A\">8</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">5</span><span style=\"color: #000000\">] </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> <data-lsp lsp='any'>const</data-lsp>;</span>\n<span style=\"color: #008000\">// OK</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const angle: number'>angle</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='var Math: Math'>Math</data-lsp>.<data-lsp lsp='(method) Math.atan2(y: number, x: number): number'>atan2</data-lsp>(...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const args: readonly [8, 5]'>args</data-lsp></span><span style=\"color: #000000\">);</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEEkDsDMFMCd6wCagIYGdQCYC0AbWSAcwBcALUUgVwAdCAoAYwHtINT15isBeUANoAOADSgArAF10WVu1IBuBiFAB5ANLM2HdCUKh+AWTQUAdCbSRsAClN203DAEoFQA'>Try</a></div></pre>\n<!-- TODO link to downlevel iteration -->\n<h2 id=\"parameter-destructuring\" style=\"position:relative;\"><a href=\"#parameter-destructuring\" aria-label=\"parameter destructuring permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parameter Destructuring</h2>\n<blockquote>\n<blockquote>\n<p><strong>Background reading</strong>: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">Destructuring Assignment</a></p>\n</blockquote>\n</blockquote>\n<p>You can use parameter destructuring to conveniently unpack objects provided as an argument into one or more local variables in the function body.\nIn JavaScript, it looks like this:</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> sum({ </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">c</span><span style=\"color: #000000\"> }) {</span>\n<span style=\"color: #000000\">  console.log(</span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">c</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #000000\">sum({ a: </span><span style=\"color: #09835A\">10</span><span style=\"color: #000000\">, b: </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">, c: </span><span style=\"color: #09835A\">9</span><span style=\"color: #000000\"> });</span></code></div></pre>\n<p>The type annotation for the object goes after the destructuring syntax:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function sum({ a, b, c }: {&amp;#13;    a: number;&amp;#13;    b: number;&amp;#13;    c: number;&amp;#13;}): void'>sum</data-lsp>({ </span><span style=\"color: #1A1A1A\"><data-lsp lsp='var a: number'>a</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='var b: number'>b</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='var c: number'>c</data-lsp></span><span style=\"color: #000000\"> }: { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) a: number'>a</data-lsp></span><span style=\"color: #000000\">: number; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) b: number'>b</data-lsp></span><span style=\"color: #000000\">: number; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) c: number'>c</data-lsp></span><span style=\"color: #000000\">: number }) {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='var a: number'>a</data-lsp></span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\"><data-lsp lsp='var b: number'>b</data-lsp></span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\"><data-lsp lsp='var c: number'>c</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZxAWwBQG9EEMA0iARoRIgL4BciOu1Y6RApgE4Dcx9jrHEXazFhQCUNAFCJEEBMjgAbJgDo5cAOYZciANTFtU4WzHkgA'>Try</a></div></pre>\n<p>This can look a bit verbose, but you can use a named type here as well:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #008000\">// Same as prior example</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> <data-lsp lsp='type ABC = {&amp;#13;    a: number;&amp;#13;    b: number;&amp;#13;    c: number;&amp;#13;}'>ABC</data-lsp> = { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) a: number'>a</data-lsp></span><span style=\"color: #000000\">: number; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) b: number'>b</data-lsp></span><span style=\"color: #000000\">: number; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) c: number'>c</data-lsp></span><span style=\"color: #000000\">: number };</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function sum({ a, b, c }: ABC): void'>sum</data-lsp>({ </span><span style=\"color: #1A1A1A\"><data-lsp lsp='var a: number'>a</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='var b: number'>b</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='var c: number'>c</data-lsp></span><span style=\"color: #000000\"> }: <data-lsp lsp='type ABC = {&amp;#13;    a: number;&amp;#13;    b: number;&amp;#13;    c: number;&amp;#13;}'>ABC</data-lsp>) {</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='var a: number'>a</data-lsp></span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\"><data-lsp lsp='var b: number'>b</data-lsp></span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\"><data-lsp lsp='var c: number'>c</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEGUEMFsFNUgZ1ABwE4EsD2bSwB4woA2sAUAC4CeK8AggEIDCoAvKAN4IBcoAdgFdoAI1hoA3KGG9BIsZIDGMoaNwBfcWQBmAvgorY+oREIAUXSABop1haDW9GTAJScyoUAqx9EWUgDpiLABzU0hQAGopSM9nTTUgA'>Try</a></div></pre>\n<h2 id=\"assignability-of-functions\" style=\"position:relative;\"><a href=\"#assignability-of-functions\" aria-label=\"assignability of functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Assignability of Functions</h2>\n<h3 id=\"return-type-void\" style=\"position:relative;\"><a href=\"#return-type-void\" aria-label=\"return type void permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Return type <code>void</code></h3>\n<p>The <code>void</code> return type for functions can produce some unusual, but expected behavior.</p>\n<p>Contextual typing with a return type of <code>void</code> does <strong>not</strong> force functions to <strong>not</strong> return something. Another way to say this is a contextual function type with a <code>void</code> return type (<code>type vf = () => void</code>), when implemented, can return <em>any</em> other value, but it will be ignored.</p>\n<p>Thus, the following implementations of the type <code>() => void</code> are valid:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> <data-lsp lsp='type voidFunc = () => void'>voidFunc</data-lsp> = () </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void</span>\n\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const f1: voidFunc'>f1</data-lsp></span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> <data-lsp lsp='type voidFunc = () => void'>voidFunc</data-lsp> </span><span style=\"color: #000000\">= () </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">true</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const f2: voidFunc'>f2</data-lsp></span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> <data-lsp lsp='type voidFunc = () => void'>voidFunc</data-lsp> </span><span style=\"color: #000000\">= () </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">true</span>\n\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const f3: voidFunc'>f3</data-lsp></span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> <data-lsp lsp='type voidFunc = () => void'>voidFunc</data-lsp> </span><span style=\"color: #000000\">= </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> () {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">true</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAKCqzgwGdgoAzARgC4Ll1s9CSucgG8qUKACcIwNBIxRgEtBCoBfGnUbMWAJi7wemHPmJkFSlbXpNWAZn2Vex1keAJ6AqKPFSZc88pqQA'>Try</a></div></pre>\n<p>And when the return value of one of these functions is assigned to another variable, it will retain the type of <code>void</code>:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const v1: void'>v1</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='const f1: () => void'>f1</data-lsp>()</span>\n\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const v2: void'>v2</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='const f2: () => void'>f2</data-lsp>()</span>\n\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const v3: void'>v3</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='const f3: () => void'>f3</data-lsp>()</span></code><a href='https://www.typescriptlang.org/play/#code/C4TwDgpgBAbg9gSwCYDECuA7AxlAvFACgEo8A+WRJAKCqzgwGdgoAzARgC4Ll1s9CSucgG8qUKACcIwNBIxRgEtBCoBfGnUbMWAJi7wemHPmJkFSlbXpNWAZn2Vex1keAJ6AqKPFSZc88pqVAD0wVAAtJFYaMCR4VZasGz87MQa1swwOik6aQk2MLYptsRAA'>Try</a></div></pre>\n<p>This behavior exists so that the following code is valid even though <code>Array.prototype.push</code> returns a number and the <code>Array.prototype.forEach</code> method expects a function with a return type of <code>void</code>.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const src: number[]'>src</data-lsp> </span><span style=\"color: #000000\">= [</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">]</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const dst: number[]'>dst</data-lsp> </span><span style=\"color: #000000\">= [</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">]</span>\n\n<span style=\"color: #1A1A1A\"><data-lsp lsp='const src: number[]'>src</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Array&amp;lt;number>.forEach(callbackfn: (value: number, index: number, array: number[]) => void, thisArg?: any): void'>forEach</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) el: number'>el</data-lsp></span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const dst: number[]'>dst</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Array&amp;lt;number>.push(...items: number[]): number'>push</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) el: number'>el</data-lsp></span><span style=\"color: #000000\">))</span></code><a href='https://www.typescriptlang.org/play/#code/MYewdgzgLgBBBOwYF4YG0CMAaGAmHAzALoBQoksAJtCugAykkLAB0AZiPAKICGwAFgAoApgBsUAPhjUoLAA4BXCELEBKVUA'>Try</a></div></pre>\n<p>There is one other special case to be aware of, when a literal function definition has a <code>void</code> return type, that function must <strong>not</strong> return anything.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function f2(): void'>f2</data-lsp> (): void {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// @ts-expect-error</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">true</span><span style=\"color: #000000\"> </span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const f3: () => void'>f3</data-lsp> </span><span style=\"color: #000000\">= </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (): void {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// @ts-expect-error</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">true</span><span style=\"color: #000000\"> </span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMATIgFASgFyIG5wwAmiA3gFCKID01iAAlAM4C0ApgB4AOb07ATvzj9Kifmygh+SKPxBtE5AL7lyEBEyjIAzIgC8ycNHhIsuAsTKjaDZu268oAoSKrjJ0xLPmKlQA'>Try</a></div></pre>\n<p>For more on <code>void</code> please refer to these other documentation entries:</p>\n<ul>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/basic-types.html#void\">v1 handbook</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/functions.html#void\">v2 handbook</a></li>\n<li><a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-functions-returning-non-void-assignable-to-function-returning-void\">FAQ - “Why are functions returning non-void assignable to function returning void?”</a></li>\n</ul>","headings":[{"value":"Function Type Expressions","depth":2},{"value":"Call Signatures","depth":2},{"value":"Construct Signatures","depth":2},{"value":"Generic Functions","depth":2},{"value":"Inference","depth":3},{"value":"Constraints","depth":3},{"value":"Working with Constrained Values","depth":3},{"value":"Specifying Type Arguments","depth":3},{"value":"Guidelines for Writing Good Generic Functions","depth":3},{"value":"Push Type Parameters Down","depth":4},{"value":"Use Fewer Type Parameters","depth":4},{"value":"Type Parameters Should Appear Twice","depth":4},{"value":"Optional Parameters","depth":2},{"value":"Optional Parameters in Callbacks","depth":3},{"value":"Function Overloads","depth":2},{"value":"Overload Signatures and the Implementation Signature","depth":3},{"value":"Writing Good Overloads","depth":3},{"value":"Other Types to Know About","depth":2},{"value":"void","depth":3},{"value":"object","depth":3},{"value":"unknown","depth":3},{"value":"never","depth":3},{"value":"Function","depth":3},{"value":"Rest Parameters and Arguments","depth":2},{"value":"Rest Parameters","depth":3},{"value":"Rest Arguments","depth":3},{"value":"Parameter Destructuring","depth":2},{"value":"Assignability of Functions","depth":2},{"value":"Return type void","depth":3}],"frontmatter":{"permalink":"/docs/handbook/2/functions.html","title":"More on Functions","disable_toc":null,"oneline":"Learn about how Functions work in TypeScript.","beta":true}},"prev":{"childMarkdownRemark":{"frontmatter":{"title":"Narrowing","oneline":"Step one in learning TypeScript: The basics types.","permalink":"/docs/handbook/2/narrowing.html"}}},"next":{"childMarkdownRemark":{"frontmatter":{"title":"Classes","oneline":"How classes work in TypeScript","permalink":"/docs/handbook/2/classes.html"}}}},"pageContext":{"id":"8more-on-functions","slug":"/docs/handbook/2/functions.html","repoPath":"/packages/documentation/copy/en/handbook-v2/More on Functions.md","previousID":"f89ff230-961f-5a3e-8344-16d0f7f8b69b","nextID":"78f5ab88-e5d9-504e-a5ea-a55372cfb93a","lang":"en","modifiedTime":"2020-10-29T11:50:57.702Z"}},"staticQueryHashes":[]}