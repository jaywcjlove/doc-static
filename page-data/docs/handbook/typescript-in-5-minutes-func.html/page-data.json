{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/typescript-in-5-minutes-func.html","result":{"data":{"allSitePage":{"nodes":[{"path":"/dev-404-page/"},{"path":"/docs/handbook/nightly-builds.html"},{"path":"/docs/handbook/declaration-files/by-example.html"},{"path":"/docs/handbook/declaration-files/consumption.html"},{"path":"/docs/handbook/declaration-files/deep-dive.html"},{"path":"/docs/handbook/declaration-files/do-s-and-don-ts.html"},{"path":"/docs/handbook/declaration-files/introduction.html"},{"path":"/docs/handbook/declaration-files/library-structures.html"},{"path":"/docs/handbook/declaration-files/publishing.html"},{"path":"/docs/handbook/declaration-files/templates.html"},{"path":"/docs/handbook/typescript-in-5-minutes-func.html"},{"path":"/docs/handbook/typescript-in-5-minutes.html"},{"path":"/docs/handbook/typescript-in-5-minutes-oop.html"},{"path":"/docs/handbook/typescript-from-scratch.html"},{"path":"/docs/handbook/basic-types.html"},{"path":"/docs/handbook/classes.html"},{"path":"/docs/handbook/enums.html"},{"path":"/docs/handbook/functions.html"},{"path":"/docs/handbook/generics.html"},{"path":"/docs/handbook/interfaces.html"},{"path":"/docs/handbook/literal-types.html"},{"path":"/docs/handbook/intro.html"},{"path":"/docs/handbook/unions-and-intersections.html"},{"path":"/docs/handbook/declaration-files/dts-from-js.html"},{"path":"/docs/handbook/intro-to-js-ts.html"},{"path":"/docs/handbook/jsdoc-supported-types.html"},{"path":"/docs/handbook/type-checking-javascript-files.html"},{"path":"/docs/handbook/compiler-options-in-msbuild.html"},{"path":"/docs/handbook/compiler-options.html"},{"path":"/docs/handbook/configuring-watch.html"},{"path":"/docs/handbook/integrating-with-build-tools.html"},{"path":"/docs/handbook/project-references.html"},{"path":"/docs/handbook/tsconfig-json.html"},{"path":"/docs/handbook/advanced-types.html"},{"path":"/docs/handbook/declaration-merging.html"},{"path":"/docs/handbook/decorators.html"},{"path":"/docs/handbook/iterators-and-generators.html"},{"path":"/docs/handbook/jsx.html"},{"path":"/docs/handbook/mixins.html"},{"path":"/docs/handbook/module-resolution.html"},{"path":"/docs/handbook/modules.html"},{"path":"/docs/handbook/namespaces-and-modules.html"},{"path":"/docs/handbook/namespaces.html"},{"path":"/docs/handbook/symbols.html"},{"path":"/docs/handbook/triple-slash-directives.html"},{"path":"/docs/handbook/type-compatibility.html"},{"path":"/docs/handbook/type-inference.html"},{"path":"/docs/handbook/utility-types.html"},{"path":"/docs/handbook/variable-declarations.html"},{"path":"/docs/handbook/release-notes/typescript-1-1.html"},{"path":"/docs/handbook/release-notes/typescript-1-3.html"},{"path":"/docs/handbook/release-notes/typescript-1-4.html"},{"path":"/docs/handbook/release-notes/typescript-1-5.html"},{"path":"/docs/handbook/release-notes/typescript-1-6.html"},{"path":"/docs/handbook/release-notes/typescript-1-7.html"},{"path":"/docs/handbook/release-notes/typescript-1-8.html"},{"path":"/docs/handbook/release-notes/typescript-2-0.html"},{"path":"/docs/handbook/release-notes/typescript-2-1.html"},{"path":"/docs/handbook/release-notes/typescript-2-2.html"},{"path":"/docs/handbook/release-notes/typescript-2-3.html"},{"path":"/docs/handbook/release-notes/typescript-2-4.html"},{"path":"/docs/handbook/release-notes/typescript-2-5.html"},{"path":"/docs/handbook/release-notes/typescript-2-6.html"},{"path":"/docs/handbook/release-notes/typescript-2-7.html"},{"path":"/docs/handbook/release-notes/typescript-2-8.html"},{"path":"/docs/handbook/release-notes/typescript-2-9.html"},{"path":"/docs/handbook/release-notes/typescript-3-0.html"},{"path":"/docs/handbook/release-notes/typescript-3-1.html"},{"path":"/docs/handbook/release-notes/typescript-3-2.html"},{"path":"/docs/handbook/release-notes/typescript-3-3.html"},{"path":"/docs/handbook/release-notes/typescript-3-4.html"},{"path":"/docs/handbook/release-notes/typescript-3-5.html"},{"path":"/docs/handbook/release-notes/typescript-3-6.html"},{"path":"/docs/handbook/release-notes/typescript-3-7.html"},{"path":"/docs/handbook/release-notes/typescript-3-8.html"},{"path":"/docs/handbook/release-notes/typescript-3-9.html"},{"path":"/docs/handbook/asp-net-core.html"},{"path":"/docs/handbook/angular.html"},{"path":"/docs/handbook/babel-with-typescript.html"},{"path":"/docs/handbook/dom-manipulation.html"},{"path":"/docs/handbook/gulp.html"},{"path":"/docs/handbook/migrating-from-javascript.html"},{"path":"/docs/handbook/react.html"},{"path":"/docs/handbook/typescript-tooling-in-5-minutes.html"},{"path":"/vo/docs/handbook/basic-types.html"},{"path":"/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/global-plugin-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/global-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-class-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-function-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-plugin-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-d-ts.html"},{"path":"/docs/handbook/release-notes/overview.html"},{"path":"/tsconfig"},{"path":"/en/tsconfig"},{"path":"/vo/tsconfig"},{"path":"/ja/tsconfig"},{"path":"/pt/tsconfig"},{"path":"/play"},{"path":"/en/play"},{"path":"/es/play"},{"path":"/ja/play"},{"path":"/pt/play"},{"path":"/vo/play"},{"path":"/zh/play"},{"path":"/fa/play"},{"path":"/play/3-7/fixits/big-number-literals.ts"},{"path":"/play/3-7/fixits/const-to-let.ts"},{"path":"/play/3-7/fixits/infer-from-usage-changes.ts"},{"path":"/play/3-7/syntax-and-messaging/flattened-error-reporting.ts"},{"path":"/play/3-7/syntax-and-messaging/nullish-coalescing.ts"},{"path":"/play/3-7/syntax-and-messaging/optional-chaining.ts"},{"path":"/play/3-7/types-and-code-flow/assertion-functions.ts"},{"path":"/play/3-7/types-and-code-flow/recursive-type-references.ts"},{"path":"/play/3-7/types-and-code-flow/uncalled-function-checks.ts"},{"path":"/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts"},{"path":"/play/3-8/jsdoc-improvements/accessibility-modifiers.js"},{"path":"/play/3-8/syntax-and-messaging/export-modules-from.ts"},{"path":"/play/3-8/syntax-and-messaging/private-class-fields.ts"},{"path":"/play/4-0/new-checks/class-constructor-code-flow.ts"},{"path":"/play/4-0/new-js-features/jsdoc-deprecated.ts"},{"path":"/play/4-0/new-js-features/logical-operators-and-assignment.ts"},{"path":"/play/4-0/new-js-features/nullish-coalescing.ts"},{"path":"/play/4-0/new-ts-features/named-tuples.ts"},{"path":"/play/4-0/new-ts-features/unknown-in-catch.ts"},{"path":"/play/4-0/new-ts-features/variadic-tuples.ts"},{"path":"/play/javascript/external-apis/typescript-with-deno.ts"},{"path":"/play/javascript/external-apis/typescript-with-node.js"},{"path":"/play/javascript/external-apis/typescript-with-web.js"},{"path":"/play/javascript/external-apis/typescript-with-webgl.js"},{"path":"/play/javascript/functions-with-javascript/function-chaining.ts"},{"path":"/play/javascript/functions-with-javascript/generic-functions.ts"},{"path":"/play/javascript/functions-with-javascript/typing-functions.ts"},{"path":"/play/javascript/helping-with-javascript/errors.ts"},{"path":"/play/javascript/helping-with-javascript/quick-fixes.ts"},{"path":"/play/javascript/javascript-essentials/code-flow.ts"},{"path":"/play/javascript/javascript-essentials/functions.ts"},{"path":"/play/javascript/javascript-essentials/hello-world.ts"},{"path":"/play/javascript/javascript-essentials/objects-and-arrays.ts"},{"path":"/play/javascript/modern-javascript/async-await.ts"},{"path":"/play/javascript/modern-javascript/immutability.ts"},{"path":"/play/javascript/modern-javascript/import-export.ts"},{"path":"/play/javascript/modern-javascript/jsdoc-support.js"},{"path":"/play/javascript/working-with-classes/classes-101.ts"},{"path":"/play/javascript/working-with-classes/generic-classes.ts"},{"path":"/play/javascript/working-with-classes/mixins.ts"},{"path":"/play/javascript/working-with-classes/this.ts"},{"path":"/play/playground/config/javascript-playgrounds.js"},{"path":"/play/playground/config/new-compiler-defaults.ts"},{"path":"/play/playground/language/automatic-type-acquisition.ts"},{"path":"/play/playground/language/fixits.ts"},{"path":"/play/playground/tooling/mobile-support.ts"},{"path":"/play/playground/tooling/sharable-urls.ts"},{"path":"/play/playground/tooling/typescript-versions.ts"},{"path":"/play/typescript/language/soundness.ts"},{"path":"/play/typescript/language/structural-typing.ts"},{"path":"/play/typescript/language/type-guards.ts"},{"path":"/play/typescript/language/type-widening-and-narrowing.ts"},{"path":"/play/typescript/language-extensions/enums.ts"},{"path":"/play/typescript/language-extensions/nominal-typing.ts"},{"path":"/play/typescript/language-extensions/types-vs-interfaces.ts"},{"path":"/play/typescript/meta-types/conditional-types.ts"},{"path":"/play/typescript/meta-types/discriminate-types.ts"},{"path":"/play/typescript/meta-types/indexed-types.ts"},{"path":"/play/typescript/meta-types/mapped-types.ts"},{"path":"/play/typescript/primitives/any.ts"},{"path":"/play/typescript/primitives/literals.ts"},{"path":"/play/typescript/primitives/union-and-intersection-types.ts"},{"path":"/play/typescript/primitives/unknown-and-never.ts"},{"path":"/play/typescript/type-primitives/built-in-utility-types.ts"},{"path":"/play/typescript/type-primitives/nullable-types.ts"},{"path":"/play/typescript/type-primitives/tuples.ts"},{"path":"/es/play/javascript/external-apis/typescript-with-deno.ts"},{"path":"/es/play/javascript/external-apis/typescript-with-node.js"},{"path":"/es/play/javascript/external-apis/typescript-with-web.js"},{"path":"/es/play/javascript/functions-with-javascript/function-chaining.ts"},{"path":"/es/play/javascript/functions-with-javascript/generic-functions.ts"},{"path":"/es/play/javascript/javascript-essentials/hello-world.ts"},{"path":"/es/play/javascript/javascript-essentials/objects-and-arrays.ts"},{"path":"/es/play/typescript/language/soundness.ts"},{"path":"/es/play/typescript/language/structural-typing.ts"},{"path":"/es/play/typescript/language/type-guards.ts"},{"path":"/es/play/typescript/language/type-widening-and-narrowing.ts"},{"path":"/es/play/typescript/meta-types/conditional-types.ts"},{"path":"/es/play/typescript/meta-types/discriminate-types.ts"},{"path":"/es/play/typescript/meta-types/indexed-types.ts"},{"path":"/es/play/typescript/meta-types/mapped-types.ts"},{"path":"/es/play/typescript/primitives/any.ts"},{"path":"/es/play/typescript/primitives/literals.ts"},{"path":"/es/play/typescript/primitives/union-and-intersection-types.ts"},{"path":"/es/play/typescript/primitives/unknown-and-never.ts"},{"path":"/es/play/typescript/type-primitives/built-in-utility-types.ts"},{"path":"/es/play/typescript/type-primitives/nullable-types.ts"},{"path":"/es/play/typescript/type-primitives/tuples.ts"},{"path":"/fa/play/javascript/javascript-essentials/hello-world.ts"},{"path":"/ja/play/3-7/fixits/big-number-literals.ts"},{"path":"/ja/play/3-7/syntax-and-messaging/nullish-coalescing.ts"},{"path":"/ja/play/3-7/syntax-and-messaging/optional-chaining.ts"},{"path":"/ja/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts"},{"path":"/ja/play/javascript/external-apis/typescript-with-deno.ts"},{"path":"/ja/play/typescript/language-extensions/enums.ts"},{"path":"/ja/play/typescript/language-extensions/nominal-typing.ts"},{"path":"/ja/play/typescript/language-extensions/types-vs-interfaces.ts"},{"path":"/ja/play/typescript/primitives/any.ts"},{"path":"/ja/play/typescript/primitives/literals.ts"},{"path":"/ja/play/typescript/primitives/union-and-intersection-types.ts"},{"path":"/ja/play/typescript/primitives/unknown-and-never.ts"},{"path":"/ja/play/typescript/type-primitives/built-in-utility-types.ts"},{"path":"/ja/play/typescript/type-primitives/nullable-types.ts"},{"path":"/ja/play/typescript/type-primitives/tuples.ts"},{"path":"/pt/play/javascript/javascript-essentials/code-flow.ts"},{"path":"/pt/play/javascript/javascript-essentials/functions.ts"},{"path":"/pt/play/javascript/javascript-essentials/hello-world.ts"},{"path":"/pt/play/javascript/javascript-essentials/objects-and-arrays.ts"},{"path":"/vo/play/javascript/javascript-essentials/code-flow.ts"},{"path":"/vo/play/javascript/javascript-essentials/functions.ts"},{"path":"/vo/play/javascript/javascript-essentials/hello-world.ts"},{"path":"/vo/play/javascript/javascript-essentials/objects-and-arrays.ts"},{"path":"/zh/play/javascript/external-apis/typescript-with-deno.ts"},{"path":"/zh/play/javascript/external-apis/typescript-with-node.js"},{"path":"/zh/play/javascript/external-apis/typescript-with-web.js"},{"path":"/zh/play/javascript/external-apis/typescript-with-webgl.js"},{"path":"/zh/play/javascript/functions-with-javascript/function-chaining.ts"},{"path":"/zh/play/javascript/functions-with-javascript/generic-functions.ts"},{"path":"/zh/play/javascript/functions-with-javascript/typing-functions.ts"},{"path":"/zh/play/javascript/helping-with-javascript/errors.ts"},{"path":"/zh/play/javascript/helping-with-javascript/quick-fixes.ts"},{"path":"/zh/play/javascript/javascript-essentials/code-flow.ts"},{"path":"/zh/play/javascript/javascript-essentials/functions.ts"},{"path":"/zh/play/javascript/javascript-essentials/hello-world.ts"},{"path":"/zh/play/javascript/javascript-essentials/objects-and-arrays.ts"},{"path":"/zh/play/javascript/modern-javascript/async-await.ts"},{"path":"/zh/play/javascript/modern-javascript/immutability.ts"},{"path":"/zh/play/javascript/modern-javascript/import-export.ts"},{"path":"/zh/play/javascript/modern-javascript/jsdoc-support.js"},{"path":"/zh/play/javascript/working-with-classes/classes-101.ts"},{"path":"/zh/play/javascript/working-with-classes/generic-classes.ts"},{"path":"/zh/play/javascript/working-with-classes/mixins.ts"},{"path":"/zh/play/javascript/working-with-classes/this.ts"},{"path":"/zh/play/playground/config/javascript-playgrounds.js"},{"path":"/zh/play/playground/config/new-compiler-defaults.ts"},{"path":"/zh/play/playground/language/automatic-type-acquisition.ts"},{"path":"/zh/play/playground/language/fixits.ts"},{"path":"/zh/play/playground/tooling/mobile-support.ts"},{"path":"/zh/play/playground/tooling/sharable-urls.ts"},{"path":"/zh/play/playground/tooling/typescript-versions.ts"},{"path":"/zh/play/typescript/language/soundness.ts"},{"path":"/zh/play/typescript/language/structural-typing.ts"},{"path":"/zh/play/typescript/language/type-guards.ts"},{"path":"/zh/play/typescript/language/type-widening-and-narrowing.ts"},{"path":"/zh/play/typescript/language-extensions/enums.ts"},{"path":"/zh/play/typescript/language-extensions/nominal-typing.ts"},{"path":"/zh/play/typescript/language-extensions/types-vs-interfaces.ts"},{"path":"/zh/play/typescript/meta-types/conditional-types.ts"},{"path":"/zh/play/typescript/meta-types/discriminate-types.ts"},{"path":"/zh/play/typescript/meta-types/indexed-types.ts"},{"path":"/zh/play/typescript/meta-types/mapped-types.ts"},{"path":"/zh/play/typescript/primitives/any.ts"},{"path":"/zh/play/typescript/primitives/literals.ts"},{"path":"/zh/play/typescript/primitives/union-and-intersection-types.ts"},{"path":"/zh/play/typescript/primitives/unknown-and-never.ts"},{"path":"/zh/play/typescript/type-primitives/built-in-utility-types.ts"},{"path":"/zh/play/typescript/type-primitives/nullable-types.ts"},{"path":"/zh/play/typescript/type-primitives/tuples.ts"},{"path":"/ja/play/3-7/syntax-and-messaging/flattened-error-reporting.ts"},{"path":"/ja/play/3-7/fixits/infer-from-usage-changes.ts"},{"path":"/ja/play/3-7/fixits/const-to-let.ts"},{"path":"/community"},{"path":"/es/community"},{"path":"/ja/community"},{"path":"/vo/community"},{"path":"/zh/community"},{"path":"/download"},{"path":"/es/download"},{"path":"/ja/download"},{"path":"/vo/download"},{"path":"/zh/download"},{"path":"/empty"},{"path":"/es/empty"},{"path":"/ja/empty"},{"path":"/vo/empty"},{"path":"/zh/empty"},{"path":"/"},{"path":"/es/"},{"path":"/ja/"},{"path":"/vo/"},{"path":"/zh/"},{"path":"/tools"},{"path":"/es/tools"},{"path":"/ja/tools"},{"path":"/vo/tools"},{"path":"/zh/tools"},{"path":"/why-create-typescript"},{"path":"/es/why-create-typescript"},{"path":"/ja/why-create-typescript"},{"path":"/vo/why-create-typescript"},{"path":"/zh/why-create-typescript"},{"path":"/docs/bootstrap"},{"path":"/es/docs/bootstrap"},{"path":"/ja/docs/bootstrap"},{"path":"/vo/docs/bootstrap"},{"path":"/zh/docs/bootstrap"},{"path":"/docs/"},{"path":"/es/docs/"},{"path":"/ja/docs/"},{"path":"/vo/docs/"},{"path":"/zh/docs/"},{"path":"/docs/handbook/"},{"path":"/es/docs/handbook/"},{"path":"/ja/docs/handbook/"},{"path":"/vo/docs/handbook/"},{"path":"/zh/docs/handbook/"},{"path":"/branding/"},{"path":"/dev/bug-workbench/"},{"path":"/dev/playground-plugins/"},{"path":"/dev/sandbox/"},{"path":"/dev/twoslash/"},{"path":"/dev/typescript-vfs/"},{"path":"/upcoming/"}]},"markdownRemark":{"id":"fa0c6d3d-a71a-5ab3-ac87-2528a76264ac","excerpt":"TypeScript began its life as an attempt to bring traditional object-oriented types\nto JavaScript so that the programmers at Microsoft could bring\ntraditional…","html":"<p>TypeScript began its life as an attempt to bring traditional object-oriented types\nto JavaScript so that the programmers at Microsoft could bring\ntraditional object-oriented programs to the web. As it has developed, TypeScript’s type\nsystem has evolved to model code written by native JavaScripters. The\nresulting system is powerful, interesting and messy.</p>\n<p>This introduction is designed for working Haskell or ML programmers\nwho want to learn TypeScript. It describes how the type system of\nTypeScript differs from Haskell’s type system. It also describes\nunique features of TypeScript’s type system that arise from its\nmodelling of JavaScript code.</p>\n<p>This introduction does not cover object-oriented programming. In\npractice, object-oriented programs in TypeScript are similar to those\nin other popular languages with OO features.</p>\n<h2 id=\"prerequisites\" style=\"position:relative;\"><a href=\"#prerequisites\" aria-label=\"prerequisites permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Prerequisites</h2>\n<p>In this introduction, I assume you know the following:</p>\n<ul>\n<li>How to program in JavaScript, the good parts.</li>\n<li>Type syntax of a C-descended language.</li>\n</ul>\n<p>If you need to learn the good parts of JavaScript, read\n<a href=\"http://shop.oreilly.com/product/9780596517748.do\">JavaScript: The Good Parts</a>.\nYou may be able to skip the book if you know how to write programs in\na call-by-value lexically scoped language with lots of mutability and\nnot much else.\n<a href=\"https://people.csail.mit.edu/jaffer/r4rs.pdf\">R<sup>4</sup>RS Scheme</a> is a good example.</p>\n<p><a href=\"http://www.stroustrup.com/4th.html\">The C++ Programming Language</a> is\na good place to learn about C-style type syntax. Unlike C++,\nTypeScript uses postfix types, like so: <code>x: string</code> instead of <code>string x</code>.</p>\n<h2 id=\"concepts-not-in-haskell\" style=\"position:relative;\"><a href=\"#concepts-not-in-haskell\" aria-label=\"concepts not in haskell permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Concepts not in Haskell</h2>\n<h2 id=\"built-in-types\" style=\"position:relative;\"><a href=\"#built-in-types\" aria-label=\"built in types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Built-in types</h2>\n<p>JavaScript defines 7 built-in types:</p>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Explanation</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Number</code></td>\n<td>a double-precision IEEE 754 floating point.</td>\n</tr>\n<tr>\n<td><code>String</code></td>\n<td>an immutable UTF-16 string.</td>\n</tr>\n<tr>\n<td><code>BigInt</code></td>\n<td>integers in the arbitrary precision format.</td>\n</tr>\n<tr>\n<td><code>Boolean</code></td>\n<td><code>true</code> and <code>false</code>.</td>\n</tr>\n<tr>\n<td><code>Symbol</code></td>\n<td>a unique value usually used as a key.</td>\n</tr>\n<tr>\n<td><code>Null</code></td>\n<td>equivalent to the unit type.</td>\n</tr>\n<tr>\n<td><code>Undefined</code></td>\n<td>also equivalent to the unit type.</td>\n</tr>\n<tr>\n<td><code>Object</code></td>\n<td>similar to records.</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Data_structures\">See the MDN page for more detail</a>.</p>\n<p>TypeScript has corresponding primitive types for the built-in types:</p>\n<ul>\n<li><code>number</code></li>\n<li><code>string</code></li>\n<li><code>bigint</code></li>\n<li><code>boolean</code></li>\n<li><code>symbol</code></li>\n<li><code>null</code></li>\n<li><code>undefined</code></li>\n<li><code>object</code></li>\n</ul>\n<h3 id=\"other-important-typescript-types\" style=\"position:relative;\"><a href=\"#other-important-typescript-types\" aria-label=\"other important typescript types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Other important TypeScript types</h3>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Explanation</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>unknown</code></td>\n<td>the top type.</td>\n</tr>\n<tr>\n<td><code>never</code></td>\n<td>the bottom type.</td>\n</tr>\n<tr>\n<td>object literal</td>\n<td>eg <code>{ property: Type }</code></td>\n</tr>\n<tr>\n<td><code>void</code></td>\n<td>a subtype of <code>undefined</code> intended for use as a return type.</td>\n</tr>\n<tr>\n<td><code>T[]</code></td>\n<td>mutable arrays, also written <code>Array&#x3C;T></code></td>\n</tr>\n<tr>\n<td><code>[T, T]</code></td>\n<td>tuples, which are fixed-length but mutable</td>\n</tr>\n<tr>\n<td><code>(t: T) => U</code></td>\n<td>functions</td>\n</tr>\n</tbody>\n</table>\n<p>Notes:</p>\n<ol>\n<li>\n<p>Function syntax includes parameter names. This is pretty hard to get used to!</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">fst</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> (a</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> any, d</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> any) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #1A1A1A\"> any </span><span style=\"color: #000000\">= (</span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">d</span><span style=\"color: #000000\">) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #008000\">// or more precisely:</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">snd</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> &lt;T, U&gt;(a</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> T, d</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> U) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #1A1A1A\"> U </span><span style=\"color: #000000\">= (</span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">d</span><span style=\"color: #000000\">) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">d</span><span style=\"color: #000000\">;</span></code></div></pre>\n</li>\n<li>\n<p>Object literal type syntax closely mirrors object literal value syntax:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">o</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> { n</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> number; xs</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> object[] } </span><span style=\"color: #000000\">= { n: </span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, xs: [] };</span></code></div></pre>\n</li>\n<li><code>[T, T]</code> is a subtype of <code>T[]</code>. This is different than Haskell, where tuples are not related to lists.</li>\n</ol>\n<h3 id=\"boxed-types\" style=\"position:relative;\"><a href=\"#boxed-types\" aria-label=\"boxed types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Boxed types</h3>\n<p>JavaScript has boxed equivalents of primitive types that contain the\nmethods that programmers associate with those types. TypeScript\nreflects this with, for example, the difference between the primitive\ntype <code>number</code> and the boxed type <code>Number</code>. The boxed types are rarely\nneeded, since their methods return primitives.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #000000\">(</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">).toExponential();</span>\n<span style=\"color: #008000\">// equivalent to</span>\n<span style=\"color: #000000\">Number.prototype.</span><span style=\"color: #1A1A1A\">toExponential</span><span style=\"color: #000000\">.call(</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">);</span></code></div></pre>\n<p>Note that calling a method on a numeric literal requires it to be in\nparentheses to aid the parser.</p>\n<h2 id=\"gradual-typing\" style=\"position:relative;\"><a href=\"#gradual-typing\" aria-label=\"gradual typing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gradual typing</h2>\n<p>TypeScript uses the type <code>any</code> whenever it can’t tell what the type of\nan expression should be. Compared to <code>Dynamic</code>, calling <code>any</code> a type\nis an overstatement. It just turns off the type checker\nwherever it appears. For example, you can push any value into an\n<code>any[]</code> without marking the value in any way:</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #008000\">// with \"noImplicitAny\": false in tsconfig.json, anys: any[]</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const anys: any[]'>anys</data-lsp> </span><span style=\"color: #000000\">= [];</span>\n<span style=\"color: #1A1A1A\"><data-lsp lsp='const anys: any[]'>anys</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Array&amp;lt;any>.push(...items: any[]): number'>push</data-lsp>(</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #1A1A1A\"><data-lsp lsp='const anys: any[]'>anys</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Array&amp;lt;any>.push(...items: any[]): number'>push</data-lsp>(</span><span style=\"color: #A31515\">\"oh no\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #1A1A1A\"><data-lsp lsp='const anys: any[]'>anys</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Array&amp;lt;any>.push(...items: any[]): number'>push</data-lsp>({ <data-lsp lsp='(property) anything: string'>anything</data-lsp>: </span><span style=\"color: #A31515\">\"goes\"</span><span style=\"color: #000000\"> });</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEHcEsBcAtQEQDsD2BJAtgBwDaQMYwCCSAnggFygBmAhjgM4CmokSo0D+KS1kA5gDoAVgx4AaULTIMq00gG0AugChuSBtCkzQAXlDKA3CvkNBWAK4NYACgCMASmOnzV2whTxUCJyZmvrGwBvbVI4Nn4qBH4UJgYEUABfJyA'>Try</a></div></pre>\n<p>And you can use an expression of type <code>any</code> anywhere:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #1A1A1A\">anys</span><span style=\"color: #000000\">.map(</span><span style=\"color: #1A1A1A\">anys</span><span style=\"color: #000000\">[</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">]); </span><span style=\"color: #008000\">// oh no, \"oh no\" is not a function</span></code></div></pre>\n<p><code>any</code> is contagious, too — if you initialise a variable with an\nexpression of type <code>any</code>, the variable has type <code>any</code> too.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">sepsis </span><span style=\"color: #000000\">= </span><span style=\"color: #1A1A1A\">anys</span><span style=\"color: #000000\">[</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">] + </span><span style=\"color: #1A1A1A\">anys</span><span style=\"color: #000000\">[</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">]; </span><span style=\"color: #008000\">// this could mean anything</span></code></div></pre>\n<p>To get an error when TypeScript produces an <code>any</code>, use\n<code>\"noImplicitAny\": true</code>, or <code>\"strict\": true</code> in <code>tsconfig.json</code>.</p>\n<h2 id=\"structural-typing\" style=\"position:relative;\"><a href=\"#structural-typing\" aria-label=\"structural typing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Structural typing</h2>\n<p>Structural typing is a familiar concept to most functional\nprogrammers, although Haskell and most MLs are not\nstructurally typed. Its basic form is pretty simple:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #008000\">// @strict: false</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">o </span><span style=\"color: #000000\">= { x: </span><span style=\"color: #A31515\">\"hi\"</span><span style=\"color: #000000\">, extra: </span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\"> }; </span><span style=\"color: #008000\">// ok</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">o2</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> { x</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> string } </span><span style=\"color: #000000\">= </span><span style=\"color: #1A1A1A\">o</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// ok</span></code></div></pre>\n<p>Here, the object literal <code>{ x: \"hi\", extra: 1 }</code> has a matching\nliteral type <code>{ x: string, extra: number }</code>. That\ntype is assignable to <code>{ x: string }</code> since\nit has all the required properties and those properties have\nassignable types. The extra property doesn’t prevent assignment, it\njust makes it a subtype of <code>{ x: string }</code>.</p>\n<p>Named types just give a name to a type; for assignability purposes\nthere’s no difference between the type alias <code>One</code> and the interface\ntype <code>Two</code> below. They both have a property <code>p: string</code>. (Type aliases\nbehave differently from interfaces with respect to recursive\ndefinitions and type parameters, however.)</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> <data-lsp lsp='type One = {&amp;#13;    p: string;&amp;#13;}'>One</data-lsp> = { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) p: string'>p</data-lsp></span><span style=\"color: #000000\">: string };</span>\n<span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> <data-lsp lsp='interface Two'>Two</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Two.p: string'>p</data-lsp></span><span style=\"color: #000000\">: string;</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> <data-lsp lsp='class Three'>Three</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Three.p: string'>p</data-lsp></span><span style=\"color: #000000\"> = </span><span style=\"color: #A31515\">\"Hello\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let x: One'>x</data-lsp></span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> <data-lsp lsp='type One = {&amp;#13;    p: string;&amp;#13;}'>One</data-lsp> </span><span style=\"color: #000000\">= { <data-lsp lsp='(property) p: string'>p</data-lsp>: </span><span style=\"color: #A31515\">\"hi\"</span><span style=\"color: #000000\"> };</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let two: Two'>two</data-lsp></span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> <data-lsp lsp='interface Two'>Two</data-lsp> </span><span style=\"color: #000000\">= </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let x: One'>x</data-lsp></span><span style=\"color: #000000\">;</span>\n<span style=\"color: #1A1A1A\"><data-lsp lsp='let two: Two'>two</data-lsp></span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> <data-lsp lsp='constructor Three(): Three'>Three</data-lsp>();</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGY1oFABcBPAB0lAHkA7UgXlAG9QjVE9oBLCgc1AF8BuHBzwwAZgEMAxqQAqAdzj0coRs1YdOAnjgkAbMYkShpAC2iRSdJY1C0ARAAlIOnXFuacOHZDygAHqkoaehVQW2M2W14BLx88eVQ5BVpfATik0CpZI1NzAAoASj4gA'>Try</a></div></pre>\n<h2 id=\"unions\" style=\"position:relative;\"><a href=\"#unions\" aria-label=\"unions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unions</h2>\n<p>In TypeScript, union types are untagged. In other words, they are not\ndiscriminated unions like <code>data</code> in Haskell. However, you can often\ndiscriminate types in a union using built-in tags or other properties.</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function start(arg: string | string[] | (() => string) | {&amp;#13;    s: string;&amp;#13;}): string'>start</data-lsp>(</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arg: string | string[] | (() => string) | {&amp;#13;    s: string;&amp;#13;}'>arg</data-lsp></span><span style=\"color: #000000\">: string | string[] | (() </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> string) | { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) s: string'>s</data-lsp></span><span style=\"color: #000000\">: string }</span>\n<span style=\"color: #000000\">): string {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// this is super common in JavaScript</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #0000FF\">typeof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arg: string | string[] | (() => string) | {&amp;#13;    s: string;&amp;#13;}'>arg</data-lsp></span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"string\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> <data-lsp lsp='(local function) commonCase(s: string): string'>commonCase</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arg: string'>arg</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">  } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (<data-lsp lsp='var Array: ArrayConstructor'>Array</data-lsp>.<data-lsp lsp='(method) ArrayConstructor.isArray(arg: any): arg is any[]'>isArray</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arg: string[] | (() => string) | {&amp;#13;    s: string;&amp;#13;}'>arg</data-lsp></span><span style=\"color: #000000\">)) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arg: string[]'>arg</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Array&amp;lt;string>.map&amp;lt;string>(callbackfn: (value: string, index: number, array: string[]) => string, thisArg?: any): string[]'>map</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(local function) commonCase(s: string): string'>commonCase</data-lsp></span><span style=\"color: #000000\">).<data-lsp lsp='(method) Array&amp;lt;string>.join(separator?: string | undefined): string'>join</data-lsp>(</span><span style=\"color: #A31515\">\",\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">  } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #0000FF\">typeof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arg: (() => string) | {&amp;#13;    s: string;&amp;#13;}'>arg</data-lsp></span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"function\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> <data-lsp lsp='(local function) commonCase(s: string): string'>commonCase</data-lsp>(<data-lsp lsp='(parameter) arg: () => string'>arg</data-lsp>());</span>\n<span style=\"color: #000000\">  } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> <data-lsp lsp='(local function) commonCase(s: string): string'>commonCase</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arg: {&amp;#13;    s: string;&amp;#13;}'>arg</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) s: string'>s</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">  }</span>\n\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='(local function) commonCase(s: string): string'>commonCase</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: string'>s</data-lsp></span><span style=\"color: #000000\">: string): string {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #008000\">// finally, just convert a string to another string</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: string'>s</data-lsp></span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABAZygQwE5QBQChGKYDmAXClBjGEYgD7mXUDaAunYttgJSIC8AfAypEe9AN4oyqRjQC+uLlIrDEY-IgD0GxFAAWMZIgMoQABwCmGRBDgBbWwiNIAUmgBuaAMoRKpqOphgDigATws4IOI+Xl5EACJpYTieNQICDHMoEAwkG3sEAGE0ZHNsYi4AbnVZRHMAGxKjIOwAQQwMNBCAOgM2jpCyjBEU9XTM7KRiLts0U2w8hzAikq4ugCs4Kmw4gBpkqoIa+sbA4LDzCMIh6Ni40EhYBGTVUcQMrJzrO0Xl0uJuSrVWoNcwvNJvcafBaFYp-IZdZCAw64dT3aDwXLfGElbDIJQyRRCahgtJaRDAKhoOp1EI7RBrECoL5gNyWKCEIk0KBwQhgOB6Syc17vCYoA6IeSyIA'>Try</a></div></pre>\n<p><code>string</code>, <code>Array</code> and <code>Function</code> have built-in type predicates,\nconveniently leaving the object type for the <code>else</code> branch. It is\npossible, however, to generate unions that are difficult to\ndifferentiate at runtime. For new code, it’s best to build only\ndiscriminated unions.</p>\n<p>The following types have built-in predicates:</p>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Predicate</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>string</td>\n<td><code>typeof s === \"string\"</code></td>\n</tr>\n<tr>\n<td>number</td>\n<td><code>typeof n === \"number\"</code></td>\n</tr>\n<tr>\n<td>bigint</td>\n<td><code>typeof m === \"bigint\"</code></td>\n</tr>\n<tr>\n<td>boolean</td>\n<td><code>typeof b === \"boolean\"</code></td>\n</tr>\n<tr>\n<td>symbol</td>\n<td><code>typeof g === \"symbol\"</code></td>\n</tr>\n<tr>\n<td>undefined</td>\n<td><code>typeof undefined === \"undefined\"</code></td>\n</tr>\n<tr>\n<td>function</td>\n<td><code>typeof f === \"function\"</code></td>\n</tr>\n<tr>\n<td>array</td>\n<td><code>Array.isArray(a)</code></td>\n</tr>\n<tr>\n<td>object</td>\n<td><code>typeof o === \"object\"</code></td>\n</tr>\n</tbody>\n</table>\n<p>Note that functions and arrays are objects at runtime, but have their\nown predicates.</p>\n<h3 id=\"intersections\" style=\"position:relative;\"><a href=\"#intersections\" aria-label=\"intersections permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intersections</h3>\n<p>In addition to unions, TypeScript also has intersections:</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> <data-lsp lsp='type Combined = {&amp;#13;    a: number;&amp;#13;} &amp;amp; {&amp;#13;    b: string;&amp;#13;}'>Combined</data-lsp> = { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) a: number'>a</data-lsp></span><span style=\"color: #000000\">: number } & { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) b: string'>b</data-lsp></span><span style=\"color: #000000\">: string };</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> <data-lsp lsp='type Conflicting = {&amp;#13;    a: number;&amp;#13;} &amp;amp; {&amp;#13;    a: string;&amp;#13;}'>Conflicting</data-lsp> = { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) a: number'>a</data-lsp></span><span style=\"color: #000000\">: number } & { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) a: string'>a</data-lsp></span><span style=\"color: #000000\">: string };</span></code><a href='https://www.typescriptlang.org/play/#code/C4TwDgpgBAwg9gWwEYEsB2EAmUC8UDeUAhgFxRoCuyEATlAL5QBkBUSZAzsDegOYMBuAFChIsOGgBmAGxQBjYH1ytS5KkloNmKztyX0BQA'>Try</a></div></pre>\n<p><code>Combined</code> has two properties, <code>a</code> and <code>b</code>, just as if they had been\nwritten as one object literal type. Intersection and union are\nrecursive in case of conflicts, so <code>Conflicting.a: number &#x26; string</code>.</p>\n<h2 id=\"unit-types\" style=\"position:relative;\"><a href=\"#unit-types\" aria-label=\"unit types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unit types</h2>\n<p>Unit types are subtypes of primitive types that contain exactly one\nprimitive value. For example, the string <code>\"foo\"</code> has the type\n<code>\"foo\"</code>. Since JavaScript has no built-in enums, it is common to use a set of\nwell-known strings instead. Unions of string literal types allow\nTypeScript to type this pattern:</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function pad(s: string, n: number, direction: &amp;quot;left&amp;quot; | &amp;quot;right&amp;quot;): string'>pad</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: string'>s</data-lsp></span><span style=\"color: #000000\">: string, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) n: number'>n</data-lsp></span><span style=\"color: #000000\">: number, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) direction: &amp;quot;left&amp;quot; | &amp;quot;right&amp;quot;'>direction</data-lsp></span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"left\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"right\"</span><span style=\"color: #000000\">): string;</span>\n<span style=\"color: #000000\"><data-lsp lsp='function pad(s: string, n: number, direction: &amp;quot;left&amp;quot; | &amp;quot;right&amp;quot;): string'>pad</data-lsp>(</span><span style=\"color: #A31515\">\"hi\"</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">10</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"left\"</span><span style=\"color: #000000\">);</span></code><a href='https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAcpgAKAZwC54yMYtUBzAGnlStWQFsAjEGF4FjiZcbeACIIIRBnHwAPhLoMAFrICUVGnUYBuAFBFS4lVnEsAjAAYWk6Rt1A'>Try</a></div></pre>\n<p>When needed, the compiler <em>widens</em> — converts to a\nsupertype — the unit type to the primitive type, such as <code>\"foo\"</code>\nto <code>string</code>. This happens when using mutability, which can hamper some\nuses of mutable variables:</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let s: string'>s</data-lsp> </span><span style=\"color: #000000\">= </span><span style=\"color: #A31515\">\"right\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\"><data-lsp lsp='function pad(s: string, n: number, direction: &amp;quot;left&amp;quot; | &amp;quot;right&amp;quot;): string'>pad</data-lsp>(</span><span style=\"color: #A31515\">\"hi\"</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">10</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-err><data-lsp lsp='let s: string'>s</data-lsp></data-err></span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// error: &apos;string&apos; is not assignable to &apos;\"left\" | \"right\"&apos;</span>\n<span class=\"error\"><span>Argument of type 'string' is not assignable to parameter of type '\"left\" | \"right\"'.</span><span class=\"code\">2345</span></span><span class=\"error-behind\">Argument of type 'string' is not assignable to parameter of type '\"left\" | \"right\"'.</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWAUACaQDGANgIbSSgBmArgHbEAuAlnA6AA7kEAUKUImbRWDAOYAaUA1QM6AWwBGMaQVZUW7WaABEpSDWa7QAHz2jxAC2MBKVMNESA3HhCgAtF+J1mXj3gGzEKgALwWrNbGrjz8ulasutIAjAAM0oi2zqDuMPDQqADkjmLihaCsiDJwweSIiJEM5EoGoMxwoIX6hsZmEVG6hUA'>Try</a></div></pre>\n<p>Here’s how the error happens:</p>\n<ul>\n<li><code>\"right\": \"right\"</code></li>\n<li><code>s: string</code> because <code>\"right\"</code> widens to <code>string</code> on assignment to a mutable variable.</li>\n<li><code>string</code> is not assignable to <code>\"left\" | \"right\"</code></li>\n</ul>\n<p>You can work around this with a type annotation for <code>s</code>, but that\nin turn prevents assignments to <code>s</code> of variables that are not of type\n<code>\"left\" | \"right\"</code>.</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let s: &amp;quot;left&amp;quot; | &amp;quot;right&amp;quot;'>s</data-lsp></span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> </span><span style=\"color: #A31515\">\"left\"</span><span style=\"color: #1A1A1A\"> </span><span style=\"color: #000000\">|</span><span style=\"color: #1A1A1A\"> </span><span style=\"color: #A31515\">\"right\"</span><span style=\"color: #1A1A1A\"> </span><span style=\"color: #000000\">= </span><span style=\"color: #A31515\">\"right\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\"><data-lsp lsp='function pad(s: string, n: number, direction: &amp;quot;left&amp;quot; | &amp;quot;right&amp;quot;): string'>pad</data-lsp>(</span><span style=\"color: #A31515\">\"hi\"</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">10</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let s: &amp;quot;right&amp;quot;'>s</data-lsp></span><span style=\"color: #000000\">);</span></code><a href='https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwAcpgAKAZwC54yMYtUBzAGnlStWQFsAjEGF4FjiZcbeACIIIRBnHwAPhLoMAFrICUVGnUYBuAFAB6Q-AC05sMgznT+qRmpVJ02QqVZVrgLzvP4g0Sk4ipY4iwAjAAMLGTqukA'>Try</a></div></pre>\n<h2 id=\"concepts-similar-to-haskell\" style=\"position:relative;\"><a href=\"#concepts-similar-to-haskell\" aria-label=\"concepts similar to haskell permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Concepts similar to Haskell</h2>\n<h2 id=\"contextual-typing\" style=\"position:relative;\"><a href=\"#contextual-typing\" aria-label=\"contextual typing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Contextual typing</h2>\n<p>TypeScript has some obvious places where it can infer types, like\nvariable declarations:</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let s: string'>s</data-lsp> </span><span style=\"color: #000000\">= </span><span style=\"color: #A31515\">\"I&apos;m a string!\"</span><span style=\"color: #000000\">;</span></code><a href='https://www.typescriptlang.org/play/#code/DYUwLgBAzhC8ECICSByAthAhtMAnAlgHYDmAhAgNxA'>Try</a></div></pre>\n<p>But it also infers types in a few other places that you may not expect\nif you’ve worked with other C-syntax languages:</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function map&amp;lt;T, U>(f: (t: T) => U, ts: T[]): U[]'>map</data-lsp>&lt;<data-lsp lsp='(type parameter) T in map&amp;lt;T, U>(f: (t: T) => U, ts: T[]): U[]'>T</data-lsp>, <data-lsp lsp='(type parameter) U in map&amp;lt;T, U>(f: (t: T) => U, ts: T[]): U[]'>U</data-lsp>>(<data-lsp lsp='(parameter) f: (t: T) => U'>f</data-lsp>: (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) t: T'>t</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in map&amp;lt;T, U>(f: (t: T) => U, ts: T[]): U[]'>T</data-lsp>) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> <data-lsp lsp='(type parameter) U in map&amp;lt;T, U>(f: (t: T) => U, ts: T[]): U[]'>U</data-lsp>, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) ts: T[]'>ts</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in map&amp;lt;T, U>(f: (t: T) => U, ts: T[]): U[]'>T</data-lsp>[]): <data-lsp lsp='(type parameter) U in map&amp;lt;T, U>(f: (t: T) => U, ts: T[]): U[]'>U</data-lsp>[];</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let sns: string[]'>sns</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function map&amp;lt;number, string>(f: (t: number) => string, ts: number[]): string[]'>map</data-lsp>((</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) n: number'>n</data-lsp></span><span style=\"color: #000000\">) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) n: number'>n</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) Number.toString(radix?: number | undefined): string'>toString</data-lsp>(), [</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">]);</span></code><a href='https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFsoAHAHgBUAaeAVQD4AKRALngY1fIEp4BeO2tQwBnTgG0Aul1Y1JAbgBQEEBnjDUwvoRIMGqHv3ioAdBhwBlDDCyoA5gy7UxARmoAmagGYpcoA'>Try</a></div></pre>\n<p>Here, <code>n: number</code> in this example also, despite the fact that <code>T</code> and <code>U</code>\nhave not been inferred before the call. In fact, after <code>[1,2,3]</code> has\nbeen used to infer <code>T=number</code>, the return type of <code>n => n.toString()</code>\nis used to infer <code>U=string</code>, causing <code>sns</code> to have the type\n<code>string[]</code>.</p>\n<p>Note that inference will work in any order, but intellisense will only\nwork left-to-right, so TypeScript prefers to declare <code>map</code> with the\narray first:</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function map&amp;lt;T, U>(ts: T[], f: (t: T) => U): U[]'>map</data-lsp>&lt;<data-lsp lsp='(type parameter) T in map&amp;lt;T, U>(ts: T[], f: (t: T) => U): U[]'>T</data-lsp>, <data-lsp lsp='(type parameter) U in map&amp;lt;T, U>(ts: T[], f: (t: T) => U): U[]'>U</data-lsp>>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) ts: T[]'>ts</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in map&amp;lt;T, U>(ts: T[], f: (t: T) => U): U[]'>T</data-lsp>[], <data-lsp lsp='(parameter) f: (t: T) => U'>f</data-lsp>: (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) t: T'>t</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in map&amp;lt;T, U>(ts: T[], f: (t: T) => U): U[]'>T</data-lsp>) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> <data-lsp lsp='(type parameter) U in map&amp;lt;T, U>(ts: T[], f: (t: T) => U): U[]'>U</data-lsp>): <data-lsp lsp='(type parameter) U in map&amp;lt;T, U>(ts: T[], f: (t: T) => U): U[]'>U</data-lsp>[];</span></code><a href='https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXwFsoAHAHgBUAaeAVQD4AKDAZwC55yBtAXWsXabtyASngBeOrWHsaPANxA'>Try</a></div></pre>\n<p>Contextual typing also works recursively through object literals, and\non unit types that would otherwise be inferred as <code>string</code> or\n<code>number</code>. And it can infer return types from context:</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function run&amp;lt;T>(thunk: (t: T) => void): T'>run</data-lsp>&lt;<data-lsp lsp='(type parameter) T in run&amp;lt;T>(thunk: (t: T) => void): T'>T</data-lsp>>(<data-lsp lsp='(parameter) thunk: (t: T) => void'>thunk</data-lsp>: (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) t: T'>t</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in run&amp;lt;T>(thunk: (t: T) => void): T'>T</data-lsp>) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void): <data-lsp lsp='(type parameter) T in run&amp;lt;T>(thunk: (t: T) => void): T'>T</data-lsp>;</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let i: {&amp;#13;    inference: string;&amp;#13;}'>i</data-lsp></span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> { <data-lsp lsp='(property) inference: string'>inference</data-lsp></span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> string } </span><span style=\"color: #000000\">= <data-lsp lsp='function run&amp;lt;{&amp;#13;    inference: string;&amp;#13;}>(thunk: (t: {&amp;#13;    inference: string;&amp;#13;}) => void): {&amp;#13;    inference: string;&amp;#13;}'>run</data-lsp>((</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) o: {&amp;#13;    inference: string;&amp;#13;}'>o</data-lsp></span><span style=\"color: #000000\">) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) o: {&amp;#13;    inference: string;&amp;#13;}'>o</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) inference: string'>inference</data-lsp></span><span style=\"color: #000000\"> = </span><span style=\"color: #A31515\">\"INSERT STATE HERE\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">});</span></code><a href='https://www.typescriptlang.org/play/#code/CYUwxgNghgTiAEAzArgOzAFwJYHtXxjQB4AVAPgAoMALNAawC54qmSBKeAXjPgDccswNqwDcAKAggM8LEwDeM1IhBx0IJgGcMMLKgDm8AL5cCaChRwdu8OWPjwcAOl3LVYBJ3gAiAJIA5AGUAUQAlEngAkgBBEiD4AAlQoK9xQzYRIA'>Try</a></div></pre>\n<p>The type of <code>o</code> is determined to be <code>{ inference: string }</code> because</p>\n<ol>\n<li>Declaration initialisers are contextually typed by the\ndeclaration’s type: <code>{ inference: string }</code>.</li>\n<li>The return type of a call uses the contextual type for inferences,\nso the compiler infers that <code>T={ inference: string }</code>.</li>\n<li>Arrow functions use the contextual type to type their parameters,\nso the compiler gives <code>o: { inference: string }</code>.</li>\n</ol>\n<p>And it does so while you are typing, so that after typing <code>o.</code>, you\nget completions for the property <code>inference</code>, along with any other\nproperties you’d have in a real program.\nAltogether, this feature can make TypeScript’s inference look a bit\nlike a unifying type inference engine, but it is not.</p>\n<h2 id=\"type-aliases\" style=\"position:relative;\"><a href=\"#type-aliases\" aria-label=\"type aliases permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type aliases</h2>\n<p>Type aliases are mere aliases, just like <code>type</code> in Haskell. The\ncompiler will attempt to use the alias name wherever it was used in\nthe source code, but does not always succeed.</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> <data-lsp lsp='type Size = [number, number]'>Size</data-lsp> = [number, number];</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let x: Size'>x</data-lsp></span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> <data-lsp lsp='type Size = [number, number]'>Size</data-lsp> </span><span style=\"color: #000000\">= [</span><span style=\"color: #09835A\">101.1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">999.9</span><span style=\"color: #000000\">];</span></code><a href='https://www.typescriptlang.org/play/#code/C4TwDgpgBAyglgL2gXigbQHYFcC2AjCAJwBopt8iBdAbgCgAbCYKADwC5ZEV0BGABh4A6HqQCc4waJpA'>Try</a></div></pre>\n<p>The closest equivalent to <code>newtype</code> is a <em>tagged intersection</em>:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> FString = string & { </span><span style=\"color: #1A1A1A\">__compileTimeOnly</span><span style=\"color: #000000\">: any };</span></code></div></pre>\n<p>An <code>FString</code> is just like a normal string, except that the compiler\nthinks it has a property named <code>__compileTimeOnly</code> that doesn’t\nactually exist. This means that <code>FString</code> can still be assigned to\n<code>string</code>, but not the other way round.</p>\n<h2 id=\"discriminated-unions\" style=\"position:relative;\"><a href=\"#discriminated-unions\" aria-label=\"discriminated unions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Discriminated Unions</h2>\n<p>The closest equivalent to <code>data</code> is a union of types with discriminant\nproperties, normally called discriminated unions in TypeScript:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Shape =</span>\n<span style=\"color: #000000\">  | { </span><span style=\"color: #1A1A1A\">kind</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"circle\"</span><span style=\"color: #000000\">; </span><span style=\"color: #1A1A1A\">radius</span><span style=\"color: #000000\">: number }</span>\n<span style=\"color: #000000\">  | { </span><span style=\"color: #1A1A1A\">kind</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"square\"</span><span style=\"color: #000000\">; </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: number }</span>\n<span style=\"color: #000000\">  | { </span><span style=\"color: #1A1A1A\">kind</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"triangle\"</span><span style=\"color: #000000\">; </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: number; </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">: number };</span></code></div></pre>\n<p>Unlike Haskell, the tag, or discriminant, is just a property in each\nobject type. Each variant has an identical property with a different\nunit type. This is still a normal union type; the leading <code>|</code> is\nan optional part of the union type syntax. You can discriminate the\nmembers of the union using normal JavaScript code:</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> <data-lsp lsp='type Shape = {&amp;#13;    kind: &amp;quot;circle&amp;quot;;&amp;#13;    radius: number;&amp;#13;} | {&amp;#13;    kind: &amp;quot;square&amp;quot;;&amp;#13;    x: number;&amp;#13;} | {&amp;#13;    kind: &amp;quot;triangle&amp;quot;;&amp;#13;    x: number;&amp;#13;    y: number;&amp;#13;}'>Shape</data-lsp> =</span>\n<span style=\"color: #000000\">  | { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) kind: &amp;quot;circle&amp;quot;'>kind</data-lsp></span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"circle\"</span><span style=\"color: #000000\">; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) radius: number'>radius</data-lsp></span><span style=\"color: #000000\">: number }</span>\n<span style=\"color: #000000\">  | { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) kind: &amp;quot;square&amp;quot;'>kind</data-lsp></span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"square\"</span><span style=\"color: #000000\">; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) x: number'>x</data-lsp></span><span style=\"color: #000000\">: number }</span>\n<span style=\"color: #000000\">  | { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) kind: &amp;quot;triangle&amp;quot;'>kind</data-lsp></span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"triangle\"</span><span style=\"color: #000000\">; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) x: number'>x</data-lsp></span><span style=\"color: #000000\">: number; </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) y: number'>y</data-lsp></span><span style=\"color: #000000\">: number };</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function area(s: Shape): number'>area</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: Shape'>s</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='type Shape = {&amp;#13;    kind: &amp;quot;circle&amp;quot;;&amp;#13;    radius: number;&amp;#13;} | {&amp;#13;    kind: &amp;quot;square&amp;quot;;&amp;#13;    x: number;&amp;#13;} | {&amp;#13;    kind: &amp;quot;triangle&amp;quot;;&amp;#13;    x: number;&amp;#13;    y: number;&amp;#13;}'>Shape</data-lsp>) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: Shape'>s</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) kind: &amp;quot;circle&amp;quot; | &amp;quot;square&amp;quot; | &amp;quot;triangle&amp;quot;'>kind</data-lsp></span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"circle\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> <data-lsp lsp='var Math: Math'>Math</data-lsp>.<data-lsp lsp='(property) Math.PI: number'>PI</data-lsp> * </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: {&amp;#13;    kind: &amp;quot;circle&amp;quot;;&amp;#13;    radius: number;&amp;#13;}'>s</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) radius: number'>radius</data-lsp></span><span style=\"color: #000000\"> * </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: {&amp;#13;    kind: &amp;quot;circle&amp;quot;;&amp;#13;    radius: number;&amp;#13;}'>s</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) radius: number'>radius</data-lsp></span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: {&amp;#13;    kind: &amp;quot;square&amp;quot;;&amp;#13;    x: number;&amp;#13;} | {&amp;#13;    kind: &amp;quot;triangle&amp;quot;;&amp;#13;    x: number;&amp;#13;    y: number;&amp;#13;}'>s</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) kind: &amp;quot;square&amp;quot; | &amp;quot;triangle&amp;quot;'>kind</data-lsp></span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"square\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: {&amp;#13;    kind: &amp;quot;square&amp;quot;;&amp;#13;    x: number;&amp;#13;}'>s</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(property) x: number'>x</data-lsp> * </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: {&amp;#13;    kind: &amp;quot;square&amp;quot;;&amp;#13;    x: number;&amp;#13;}'>s</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(property) x: number'>x</data-lsp>;</span>\n<span style=\"color: #000000\">  } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: {&amp;#13;    kind: &amp;quot;triangle&amp;quot;;&amp;#13;    x: number;&amp;#13;    y: number;&amp;#13;}'>s</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(property) x: number'>x</data-lsp> * </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: {&amp;#13;    kind: &amp;quot;triangle&amp;quot;;&amp;#13;    x: number;&amp;#13;    y: number;&amp;#13;}'>s</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(property) y: number'>y</data-lsp>) / </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwAewsZOlzMOfMXJVqwBkQQkA5qw5R9UERKmcQBz8fZoaABmfCS0wEQA9iRQWhAIABRCsIiQAJR48kRBUEkAdBZkqCgoNPRMzhm48pjawHwMMQCyCMBweQAKAJJQAFRQAnncvIJ9A0M8-AIBmDJQEMwC0Nm5g4XFpdTqmtrUVTVcEPWN47pjg7ozsvOL0NWYtUcNMfln-YMgGQD0UABMV3IZEA'>Try</a></div></pre>\n<p>Note that the return type of <code>area</code> is inferred to be <code>number</code> because\nTypeScript knows the function is total. If some variant is not\ncovered, the return type of <code>area</code> will be <code>number | undefined</code> instead.</p>\n<p>Also, unlike Haskell, common properties show up in any union, so you\ncan usefully discriminate multiple members of the union:</p>\n<pre class=\"shiki twoslash\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function height(s: Shape): number'>height</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: Shape'>s</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='type Shape = {&amp;#13;    kind: &amp;quot;circle&amp;quot;;&amp;#13;    radius: number;&amp;#13;} | {&amp;#13;    kind: &amp;quot;square&amp;quot;;&amp;#13;    x: number;&amp;#13;} | {&amp;#13;    kind: &amp;quot;triangle&amp;quot;;&amp;#13;    x: number;&amp;#13;    y: number;&amp;#13;}'>Shape</data-lsp>) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: Shape'>s</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) kind: &amp;quot;circle&amp;quot; | &amp;quot;square&amp;quot; | &amp;quot;triangle&amp;quot;'>kind</data-lsp></span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"circle\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\"> * </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: {&amp;#13;    kind: &amp;quot;circle&amp;quot;;&amp;#13;    radius: number;&amp;#13;}'>s</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) radius: number'>radius</data-lsp></span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #008000\">// s.kind: \"square\" | \"triangle\"</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) s: {&amp;#13;    kind: &amp;quot;square&amp;quot;;&amp;#13;    x: number;&amp;#13;} | {&amp;#13;    kind: &amp;quot;triangle&amp;quot;;&amp;#13;    x: number;&amp;#13;    y: number;&amp;#13;}'>s</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(property) x: number'>x</data-lsp>;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/C4TwDgpgBAygFgQ0lAvAKClAPlA3lAawEsA7AEwC4oAiAYyICdaAbCagbigYTKIFcAzlRJ8AtgCMIDKAF8M2PIVKUaAgI58EDNpwAewsZOlzMOfMXJVqwBkQQkA5qw5R9UERKmcQBz8fZoAPSBUAC04bR8wOGhaABmfCS0wEQA9iRQcBBEDnDAABRCsIiQAJR48kRxUIUAdBZkqCgoNPRMzuW48pjawHwMGQBMUABUUAK13LyCAZgyUBDMAtBdmJjB4-XKVuqa2tQK1rb2TmzdXBB9A5u6s7JoMkA'>Try</a></div></pre>\n<h2 id=\"type-parameters\" style=\"position:relative;\"><a href=\"#type-parameters\" aria-label=\"type parameters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Parameters</h2>\n<p>Like most C-descended languages, TypeScript requires declaration of\ntype parameters:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> liftArray&lt;T&gt;(</span><span style=\"color: #1A1A1A\">t</span><span style=\"color: #000000\">: T): Array&lt;T&gt; {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> [</span><span style=\"color: #1A1A1A\">t</span><span style=\"color: #000000\">];</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>There is no case requirement, but type parameters are conventionally\nsingle uppercase letters. Type parameters can also be constrained to a\ntype, which behaves a bit like type class constraints:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> firstish&lt;T </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> { </span><span style=\"color: #1A1A1A\">length</span><span style=\"color: #000000\">: number }&gt;(</span><span style=\"color: #1A1A1A\">t1</span><span style=\"color: #000000\">: T, </span><span style=\"color: #1A1A1A\">t2</span><span style=\"color: #000000\">: T): T {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">t1</span><span style=\"color: #000000\">.length &gt; </span><span style=\"color: #1A1A1A\">t2</span><span style=\"color: #000000\">.length ? </span><span style=\"color: #1A1A1A\">t1</span><span style=\"color: #000000\"> : </span><span style=\"color: #1A1A1A\">t2</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>TypeScript can usually infer type arguments from a call based on the\ntype of the arguments, so type arguments are usually not needed.</p>\n<p>Because TypeScript is structural, it doesn’t need type parameters as\nmuch as nominal systems. Specifically, they are not needed to make a\nfunction polymorphic. Type parameters should only be used to\n<em>propagate</em> type information, such as constraining parameters to be\nthe same type:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> length&lt;T </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> ArrayLike&lt;unknown&gt;&gt;(</span><span style=\"color: #1A1A1A\">t</span><span style=\"color: #000000\">: T): number {}</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> length(</span><span style=\"color: #1A1A1A\">t</span><span style=\"color: #000000\">: ArrayLike&lt;unknown&gt;): number {}</span></code></div></pre>\n<p>In the first <code>length</code>, T is not necessary; notice that it’s only\nreferenced once, so it’s not being used to constrain the type of the\nreturn value or other parameters.</p>\n<h3 id=\"higher-kinded-types\" style=\"position:relative;\"><a href=\"#higher-kinded-types\" aria-label=\"higher kinded types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Higher-kinded types</h3>\n<p>TypeScript does not have higher kinded types, so the following is not legal:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> length&lt;T </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> ArrayLike&lt;unknown&gt;, U&gt;(</span><span style=\"color: #1A1A1A\">m</span><span style=\"color: #000000\">: T&lt;U&gt;) {}</span></code></div></pre>\n<h3 id=\"point-free-programming\" style=\"position:relative;\"><a href=\"#point-free-programming\" aria-label=\"point free programming permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Point-free programming</h3>\n<p>Point-free programming — heavy use of currying and function\ncomposition — is possible in JavaScript, but can be verbose.\nIn TypeScript, type inference often fails for point-free programs, so\nyou’ll end up specifying type parameters instead of value parameters. The\nresult is so verbose that it’s usually better to avoid point-free\nprogramming.</p>\n<h2 id=\"module-system\" style=\"position:relative;\"><a href=\"#module-system\" aria-label=\"module system permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Module system</h2>\n<p>JavaScript’s modern module syntax is a bit like Haskell’s, except that\nany file with <code>import</code> or <code>export</code> is implicitly a module:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">Type</span><span style=\"color: #000000\"> } </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"npm-package\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #1A1A1A\">other</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">Types</span><span style=\"color: #000000\"> } </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./local-package\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">prefix</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"../lib/third-package\"</span><span style=\"color: #000000\">;</span></code></div></pre>\n<p>You can also import commonjs modules — modules written using node.js’\nmodule system:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">f</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"single-function-package\"</span><span style=\"color: #000000\">);</span></code></div></pre>\n<p>You can export with an export list:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> { </span><span style=\"color: #1A1A1A\">f</span><span style=\"color: #000000\"> };</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> f() {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> g();</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> g() {} </span><span style=\"color: #008000\">// g is not exported</span></code></div></pre>\n<p>Or by marking each export individually:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> f { </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> g() }</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> g() { }</span></code></div></pre>\n<p>The latter style is more common but both are allowed, even in the same\nfile.</p>\n<h2 id=\"readonly-and-const\" style=\"position:relative;\"><a href=\"#readonly-and-const\" aria-label=\"readonly and const permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>readonly</code> and <code>const</code></h2>\n<p>In JavaScript, mutability is the default, although it allows variable\ndeclarations with <code>const</code> to declare that the <em>reference</em> is\nimmutable. The referent is still mutable:</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> = [</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">];</span>\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">.push(</span><span style=\"color: #09835A\">102</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// ):</span>\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">[</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">] = </span><span style=\"color: #09835A\">101</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// D:</span></code></div></pre>\n<p>TypeScript additionally has a <code>readonly</code> modifier for properties.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Rx {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">readonly</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">rx</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> Rx </span><span style=\"color: #000000\">= { x: </span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\"> };</span>\n<span style=\"color: #1A1A1A\">rx</span><span style=\"color: #000000\">.x = </span><span style=\"color: #09835A\">12</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// error</span></code></div></pre>\n<p>It also ships with a mapped type <code>Readonly&#x3C;T></code> that makes\nall properties <code>readonly</code>:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> X {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">rx</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> Readonly&lt;X&gt; </span><span style=\"color: #000000\">= { x: </span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\"> };</span>\n<span style=\"color: #1A1A1A\">rx</span><span style=\"color: #000000\">.x = </span><span style=\"color: #09835A\">12</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// error</span></code></div></pre>\n<p>And it has a specific <code>ReadonlyArray&#x3C;T></code> type that removes\nside-affecting methods and prevents writing to indices of the array,\nas well as special syntax for this type:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> ReadonlyArray&lt;number&gt; </span><span style=\"color: #000000\">= [</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">];</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> readonly number[] </span><span style=\"color: #000000\">= [</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">];</span>\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">.push(</span><span style=\"color: #09835A\">102</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// error</span>\n<span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">[</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">] = </span><span style=\"color: #09835A\">101</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// error</span></code></div></pre>\n<p>You can also use a const-assertion, which operates on arrays and\nobject literals:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">a </span><span style=\"color: #000000\">= [</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">] </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> const;</span>\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">.push(</span><span style=\"color: #09835A\">102</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// error</span>\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">[</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">] = </span><span style=\"color: #09835A\">101</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// error</span></code></div></pre>\n<p>However, none of these options are the default, so they are not\nconsistently used in TypeScript code.</p>\n<h2 id=\"next-steps\" style=\"position:relative;\"><a href=\"#next-steps\" aria-label=\"next steps permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Next Steps</h2>\n<p>This doc is a high level overview of the syntax and types you would use in everyday code. From here you should:</p>\n<ul>\n<li>Read the full Handbook <a href=\"/docs/handbook/intro.html\">from start to finish</a> (30m)</li>\n<li>Explore the <a href=\"/play#show-examples\">Playground examples</a>.</li>\n</ul>","headings":[{"value":"Prerequisites","depth":2},{"value":"Concepts not in Haskell","depth":2},{"value":"Built-in types","depth":2},{"value":"Other important TypeScript types","depth":3},{"value":"Boxed types","depth":3},{"value":"Gradual typing","depth":2},{"value":"Structural typing","depth":2},{"value":"Unions","depth":2},{"value":"Intersections","depth":3},{"value":"Unit types","depth":2},{"value":"Concepts similar to Haskell","depth":2},{"value":"Contextual typing","depth":2},{"value":"Type aliases","depth":2},{"value":"Discriminated Unions","depth":2},{"value":"Type Parameters","depth":2},{"value":"Higher-kinded types","depth":3},{"value":"Point-free programming","depth":3},{"value":"Module system","depth":2},{"value":"readonly and const","depth":2},{"value":"Next Steps","depth":2}],"frontmatter":{"permalink":"/docs/handbook/typescript-in-5-minutes-func.html","title":"TypeScript for Functional Programmers","disable_toc":null,"oneline":"Learn TypeScript if you have a background in functional programming"}},"prev":null,"next":null},"pageContext":{"id":"typescript-for-functional-programmers","slug":"/docs/handbook/typescript-in-5-minutes-func.html","repoPath":"/packages/documentation/copy/en/get-started/TS for Functional Programmers.md","lang":"en","modifiedTime":"2020-08-09T01:41:30.803Z"}}}