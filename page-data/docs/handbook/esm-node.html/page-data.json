{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/esm-node.html","result":{"data":{"markdownRemark":{"id":"7815fa81-ff6e-5e5b-a370-19afe8257643","excerpt":"For the last few years, Node.js has been working to support running ECMAScript modules (ESM).\nThis has been a very difficult feature to support, since the…","html":"<p>For the last few years, Node.js has been working to support running ECMAScript modules (ESM).\nThis has been a very difficult feature to support, since the foundation of the Node.js ecosystem is built on a different module system called CommonJS (CJS).</p>\n<p>Interoperating between the two module systems brings large challenges, with many new features to juggle;\nhowever, support for ESM in Node.js is now implemented in Node.js, and the dust has begun to settle.</p>\n<p>That’s why TypeScript brings two new <code>module</code> and <code>moduleResolution</code> settings: <code>node16</code> and <code>nodenext</code>.</p>\n<pre class=\"shiki light-plus tsconfig lsp\" style=\"background-color: #FFFFFF; color: #000000\" tsconfig=\"true\"><div class='code-container'><code><div class='line'><span style=\"color: #000000\">{</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"<a aria-hidden=true tabindex=\"-1\" href='https://www.typescriptlang.org/tsconfig#compilerOptions'><data-lsp lsp=\"The set of compiler options for your project\">compilerOptions</data-lsp></a>\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0451A5\">\"<a aria-hidden=true tabindex=\"-1\" href='https://www.typescriptlang.org/tsconfig#module'><data-lsp lsp=\"Specify what module code is generated.\">module</data-lsp></a>\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"nodenext\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>These new modes bring a few high-level features which we’ll explore here.</p>\n<h3 id=\"type-in-packagejson-and-new-extensions\" style=\"position:relative;\"><a href=\"#type-in-packagejson-and-new-extensions\" aria-label=\"type in packagejson and new extensions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>type</code> in <code>package.json</code> and New Extensions</h3>\n<p>Node.js supports <a href=\"https://nodejs.org/api/packages.html#packages_package_json_and_file_extensions\">a new setting in <code>package.json</code></a> called <code>type</code>.\n<code>\"type\"</code> can be set to either <code>\"module\"</code> or <code>\"commonjs\"</code>.</p>\n<pre class=\"shiki light-plus tsconfig lsp\" style=\"background-color: #FFFFFF; color: #000000\" tsconfig=\"true\"><div class='code-container'><code><div class='line'><span style=\"color: #000000\">{</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"name\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"my-package\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"type\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"module\"</span><span style=\"color: #000000\">,</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"//\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"...\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"dependencies\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>This setting controls whether <code>.js</code> files are interpreted as ES modules or CommonJS modules, and defaults to CommonJS when not set.\nWhen a file is considered an ES module, a few different rules come into play compared to CommonJS:</p>\n<ul>\n<li><code>import</code>/<code>export</code> statements and top-level <code>await</code> can be used</li>\n<li>relative import paths need full extensions (e.g we have to write <code>import \"./foo.js\"</code> instead of <code>import \"./foo\"</code>)</li>\n<li>imports might resolve differently from dependencies in <code>node_modules</code></li>\n<li>certain global-like values like <code>require()</code> and <code>__dirname</code> cannot be used directly</li>\n<li>CommonJS modules get imported under certain special rules</li>\n</ul>\n<p>We’ll come back to some of these.</p>\n<p>To overlay the way TypeScript works in this system, <code>.ts</code> and <code>.tsx</code> files now work the same way.\nWhen TypeScript finds a <code>.ts</code>, <code>.tsx</code>, <code>.js</code>, or <code>.jsx</code> file, it will walk up looking for a <code>package.json</code> to see whether that file is an ES module, and use that to determine:</p>\n<ul>\n<li>how to find other modules which that file imports</li>\n<li>and how to transform that file if producing outputs</li>\n</ul>\n<p>When a <code>.ts</code> file is compiled as an ES module, ECMAScript <code>import</code>/<code>export</code> syntax is left alone in the <code>.js</code> output;\nwhen it’s compiled as a CommonJS module, it will produce the same output you get today under <a href=\"/tsconfig#module\"><code>module</code></a>: <code>commonjs</code>.</p>\n<p>This also means paths resolve differently between <code>.ts</code> files that are ES modules and ones that are CJS modules.\nFor example, let’s say you have the following code today:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// ./foo.ts</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">helper</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #008000\">// ...</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// ./bar.ts</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">helper</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./foo\"</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// only works in CJS</span></div><div class='line'></div><div class='line'><span style=\"color: #795E26\">helper</span><span style=\"color: #000000\">();</span></div></code></div></pre>\n<p>This code works in CommonJS modules, but will fail in ES modules because relative import paths need to use extensions.\nAs a result, it will have to be rewritten to use the extension of the <em>output</em> of <code>foo.ts</code> - so <code>bar.ts</code> will instead have to import from <code>./foo.js</code>.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// ./bar.ts</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">helper</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./foo.js\"</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// works in ESM & CJS</span></div><div class='line'></div><div class='line'><span style=\"color: #795E26\">helper</span><span style=\"color: #000000\">();</span></div></code></div></pre>\n<p>This might feel a bit cumbersome at first, but TypeScript tooling like auto-imports and path completion will typically just do this for you.</p>\n<p>One other thing to mention is the fact that this applies to <code>.d.ts</code> files too.\nWhen TypeScript finds a <code>.d.ts</code> file in package, whether it is treated as an ESM or CommonJS file is based on the containing package.</p>\n<h3 id=\"new-file-extensions\" style=\"position:relative;\"><a href=\"#new-file-extensions\" aria-label=\"new file extensions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>New File Extensions</h3>\n<p>The <code>type</code> field in <code>package.json</code> is nice because it allows us to continue using the <code>.ts</code> and <code>.js</code> file extensions which can be convenient;\nhowever, you will occasionally need to write a file that differs from what <code>type</code> specifies.\nYou might also just prefer to always be explicit.</p>\n<p>Node.js supports two extensions to help with this: <code>.mjs</code> and <code>.cjs</code>.\n<code>.mjs</code> files are always ES modules, and <code>.cjs</code> files are always CommonJS modules, and there’s no way to override these.</p>\n<p>In turn, TypeScript supports two new source file extensions: <code>.mts</code> and <code>.cts</code>.\nWhen TypeScript emits these to JavaScript files, it will emit them to <code>.mjs</code> and <code>.cjs</code> respectively.</p>\n<p>Furthermore, TypeScript also supports two new declaration file extensions: <code>.d.mts</code> and <code>.d.cts</code>.\nWhen TypeScript generates declaration files for <code>.mts</code> and <code>.cts</code>, their corresponding extensions will be <code>.d.mts</code> and <code>.d.cts</code>.</p>\n<p>Using these extensions is entirely optional, but will often be useful even if you choose not to use them as part of your primary workflow.</p>\n<h3 id=\"commonjs-interop\" style=\"position:relative;\"><a href=\"#commonjs-interop\" aria-label=\"commonjs interop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CommonJS Interop</h3>\n<p>Node.js allows ES modules to import CommonJS modules as if they were ES modules with a default export.</p>\n<pre class=\"shiki light-plus twoslash lsp\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @filename: helper.cts</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">helper</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"hello world!\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'>&nbsp;</div><div class='line'><span style=\"color: #008000\">// @filename: index.mts</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">foo</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./helper.cjs\"</span><span style=\"color: #000000\">;</span></div><div class='line'>&nbsp;</div><div class='line'><span style=\"color: #008000\">// prints \"hello world!\"</span></div><div class='line'><span style=\"color: #001080\">foo</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">helper</span><span style=\"color: #000000\">();</span></div></code><a class='playground-link' href='https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAdnZHkA8AXAKBAgDMBLFDAQ0jVAAtlEAHZAJwDoBjAgZyL5W0DgVBl4GPhWgYmLdhwAUASlABvIqB2gec-tBRdE0AObKARM0SnQAd1GJYAQkuqA3EQC+REmHBKajoGCgxYfC5IASIKSBExCWhoCQ5oSFBLLmAbJV4AK35LL39QVg4wgUybO0cOZzciMmSuXM41DyA'>Try</a></div></pre>\n<p>In some cases, Node.js also synthesizes named exports from CommonJS modules, which can be more convenient.\nIn these cases, ES modules can use a “namespace-style” import (i.e. <code>import * as foo from \"...\"</code>), or named imports (i.e. <code>import { helper } from \"...\"</code>).</p>\n<pre class=\"shiki light-plus twoslash lsp\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @filename: helper.cts</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">helper</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"hello world!\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'>&nbsp;</div><div class='line'><span style=\"color: #008000\">// @filename: index.mts</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">helper</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./helper.cjs\"</span><span style=\"color: #000000\">;</span></div><div class='line'>&nbsp;</div><div class='line'><span style=\"color: #008000\">// prints \"hello world!\"</span></div><div class='line'><span style=\"color: #795E26\">helper</span><span style=\"color: #000000\">();</span></div></code><a class='playground-link' href='https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAdnZHkA8AXAKBAgDMBLFDAQ0jVAAtlEAHZAJwDoBjAgZyL5W0DgVBl4GPhWgYmLdhwAUASlABvIqB2gec-tBRdE0AObKARM0SnQAd1GJYAQkuqA3EQC+REmHBKajoGCgxYfC5IASIKSBExTQU2TlBvCQ5oSFBLLmAbJV4AK35LL39QVg4wgRybO0cOZzciAs41DyA'>Try</a></div></pre>\n<p>There isn’t always a way for TypeScript to know whether these named imports will be synthesized, but TypeScript will err on being permissive and use some heuristics when importing from a file that is definitely a CommonJS module.</p>\n<p>One TypeScript-specific note about interop is the following syntax:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">foo</span><span style=\"color: #000000\"> = </span><span style=\"color: #AF00DB\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"foo\"</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>In a CommonJS module, this just boils down to a <code>require()</code> call, and in an ES module, this imports <a href=\"https://nodejs.org/api/module.html#module_module_createrequire_filename\"><code>createRequire</code></a> to achieve the same thing.\nThis will make code less portable on runtimes like the browser (which don’t support <code>require()</code>), but will often be useful for interoperability.\nIn turn, you can write the above example using this syntax as follows:</p>\n<pre class=\"shiki light-plus twoslash lsp\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @filename: helper.cts</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">helper</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"hello world!\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'>&nbsp;</div><div class='line'><span style=\"color: #008000\">// @filename: index.mts</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">foo</span><span style=\"color: #000000\"> = </span><span style=\"color: #AF00DB\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"./foo.cjs\"</span><span style=\"color: #000000\">);</span></div><div class='line'>&nbsp;</div><div class='line'><span style=\"color: #001080\">foo</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">helper</span><span style=\"color: #000000\">()</span></div></code><a class='playground-link' href='https://www.typescriptlang.org/play/#code/PTAEAEFsHsBMFcA2BTAXKAdnZHkA8AXAKBAgDMBLFDAQ0jVAAtlEAHZAJwDoBjAgZyL5W0DgVBl4GPhWgYmLdhwAUASlABvIqB2gec-tBRdE0AObKARM0SnQAd1GJYAQkuqA3EQC+REmHBKajoGCgxYfC5IASIKSBExCWhoUABeUA5kAEd4CkyrLmAyZN4AK353LyJi6C4bJTUgA'>Try</a></div></pre>\n<p>Finally, it’s worth noting that the only way to import ESM files from a CJS module is using dynamic <code>import()</code> calls.\nThis can present challenges, but is the behavior in Node.js today.</p>\n<p>You can <a href=\"https://nodejs.org/api/esm.html#esm_interoperability_with_commonjs\">read more about ESM/CommonJS interop in Node.js here</a>.</p>\n<h3 id=\"packagejson-exports-imports-and-self-referencing\" style=\"position:relative;\"><a href=\"#packagejson-exports-imports-and-self-referencing\" aria-label=\"packagejson exports imports and self referencing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>package.json</code> Exports, Imports, and Self-Referencing</h3>\n<p>Node.js supports <a href=\"https://nodejs.org/api/packages.html#packages_exports\">a new field for defining entry points in <code>package.json</code> called <code>\"exports\"</code></a>.\nThis field is a more powerful alternative to defining <code>\"main\"</code> in <code>package.json</code>, and can control what parts of your package are exposed to consumers.</p>\n<p>Here’s an <code>package.json</code> that supports separate entry-points for CommonJS and ESM:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">json</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// package.json</span></div><div class='line'><span style=\"color: #000000\">{</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"name\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"my-package\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"type\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"module\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"exports\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0451A5\">\".\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">            </span><span style=\"color: #008000\">// Entry-point for `import \"my-package\"` in ESM</span></div><div class='line'><span style=\"color: #000000\">            </span><span style=\"color: #0451A5\">\"import\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"./esm/index.js\"</span><span style=\"color: #000000\">,</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">            </span><span style=\"color: #008000\">// Entry-point for `require(\"my-package\") in CJS</span></div><div class='line'><span style=\"color: #000000\">            </span><span style=\"color: #0451A5\">\"require\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"./commonjs/index.cjs\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">        },</span></div><div class='line'><span style=\"color: #000000\">    },</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #008000\">// CJS fall-back for older versions of Node.js</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"main\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"./commonjs/index.cjs\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>There’s a lot to this feature, <a href=\"https://nodejs.org/api/packages.html\">which you can read more about on the Node.js documentation</a>.\nHere we’ll try to focus on how TypeScript supports it.</p>\n<p>With TypeScript’s original Node support, it would look for a <code>\"main\"</code> field, and then look for declaration files that corresponded to that entry.\nFor example, if <code>\"main\"</code> pointed to <code>./lib/index.js</code>, TypeScript would look for a file called <code>./lib/index.d.ts</code>.\nA package author could override this by specifying a separate field called <code>\"types\"</code> (e.g. <code>\"types\": \"./types/index.d.ts\"</code>).</p>\n<p>The new support works similarly with <a href=\"https://nodejs.org/api/packages.html\">import conditions</a>.\nBy default, TypeScript overlays the same rules with import conditions - if you write an <code>import</code> from an ES module, it will look up the <code>import</code> field, and from a CommonJS module, it will look at the <code>require</code> field.\nIf it finds them, it will look for a colocated declaration file.\nIf you need to point to a different location for your type declarations, you can add a <code>\"types\"</code> import condition.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">json</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// package.json</span></div><div class='line'><span style=\"color: #000000\">{</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"name\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"my-package\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"type\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"module\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"exports\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0451A5\">\".\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">            </span><span style=\"color: #008000\">// Entry-point for TypeScript resolution - must occur first!</span></div><div class='line'><span style=\"color: #000000\">            </span><span style=\"color: #0451A5\">\"types\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"./types/index.d.ts\"</span><span style=\"color: #000000\">,</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">            </span><span style=\"color: #008000\">// Entry-point for `import \"my-package\"` in ESM</span></div><div class='line'><span style=\"color: #000000\">            </span><span style=\"color: #0451A5\">\"import\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"./esm/index.js\"</span><span style=\"color: #000000\">,</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">            </span><span style=\"color: #008000\">// Entry-point for `require(\"my-package\") in CJS</span></div><div class='line'><span style=\"color: #000000\">            </span><span style=\"color: #0451A5\">\"require\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"./commonjs/index.cjs\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">        },</span></div><div class='line'><span style=\"color: #000000\">    },</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #008000\">// CJS fall-back for older versions of Node.js</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"main\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"./commonjs/index.cjs\"</span><span style=\"color: #000000\">,</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #008000\">// Fall-back for older versions of TypeScript</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"types\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"./types/index.d.ts\"</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>TypeScript also supports <a href=\"https://nodejs.org/api/packages.html#packages_imports\">the <code>\"imports\"</code> field of <code>package.json</code></a> in a similar manner (looking for declaration files alongside corresponding files), and supports <a href=\"https://nodejs.org/api/packages.html#packages_self_referencing_a_package_using_its_name\">packages self-referencing themselves</a>.\nThese features are generally not as involved, but are supported.</p>","headings":[{"value":"type in package.json and New Extensions","depth":3},{"value":"New File Extensions","depth":3},{"value":"CommonJS Interop","depth":3},{"value":"package.json Exports, Imports, and Self-Referencing","depth":3}],"frontmatter":{"permalink":"/docs/handbook/esm-node.html","title":"ECMAScript Modules in Node.js","disable_toc":null,"handbook":null,"oneline":"Using ECMAScript Modules in Node.js","preamble":null,"deprecated_by":null,"deprecation_redirects":null,"experimental":null}},"prev":null,"next":null},"pageContext":{"id":"2-ecmascript-modules-in-node.js","slug":"/docs/handbook/esm-node.html","repoPath":"/packages/documentation/copy/en/reference/ESM Support for Node.md","lang":"en","modifiedTime":"2023-02-21T11:32:56.854Z"}},"staticQueryHashes":[]}