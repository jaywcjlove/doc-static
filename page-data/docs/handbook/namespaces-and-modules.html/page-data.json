{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/namespaces-and-modules.html","result":{"data":{"markdownRemark":{"id":"0a231a11-f8d6-5b42-9070-8db75b931668","excerpt":"This post outlines the various ways to organize your code using modules and namespaces in TypeScript.\nWe’ll also go over some advanced topics of how to use…","html":"<p>This post outlines the various ways to organize your code using modules and namespaces in TypeScript.\nWe’ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.</p>\n<p>See the <a href=\"/docs/handbook/modules.html\">Modules</a> documentation for more information about ES Modules.\nSee the <a href=\"/docs/handbook/namespaces.html\">Namespaces</a> documentation for more information about TypeScript namespaces.</p>\n<p>Note: In <em>very</em> old versions of TypeScript namespaces were called ‘Internal Modules’, these pre-date JavaScript module systems.</p>\n<h2 id=\"using-modules\" style=\"position:relative;\"><a href=\"#using-modules\" aria-label=\"using modules permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using Modules</h2>\n<p>Modules can contain both code and declarations.</p>\n<p>Modules also have a dependency on a module loader (such as CommonJs/Require.js) or a runtime which supports ES Modules.\nModules provide for better code reuse, stronger isolation and better tooling support for bundling.</p>\n<p>It is also worth noting that, for Node.js applications, modules are the default and <strong>we recommended modules over namespaces in modern code</strong>.</p>\n<p>Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations.\nThus, for new projects modules would be the recommended code organization mechanism.</p>\n<h2 id=\"using-namespaces\" style=\"position:relative;\"><a href=\"#using-namespaces\" aria-label=\"using namespaces permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using Namespaces</h2>\n<p>Namespaces are a TypeScript-specific way to organize code.<br>\nNamespaces are simply named JavaScript objects in the global namespace.\nThis makes namespaces a very simple construct to use.\nUnlike modules, they can span multiple files, and can be concatenated using <code>--outFile</code>.\nNamespaces can be a good way to structure your code in a Web Application, with all dependencies included as <code>&#x3C;script></code> tags in your HTML page.</p>\n<p>Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.</p>\n<h2 id=\"pitfalls-of-namespaces-and-modules\" style=\"position:relative;\"><a href=\"#pitfalls-of-namespaces-and-modules\" aria-label=\"pitfalls of namespaces and modules permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pitfalls of Namespaces and Modules</h2>\n<p>In this section we’ll describe various common pitfalls in using namespaces and modules, and how to avoid them.</p>\n<h2 id=\"-reference-ing-a-module\" style=\"position:relative;\"><a href=\"#-reference-ing-a-module\" aria-label=\" reference ing a module permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>/// &#x3C;reference></code>-ing a module</h2>\n<p>A common mistake is to try to use the <code>/// &#x3C;reference ... /></code> syntax to refer to a module file, rather than using an <code>import</code> statement.\nTo understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of an <code>import</code> (e.g. the <code>...</code> in <code>import x from \"...\";</code>, <code>import x = require(\"...\");</code>, etc.) path.</p>\n<p>The compiler will try to find a <code>.ts</code>, <code>.tsx</code>, and then a <code>.d.ts</code> with the appropriate path.\nIf a specific file could not be found, then the compiler will look for an <em>ambient module declaration</em>.\nRecall that these need to be declared in a <code>.d.ts</code> file.</p>\n<ul>\n<li>\n<p><code>myModules.d.ts</code></p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #008000\">// In a .d.ts file or .ts file that is not a module:</span>\n<span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">module</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"SomeModule\"</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> fn(): string;</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n</li>\n<li>\n<p><code>myOtherModule.ts</code></p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #008000\">/// </span><span style=\"color: #800000\">&lt;reference</span><span style=\"color: #008000\"> </span><span style=\"color: #DC0000\">path</span><span style=\"color: #000000\">=</span><span style=\"color: #A31515\">\"myModules.d.ts\"</span><span style=\"color: #008000\"> </span><span style=\"color: #800000\">/&gt;</span>\n<span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">m</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"SomeModule\"</span><span style=\"color: #000000\">;</span></code></div></pre>\n</li>\n</ul>\n<p>The reference tag here allows us to locate the declaration file that contains the declaration for the ambient module.\nThis is how the <code>node.d.ts</code> file that several of the TypeScript samples use is consumed.</p>\n<h2 id=\"needless-namespacing\" style=\"position:relative;\"><a href=\"#needless-namespacing\" aria-label=\"needless namespacing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Needless Namespacing</h2>\n<p>If you’re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:</p>\n<ul>\n<li>\n<p><code>shapes.ts</code></p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">namespace</span><span style=\"color: #000000\"> Shapes {</span>\n<span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> Triangle {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">/* ... */</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> Square {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">/* ... */</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n</li>\n</ul>\n<p>The top-level module here <code>Shapes</code> wraps up <code>Triangle</code> and <code>Square</code> for no reason.\nThis is confusing and annoying for consumers of your module:</p>\n<ul>\n<li>\n<p><code>shapeConsumer.ts</code></p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">shapes</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./shapes\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">t </span><span style=\"color: #000000\">= </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> shapes.Shapes.Triangle(); </span><span style=\"color: #008000\">// shapes.Shapes?</span></code></div></pre>\n</li>\n</ul>\n<p>A key feature of modules in TypeScript is that two different modules will never contribute names to the same scope.\nBecause the consumer of a module decides what name to assign it, there’s no need to proactively wrap up the exported symbols in a namespace.</p>\n<p>To reiterate why you shouldn’t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions.\nBecause the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it’s unnecessary to use an additional module layer for exported objects.</p>\n<p>Here’s a revised example:</p>\n<ul>\n<li>\n<p><code>shapes.ts</code></p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> Triangle {</span>\n<span style=\"color: #008000\">/* ... */</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> Square {</span>\n<span style=\"color: #008000\">/* ... */</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n</li>\n<li>\n<p><code>shapeConsumer.ts</code></p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">shapes</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./shapes\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">t </span><span style=\"color: #000000\">= </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> shapes.Triangle();</span></code></div></pre>\n</li>\n</ul>\n<h2 id=\"trade-offs-of-modules\" style=\"position:relative;\"><a href=\"#trade-offs-of-modules\" aria-label=\"trade offs of modules permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Trade-offs of Modules</h2>\n<p>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files.\nOne effect of this is that it’s not possible to concatenate multiple module source files depending on the module system you target.\nFor instance, you can’t use the <code>outFile</code> option while targeting <code>commonjs</code> or <code>umd</code>, but with TypeScript 1.8 and later, <a href=\"./release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile\">it’s possible</a> to use <code>outFile</code> when targeting <code>amd</code> or <code>system</code>.</p>","headings":[{"value":"Using Modules","depth":2},{"value":"Using Namespaces","depth":2},{"value":"Pitfalls of Namespaces and Modules","depth":2},{"value":"/// <reference>-ing a module","depth":2},{"value":"Needless Namespacing","depth":2},{"value":"Trade-offs of Modules","depth":2}],"frontmatter":{"permalink":"/docs/handbook/namespaces-and-modules.html","title":"Namespaces and Modules","disable_toc":null,"handbook":null,"oneline":"How to organize code in TypeScript via modules or namespaces","beta":null}},"prev":null,"next":null},"pageContext":{"id":"2namespaces-and-modules","slug":"/docs/handbook/namespaces-and-modules.html","repoPath":"/packages/documentation/copy/en/reference/Namespaces and Modules.md","lang":"en","modifiedTime":"2020-11-23T10:39:15.619Z"}},"staticQueryHashes":[]}