{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/release-notes/typescript-3-1.html","result":{"data":{"markdownRemark":{"id":"f9d6dc17-4697-5231-bdec-c6053f07ccd6","excerpt":"Mapped types on tuples and arrays In TypeScript 3.1, mapped object types[1] over tuples and arrays now produce new tuples/arrays, rather than creating a new…","html":"<h2 id=\"mapped-types-on-tuples-and-arrays\" style=\"position:relative;\"><a href=\"#mapped-types-on-tuples-and-arrays\" aria-label=\"mapped types on tuples and arrays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mapped types on tuples and arrays</h2>\n<p>In TypeScript 3.1, mapped object types<sup><a href=\"#ts-3-1-only-homomorphic\">[1]</a></sup> over tuples and arrays now produce new tuples/arrays, rather than creating a new type where members like <code>push()</code>, <code>pop()</code>, and <code>length</code> are converted.\nFor example:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> MapToPromise&lt;T&gt; = { [K </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keyof</span><span style=\"color: #000000\"> T]: Promise&lt;T[K]&gt; };</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Coordinate = [number, number];</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> PromiseCoordinate = MapToPromise&lt;Coordinate&gt;; </span><span style=\"color: #008000\">// [Promise&lt;number&gt;, Promise&lt;number&gt;]</span></code></div></pre>\n<p><code>MapToPromise</code> takes a type <code>T</code>, and when that type is a tuple like <code>Coordinate</code>, only the numeric properties are converted.\nIn <code>[number, number]</code>, there are two numerically named properties: <code>0</code> and <code>1</code>.\nWhen given a tuple like that, <code>MapToPromise</code> will create a new tuple where the <code>0</code> and <code>1</code> properties are <code>Promise</code>s of the original type.\nSo the resulting type <code>PromiseCoordinate</code> ends up with the type <code>[Promise&#x3C;number>, Promise&#x3C;number>]</code>.</p>\n<h2 id=\"properties-declarations-on-functions\" style=\"position:relative;\"><a href=\"#properties-declarations-on-functions\" aria-label=\"properties declarations on functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Properties declarations on functions</h2>\n<p>TypeScript 3.1 brings the ability to define properties on function declarations and <code>const</code>-declared functions, simply by assigning to properties on these functions in the same scope.\nThis allows us to write canonical JavaScript code without resorting to <code>namespace</code> hacks.\nFor example:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> readImage(</span><span style=\"color: #1A1A1A\">path</span><span style=\"color: #000000\">: string, callback: (</span><span style=\"color: #1A1A1A\">err</span><span style=\"color: #000000\">: any, </span><span style=\"color: #1A1A1A\">image</span><span style=\"color: #000000\">: Image) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #1A1A1A\">readImage</span><span style=\"color: #000000\">.sync = (</span><span style=\"color: #1A1A1A\">path</span><span style=\"color: #000000\">: string) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">contents </span><span style=\"color: #000000\">= fs.readFileSync(path);</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> decodeImageSync(</span><span style=\"color: #1A1A1A\">contents</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">};</span></code></div></pre>\n<p>Here, we have a function <code>readImage</code> which reads an image in a non-blocking asynchronous way.\nIn addition to <code>readImage</code>, we’ve provided a convenience function on <code>readImage</code> itself called <code>readImage.sync</code>.</p>\n<p>While ECMAScript exports are often a better way of providing this functionality, this new support allows code written in this style to “just work” TypeScript.\nAdditionally, this approach for property declarations allows us to express common patterns like <code>defaultProps</code> and <code>propTypes</code> on React function components (formerly known as SFCs).</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">FooComponent </span><span style=\"color: #000000\">= ({ </span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\"> }) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> &lt;div&gt;</span><span style=\"color: #1A1A1A\">Hello</span><span style=\"color: #000000\">! I </span><span style=\"color: #1A1A1A\">am</span><span style=\"color: #000000\"> {</span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\">}&lt;/</span><span style=\"color: #1A1A1A\">div</span><span style=\"color: #000000\">&gt;;</span>\n\n<span style=\"color: #1A1A1A\">FooComponent</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">defaultProps</span><span style=\"color: #000000\"> = {</span>\n<span style=\"color: #000000\">  name: </span><span style=\"color: #A31515\">\"(anonymous)\"</span>\n<span style=\"color: #000000\">};</span></code></div></pre>\n<!--\nfs.readFile(path, (err, data) => {\n        if (err) callback(err, undefined);\n        else decodeImage(data, (err, image) => {\n            if (err) callback(err, undefined);\n            else callback(undefined, image);\n        });\n    });\n-->\n<hr>\n<p><sup id=\"ts-3-1-only-homomorphic\">[1]</sup> More specifically, homomorphic mapped types like in the above form.</p>\n<h2 id=\"version-selection-with-typesversions\" style=\"position:relative;\"><a href=\"#version-selection-with-typesversions\" aria-label=\"version selection with typesversions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Version selection with <code>typesVersions</code></h2>\n<p>Feedback from our community, as well as our own experience, has shown us that leveraging the newest TypeScript features while also accommodating users on the older versions are difficult.\nTypeScript introduces a new feature called <code>typesVersions</code> to help accommodate these scenarios.</p>\n<p>When using Node module resolution in TypeScript 3.1, when TypeScript cracks open a <code>package.json</code> file to figure out which files it needs to read, it first looks at a new field called <code>typesVersions</code>.\nA <code>package.json</code> with a <code>typesVersions</code> field might look like this:</p>\n<pre class=\"shiki\"><div class=\"language-id\">json</div><div class='code-container'><code><span style=\"color: #000000\">{</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"name\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"package-name\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"version\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"1.0\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"types\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"./index.d.ts\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"typesVersions\"</span><span style=\"color: #000000\">: {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"&gt;=3.1\"</span><span style=\"color: #000000\">: { </span><span style=\"color: #0451A5\">\"*\"</span><span style=\"color: #000000\">: [</span><span style=\"color: #A31515\">\"ts3.1/*\"</span><span style=\"color: #000000\">] }</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>This <code>package.json</code> tells TypeScript to check whether the current version of TypeScript is running.\nIf it’s 3.1 or later, it figures out the path you’ve imported relative to the package, and reads from the package’s <code>ts3.1</code> folder.\nThat’s what that <code>{ \"*\": [\"ts3.1/*\"] }</code> means - if you’re familiar with path mapping today, it works exactly like that.</p>\n<p>So in the above example, if we’re importing from <code>\"package-name\"</code>, we’ll try to resolve from <code>[...]/node_modules/package-name/ts3.1/index.d.ts</code> (and other relevant paths) when running in TypeScript 3.1.\nIf we import from <code>package-name/foo</code>, we’ll try to look for <code>[...]/node_modules/package-name/ts3.1/foo.d.ts</code> and <code>[...]/node_modules/package-name/ts3.1/foo/index.d.ts</code>.</p>\n<p>What if we’re not running in TypeScript 3.1 in this example?\nWell, if none of the fields in <code>typesVersions</code> get matched, TypeScript falls back to the <code>types</code> field, so here TypeScript 3.0 and earlier will be redirected to <code>[...]/node_modules/package-name/index.d.ts</code>.</p>\n<h2 id=\"matching-behavior\" style=\"position:relative;\"><a href=\"#matching-behavior\" aria-label=\"matching behavior permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Matching behavior</h2>\n<p>The way that TypeScript decides on whether a version of the compiler &#x26; language matches is by using Node’s <a href=\"https://github.com/npm/node-semver#ranges\">semver ranges</a>.</p>\n<h2 id=\"multiple-fields\" style=\"position:relative;\"><a href=\"#multiple-fields\" aria-label=\"multiple fields permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multiple fields</h2>\n<p><code>typesVersions</code> can support multiple fields where each field name is specified by the range to match on.</p>\n<pre class=\"shiki\"><div class=\"language-id\">json</div><div class='code-container'><code><span style=\"color: #000000\">{</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"name\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"package-name\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"version\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"1.0\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"types\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"./index.d.ts\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"typesVersions\"</span><span style=\"color: #000000\">: {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"&gt;=3.2\"</span><span style=\"color: #000000\">: { </span><span style=\"color: #0451A5\">\"*\"</span><span style=\"color: #000000\">: [</span><span style=\"color: #A31515\">\"ts3.2/*\"</span><span style=\"color: #000000\">] },</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"&gt;=3.1\"</span><span style=\"color: #000000\">: { </span><span style=\"color: #0451A5\">\"*\"</span><span style=\"color: #000000\">: [</span><span style=\"color: #A31515\">\"ts3.1/*\"</span><span style=\"color: #000000\">] }</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Since ranges have the potential to overlap, determining which redirect applies is order-specific.\nThat means in the above example, even though both the <code>>=3.2</code> and the <code>>=3.1</code> matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.</p>\n<pre class=\"shiki\"><div class=\"language-id\">json</div><div class='code-container'><code><span style=\"color: #000000\">{</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #AF0B08\">name</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"package-name\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #AF0B08\">version</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"1.0\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #AF0B08\">types</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"./index.d.ts\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #AF0B08\">typesVersions</span><span style=\"color: #000000\">: {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #008000\">// NOTE: this doesn't work!</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"&gt;=3.1\"</span><span style=\"color: #000000\">: { </span><span style=\"color: #0451A5\">\"*\"</span><span style=\"color: #000000\">: [</span><span style=\"color: #A31515\">\"ts3.1/*\"</span><span style=\"color: #000000\">] },</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"&gt;=3.2\"</span><span style=\"color: #000000\">: { </span><span style=\"color: #0451A5\">\"*\"</span><span style=\"color: #000000\">: [</span><span style=\"color: #A31515\">\"ts3.2/*\"</span><span style=\"color: #000000\">] }</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code></div></pre>","headings":[{"value":"Mapped types on tuples and arrays","depth":2},{"value":"Properties declarations on functions","depth":2},{"value":"Version selection with typesVersions","depth":2},{"value":"Matching behavior","depth":2},{"value":"Multiple fields","depth":2}],"frontmatter":{"permalink":"/docs/handbook/release-notes/typescript-3-1.html","title":"TypeScript 3.1","disable_toc":null,"handbook":null,"oneline":"TypeScript 3.1 Release Notes","beta":null}},"prev":null,"next":null},"pageContext":{"id":"4typescript-3.1","slug":"/docs/handbook/release-notes/typescript-3-1.html","repoPath":"/packages/documentation/copy/en/release-notes/TypeScript 3.1.md","lang":"en","modifiedTime":"2020-11-23T10:39:15.623Z"}},"staticQueryHashes":[]}