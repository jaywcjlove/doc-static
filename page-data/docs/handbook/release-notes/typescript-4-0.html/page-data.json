{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/release-notes/typescript-4-0.html","result":{"data":{"markdownRemark":{"id":"9a1a570f-d644-569c-9567-e128831aae2e","excerpt":"Variadic Tuple Types Consider a function in JavaScript called concat that takes two array or tuple types and concatenates them together to make a new array…","html":"<h2 id=\"variadic-tuple-types\" style=\"position:relative;\"><a href=\"#variadic-tuple-types\" aria-label=\"variadic tuple types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Variadic Tuple Types</h2>\n<p>Consider a function in JavaScript called <code>concat</code> that takes two array or tuple types and concatenates them together to make a new array.</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> [...</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">, ...</span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">];</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Also consider <code>tail</code>, that takes an array or tuple, and returns all elements but the first.</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> tail(</span><span style=\"color: #1A1A1A\">arg</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> [</span><span style=\"color: #1A1A1A\">_</span><span style=\"color: #000000\">, ...</span><span style=\"color: #1A1A1A\">result</span><span style=\"color: #000000\">] = </span><span style=\"color: #1A1A1A\">arg</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">result</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>How would we type either of these in TypeScript?</p>\n<p>For <code>concat</code>, the only valid thing we could do in older versions of the language was to try and write some overloads.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: []): [];</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;A&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [A], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: []): [A];</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;A, B&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [A, B], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: []): [A, B];</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;A, B, C&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [A, B, C], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: []): [A, B, C];</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;A, B, C, D&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [A, B, C, D], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: []): [A, B, C, D];</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;A, B, C, D, E&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [A, B, C, D, E], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: []): [A, B, C, D, E];</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;A, B, C, D, E, F&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [A, B, C, D, E, F], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: []): [A, B, C, D, E, F];)</span></code></div></pre>\n<p>Uh…okay, that’s…seven overloads for when the second array is always empty.\nLet’s add some for when <code>arr2</code> has one argument.</p>\n<!-- prettier-ignore -->\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;A2&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: [A2]): [A2];</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;A1, A2&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [A1], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: [A2]): [A1, A2];</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;A1, B1, A2&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [A1, B1], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: [A2]): [A1, B1, A2];</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;A1, B1, C1, A2&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [A1, B1, C1], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: [A2]): [A1, B1, C1, A2];</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;A1, B1, C1, D1, A2&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [A1, B1, C1, D1], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: [A2]): [A1, B1, C1, D1, A2];</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;A1, B1, C1, D1, E1, A2&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [A1, B1, C1, D1, E1], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: [A2]): [A1, B1, C1, D1, E1, A2];</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;A1, B1, C1, D1, E1, F1, A2&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: [A1, B1, C1, D1, E1, F1], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: [A2]): [A1, B1, C1, D1, E1, F1, A2];</span></code></div></pre>\n<p>We hope it’s clear that this is getting unreasonable.\nUnfortunately, you’d also end up with the same sorts of issues typing a function like <code>tail</code>.</p>\n<p>This is another case of what we like to call “death by a thousand overloads”, and it doesn’t even solve the problem generally.\nIt only gives correct types for as many overloads as we care to write.\nIf we wanted to make a catch-all case, we’d need an overload like the following:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> concat&lt;T, U&gt;(</span><span style=\"color: #1A1A1A\">arr1</span><span style=\"color: #000000\">: T[], </span><span style=\"color: #1A1A1A\">arr2</span><span style=\"color: #000000\">: U[]): Array&lt;T | U&gt;;</span></code></div></pre>\n<p>But that signature doesn’t encode anything about the lengths of the input, or the order of the elements, when using tuples.</p>\n<p>TypeScript 4.0 brings two fundamental changes, along with inference improvements, to make typing these possible.</p>\n<p>The first change is that spreads in tuple type syntax can now be generic.\nThis means that we can represent higher-order operations on tuples and arrays even when we don’t know the actual types we’re operating over.\nWhen generic spreads are instantiated (or, replaced with a real type) in these tuple types, they can produce other sets of array and tuple types.</p>\n<p>For example, that means we can type function like <code>tail</code>, without our “death by a thousand overloads” issue.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function tail&amp;lt;T extends any[]>(arr: readonly [any, ...T]): [...T]'>tail</data-lsp>&lt;<data-lsp lsp='(type parameter) T in tail&amp;lt;T extends any[]>(arr: readonly [any, ...T]): [...T]'>T</data-lsp> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> any[]&gt;(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: readonly [any, ...T]'>arr</data-lsp></span><span style=\"color: #000000\">: readonly [any, ...<data-lsp lsp='(type parameter) T in tail&amp;lt;T extends any[]>(arr: readonly [any, ...T]): [...T]'>T</data-lsp>]) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> [</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const _ignored: any'>_ignored</data-lsp></span><span style=\"color: #000000\">, ...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const rest: [...T]'>rest</data-lsp></span><span style=\"color: #000000\">] = </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr: readonly [any, ...T]'>arr</data-lsp></span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const rest: [...T]'>rest</data-lsp></span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const myTuple: readonly [1, 2, 3, 4]'>myTuple</data-lsp> </span><span style=\"color: #000000\">= [</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">4</span><span style=\"color: #000000\">] </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> <data-lsp lsp='any'>const</data-lsp>;</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const myArray: string[]'>myArray</data-lsp> </span><span style=\"color: #000000\">= [</span><span style=\"color: #A31515\">\"hello\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"world\"</span><span style=\"color: #000000\">];</span>\n\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const r1: [2, 3, 4]'>r1</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function tail&amp;lt;[2, 3, 4]>(arr: readonly [any, 2, 3, 4]): [2, 3, 4]'>tail</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const myTuple: readonly [1, 2, 3, 4]'>myTuple</data-lsp></span><span style=\"color: #000000\">);</span>\n<span class='query'>//    ^ = const r1: [2, 3, 4]</span>\n\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const r2: [2, 3, 4, ...string[]]'>r2</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function tail&amp;lt;[2, 3, 4, ...string[]]>(arr: readonly [any, 2, 3, 4, ...string[]]): [2, 3, 4, ...string[]]'>tail</data-lsp>([...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const myTuple: readonly [1, 2, 3, 4]'>myTuple</data-lsp></span><span style=\"color: #000000\">, ...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const myArray: string[]'>myArray</data-lsp></span><span style=\"color: #000000\">] </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> <data-lsp lsp='any'>const</data-lsp>);</span>\n<span class='query'>//    ^ = const r2: [2, 3, 4, ...string[]]</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABFAhjANgHgCqIKYAeUeYAJgM6IpgCeA2gLoB8AFCgE7sBci7eKpBOhqI61GgBpEAOlnYGASkQBvAFCJEEBOSiiA+jADmYOH1JTZ0vjoaIAvFU4BudbzxQQ7JNaguAvqqqWmA6iAC2NNggAA7oePaiAIxSAExSAMxSACy2KJTBOi4FuhEAgpwoIg50AEQAFnjo6HA1UjUA7qbopDUMLkHauuyJCagYLBFRsXgKLgD0cxoaAHoA-IHFvCmjaOgsdJaTMXEWsmUVNLn5g7OqC0uIa0A'>Try</a></div></pre>\n<p>The second change is that rest elements can occur anywhere in a tuple - not just at the end!</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Strings = [string, string];</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Numbers = [number, number];</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> StrStrNumNumBool = [...Strings, ...Numbers, boolean];</span></code></div></pre>\n<p>Previously, TypeScript would issue an error like the following:</p>\n<pre class=\"shiki\"><div class='code-container'><code>A rest element must be last in a tuple type.</code></div></pre>\n<p>But with TypeScript 4.0, this restriction is relaxed.</p>\n<p>Note that in cases when we spread in a type without a known length, the resulting type becomes unbounded as well, and all the following elements factor into the resulting rest element type.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Strings = [string, string];</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Numbers = number[];</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Unbounded = [...Strings, ...Numbers, boolean];</span></code></div></pre>\n<p>By combining both of these behaviors together, we can write a single well-typed signature for <code>concat</code>:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> <data-lsp lsp='type Arr = readonly any[]'>Arr</data-lsp> = readonly any[];</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function concat&amp;lt;T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U]'>concat</data-lsp>&lt;<data-lsp lsp='(type parameter) T in concat&amp;lt;T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U]'>T</data-lsp> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> <data-lsp lsp='type Arr = readonly any[]'>Arr</data-lsp>, <data-lsp lsp='(type parameter) U in concat&amp;lt;T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U]'>U</data-lsp> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> <data-lsp lsp='type Arr = readonly any[]'>Arr</data-lsp>>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr1: T extends Arr'>arr1</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in concat&amp;lt;T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U]'>T</data-lsp>, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr2: U extends Arr'>arr2</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) U in concat&amp;lt;T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U]'>U</data-lsp>): [...<data-lsp lsp='(type parameter) T in concat&amp;lt;T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U]'>T</data-lsp>, ...<data-lsp lsp='(type parameter) U in concat&amp;lt;T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U]'>U</data-lsp>] {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> [...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr1: T extends Arr'>arr1</data-lsp></span><span style=\"color: #000000\">, ...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) arr2: U extends Arr'>arr2</data-lsp></span><span style=\"color: #000000\">];</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/C4TwDgpgBAggTnKBeKcIEMAmB7AdgGxCnVxAG0BdAbgCgaAzAV1wGNgBLPKFvF9YADwAVKBAAewCLkwBnWAgA0UAKqiJU2fLgA+ABToEARgBcUIUoNwATKeUBKU2QB0L81BdPlFKAG8aUVAhgRjhcKGcXS0MlD0srahoAXyA'>Try</a></div></pre>\n<p>While that one signature is still a bit lengthy, it’s just one signature that doesn’t have to be repeated, and it gives predictable behavior on all arrays and tuples.</p>\n<p>This functionality on its own is great, but it shines in more sophisticated scenarios too.\nFor example, consider a function to <a href=\"https://en.wikipedia.org/wiki/Partial_application\">partially apply arguments</a> called <code>partialCall</code>.\n<code>partialCall</code> takes a function - let’s call it <code>f</code> - along with the initial few arguments that <code>f</code> expects.\nIt then returns a new function that takes any other arguments that <code>f</code> still needs, and calls <code>f</code> when it receives them.</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> partialCall(</span><span style=\"color: #1A1A1A\">f</span><span style=\"color: #000000\">, ...</span><span style=\"color: #1A1A1A\">headArgs</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> (...</span><span style=\"color: #1A1A1A\">tailArgs</span><span style=\"color: #000000\">) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> f(...</span><span style=\"color: #1A1A1A\">headArgs</span><span style=\"color: #000000\">, ...</span><span style=\"color: #1A1A1A\">tailArgs</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>TypeScript 4.0 improves the inference process for rest parameters and rest tuple elements so that we can type this and have it “just work”.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> <data-lsp lsp='type Arr = readonly unknown[]'>Arr</data-lsp> = readonly unknown[];</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function partialCall&amp;lt;T extends Arr, U extends Arr, R>(f: (...args: [...T, ...U]) => R, ...headArgs: T): (...tailArgs: U) => R'>partialCall</data-lsp>&lt;<data-lsp lsp='(type parameter) T in partialCall&amp;lt;T extends Arr, U extends Arr, R>(f: (...args: [...T, ...U]) => R, ...headArgs: T): (...tailArgs: U) => R'>T</data-lsp> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> <data-lsp lsp='type Arr = readonly unknown[]'>Arr</data-lsp>, <data-lsp lsp='(type parameter) U in partialCall&amp;lt;T extends Arr, U extends Arr, R>(f: (...args: [...T, ...U]) => R, ...headArgs: T): (...tailArgs: U) => R'>U</data-lsp> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> <data-lsp lsp='type Arr = readonly unknown[]'>Arr</data-lsp>, <data-lsp lsp='(type parameter) R in partialCall&amp;lt;T extends Arr, U extends Arr, R>(f: (...args: [...T, ...U]) => R, ...headArgs: T): (...tailArgs: U) => R'>R</data-lsp>>(</span>\n<span style=\"color: #000000\">  <data-lsp lsp='(parameter) f: (...args: [...T, ...U]) => R'>f</data-lsp>: (...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) args: [...T, ...U]'>args</data-lsp></span><span style=\"color: #000000\">: [...<data-lsp lsp='(type parameter) T in partialCall&amp;lt;T extends Arr, U extends Arr, R>(f: (...args: [...T, ...U]) => R, ...headArgs: T): (...tailArgs: U) => R'>T</data-lsp>, ...<data-lsp lsp='(type parameter) U in partialCall&amp;lt;T extends Arr, U extends Arr, R>(f: (...args: [...T, ...U]) => R, ...headArgs: T): (...tailArgs: U) => R'>U</data-lsp>]) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> <data-lsp lsp='(type parameter) R in partialCall&amp;lt;T extends Arr, U extends Arr, R>(f: (...args: [...T, ...U]) => R, ...headArgs: T): (...tailArgs: U) => R'>R</data-lsp>,</span>\n<span style=\"color: #000000\">  ...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) headArgs: T extends Arr'>headArgs</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) T in partialCall&amp;lt;T extends Arr, U extends Arr, R>(f: (...args: [...T, ...U]) => R, ...headArgs: T): (...tailArgs: U) => R'>T</data-lsp></span>\n<span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> (...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) tailArgs: U extends Arr'>tailArgs</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='(type parameter) U in partialCall&amp;lt;T extends Arr, U extends Arr, R>(f: (...args: [...T, ...U]) => R, ...headArgs: T): (...tailArgs: U) => R'>U</data-lsp>) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> <data-lsp lsp='(parameter) f: (...args: [...T, ...U]) => R'>f</data-lsp>(...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) headArgs: T extends Arr'>headArgs</data-lsp></span><span style=\"color: #000000\">, ...</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) tailArgs: U extends Arr'>tailArgs</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/C4TwDgpgBAggTnKBeKcIEMAmB7AdgGxCgFdcBrXbAd1wG0BdAbgChmAzUgY2AEs8ow6OL3T4AwqPwAeACpQIAD2ARcmAM6wEAGigBVeUpXrNcHQCUAfAApmUKGwBcUKwDo3QgOZqntNy5k6frr0AJTIFlBmWrZQfgAWGJjwXk4yzGEA3jFowMRwuM5+wOg8+MneemFIEWyubglY5YFuxaXlISwAvkA'>Try</a></div></pre>\n<p>In this case, <code>partialCall</code> understands which parameters it can and can’t initially take, and returns functions that appropriately accept and reject anything left over.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const foo: (x: string, y: number, z: boolean) => void'>foo</data-lsp> </span><span style=\"color: #000000\">= (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: string'>x</data-lsp></span><span style=\"color: #000000\">: string, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) y: number'>y</data-lsp></span><span style=\"color: #000000\">: number, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) z: boolean'>z</data-lsp></span><span style=\"color: #000000\">: boolean) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> {};</span>\n\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const f1: (y: number, z: boolean) => void'>f1</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function partialCall&amp;lt;[x: string], [y: number, z: boolean], void>(f: (x: string, y: number, z: boolean) => void, x: string): (y: number, z: boolean) => void'>partialCall</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const foo: (x: string, y: number, z: boolean) => void'>foo</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\"><data-err>100</data-err></span><span style=\"color: #000000\">);</span>\n<span class=\"error\"><span>Argument of type 'number' is not assignable to parameter of type 'string'.</span><span class=\"code\">2345</span></span><span class=\"error-behind\">Argument of type 'number' is not assignable to parameter of type 'string'.</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const f2: () => void'>f2</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function partialCall&amp;lt;[x: string, y: number, z: boolean], [], void>(f: (x: string, y: number, z: boolean) => void, x: string, y: number, z: boolean): () => void'>partialCall</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const foo: (x: string, y: number, z: boolean) => void'>foo</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"hello\"</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">100</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\">true</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\"><data-err>&quot;oops&quot;</data-err></span><span style=\"color: #000000\">);</span>\n<span class=\"error\"><span>Expected 4 arguments, but got 5.</span><span class=\"code\">2554</span></span><span class=\"error-behind\">Expected 4 arguments, but got 5.</span>\n<span style=\"color: #008000\">// This works!</span>\n<span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const f3: (y: number, z: boolean) => void'>f3</data-lsp> </span><span style=\"color: #000000\">= <data-lsp lsp='function partialCall&amp;lt;[string], [y: number, z: boolean], void>(f: (args_0: string, args_1: number, args_2: boolean) => void, headArgs_0: string): (y: number, z: boolean) => void'>partialCall</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const foo: (x: string, y: number, z: boolean) => void'>foo</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"hello\"</span><span style=\"color: #000000\">);</span>\n<span class='query'>//    ^ = const f3: (y: number, z: boolean) => void</span>\n\n<span style=\"color: #008000\">// What can we do with f3 now?</span>\n\n<span style=\"color: #008000\">// Works!</span>\n<span style=\"color: #000000\"><data-lsp lsp='const f3: (y: number, z: boolean) => void'>f3</data-lsp>(</span><span style=\"color: #09835A\">123</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\">true</span><span style=\"color: #000000\">);</span>\n\n<span style=\"color: #000000\"><data-err><data-lsp lsp='const f3: (y: number, z: boolean) => void'>f3</data-lsp>();</data-err></span>\n<span class=\"error\"><span>Expected 2 arguments, but got 0.</span><span class=\"code\">2554</span></span><span class=\"error-behind\">Expected 2 arguments, but got 0.</span>\n<span style=\"color: #000000\"><data-lsp lsp='const f3: (y: number, z: boolean) => void'>f3</data-lsp>(</span><span style=\"color: #09835A\">123</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\"><data-err>&quot;hello&quot;</data-err></span><span style=\"color: #000000\">);</span>\n<span class=\"error\"><span>Argument of type 'string' is not assignable to parameter of type 'boolean'.</span><span class=\"code\">2345</span></span><span class=\"error-behind\">Argument of type 'string' is not assignable to parameter of type 'boolean'.</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwGYAsBWdOct9D1scAoAFwE8AHSUAQVlAF5RpIBDAEzgDsANtVABXfgGt+cAO78A2gF0A3OXIAzcQGNKASwGhaXaHq6CAwmcEAeACqhIAD0qR+PRE1gAaUAFUHzq7untA+AEoAfAAU5KCg6qhRAHQpxgDmKKDyKUm2Pjm+igCUbBGgYV6xoDkAFtw8zBmotuQlAN5VnJSi0PygySmUXLqCjZm+Jaxl6gNJdbxj+YPDo9AZRaoAvuQgoAC0B1qilAd75FoCiJTxcHBs-Y6oV9C6-Gk+1Kj8ogC2AEYwHwAL1Qf1ugm4-EmZTam1U50u13UAEZ7kYTLozJZBIIoupbj5kQAGIkbNQXfhXeJoNHGUwWKx4gmgABEdRxcBZhJJPko0FEkB8LNutEQLLJOzAthqug8MgQEkQAEIEZSkRhaRisYz8XAhezBJyybs4qAAHoAfjUuwA6jUuNctFw+jIGHxQDJdJQavENdIZFbJaAbQrlRoMFFkZhefzIBL1BH4xGoxh9ZAOeLlEA'>Try</a></div></pre>\n<p>Variadic tuple types enable a lot of new exciting patterns, especially around function composition.\nWe expect we may be able to leverage it to do a better job type-checking JavaScript’s built-in <code>bind</code> method.\nA handful of other inference improvements and patterns also went into this, and if you’re interested in learning more, you can take a look at <a href=\"https://github.com/microsoft/TypeScript/pull/39094\">the pull request</a> for variadic tuples.</p>\n<h2 id=\"labeled-tuple-elements\" style=\"position:relative;\"><a href=\"#labeled-tuple-elements\" aria-label=\"labeled tuple elements permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Labeled Tuple Elements</h2>\n<p>Improving the experience around tuple types and parameter lists is important because it allows us to get strongly typed validation around common JavaScript idioms - really just slicing and dicing argument lists and passing them to other functions.\nThe idea that we can use tuple types for rest parameters is one place where this is crucial.</p>\n<p>For example, the following function that uses a tuple type as a rest parameter…</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> foo(...</span><span style=\"color: #1A1A1A\">args</span><span style=\"color: #000000\">: [string, number]): void {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>…should appear no different from the following function…</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> foo(</span><span style=\"color: #1A1A1A\">arg0</span><span style=\"color: #000000\">: string, </span><span style=\"color: #1A1A1A\">arg1</span><span style=\"color: #000000\">: number): void {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>…for any caller of <code>foo</code>.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #000000\"><data-lsp lsp='function foo(arg0: string, arg1: number): void'>foo</data-lsp>(</span><span style=\"color: #A31515\">\"hello\"</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">42</span><span style=\"color: #000000\">);</span>\n\n<span style=\"color: #000000\"><data-lsp lsp='function foo(arg0: string, arg1: number): void'>foo</data-lsp>(</span><span style=\"color: #A31515\">\"hello\"</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">42</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\"><data-err>true</data-err></span><span style=\"color: #000000\">);</span>\n<span class=\"error\"><span>Expected 2 arguments, but got 3.</span><span class=\"code\">2554</span></span><span class=\"error-behind\">Expected 2 arguments, but got 3.</span><span style=\"color: #000000\"><data-lsp lsp='function foo(arg0: string, arg1: number): void'>foo</data-lsp>(</span><span style=\"color: #A31515\">\"hello\"</span><span style=\"color: #000000\">);</span>\n<span class=\"error\"><span>Expected 2 arguments, but got 1.</span><span class=\"code\">2554</span></span><span class=\"error-behind\">Expected 2 arguments, but got 1.</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYMBYBQAzAVwDsBjAFwEs5jR844AKAQ2gHMAGVRc6S4tgBpQrNgEZUxQgFsARjACUqAG5xKAE1ABvXKFAhQAOmO4AvrgMBaa6ULlrlgg0YAiABaQANp7gvh2NAUAblwnJncvHz9QAOFeQkhgsNcPb19goA'>Try</a></div></pre>\n<p>There is one place where the differences begin to become observable though: readability.\nIn the first example, we have no parameter names for the first and second elements.\nWhile these have no impact on type-checking, the lack of labels on tuple positions can make them harder to use - harder to communicate our intent.</p>\n<p>That’s why in TypeScript 4.0, tuples types can now provide labels.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Range = [start: number, end: number];</span></code></div></pre>\n<p>To deepen the connection between parameter lists and tuple types, the syntax for rest elements and optional elements mirrors the syntax for parameter lists.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Foo = [first: number, second?: string, ...rest: any[]];</span></code></div></pre>\n<p>There are a few rules when using labeled tuples.\nFor one, when labeling a tuple element, all other elements in the tuple must also be labeled.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"><data-err> <data-lsp lsp='type Bar = [string, number]'>Bar</data-lsp> = [<data-lsp lsp='any'>first</data-lsp>: string, number];</data-err></span>\n<span class=\"error\"><span>Tuple members must all have names or all not have names.</span><span class=\"code\">5084</span></span><span class=\"error-behind\">Tuple members must all have names or all not have names.</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygKwAYAcAWAUAC4CeADpKAEICG0oAvKANoBmAlkgaogdKwHYBzADSg+AVwC2AIxgBdANxA'>Try</a></div></pre>\n<p>It’s worth noting - labels don’t require us to name our variables differently when destructuring.\nThey’re purely there for documentation and tooling.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function foo(x: [first: string, second: number]): void'>foo</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: [first: string, second: number]'>x</data-lsp></span><span style=\"color: #000000\">: [<data-lsp lsp='any'>first</data-lsp>: string, <data-lsp lsp='any'>second</data-lsp>: number]) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #008000\">// ...</span>\n\n<span style=\"color: #000000\">    </span><span style=\"color: #008000\">// note: we didn&apos;t need to name these &apos;first&apos; and &apos;second&apos;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> [</span><span style=\"color: #1A1A1A\"><data-lsp lsp='const a: string'>a</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const b: number'>b</data-lsp></span><span style=\"color: #000000\">] = </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: [first: string, second: number]'>x</data-lsp></span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const a: string'>a</data-lsp></span>\n<span class='query'>//  ^ = const a: string</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const b: number'>b</data-lsp></span>\n<span class='query'>//  ^ = const b: number</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/GYVwdgxgLglg9mABMOcAUAPAXIg2sGAJwGcodTCYwBzAGkWIFMIEATHMEAWwCNHCAugEpEAbwBQiKYgD0MxADol4ydLmIwcKIxwB3RolYxWYAORQNjRq0RQ4GgIZcDUABaMmiUwRJRTiBzAbUyYWINNVKTDSPAd6HgFEAF5EDABuSIDxdUQAPQB+TJ5s+TzCgF8gA'>Try</a></div></pre>\n<p>Overall, labeled tuples are handy when taking advantage of patterns around tuples and argument lists, along with implementing overloads in a type-safe way.\nIn fact, TypeScript’s editor support will try to display them as overloads when possible.</p>\n<p><img src=\"https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/signatureHelpLabeledTuples.gif\" alt=\"Signature help displaying a union of labeled tuples as in a parameter list as two signatures\"></p>\n<p>To learn more, check out <a href=\"https://github.com/microsoft/TypeScript/pull/38234\">the pull request</a> for labeled tuple elements.</p>\n<h2 id=\"class-property-inference-from-constructors\" style=\"position:relative;\"><a href=\"#class-property-inference-from-constructors\" aria-label=\"class property inference from constructors permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class Property Inference from Constructors</h2>\n<p>TypeScript 4.0 can now use control flow analysis to determine the types of properties in classes when <code>noImplicitAny</code> is enabled.</p>\n<!--prettier-ignore -->\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> <data-lsp lsp='class Square'>Square</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// Previously both of these were any</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Square.area: number'>area</data-lsp></span><span style=\"color: #000000\">;</span>\n<span class='query'>// ^ = (property) Square.area: number</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Square.sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\">;</span>\n<span class='query'>// ^ = (property) Square.sideLength: number</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\">: number) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Square.sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Square.area: number'>area</data-lsp></span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\"> ** </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKCOBXMAnAptA3gKGtA9PtAAroBuAlgPaIQgCe0ARlQC4AW0VAZtB2hAwB3NOmhgAdvVzj0YANzZC0AHoB+GRAoATNABk0EgOYdFy9TOBUJEVikTBWVFAAotug8Y4AuaBMQAtkyiAJRYMngcFBAAdO76hiacALzQ8Z5JiniR7NExqGhg0KnpiRzQAFQV0ABMWdAAvtgNQA'>Try</a></div></pre>\n<p>In cases where not all paths of a constructor assign to an instance member, the property is considered to potentially be <code>undefined</code>.</p>\n<!--prettier-ignore -->\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> <data-lsp lsp='class Square'>Square</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Square.sideLength: number | undefined'>sideLength</data-lsp></span><span style=\"color: #000000\">;</span>\n<span class='query'>// ^ = (property) Square.sideLength: number | undefined</span>\n\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\">: number) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (<data-lsp lsp='var Math: Math'>Math</data-lsp>.<data-lsp lsp='(method) Math.random(): number'>random</data-lsp>()) {</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Square.sideLength: number | undefined'>sideLength</data-lsp></span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">    }</span>\n<span style=\"color: #000000\">  }</span>\n\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">get</span><span style=\"color: #000000\"> <data-lsp lsp='(property) Square.area: number'>area</data-lsp>() {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Square.sideLength: number | undefined'>sideLength</data-lsp></span><span style=\"color: #000000\"> ** </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">;</span>\n<span class=\"error\"><span>Object is possibly 'undefined'.</span><span class=\"code\">2532</span></span><span class=\"error-behind\">Object is possibly 'undefined'.</span><span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDMaBQBjAGwENFFQBlARwFdjpJQBvXUURASwBNIAZSAHYBzAC4ALANy4QoAHoB+XK1D44AxCOg18IhAApOPfsPGoBNALYAjGAEpmythwBmoPQFli4gHTRiArjgLPVt7FjYI0HEORG9DPkFRMVAAXnZuBJNJR1AAX2V85SFIEVB6SGIQh0iGERpoASixGLiM4yTQACpO9Ck2fNygA'>Try</a></div></pre>\n<p>In cases where you know better (e.g. you have an <code>initialize</code> method of some sort), you’ll still need an explicit type annotation along with a definite assignment assertion (<code>!</code>) if you’re in <code>strictPropertyInitialization</code>.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> <data-lsp lsp='class Square'>Square</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// definite assignment assertion</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">//        v</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Square.sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\">!: number;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// type annotation</span>\n\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\">: number) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.<data-lsp lsp='(method) Square.initialize(sideLength: number): void'>initialize</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">  }</span>\n\n<span style=\"color: #000000\">  <data-lsp lsp='(method) Square.initialize(sideLength: number): void'>initialize</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\">: number) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Square.sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">get</span><span style=\"color: #000000\"> <data-lsp lsp='(property) Square.area: number'>area</data-lsp>() {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Square.sideLength: number'>sideLength</data-lsp></span><span style=\"color: #000000\"> ** </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/MYGwhgzhAEDKCOBXMAnAptA3gKGtA9PtACZoBmAlgHYUAuGkEFA5lQLZpW3SNoq0UA9lVwEieCXgBuopqQAynZrQAWAQgBc0KojYAjPgG5RhSWYB6lq5ZNFaATwAODKlUG0wA4dlHBhEWhREYFpBFAAKOTRFKmUVLR19PgBKLFE8VQoIADpqOgowEAoALzRIigUlVWTjPABfHzw8gUKSsqiYuITdAxRUnElMnI6qlWgAXmgR2NVa6AbRZjRuVDQwcP706HRaRBQqaCHs6bjoACoz6AAmOYa6oA'>Try</a></div></pre>\n<p>For more details, <a href=\"https://github.com/microsoft/TypeScript/pull/37920\">see the implementing pull request</a>.</p>\n<h2 id=\"short-circuiting-assignment-operators\" style=\"position:relative;\"><a href=\"#short-circuiting-assignment-operators\" aria-label=\"short circuiting assignment operators permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Short-Circuiting Assignment Operators</h2>\n<p>JavaScript, and a lot of other languages, support a set of operators called <em>compound assignment</em> operators.\nCompound assignment operators apply an operator to two arguments, and then assign the result to the left side.\nYou may have seen these before:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #008000\">// Addition</span>\n<span style=\"color: #008000\">// a = a + b</span>\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> += </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">;</span>\n\n<span style=\"color: #008000\">// Subtraction</span>\n<span style=\"color: #008000\">// a = a - b</span>\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> -= </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">;</span>\n\n<span style=\"color: #008000\">// Multiplication</span>\n<span style=\"color: #008000\">// a = a * b</span>\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> *= </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">;</span>\n\n<span style=\"color: #008000\">// Division</span>\n<span style=\"color: #008000\">// a = a / b</span>\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> /= </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">;</span>\n\n<span style=\"color: #008000\">// Exponentiation</span>\n<span style=\"color: #008000\">// a = a ** b</span>\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> **= </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">;</span>\n\n<span style=\"color: #008000\">// Left Bit Shift</span>\n<span style=\"color: #008000\">// a = a &lt;&lt; b</span>\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> &lt;&lt;= </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">;</span></code></div></pre>\n<p>So many operators in JavaScript have a corresponding assignment operator!\nUp until recently, however, there were three notable exceptions: logical <em>and</em> (<code>&#x26;&#x26;</code>), logical <em>or</em> (<code>||</code>), and nullish coalescing (<code>??</code>).</p>\n<p>That’s why TypeScript 4.0 supports a new ECMAScript feature to add three new assignment operators: <code>&#x26;&#x26;=</code>, <code>||=</code>, and <code>??=</code>.</p>\n<p>These operators are great for substituting any example where a user might write code like the following:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> && </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> || </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> ?? </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">;</span></code></div></pre>\n<p>Or a similar <code>if</code> block like</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #008000\">// could be 'a ||= b'</span>\n<span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (!</span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>There are even some patterns we’ve seen (or, uh, written ourselves) to lazily initialize values, only if they’ll be needed.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">values</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> string[]</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">(</span><span style=\"color: #1A1A1A\">values</span><span style=\"color: #000000\"> ?? (</span><span style=\"color: #1A1A1A\">values</span><span style=\"color: #000000\"> = [])).push(</span><span style=\"color: #A31515\">\"hello\"</span><span style=\"color: #000000\">);</span>\n\n<span style=\"color: #008000\">// After</span>\n<span style=\"color: #000000\">(</span><span style=\"color: #1A1A1A\">values</span><span style=\"color: #000000\"> ??= []).push(</span><span style=\"color: #A31515\">\"hello\"</span><span style=\"color: #000000\">);</span></code></div></pre>\n<p>(look, we’re not proud of <em>all</em> the code we write…)</p>\n<p>On the rare case that you use getters or setters with side-effects, it’s worth noting that these operators only perform assignments if necessary.\nIn that sense, not only is the right side of the operator “short-circuited” - the assignment itself is too.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #1A1A1A\">obj</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">prop</span><span style=\"color: #000000\"> ||= foo();</span>\n\n<span style=\"color: #008000\">// roughly equivalent to either of the following</span>\n\n<span style=\"color: #1A1A1A\">obj</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">prop</span><span style=\"color: #000000\"> || (</span><span style=\"color: #1A1A1A\">obj</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">prop</span><span style=\"color: #000000\"> = foo());</span>\n\n<span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (!</span><span style=\"color: #1A1A1A\">obj</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">prop</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #1A1A1A\">obj</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">prop</span><span style=\"color: #000000\"> = foo();</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p><a href=\"https://www.typescriptlang.org/play?ts=Nightly#code/MYewdgzgLgBCBGArGBeGBvAsAKBnmA5gKawAOATiKQBQCUGO+TMokIANkQHTsgHUAiYlChFyMABYBDCDHIBXMANoBuHI2Z4A9FpgAlIqXZTgRGAFsiAQg2byJeeTAwAslKgSu5KWAAmIczoYAB4YAAYuAFY1XHwAXwAaWxgIEhgKKmoAfQA3KXYALhh4EA4iH3osWM1WCDKePkFUkTFJGTlFZRimOJw4mJwAM0VgKABLcBhB0qCqplr63n4BcjGCCVgIMd8zIjz2eXciXy7k+yhHZygFIhje7BwFzgblgBUJMdlwM3yAdykAJ6yBSQGAeMzNUTkU7YBCILgZUioOBIBGUJEAHwxUxmqnU2Ce3CWgnenzgYDMACo6pZxpYIJSOqDwSkSFCYXC0VQYFi0NMQHQVEA\">Try running the following example</a> to see how that differs from <em>always</em> performing the assignment.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const obj: {&amp;#13;    prop: boolean;&amp;#13;}'>obj</data-lsp> </span><span style=\"color: #000000\">= {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">get</span><span style=\"color: #000000\"> <data-lsp lsp='(property) prop: boolean'>prop</data-lsp>() {</span>\n<span style=\"color: #000000\">        <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #A31515\">\"getter has run\"</span><span style=\"color: #000000\">);</span>\n\n<span style=\"color: #000000\">        </span><span style=\"color: #008000\">// Replace me!</span>\n<span style=\"color: #000000\">        </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> <data-lsp lsp='var Math: Math'>Math</data-lsp>.<data-lsp lsp='(method) Math.random(): number'>random</data-lsp>() &lt; </span><span style=\"color: #09835A\">0.5</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">    },</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">set</span><span style=\"color: #000000\"> <data-lsp lsp='(property) prop: boolean'>prop</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) _val: boolean'>_val</data-lsp></span><span style=\"color: #000000\">: boolean) {</span>\n<span style=\"color: #000000\">        <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #A31515\">\"setter has run\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">    }</span>\n<span style=\"color: #000000\">};</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function foo(): boolean'>foo</data-lsp>() {</span>\n<span style=\"color: #000000\">    <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #A31515\">\"right side evaluated\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">true</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #000000\"><data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #A31515\">\"This one always runs the setter\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #1A1A1A\"><data-lsp lsp='const obj: {&amp;#13;    prop: boolean;&amp;#13;}'>obj</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) prop: boolean'>prop</data-lsp></span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const obj: {&amp;#13;    prop: boolean;&amp;#13;}'>obj</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) prop: boolean'>prop</data-lsp></span><span style=\"color: #000000\"> || <data-lsp lsp='function foo(): boolean'>foo</data-lsp>();</span>\n\n<span style=\"color: #000000\"><data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #A31515\">\"This one *sometimes* runs the setter\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #1A1A1A\"><data-lsp lsp='const obj: {&amp;#13;    prop: boolean;&amp;#13;}'>obj</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) prop: boolean'>prop</data-lsp></span><span style=\"color: #000000\"> ||= <data-lsp lsp='function foo(): boolean'>foo</data-lsp>();</span></code><a href='https://www.typescriptlang.org/play/#code/MYewdgzgLgBCBGArGBeGBvAUDHMDmAprAA4BOIxAFAJQba4OiQgA2BAdCyHpQESFQoBUjAAWAQwgxSAVzC9qAbkz0GOAPTqYAJQLEW44ARgBbAgEJVa0kRmkwMALLioo9qXFgAJiBM0YADwwAAzsAKzKDAC+ADRWEEQwZBSUAPoAbuIsAFww8CCsBJ60WGq4TBCFnNx8CYLCYpLScgqRuFGYUcqYAGZywFAAluAwPQX+peXglWzVPLykg3iisBCDXsYEmSwyLgRerVY2UHYOULIEyh2YFVVc8wAqooNS4MZZAO7iAJ5SspAwVzGOpCUiHBCIdjJYioOBIKHkGEAHyRo3GShUt1m9z4TxecDAxgAVJUzEMzBAic0AUCYCDhOD4dCYCi0GMQDRFEA'>Try</a></div></pre>\n<p>We’d like to extend a big thanks to community member <a href=\"https://github.com/Kingwl\">Wenlu Wang</a> for this contribution!</p>\n<p>For more details, you can <a href=\"https://github.com/microsoft/TypeScript/pull/37727\">take a look at the pull request here</a>.\nYou can also <a href=\"https://github.com/tc39/proposal-logical-assignment/\">check out TC39’s proposal repository for this feature</a>.</p>\n<h2 id=\"unknown-on-catch-clause-bindings\" style=\"position:relative;\"><a href=\"#unknown-on-catch-clause-bindings\" aria-label=\"unknown on catch clause bindings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>unknown</code> on <code>catch</code> Clause Bindings</h2>\n<p>Since the beginning days of TypeScript, <code>catch</code> clause variables have always been typed as <code>any</code>.\nThis meant that TypeScript allowed you to do anything you wanted with them.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">try</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// Do some work</span>\n<span style=\"color: #000000\">} </span><span style=\"color: #0000FF\">catch</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='var x: any'>x</data-lsp></span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// x has type &apos;any&apos; - have fun!</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='var x: any'>x</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='any'>message</data-lsp></span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='var x: any'>x</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='any'>toUpperCase</data-lsp>());</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='var x: any'>x</data-lsp></span><span style=\"color: #000000\">++;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='var x: any'>x</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='any'>yadda</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='any'>yadda</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='any'>yadda</data-lsp>();</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/C4JwngBA3gUBEHoEQCIHsIGc0FsCmEA7miANYwC+EAxgIbDUAWEAFAB4CU0ciybEjWpgjAwABwIByWgDswkiAFoBtAG4EAZgFcZAQh7U0M7ABs8AOhNoA5u3P5MmWtbwcA3AaOmLV223PAaACqYhIgAMJCeCwc7jxsANQJHvD+YLQAJhm05ulZOXnZMR4UQA'>Try</a></div></pre>\n<p>The above has some undesirable behavior if we’re trying to prevent <em>more</em> errors from happening in our error-handling code!\nBecause these variables have the type <code>any</code> by default, they lack any type-safety which could have errored on invalid operations.</p>\n<p>That’s why TypeScript 4.0 now lets you specify the type of <code>catch</code> clause variables as <code>unknown</code> instead.\n<code>unknown</code> is safer than <code>any</code> because it reminds us that we need to perform some sorts of type-checks before operating on our values.</p>\n<!--prettier-ignore -->\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">try</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">} </span><span style=\"color: #0000FF\">catch</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\"><data-lsp lsp='var e: unknown'>e</data-lsp></span><span style=\"color: #000000\">: </span><span style=\"color: #1A1A1A\">unknown</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// Can&apos;t access values on unknowns</span>\n<span style=\"color: #000000\">  <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-err><data-lsp lsp='var e: unknown'>e</data-lsp></data-err></span><span style=\"color: #000000\">.<data-lsp lsp='any'>toUpperCase</data-lsp>());</span>\n<span class=\"error\"><span>Object is of type 'unknown'.</span><span class=\"code\">2571</span></span><span class=\"error-behind\">Object is of type 'unknown'.</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #0000FF\">typeof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='var e: unknown'>e</data-lsp></span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"string\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #008000\">// We&apos;ve narrowed &apos;e&apos; down to the type &apos;string&apos;.</span>\n<span style=\"color: #000000\">    <data-lsp lsp='var console: Console'>console</data-lsp>.<data-lsp lsp='(method) Console.log(...data: any[]): void'>log</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='var e: string'>e</data-lsp></span><span style=\"color: #000000\">.<data-lsp lsp='(method) String.toUpperCase(): string'>toUpperCase</data-lsp>());</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwFYDsBGAUAC7QCeoA3nqKCKAHT14C+oAxgIYEsAWoAFJKgCuAOwDWwuAHdhASnKVqYAMJthAcgKg2LFpESJQANzYAbQXtBxhoEeKnDECllcRwTkWibgBzfrQJwAKoADsEwKoiQvDIyANx4CgCWAGZ8BMRhcKmQoAC8+aAARIhEicLehXIUVFQ0AOqQaoY5wmywUpAAJqBqjaCd9qABQ1w56WE9JdBl3mq0ClTODm4eXr4eASFh0BFRMfFUjExAA'>Try</a></div></pre>\n<p>While the types of <code>catch</code> variables won’t change by default, we might consider a new <code>--strict</code> mode flag in the future so that users can opt in to this behavior.\nIn the meantime, it should be possible to write a lint rule to force <code>catch</code> variables to have an explicit annotation of either <code>: any</code> or <code>: unknown</code>.</p>\n<p>For more details you can <a href=\"https://github.com/microsoft/TypeScript/pull/39015\">peek at the changes for this feature</a>.</p>\n<h2 id=\"custom-jsx-factories\" style=\"position:relative;\"><a href=\"#custom-jsx-factories\" aria-label=\"custom jsx factories permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Custom JSX Factories</h2>\n<p>When using JSX, a <a href=\"https://reactjs.org/docs/fragments.html\"><em>fragment</em></a> is a type of JSX element that allows us to return multiple child elements.\nWhen we first implemented fragments in TypeScript, we didn’t have a great idea about how other libraries would utilize them.\nNowadays most other libraries that encourage using JSX and support fragments have a similar API shape.</p>\n<p>In TypeScript 4.0, users can customize the fragment factory through the new <code>jsxFragmentFactory</code> option.</p>\n<p>As an example, the following <code>tsconfig.json</code> file tells TypeScript to transform JSX in a way compatible with React, but switches each factory invocation to <code>h</code> instead of <code>React.createElement</code>, and uses <code>Fragment</code> instead of <code>React.Fragment</code>.</p>\n<pre class=\"shiki\"><div class=\"language-id\">json</div><div class='code-container'><code><span style=\"color: #000000\">{</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #AF0B08\">compilerOptions</span><span style=\"color: #000000\">: {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #AF0B08\">target</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"esnext\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #AF0B08\">module</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"commonjs\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #AF0B08\">jsx</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"react\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #AF0B08\">jsxFactory</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"h\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #AF0B08\">jsxFragmentFactory</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"Fragment\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  },</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>In cases where you need to have a different JSX factory on a per-file basis<!-- (maybe you like to ship React, Preact, and Inferno to give a blazing fast experience) -->, you can take advantage of the new <code>/** @jsxFrag */</code> pragma comment.\nFor example, the following…</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #008000\">// Note: these pragma comments need to be written</span>\n<span style=\"color: #008000\">// with a JSDoc-style multiline syntax to take effect.</span>\n\n<span style=\"color: #008000\">/** @jsx h */</span>\n<span style=\"color: #008000\">/** @jsxFrag Fragment */</span>\n\n<span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(alias) function h(type: string, props: (JSXInternal.HTMLAttributes &amp;amp; JSXInternal.SVGAttributes &amp;amp; Record&amp;lt;string, any>) | null, ...children: ComponentChildren[]): VNode&amp;lt;any> (+1 overload)&amp;#13;(alias) namespace h&amp;#13;import h'>h</data-lsp></span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(alias) const Fragment: ComponentClass&amp;lt;{}, {}>&amp;#13;import Fragment'>Fragment</data-lsp></span><span style=\"color: #000000\"> } </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"preact\"</span><span style=\"color: #000000\">;</span>\n\n<span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='const Header: h.JSX.Element'>Header</data-lsp></span><span style=\"color: #000000\"> = (</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #AF0B08\">&lt;&gt;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #800000\">&lt;<data-lsp lsp='(property) JSXInternal.IntrinsicElements.h1: h.JSX.HTMLAttributes&amp;lt;HTMLHeadingElement>'>h1</data-lsp>></span><span style=\"color: #000000\">Welcome</span><span style=\"color: #800000\">&lt;/<data-lsp lsp='(property) JSXInternal.IntrinsicElements.h1: h.JSX.HTMLAttributes&amp;lt;HTMLHeadingElement>'>h1</data-lsp>></span>\n<span style=\"color: #000000\">  &lt;/&gt;</span>\n<span style=\"color: #000000\">);</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAlAOWgFwKYBcouAFvivqAA7wCGA5gLZ2gDG0TT+kuKokfPgAmJaKABGVAO7wAlrgKQMYaQtKhWAKQDKAEWhsAtClwBPADZUmAVwu45FuYNAozvOgA8xJOgGsqfAAzIPw2XAA6NAwAKhiIACsUbw0Y4Fj48CTPADF6BlA8xm5eUDTouSZqZFxQAG9QUgAaQvyS2oBfUCCkJlAAIlp8OnD+gG5o-E9q+FqOSFNQAAlh4Xx4UABeUAAKNFBQAB4APn2Do9IARmOAdXwLDm5D4CvTg+fTgEoxoA'>Try</a></div></pre>\n<p>…will get transformed to this output JavaScript…</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #008000\">// Note: these pragma comments need to be written</span>\n<span style=\"color: #008000\">// with a JSDoc-style multiline syntax to take effect.</span>\n<span style=\"color: #008000\">/** @jsx h */</span>\n<span style=\"color: #008000\">/** @jsxFrag Fragment */</span>\n<span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #1A1A1A\">h</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">Fragment</span><span style=\"color: #000000\"> } </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"preact\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">Header</span><span style=\"color: #000000\"> = (h(</span><span style=\"color: #1A1A1A\">Fragment</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\">null</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">    h(</span><span style=\"color: #A31515\">\"h1\"</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\">null</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"Welcome\"</span><span style=\"color: #000000\">)));</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEDsHsFECd7XgZwFAgigFtA7rALYCWALhmAHLSkCmAXKKdrSraAA7wCGA5od1ABjaIUK1IpFKEi1aAEybRQAI3Z54ZOpAqg8ZbKEEApAMoARaEIC0KUgE8ANu0IBXR6WKPis0CnuS3AAeSkzcANbstABm0bRCpAB0aBgAVKkQAFYoIYapwGkZ4NlBAGI8vKDlfOKSoPkpxIQcyKSgAN6g2AA0VRW1bQC+oNFIhKAARFy03AkTANwptEEt8G0ikHagABIz8rTwoAC8oAAUaKCgADwAfBeX19gAjDcA6rSOIuJXwM93lz87gBKeZAA'>Try</a></div></pre>\n<p>We’d like to extend a big thanks to community member <a href=\"https://github.com/nojvek\">Noj Vek</a> for sending this pull request and patiently working with our team on it.</p>\n<p>You can see that <a href=\"https://github.com/microsoft/TypeScript/pull/38720\">the pull request</a> for more details!</p>\n<h2 id=\"speed-improvements-in-build-mode-with---noemitonerror\" style=\"position:relative;\"><a href=\"#speed-improvements-in-build-mode-with---noemitonerror\" aria-label=\"speed improvements in build mode with   noemitonerror permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Speed Improvements in <code>build</code> mode with <code>--noEmitOnError</code></h2>\n<p>Previously, compiling a program after a previous compile with errors under <code>--incremental</code> would be extremely slow when using the <code>--noEmitOnError</code> flag.\nThis is because none of the information from the last compilation would be cached in a <code>.tsbuildinfo</code> file based on the <code>--noEmitOnError</code> flag.</p>\n<p>TypeScript 4.0 changes this which gives a great speed boost in these scenarios, and in turn improves <code>--build</code> mode scenarios (which imply both <code>--incremental</code> and <code>--noEmitOnError</code>).</p>\n<p>For details, <a href=\"https://github.com/microsoft/TypeScript/pull/38853\">read up more on the pull request</a>.</p>\n<h2 id=\"--incremental-with---noemit\" style=\"position:relative;\"><a href=\"#--incremental-with---noemit\" aria-label=\"  incremental with   noemit permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>--incremental</code> with <code>--noEmit</code></h2>\n<p>TypeScript 4.0 allows us to use the <code>--noEmit</code> flag when while still leveraging <code>--incremental</code> compiles.\nThis was previously not allowed, as <code>--incremental</code> needs to emit a <code>.tsbuildinfo</code> files; however, the use-case to enable faster incremental builds is important enough to enable for all users.</p>\n<p>For more details, you can <a href=\"https://github.com/microsoft/TypeScript/pull/39122\">see the implementing pull request</a>.</p>\n<h2 id=\"editor-improvements\" style=\"position:relative;\"><a href=\"#editor-improvements\" aria-label=\"editor improvements permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Editor Improvements</h2>\n<p>The TypeScript compiler doesn’t only power the editing experience for TypeScript itself in most major editors - it also powers the JavaScript experience in the Visual Studio family of editors and more.\nFor that reason, much of our work focuses on improving editor scenarios - the place you spend most of your time as a developer.</p>\n<p>Using new TypeScript/JavaScript functionality in your editor will differ depending on your editor, but</p>\n<ul>\n<li>Visual Studio Code supports <a href=\"https://code.visualstudio.com/docs/typescript/typescript-compiling#_using-the-workspace-version-of-typescript\">selecting different versions of TypeScript</a>. Alternatively, there’s the <a href=\"https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next\">JavaScript/TypeScript Nightly Extension</a> to stay on the bleeding edge (which is typically very stable).</li>\n<li>Visual Studio 2017/2019 have [the SDK installers above] and <a href=\"https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild\">MSBuild installs</a>.</li>\n<li>Sublime Text 3 supports <a href=\"https://github.com/microsoft/TypeScript-Sublime-Plugin#note-using-different-versions-of-typescript\">selecting different versions of TypeScript</a></li>\n</ul>\n<p>You can check out a partial <a href=\"https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support\">list of editors that have support for TypeScript</a> to learn more about whether your favorite editor has support to use new versions.</p>\n<h3 id=\"convert-to-optional-chaining\" style=\"position:relative;\"><a href=\"#convert-to-optional-chaining\" aria-label=\"convert to optional chaining permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Convert to Optional Chaining</h3>\n<p>Optional chaining is a recent feature that’s received a lot of love.\nThat’s why TypeScript 4.0 brings a new refactoring to convert common patterns to take advantage of <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#optional-chaining\">optional chaining</a> and <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#nullish-coalescing\">nullish coalescing</a>!</p>\n<p><img src=\"https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/convertToOptionalChain-4-0.gif\" alt=\"Converting &#x60;a &#x26;&#x26; a.b.c &#x26;&#x26; a.b.c.d.e.f()&#x60; to &#x60;a?.b.c?.d.e.f.()&#x60;\"></p>\n<p>Keep in mind that while this refactoring doesn’t <em>perfectly</em> capture the same behavior due to subtleties with truthiness/falsiness in JavaScript, we believe it should capture the intent for most use-cases, especially when TypeScript has more precise knowledge of your types.</p>\n<p>For more details, <a href=\"https://github.com/microsoft/TypeScript/pull/39135\">check out the pull request for this feature</a>.</p>\n<h3 id=\"-deprecated--support\" style=\"position:relative;\"><a href=\"#-deprecated--support\" aria-label=\" deprecated  support permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>/** @deprecated */</code> Support</h3>\n<p>TypeScript’s editing support now recognizes when a declaration has been marked with a <code>/** @deprecated *</code> JSDoc comment.\nThat information is surfaced in completion lists and as a suggestion diagnostic that editors can handle specially.\nIn an editor like VS Code, deprecated values are typically displayed a strike-though style <del>like this</del>.</p>\n<p><img src=\"https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/06/deprecated_4-0.png\" alt=\"Some examples of deprecated declarations with strikethrough text in the editor\"></p>\n<p>This new functionality is available thanks to <a href=\"https://github.com/Kingwl\">Wenlu Wang</a>.\nSee <a href=\"https://github.com/microsoft/TypeScript/pull/38523\">the pull request</a> for more details.</p>\n<h3 id=\"partial-semantic-mode-at-startup\" style=\"position:relative;\"><a href=\"#partial-semantic-mode-at-startup\" aria-label=\"partial semantic mode at startup permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Partial Semantic Mode at Startup</h3>\n<p>We’ve heard a lot from users suffering from long startup times, especially on bigger projects.\nThe culprit is usually a process called <em>program construction</em>.\nThis is the process of starting with an initial set of root files, parsing them, finding their dependencies, parsing those dependencies, finding those dependencies’ dependencies, and so on.\nThe bigger your project is, the longer you’ll have to wait before you can get basic editor operations like go-to-definition or quick info.</p>\n<p>That’s why we’ve been working on a new mode for editors to provide a <em>partial</em> experience until the full language service experience has loaded up.\nThe core idea is that editors can run a lightweight partial server that only looks at the current files that the editor has open.</p>\n<p>It’s hard to say precisely what sorts of improvements you’ll see, but anecdotally, it used to take anywhere between <em>20 seconds to a minute</em> before TypeScript would become fully responsive on the Visual Studio Code codebase.\nIn contrast, <strong>our new partial semantic mode seems to bring that delay down to just a few seconds</strong>.\nAs an example, in the following video, you can see two side-by-side editors with TypeScript 3.9 running on the left and TypeScript 4.0 running on the right.</p>\n<video loop autoplay muted style=\"width:100%;height:100%;\" src=\"https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/partialModeFast.mp4\">\n</video>\n<p>When restarting both editors on a particularly large codebase, the one with TypeScript 3.9 can’t provide completions or quick info at all.\nOn the other hand, the editor with TypeScript 4.0 can <em>immediately</em> give us a rich experience in the current file we’re editing, despite loading the full project in the background.</p>\n<p>Currently the only editor that supports this mode is <a href=\"http://code.visualstudio.com/\">Visual Studio Code</a> which has some UX improvements coming up in <a href=\"http://code.visualstudio.com/insiders\">Visual Studio Code Insiders</a>.\nWe recognize that this experience may still have room for polish in UX and functionality, and we have <a href=\"https://github.com/microsoft/TypeScript/issues/39035\">a list of improvements</a> in mind.\nWe’re looking for more feedback on what you think might be useful.</p>\n<p>For more information, you can <a href=\"https://github.com/microsoft/TypeScript/issues/37713\">see the original proposal</a>, <a href=\"https://github.com/microsoft/TypeScript/pull/38561\">the implementing pull request</a>, along with <a href=\"https://github.com/microsoft/TypeScript/issues/39035\">the follow-up meta issue</a>.</p>\n<h3 id=\"smarter-auto-imports\" style=\"position:relative;\"><a href=\"#smarter-auto-imports\" aria-label=\"smarter auto imports permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Smarter Auto-Imports</h3>\n<p>Auto-import is a fantastic feature that makes coding a lot easier; however, every time auto-import doesn’t seem to work, it can throw users off a lot.\nOne specific issue that we heard from users was that auto-imports didn’t work on dependencies that were written in TypeScript - that is, until they wrote at least one explicit import somewhere else in their project.</p>\n<p>Why would auto-imports work for <code>@types</code> packages, but not for packages that ship their own types?\nIt turns out that auto-imports only work on packages your project <em>already</em> includes.\nBecause TypeScript has some quirky defaults that automatically add packages in <code>node_modules/@types</code> to your project, <em>those</em> packages would be auto-imported.\nOn the other hand, other packages were excluded because crawling through all your <code>node_modules</code> packages can be <em>really</em> expensive.</p>\n<p>All of this leads to a pretty lousy getting started experience for when you’re trying to auto-import something that you’ve just installed but haven’t used yet.</p>\n<p>TypeScript 4.0 now does a little extra work in editor scenarios to include the packages you’ve listed in your <code>package.json</code>’s <code>dependencies</code> (and <code>peerDependencies</code>) fields.\nThe information from these packages is only used to improve auto-imports, and doesn’t change anything else like type-checking.\nThis allows us to provide auto-imports for all of your dependencies that have types, without incurring the cost of a complete <code>node_modules</code> search.</p>\n<p>In the rare cases when your <code>package.json</code> lists more than ten typed dependencies that haven’t been imported yet, this feature automatically disables itself to prevent slow project loading.\nTo force the feature to work, or to disable it entirely, you should be able to configure your editor.\nFor Visual Studio Code, this is the “Include Package JSON Auto Imports” (or <code>typescript.preferences.includePackageJsonAutoImports</code>) setting.</p>\n<p><img src=\"https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/configurePackageJsonAutoImports4-0.png\" alt=\"Configuring &#x27;include package JSON auto imports&#x27;\">\nFor more details, you can see the <a href=\"https://github.com/microsoft/TypeScript/issues/37812\">proposal issue</a> along with <a href=\"https://github.com/microsoft/TypeScript/pull/38923\">the implementing pull request</a>.</p>\n<h2 id=\"our-new-website\" style=\"position:relative;\"><a href=\"#our-new-website\" aria-label=\"our new website permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Our New Website!</h2>\n<p><a href=\"https://www.typescriptlang.org/\">The TypeScript website</a> has recently been rewritten from the ground up and rolled out!</p>\n<p><img src=\"https://devblogs.microsoft.com/typescript/wp-content/uploads/sites/11/2020/08/ts-web.png\" alt=\"A screenshot of the new TypeScript website\"></p>\n<p><a href=\"https://devblogs.microsoft.com/typescript/announcing-the-new-typescript-website/\">We already wrote a bit about our new site</a>, so you can read up more there; but it’s worth mentioning that we’re still looking to hear what you think!\nIf you have questions, comments, or suggestions, you can <a href=\"https://github.com/microsoft/TypeScript-Website\">file them over on the website’s issue tracker</a>.</p>\n<h2 id=\"breaking-changes\" style=\"position:relative;\"><a href=\"#breaking-changes\" aria-label=\"breaking changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Breaking Changes</h2>\n<h3 id=\"libdts-changes\" style=\"position:relative;\"><a href=\"#libdts-changes\" aria-label=\"libdts changes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>lib.d.ts</code> Changes</h3>\n<p>Our <code>lib.d.ts</code> declarations have changed - most specifically, types for the DOM have changed.\nThe most notable change may be the removal of <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/origin\"><code>document.origin</code></a> which only worked in old versions of IE and Safari\nMDN recommends moving to <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/origin\"><code>self.origin</code></a>.</p>\n<h3 id=\"properties-overriding-accessors-and-vice-versa-is-an-error\" style=\"position:relative;\"><a href=\"#properties-overriding-accessors-and-vice-versa-is-an-error\" aria-label=\"properties overriding accessors and vice versa is an error permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Properties Overriding Accessors (and vice versa) is an Error</h3>\n<p>Previously, it was only an error for properties to override accessors, or accessors to override properties, when using <code>useDefineForClassFields</code>; however, TypeScript now always issues an error when declaring a property in a derived class that would override a getter or setter in the base class.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> <data-lsp lsp='class Base'>Base</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">get</span><span style=\"color: #000000\"> <data-lsp lsp='(property) Base.foo: number'>foo</data-lsp>() {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #09835A\">100</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">set</span><span style=\"color: #000000\"> <data-lsp lsp='(property) Base.foo: number'>foo</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) value: number'>value</data-lsp></span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> <data-lsp lsp='class Derived'>Derived</data-lsp> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> <data-lsp lsp='class Base'>Base</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-err><data-lsp lsp='(property) Derived.foo: number'>foo</data-lsp></data-err></span><span style=\"color: #000000\"> = </span><span style=\"color: #09835A\">10</span><span style=\"color: #000000\">;</span>\n<span class=\"error\"><span>'foo' is defined as an accessor in class 'Base', but is overridden here in 'Derived' as an instance property.</span><span class=\"code\">2610</span></span><span class=\"error-behind\">'foo' is defined as an accessor in class 'Base', but is overridden here in 'Derived' as an instance property.</span><span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygIwAYAsBOUAmANkwCgBjAGwENFFQAhGyUAbxNFAHNIAXUAMzhwAFAEpW7DqGi8ArtAB26DBgDckgL6TEvAUOEA3KhVmRxbKaBCgAdHc0kt5arVAARGAEsDkACahIAA8eSAVfOkYdCQ5BOFAAXmV1DSA'>Try</a></div></pre>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> <data-lsp lsp='class Base'>Base</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Base.prop: number'>prop</data-lsp></span><span style=\"color: #000000\"> = </span><span style=\"color: #09835A\">10</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> <data-lsp lsp='class Derived'>Derived</data-lsp> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> <data-lsp lsp='class Base'>Base</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">get</span><span style=\"color: #000000\"><data-err> <data-lsp lsp='(property) Derived.prop: number'>prop</data-lsp>() {</data-err></span>\n<span class=\"error\"><span>'prop' is defined as a property in class 'Base', but is overridden here in 'Derived' as an accessor.</span><span class=\"code\">2611</span></span><span class=\"error-behind\">'prop' is defined as a property in class 'Base', but is overridden here in 'Derived' as an accessor.</span><span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #09835A\">100</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwDYCMWBQBjAGwENFFQAhUyUAb11FAAd4nQBeULABgG5cAvrgIkyoACIwAlgDdIAE1CQAHgBdIAO3nkqiGvUYBzSKuasAFAEo6DRqGgmArtA1dufW0IFA'>Try</a></div></pre>\n<p>See more details on <a href=\"https://github.com/microsoft/TypeScript/pull/37894\">the implementing pull request</a>.</p>\n<h3 id=\"operands-for-delete-must-be-optional\" style=\"position:relative;\"><a href=\"#operands-for-delete-must-be-optional\" aria-label=\"operands for delete must be optional permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Operands for <code>delete</code> must be optional.</h3>\n<p>When using the <code>delete</code> operator in <code>strictNullChecks</code>, the operand must now be <code>any</code>, <code>unknown</code>, <code>never</code>, or be optional (in that it contains <code>undefined</code> in the type).\nOtherwise, use of the <code>delete</code> operator is an error.</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> <data-lsp lsp='interface Thing'>Thing</data-lsp> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Thing.prop: string'>prop</data-lsp></span><span style=\"color: #000000\">: string;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> <data-lsp lsp='function f(x: Thing): void'>f</data-lsp>(</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: Thing'>x</data-lsp></span><span style=\"color: #000000\">: <data-lsp lsp='interface Thing'>Thing</data-lsp>) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">delete</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='(parameter) x: Thing'>x</data-lsp></span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\"><data-lsp lsp='(property) Thing.prop: string'>prop</data-lsp></span><span style=\"color: #000000\">;</span>\n<span class=\"error\"><span>The operand of a 'delete' operator must be optional.</span><span class=\"code\">2790</span></span><span class=\"error-behind\">The operand of a 'delete' operator must be optional.</span><span style=\"color: #000000\">}</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEFMCdoe2gZwFygEwHYCcAGAUAJYB2ALjAGYCGAxpKACoAWxA5qAN56igAO8PqRCWisA3HgC+ePOQCuRaiQJwiocgAoAHqiasAlBy6gAJpAA2kMqE0A6PnB7iJQA'>Try</a></div></pre>\n<p>See more details on <a href=\"https://github.com/microsoft/TypeScript/pull/37921\">the implementing pull request</a>.</p>\n<h3 id=\"usage-of-typescripts-node-factory-is-deprecated\" style=\"position:relative;\"><a href=\"#usage-of-typescripts-node-factory-is-deprecated\" aria-label=\"usage of typescripts node factory is deprecated permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Usage of TypeScript’s Node Factory is Deprecated</h3>\n<p>Today TypeScript provides a set of “factory” functions for producing AST Nodes; however, TypeScript 4.0 provides a new node factory API.\nAs a result, for TypeScript 4.0 we’ve made the decision to deprecate these older functions in favor of the new ones.</p>\n<p>For more details, <a href=\"https://github.com/microsoft/TypeScript/pull/35282\">read up on the relevant pull request for this change</a>.</p>","headings":[{"value":"Variadic Tuple Types","depth":2},{"value":"Labeled Tuple Elements","depth":2},{"value":"Class Property Inference from Constructors","depth":2},{"value":"Short-Circuiting Assignment Operators","depth":2},{"value":"unknown on catch Clause Bindings","depth":2},{"value":"Custom JSX Factories","depth":2},{"value":"Speed Improvements in build mode with --noEmitOnError","depth":2},{"value":"--incremental with --noEmit","depth":2},{"value":"Editor Improvements","depth":2},{"value":"Convert to Optional Chaining","depth":3},{"value":"/** @deprecated */ Support","depth":3},{"value":"Partial Semantic Mode at Startup","depth":3},{"value":"Smarter Auto-Imports","depth":3},{"value":"Our New Website!","depth":2},{"value":"Breaking Changes","depth":2},{"value":"lib.d.ts Changes","depth":3},{"value":"Properties Overriding Accessors (and vice versa) is an Error","depth":3},{"value":"Operands for delete must be optional.","depth":3},{"value":"Usage of TypeScript’s Node Factory is Deprecated","depth":3}],"frontmatter":{"permalink":"/docs/handbook/release-notes/typescript-4-0.html","title":"TypeScript 4.0","disable_toc":null,"handbook":null,"oneline":"TypeScript 4.0 Release Notes","beta":null}},"prev":null,"next":null},"pageContext":{"id":"4typescript-4.0","slug":"/docs/handbook/release-notes/typescript-4-0.html","repoPath":"/packages/documentation/copy/en/release-notes/TypeScript 4.0.md","lang":"en","modifiedTime":"2020-11-23T10:39:15.623Z"}},"staticQueryHashes":[]}