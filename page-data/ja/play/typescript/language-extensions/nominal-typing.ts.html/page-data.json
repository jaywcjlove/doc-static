{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ja/play/typescript/language-extensions/nominal-typing.ts.html","result":{"pageContext":{"name":"Nominal Typing","title":"Nominal Typing","lang":"ja","html":" 公称型システムではそれぞれの型がユニークであり、\n ある2つの型が同じデータ構造をしていても\n 型をまたいで代入することはできません\n\n TypeScriptの型システムは構造的です。\n 構造的型システムでは、ある型がアヒル型と同じ構造をしていたら、それをアヒル型として扱います。\n また、ガチョウ型がアヒル型とまったく同じ属性を持っていたら、ガチョウ型はアヒル型としても扱われます。\n より詳しいことはこちらをご覧ください: example:structural-typing\n\n これにはいくつかの欠点があります。\n 文字列や数値が特別なコンテキストを持っており、\n 他の値に変換可能にしたくない場合などが該当します。\n 例:\n\n - ユーザーの入力した安全でない文字列\n - 翻訳された文字列\n - ユーザー識別番号\n - アクセストークン\n\n 少しの余分なコードを足すだけで、\n 公称型システムと同じような恩恵に預かることができます。\n\n 交差型を用いて、__brand （この名前は慣習的なもの）という\n プロパティを持つ型を作成し、\n 通常の文字列が代入不可能な\n ValidatedInputStringという型を作ってみましょう。\n\n<code><pre>\ntype ValidatedInputString = string & { __brand: \"User Input Post Validation\" };\n\n</pre></code>\n// 文字列をValidatedInputString型に変換するために関数を使います。\n 注目に値するのは、validateUserInputを通過した文字列はValidatedInputStringだと\n TypeScriptに_伝えて_いる点です。\n\n<code><pre>\nconst validateUserInput = (input: string) => {\n  const simpleValidatedInput = input.replace(/\\</g, \"≤\");\n  return simpleValidatedInput as ValidatedInputString;\n};\n\n</pre></code>\n// 次に、普通の文字列型は受け取らず、\n 作成した公称型であるValidatedInputStringだけを受け取る関数を作ってみます。\n\n<code><pre>\nconst printName = (name: ValidatedInputString) => {\n  console.log(name);\n};\n\n</pre></code>\n// 例えば、ユーザーからの安全でない入力を受け取り、\n バリデーターに通してから出力してみます。\n\n<code><pre>\nconst input = \"\\n<script>alert('bobby tables')</script>\";\nconst validatedInput = validateUserInput(input);\nprintName(validatedInput);\n\n</pre></code>\n// 一方でバリデートしていない文字列をprintNameに渡すと、\n コンパイルエラーが発生します。\n\n<code><pre>\nprintName(input);\n\n</pre></code>\n// 以下の400コメントがついたGitHubのissueに、\n 公称型を作成する色々な方法のまとめと\n それらのトレードオフがまとまっています:\n\n https://github.com/Microsoft/TypeScript/issues/202\n\n 他にも以下の記事が分かりやすいまとめになっています:\n\n https://michalzalecki.com/nominal-typing-in-typescript/\n","redirectHref":"ja/play/?#example/nominal-typing"}},"staticQueryHashes":[]}