{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ja/play/typescript/meta-types/indexed-types.ts.html","result":{"pageContext":{"name":"Indexed Types","title":"Indexed Types","lang":"ja","html":" 重複した型に気付く場合があります。\n よくある例は自動生成されたAPIレスポンスの\n ネストされたリソースです。\n\n<code><pre>\ninterface ArtworkSearchResponse {\n  artists: {\n    name: string;\n    artworks: {\n      name: string;\n      deathdate: string | null;\n      bio: string;\n    }[];\n  }[];\n}\n\n</pre></code>\n// もし、このinterfaceが手動で作られていたら、\n 以下のようにartworksからinterfaceを抜き出してくることはとても簡単です。\n\n<code><pre>\ninterface Artwork {\n  name: string;\n  deathdate: string | null;\n  bio: string;\n}\n\n</pre></code>\n// しかし、この場合、APIをいじることはできません。\n そして、もし手動でinterface作った場合に、レスポンスが変わると\n ArtworkSearchResponseのartworksと、\n Artworkの型が不整合を起こす可能性があります。\n\n これに対する修正方法は、indexed typeです。\n indexed typeは、JavaScriptの文字列を使ったプロパティへのアクセス方法を模倣しています。\n\n<code><pre>\ntype InferredArtwork = ArtworkSearchResponse[\"artists\"][0][\"artworks\"][0];\n\n</pre></code>\n// InferredArtworkは\n 型のプロパティを参照して作成され、\n 指し示した部分集合に対して新しい名前を与えます。\n","redirectHref":"ja/play/?#example/indexed-types"}},"staticQueryHashes":[]}