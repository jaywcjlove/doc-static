{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ja/play/typescript/meta-types/mapped-types.ts.html","result":{"pageContext":{"name":"Mapped Types","title":"Mapped Types","lang":"ja","html":" mapped typeは他の型を元に新しい型を作る方法であり、\n 効率的に変換できる型です。\n\n mapped typeのよくある使い方は\n 既存の型の部分集合を扱うことです。\n 例えば、APIが以下のArtistを返すとします:\n\n<code><pre>\ninterface Artist {\n  id: number;\n  name: string;\n  bio: string;\n}\n\n</pre></code>\n// もし、Artistの一部の変更するAPIを通して\n 更新を送信したいとき、\n 一般的には新たに以下の型を作成する必要があるでしょう:\n\n<code><pre>\ninterface ArtistForEdit {\n  id: number;\n  name?: string;\n  bio?: string;\n}\n\n</pre></code>\n// この型が上記のArtist型と同期されなくなってしまう\n 可能性は非常に高いでしょう。\n mapped typeは既存の型を変換した型を作成できます。\n\n<code><pre>\ntype MyPartialType<Type> = {\n  // Typeに含まれるすべてのプロパティを\n  // ?:な値に変換します\n  [Property in keyof Type]?: Type[Property];\n};\n\n</pre></code>\n// すると、新しくinterfaceを編集した型を作成する代わりに、\n mapped typeを使用できます。\n<code><pre>\ntype MappedArtistForEdit = MyPartialType<Artist>;\n\n</pre></code>\n// これでほとんど完璧ですが、\n これは、本来発生しない、idがnullになるパターンを許容してしまいます。\n 交差型を使って、ちょっと改善してみましょう。\n (詳しくは example:union-and-intersection-types を参照)\n\n<code><pre>\ntype MyPartialTypeForEdit<Type> = {\n  [Property in keyof Type]?: Type[Property];\n} & { id: number };\n\n</pre></code>\n// 上記はmapped typeの結果を使って、\n これとidが数値の集合を持つオブジェクトとマージします。\n すると、型の中にidが存在していることを強制する型が効率的にできます。\n\n<code><pre>\ntype CorrectMappedArtistForEdit = MyPartialTypeForEdit<Artist>;\n\n</pre></code>\n// 以上はmapped typeがどのように動作するかのとても簡単な例でしたが、\n 基礎的な動作のほとんどをカバーしています。\n もし、さらに深く知りたい場合は、handbookを参照ください:\n\n https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types\n","redirectHref":"ja/play/?#example/mapped-types"}},"staticQueryHashes":[]}