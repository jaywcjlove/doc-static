{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ja/play/typescript/type-primitives/nullable-types.ts.html","result":{"pageContext":{"name":"Nullable Types","title":"Nullable Types","lang":"ja","html":"\n JavaScriptでは、存在しない値を宣言する方法が2つあります。\n TypeScriptでは、optionalやnullableな値を宣言する\n 方法をさらにいくつか提供します。\n\n 最初に、JavaScriptの基本型である\n undefinedとnullの違いを見てみましょう。\n\n Undefinedは値が見つからないときあるいは設定できない場合です。\n\n<code><pre>\nconst emptyObj = {};\nconst anUndefinedProperty: undefined = emptyObj[\"anything\"];\n\n</pre></code>\n// Nullは値が意図的に欠如していることを\n 意味します。\n\n<code><pre>\nconst searchResults = {\n  video: { name: \"LEGO Movie\" },\n  text: null,\n  audio: { name: \"LEGO Movie Soundtrack\" },\n};\n\n</pre></code>\n// なぜundefinedを使わないのでしょう?\n 主な理由としては、textが正しく含まれていることを確認できるからです。\n もしtextがundefinedの場合、\n 結果はtextが存在しないときと同じものになります。\n\n これは、少し表面的に感じるかもしれません。\n しかし、JSON文字列に変換したときに、\n textがundefinedの場合、textは変換された文字列に含まれません。\n\n Strict Null Types\n\n TypeScript 2.0より前では、undefinedとnullは事実上、型システムから無視されていました。\n これによって、TypeScriptのコーディング環境は\n 型のないJavaScriptに近づいてしまっていました。\n\n バージョン2.0にて、\"strictNullChecks\"というコンパイラフラグが追加されました。\n このフラグをオンにすると、undefinedとnullが\n コードフロー分析を通して対応すべき型として扱われるようになります。\n (より詳細には example:code-flow を参照ください)\n\n TypeScriptでstrict null checksを有効にしたときの違いの例として\n 以下の\"Potential String\"型をホバーしてみてください:\n\n<code><pre>\ntype PotentialString = string | undefined | null;\n\n</pre></code>\n// PotentialString型ではundefinedとnullが切り捨てられています。\n もし、設定に行きstrictモードを有効にして戻ってくると、\n PotentialString型がすべての型の交差型になっていることが\n 確認できます。\n\n<code><pre>\ndeclare function getID(): PotentialString;\n\nconst userID = getID();\nconsole.log(\"User Logged in: \", userID.toUpperCase());\n\n// strictモードでは、上記はエラーになります。\n\n</pre></code>\n// 型アサーションや非nullアサーション演算子(!)を使うなど\n TypeScriptに詳細を教える方法はいくつかあります。\n\n<code><pre>\nconst definitelyString1 = getID() as string;\nconst definitelyString2 = getID()!;\n\n// あるいはifを用いて存在を安全に確認することもできます:\n\nif (userID) {\n  console.log(userID);\n}\n\n// Optional Properties\n\n// Void\n\n</pre></code>\n// voidは値を返さない関数の\n 戻り値型です。\n\n<code><pre>\nconst voidFunction = () => {};\nconst resultOfVoidFunction = voidFunction();\n\n</pre></code>\n// 実行時にはundefinedであっても、\n TypeScriptはコンパイルエラーを発生させるために\n void型を保持します。\n","redirectHref":"ja/play/?strictNullChecks=false#example/nullable-types"}},"staticQueryHashes":[]}