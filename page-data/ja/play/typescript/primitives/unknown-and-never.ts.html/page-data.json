{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ja/play/typescript/primitives/unknown-and-never.ts.html","result":{"pageContext":{"name":"Unknown and Never","title":"Unknown and Never","lang":"ja","html":" unknown型\n\n unknown型は、一度詳しくなると、非常に多くの用途があることに気が付く型の一つです。\n unknown型は、any型とよく似た振る舞いをします。\n anyは曖昧なままでも使用できますが、 unknownは\n 型を特定する必要がある点が異なります。\n\n JSONパーサーのWrapperは良い例です。\n JSONのデータは、多種多様であるため、JSONパーサーの利用者が\n データの形を知っているにもかかわらず、JSONパーサーの作者は、\n データがどのような形になっているのかを知ることはできません。\n\n<code><pre>\nconst jsonParser = (jsonString: string) => JSON.parse(jsonString);\n\nconst myAccount = jsonParser(`{ \"name\": \"Dorothea\" }`);\n\nmyAccount.name;\nmyAccount.email;\n\n</pre></code>\n// 変数jsonParserにカーソルを合わせると、戻り値の型がany型であることがわかります。\n そして、変数myAccountも同様にany型になります。\n これについて、ジェネリクスを使って型付けすることもできますが、\n unknown型を使うことによっても型付けできます。\n\n<code><pre>\nconst jsonParserUnknown = (jsonString: string): unknown => JSON.parse(jsonString);\n\nconst myOtherAccount = jsonParserUnknown(`{ \"name\": \"Samuel\" }`);\n\nmyOtherAccount.name;\n\n</pre></code>\n// myOtherAccountの型をTypeScriptに示すまでは、myOtherAccountのオブジェクトを使用する\n ことができません。こうすることによって、APIの使用者に、型について前もって\n 考えさせることができます。\n\n<code><pre>\ntype User = { name: string };\nconst myUserAccount = jsonParserUnknown(`{ \"name\": \"Samuel\" }`) as User;\nmyUserAccount.name;\n\n</pre></code>\n// unknown型はとても優れたツールです。より深く理解したい場合はこれらを参照してください。\n https://mariusschulz.com/blog/the-unknown-type-in-typescript\n https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type\n\n never型\n\n TypeScriptは、データフローの解析をサポートしているため、\n 論理的に絶対に発生しないコードを表現できる必要があります。\n 例えば、こちらの関数は絶対にreturnされません。\n\n<code><pre>\nconst neverReturns = () => {\n  // 1行目で例外を投げる場合\n  throw new Error(\"必ず例外が投げられるので、戻り値は返りません\");\n};\n\n</pre></code>\n// この関数にカーソルを合わせると、型が () => neverとなっていることがわかります。\n つまり、この関数は絶対にreturnされません。\n これらは、他の値と同様に、代入することは可能です。\n\n<code><pre>\nconst myValue = neverReturns();\n\n</pre></code>\n// never型を返す関数は、\n JavaScriptランタイムの予想できない挙動に対応する場合や、\n APIの利用者が型を使わない可能性がある場合に有用です。\n\n<code><pre>\nconst validateUser = (user: User) => {\n  if (user) {\n    return user.name !== \"NaN\";\n  }\n  // 型システム的には、このコードは絶対に実行されません。\n  // つまり、関数neverReturnsの戻り値の型に合致します。\n\n  return neverReturns();\n};\n\n</pre></code>\n// この関数の型定義では、引数userが必ず渡されることになっていますが、\n JavaScriptには様々な抜け道があるので、\n それを保証することはできません。\n\n 上記の例のようにnever型を返す関数を使うことで、実行される可能性がない箇所に\n コードを追加することができます。\n これは、より良いエラーメッセージを表示したい場合や、ファイルや\n ループなどのリソースをクローズしたい場合などで有用です。\n\n とてもよくあるnever型の使われ方として、\n switch文でのすべてのパスが網羅されていることの担保があります。\n\n 以下は、enumと、neverによってすべてのパスが網羅されているswith文の例です。\n 試しにFlowerに新しいオプションを追加してみてください(例: Tulipなど)\n\n<code><pre>\nenum Flower {\n  Rose,\n  Rhododendron,\n  Violet,\n  Daisy,\n}\n\nconst flowerLatinName = (flower: Flower) => {\n  switch (flower) {\n    case Flower.Rose:\n      return \"Rosa rubiginosa\";\n    case Flower.Rhododendron:\n      return \"Rhododendron ferrugineum\";\n    case Flower.Violet:\n      return \"Viola reichenbachiana\";\n    case Flower.Daisy:\n      return \"Bellis perennis\";\n\n    default:\n      const _exhaustiveCheck: never = flower;\n      return _exhaustiveCheck;\n  }\n};\n\n</pre></code>\n// 新しく追加したオプションの型は、never型に変換できない\n というエラーが表示されるはずです。\n\n 共用体でのnever型\n\n 共用体では、never型は\n 自動的に取り除かれます。\n\n<code><pre>\ntype NeverIsRemoved = string | never | number;\n\n</pre></code>\n// NeverIsRemovedの型を見てみると、\n string | number になっています。\n これは、never型の代入は実行時には絶対に起こらないためです。\n\n この特徴は、Conditinal Typesで良く使われています。 example:conditional-types\n\n","redirectHref":"ja/play/?#example/unknown-and-never"}},"staticQueryHashes":[]}