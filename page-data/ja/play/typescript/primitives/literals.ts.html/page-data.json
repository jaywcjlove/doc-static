{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ja/play/typescript/primitives/literals.ts.html","result":{"pageContext":{"name":"Literals","title":"Literals","lang":"ja","html":" TypeScriptには、ソースコードにリテラルを用いた\n とても面白い利用例があります。\n\n これは、型の拡張・型の絞り込みにおいて、多くのサポートをもたらします。\n ( example:type-widening-and-narrowing )\n そして、はじめにそれを網羅する価値があります。\n\n リテラルは集合型よりも具体的なサブタイプです。\n どういうことかと言うと、型システム内部では\n 「Hello World」は文字列ですが、文字列は「Hello World」ではありません。\n\n<code><pre>\nconst helloWorld = \"Hello World\";\nlet hiWorld = \"Hi World\"; // これはletなので文字列型です\n\n// この関数は、すべての文字列を受け入れます\ndeclare function allowsAnyString(arg: string);\nallowsAnyString(helloWorld);\nallowsAnyString(hiWorld);\n\n// この関数は、文字列リテラル「Hello World」のみを受け入れます\ndeclare function allowsOnlyHello(arg: \"Hello World\");\nallowsOnlyHello(helloWorld);\nallowsOnlyHello(hiWorld);\n\n</pre></code>\n// これにより、共用体型を使用して特定のリテラルのみを受け入れる\n APIを宣言することができます\n\n<code><pre>\ndeclare function allowsFirstFiveNumbers(arg: 1 | 2 | 3 | 4 | 5);\nallowsFirstFiveNumbers(1);\nallowsFirstFiveNumbers(10);\n\nlet potentiallyAnyNumber = 3;\nallowsFirstFiveNumbers(potentiallyAnyNumber);\n\n// しかし、このルールは混み入ったオブジェクトには適用されません。\n\nconst myUser = {\n  name: \"Sabrina\",\n};\n\n</pre></code>\n// 定数として定義された `name：\"Sabrina\"` であっても\n `name：string` に変換されてしまいます。\n こうなるのは、nameプロパティがいつでも変更できるからです。\n\n<code><pre>\nmyUser.name = \"Cynthia\";\n\n</pre></code>\n// なぜならmyUserのnameプロパティは変更できるため、\n TypeScriptは型システムにおいてリテラル型を使用できません。\n しかしながら、次の機能でこれを許容することができます。\n\n<code><pre>\nconst myUnchangingUser = {\n  name: \"Fatma\",\n} as const;\n\n</pre></code>\n// 「as const」をオブジェクトに適用すると、\n 変更できるオブジェクトの代わりに、\n 変更できないオブジェクトになります。\n\n<code><pre>\nmyUnchangingUser.name = \"Raîssa\";\n\n</pre></code>\n// 「as const」はコード中でインラインリテラルを扱ったり、\n 固定データを扱うための素晴らしいツールです。\n 「as const」は配列でも動作します。\n\n<code><pre>\nconst exampleUsers = [{ name: \"Brian\" }, { name: \"Fahrooq\" }] as const;\n","redirectHref":"ja/play/?#example/literals"}},"staticQueryHashes":[]}