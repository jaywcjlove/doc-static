{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ja/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts.html","result":{"pageContext":{"name":"Checking Unions with Index Signatures","title":"Checking Unions with Index Signatures","lang":"ja","html":" 以前のバージョンのTypeScriptでは、\n インデックスシグネチャを含む共用体に宣言されていないフィールドについて\n 型チェックが行われませんでした。\n\n インデックスシグネチャについてはこちら: example:indexed-types\n\n 例えば、以下のIdentifierCacheは、\n オブジェクトのすべてのキーが、numberであることを表しています。\n\n<code><pre>\ntype IdentifierCache = { [key: string]: number };\n\n</pre></code>\n// つまり、以下の例は型チェックエラーとなります。\n 'file_a'のキーにstringの値が設定されているためです。\n\n<code><pre>\nconst cacheWithString: IdentifierCache = { file_a: \"12343\" };\n\n</pre></code>\n// しかし、IdentifierCacheを共用体に含めると、\n 以前は、型チェックが行われませんでした。\n\n<code><pre>\nlet userCache: IdentifierCache | { index: number };\nuserCache = { file_one: 5, file_two: \"abc\" };\n\n</pre></code>\n// こちらが修正され、コンパイラーから\n 'file_two'のキーについてのエラーが出るようになりました。\n\n この型チェックは、キーの型が異なる場合も考慮に入れられています。\n 例: ([key: string] and [key: number])\n\n<code><pre>\ntype IdentifierResponseCache = { [key: number]: number };\n\nlet resultCache: IdentifierCache | IdentifierResponseCache;\nresultCache = { file_one: \"abc\" };\n","redirectHref":"ja/play/?ts=3.8.3#example/checking-unions-with-index-signatures"}},"staticQueryHashes":[]}