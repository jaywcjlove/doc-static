{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ko/play/typescript/primitives/unknown-and-never.ts.html","result":{"pageContext":{"name":"Unknown and Never","title":"Unknown and Never","lang":"ko","html":" Unknown\n\n Unknown은 검색하면\n 꽤 다양한 용도를 찾을 수 있는 타입 중 하나입니다.\n 이는 any 타입의 자매처럼 작동합니다. any가 모호함을 나타내는 반면\n unknown은 세부사항을 필요로 합니다.\n\n JSON 파서를 감싸는 것이 좋은 예시가 될 수 있습니다.\n JSON 데이터는 서로 다른 형식으로 제공되며,\n json 파싱 함수의 작성자는 데이터의 형식을 알 수 없습니다.\n 그 형식은 함수를 호출한 사람이 알고 있습니다.\n\n<code><pre>\nconst jsonParser = (jsonString: string) => JSON.parse(jsonString);\n\nconst myAccount = jsonParser(`{ \"name\": \"Dorothea\" }`);\n\nmyAccount.name;\nmyAccount.email;\n\n</pre></code>\n// jsonParser에 마우스를 올리면, 반환 타입이 any이고\n myAccount 또한 동일합니다.\n 이는 Generic을 이용하여 해결할 수 있지만\n unknown으로 해결할 수도 있습니다.\n\n<code><pre>\nconst jsonParserUnknown = (jsonString: string): unknown => JSON.parse(jsonString);\n\nconst myOtherAccount = jsonParserUnknown(`{ \"name\": \"Samuel\" }`);\n\nmyOtherAccount.name;\n\n</pre></code>\n// myOtherAccount 객체는 TypeScript에 타입이 선언되기 전까지\n 사용될 수 없습니다. 이것은 API를 사용하는 사람이\n 올바르게 타입을 정의하는지 생각하게끔 해 줍니다.\n\n<code><pre>\ntype User = { name: string };\nconst myUserAccount = jsonParserUnknown(`{ \"name\": \"Samuel\" }`) as User;\nmyUserAccount.name;\n\n</pre></code>\n// Unknown은 훌륭한 도구입니다. 더 자세히 알아보고 싶다면 다음 자료를 읽어보세요:\n https://mariusschulz.com/blog/the-unknown-type-in-typescript\n https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type\n\n Never\n\n TypeScript는 코드 흐름 분석을 지원하기 때문에,\n 코드가 논리적으로 발생할 수 없는 경우를 나타낼 수 있어야 합니다.\n 예를 들어, 아래 함수는 반환되지 않습니다:\n\n<code><pre>\nconst neverReturns = () => {\n  // 첫 번째 줄에서 throw하는 경우\n  throw new Error(\"Always throws, never returns\");\n};\n\n</pre></code>\n// 타입에 마우스를 올리면, 이것이 절대로 발생할 수 없다는 것을 의미하는\n () => never 타입이라는 것을 알 수 있습니다.\n 이러한 값은 다른 값과 마찬가지로 여전히 전달될 수 있습니다.\n\n<code><pre>\nconst myValue = neverReturns();\n\n</pre></code>\n// 함수의 리턴값을 never로 작성하는 것은\n JavaScript 런타임 시 예측 불가능하거나\n API를 사용하는 사람이 type을 사용하지 않았을 때 유용합니다.\n\n<code><pre>\nconst validateUser = (user: User) => {\n  if (user) {\n    return user.name !== \"NaN\";\n  }\n\n  // 타입 시스템에 따르면, 아래 코드는 절대 실행 될 수 없는데,\n  // 이는 neverReturns의 반환 타입에 해당합니다.\n\n  return neverReturns();\n};\n\n</pre></code>\n// 타입 정의는 user가 전달되어야 하지만\n JavaScript에 이를 보장할 수 없는\n 충분한 탈출구가 있음을 의미합니다.\n\n never를 반환하는 함수를 사용하면\n 불가능한 위치에 추가적인 코드를 사용하게끔 해 줍니다.\n 이는 더 나은 에러 메시지를 보여주거나\n 파일 또는 반복문과 같은 자원을 닫는 데 유용합니다.\n\n never는 주로 switch문이 완전하다는 것을 보장할 때 사용됩니다.\n E.g., 모든 경우가 다뤄짐을 의미합니다.\n\n enum과 완전한 switch문이 있습니다.\n enum에 새 옵션(예를 들면 Tulip?)을 넣어보세요.\n\n<code><pre>\nenum Flower {\n  Rose,\n  Rhododendron,\n  Violet,\n  Daisy,\n}\n\nconst flowerLatinName = (flower: Flower) => {\n  switch (flower) {\n    case Flower.Rose:\n      return \"Rosa rubiginosa\";\n    case Flower.Rhododendron:\n      return \"Rhododendron ferrugineum\";\n    case Flower.Violet:\n      return \"Viola reichenbachiana\";\n    case Flower.Daisy:\n      return \"Bellis perennis\";\n\n    default:\n      const _exhaustiveCheck: never = flower;\n      return _exhaustiveCheck;\n  }\n};\n\n</pre></code>\n// 새로운 꽃의 타입이 never로 변환될 수 없다는\n 컴파일 에러가 발생할 것입니다.\n\n 교차 타입에서의 Never\n\n Never는 교차타입에서\n 자동적으로 제거되는 타입입니다.\n\n<code><pre>\ntype NeverIsRemoved = string | never | number;\n\n</pre></code>\n// NeverIsRemoved 타입을 보면,\n string | number인 것을 확인할 수 있습니다.\n never에는 할당할 수 없기 때문에 런타임에서는 절대 발생하지 않을 것이기 때문입니다.\n\n 이 항목은 example:conditional-types에서 많이 사용됩니다.\n","redirectHref":"ko/play/?#example/unknown-and-never"}},"staticQueryHashes":[]}