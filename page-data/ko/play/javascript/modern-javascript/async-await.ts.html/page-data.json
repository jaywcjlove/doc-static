{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ko/play/javascript/modern-javascript/async-await.ts.html","result":{"pageContext":{"name":"Async Await","title":"Async Await","lang":"ko","html":"\n 모던 JavaScript는 특별한 구문의\n 프로미스(Promise) 기반 API를 추가하여\n 비동기 코드가 동기적으로 작동하는 것처럼\n 콜백을 처리하는 방법을 추가했습니다.\n\n 모든 언어 기능과 마찬가지로,\n 이러한 방식은 복잡성이 증가하는 대신 효율성이 증가합니다.\n 함수를 async로 만드는 것은 반환값을 프로미스 형태로 감싸주는 것을 의미합니다.\n 기존에는 string을 반환했지만 이제 Promise<string>을 반환합니다.\n\n<code><pre>\nconst func = () => \":wave:\";\nconst asyncFunc = async () => \":wave:\";\n\nconst myString = func();\nconst myPromiseString = asyncFunc();\n\nmyString.length;\n\n// myPromiseString은 string이 아닌 프로미스 입니다:\n\nmyPromiseString.length;\n\n</pre></code>\n// await 키워드를 사용하면\n 프로미스를 내부의 값으로 변환할 수 있습니다.\n 현재 이러한 기능은 async 함수 내에서만 작동합니다.\n\n<code><pre>\nconst myWrapperFunction = async () => {\n  const myString = func();\n  const myResolvedPromiseString = await asyncFunc();\n\n  // await 키워드를 통해\n  // 이제 myResolvedPromiseString 값은 문자열입니다.\n  myString.length;\n  myResolvedPromiseString.length;\n};\n\n</pre></code>\n// await을 통해 실행되는 코드는 오류 객체를 발생시킬 수 있고,\n 이러한 오류를 잡아내는 것이 중요합니다.\n\n<code><pre>\nconst myThrowingFunction = async () => {\n  throw new Error(\"Do not call this\");\n};\n\n</pre></code>\n// async 함수를 try catch 문으로 감싸\n 함수가 예기치 않게 작동하는 경우를 처리합니다.\n\n<code><pre>\nconst asyncFunctionCatching = async () => {\n  const myReturnValue = \"Hello world\";\n  try {\n    await myThrowingFunction();\n  } catch (error) {\n    console.error(\"myThrowingFunction failed\", error);\n  }\n  return myReturnValue;\n};\n\n</pre></code>\n// 단일 값을 반환하거나 오류를 발생시키는\n API의 인간 공학적 특성 때문에,\n 반환 값 내부의 결괏값에 대한 정보 제공을 고려해야 하며,\n 실제 예외적인 상황이 발생했을 때만\n throw 문을 사용해야 합니다.\n\n<code><pre>\nconst exampleSquareRootFunction = async (input: any) => {\n  if (isNaN(input)) {\n    throw new Error(\"Only numbers are accepted\");\n  }\n\n  if (input < 0) {\n    return { success: false, message: \"Cannot square root negative number\" };\n  } else {\n    return { success: true, value: Math.sqrt(input) };\n  }\n};\n\n</pre></code>\n// 그런 다음 해당 비동기 함수를 받는 객체로 응답 상태를 확인하고\n 반환 값으로 무엇을 처리할지 알아냅니다.\n 이것은 사소한 예제지만, 네트워킹에 관련된 코드를 작성한다면\n 이러한 API는 구문을 추가할만한 가치가 있습니다.\n\n<code><pre>\nconst checkSquareRoot = async (value: number) => {\n  const response = await exampleSquareRootFunction(value);\n  if (response.success) {\n    response.value;\n  }\n};\n\n// Async/Await 구문은 다음과 같은 코드를 사용해왔습니다:\n\n</pre></code>\n// getResponse(url, (response) => {\n   getResponse(response.url, (secondResponse) => {\n     const responseData = secondResponse.data\n     getResponse(responseData.url, (thirdResponse) => {\n       ...\n     })\n   })\n })\n\n 이를 순차적\u001d으로 작성하면:\n\n const response = await getResponse(url)\n const secondResponse = await getResponse(response.url)\n const responseData = secondResponse.data\n const thirdResponse = await getResponse(responseData.url)\n ...\n\n 코드가 왼쪽 가장자리에 가깝게 배치되어,\n 코드가 일관된 리듬으로 읽힐 수 있습니다.\n","redirectHref":"ko/play/?#example/async-await"}},"staticQueryHashes":[]}