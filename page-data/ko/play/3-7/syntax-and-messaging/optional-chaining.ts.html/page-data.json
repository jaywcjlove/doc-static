{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ko/play/3-7/syntax-and-messaging/optional-chaining.ts.html","result":{"pageContext":{"name":"Optional Chaining","title":"Optional Chaining","lang":"ko","html":"\n 선택적 체이닝(Optional chaining)이\n TC39 3단계에서 합의점에 도달한 내용이 TS 3.7 입니다.\n 선택적 체이닝을 사용하면 null 또는 undefined인 코드에 도달했을 때\n 즉시 중지할 수 있는 코드를 작성할 수 있습니다.\n\n 프로퍼티 접근 (Property Access)\n\n 우리가 아티스트와 아티스트 약력이 없는\n 앨범을 가지고 있다고 가정해 보겠습니다.\n 예를 들면, 컴필레이션 앨범에는 아티스트 정보가 없습니다.\n\n<code><pre>\ntype AlbumAPIResponse = {\n  title: string;\n  artist?: {\n    name: string;\n    bio?: string;\n    previousAlbums?: string[];\n  };\n};\n\ndeclare const album: AlbumAPIResponse;\n\n</pre></code>\n// 선택적 체이닝을 사용하면\n 다음과 같은 코드를 작성할 수 있습니다:\n\n<code><pre>\nconst artistBio = album?.artist?.bio;\n\n// 대신에:\n\nconst maybeArtistBio = album.artist && album.artist.bio;\n\n</pre></code>\n// 이 경우 ?.는  &&과는 다르게 동작합니다.\n 왜냐하면 &&는 \"falsy\" 값에 대한 동작이 다르기 때문입니다.\n (예. 빈 문자열, 0, NaN, 그리고, false)\n\n 선택적 체이닝은 null이거나 undefined이면\n 동작을 멈추고, undefined를 반환합니다.\n\n 선택적 요소 접근 (Optional Element Access)\n\n 프로퍼티 접근은 .연산자만을 이용하고,\n 선택적 체이닝이 요소에 접근할 때는 []연산자와 함께 이용합니다.\n\n<code><pre>\nconst maybeArtistBioElement = album?.[\"artist\"]?.[\"bio\"];\n\nconst maybeFirstPreviousAlbum = album?.artist?.previousAlbums?.[0];\n\n// 선택적 호출(Optional Calls)\n\n</pre></code>\n// 런타임 시 존재 여부를 판단하는 함수를 다룰 때,\n 선택적 체이닝은 실제로 존재하는 경우에만 함수호출을 지원합니다.\n 이는 if (func) func()와 같은\n 기존에 사용하던 코드를 대체할 수 있습니다.\n\n 예를 들어 API 요청에 의한 콜백 함수의 선택적 호출은\n 다음과 같습니다:\n\n<code><pre>\nconst callUpdateMetadata = (metadata: any) => Promise.resolve(metadata); // 가짜 API 호출\n\nconst updateAlbumMetadata = async (metadata: any, callback?: () => void) => {\n  await callUpdateMetadata(metadata);\n\n  callback?.();\n};\n\n</pre></code>\n// 선택적 체이닝에 대한 자세한 내용은 3.7 블로그 게시물을 통해 확인할 수 있습니다:\n\n https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/\n","redirectHref":"ko/play/?#example/optional-chaining"}},"staticQueryHashes":[]}