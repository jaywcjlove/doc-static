{"componentChunkName":"component---src-templates-play-example-tsx","path":"/es/play/javascript/functions-with-javascript/generic-functions.ts.html","result":{"pageContext":{"name":"Generic Functions","title":"Funciones genéricas","lang":"es","html":"\n La genericidad proporciona una forma de utilizar tipos\n como variables en otros tipos. Meta.\n\n Intentaremos mantener este ejemplo simple. Puedes hacer\n muchas cosas con la genericidad y probablemente verás\n en algún punto código muy complicado usando genericidad.\n Pero eso no significa que la genericidad es complicada.\n\n Comenzaremos con un ejemplo donde envolvemos un objeto de\n entrada en un arreglo. Solo nos importará una variable en\n este caso, el tipo suministrado:\n\n<code><pre>\nfunction wrapInArray<Type>(input: Type): Type[] {\n  return [input];\n}\n\n</pre></code>\n// Nota: es común ver el tipo Type como T. Esto es culturalmente\n similar a como las personas usan i en un cliclo for para\n representar index. T normalmente representa Type, por lo\n que usaremos el nombre completo para mayor claridad.\n\n Nuestra función usará inferencia para siempre mantener\n el tipo suministrado como entrada igual al suministrado\n como salida (aunque será envuelto en un arreglo).\n\n<code><pre>\nconst stringArray = wrapInArray(\"hello generics\");\nconst numberArray = wrapInArray(123);\n\n</pre></code>\n// Podemos verificar que funciona como se espera comprobando\n si podemos asignar un arreglo de cadenas a una función\n que debe ser un arreglo de objetos.\n<code><pre>\nconst notStringArray: string[] = wrapInArray({});\n\n</pre></code>\n// Además puedes saltarte la inferencia de tipos si añades\n el tipo tú mismo:\n<code><pre>\nconst stringArray2 = wrapInArray<string>(\"\");\n\n</pre></code>\n// wrapInArray permite que se use cualquier tipo, sin embargo\n hay casos en que necesitas permitir solo un subconjunto de\n tipos. En estos casos puedes decir que el tipo tiene que\n extender un tipo en particular.\n\n<code><pre>\ninterface Drawable {\n  draw: () => void;\n}\n\n</pre></code>\n// Esta función toma un conjunto de objetos que tiene una función\n para dibujar en la pantalla\n<code><pre>\nfunction renderToScreen<Type extends Drawable>(input: Type[]) {\n  input.forEach((i) => i.draw());\n}\n\nconst objectsWithDraw = [{ draw: () => {} }, { draw: () => {} }];\nrenderToScreen(objectsWithDraw);\n\n// Fallará si falta draw:\n\nrenderToScreen([{}, { draw: () => {} }]);\n\n</pre></code>\n// La genericidad puede comenzar a parecer complicada cuando tienes\n múltiples variables. Aquí hay un ejemplo de una función de caché\n que te permite tener diferentes conjuntos de tipos de entrada y\n de cachés.\n\n<code><pre>\ninterface CacheHost {\n  save: (a: any) => void;\n}\n\nfunction addObjectToCache<Type, Cache extends CacheHost>(obj: Type, cache: Cache): Cache {\n  cache.save(obj);\n  return cache;\n}\n\n</pre></code>\n// Esto es lo mismo que lo anterior, pero con un parámetro extra.\n Nota: Sin embargo para que esto funcione debimos usar any.\n Esto puede solucionarse usando una interfaz genérica.\n\n<code><pre>\ninterface CacheHostGeneric<ContentType> {\n  save: (a: ContentType) => void;\n}\n\n</pre></code>\n// Ahora cuando se usa CacheHostGeneric, necesitas decirle\n qué ContentType es.\n\n<code><pre>\nfunction addTypedObjectToCache<Type, Cache extends CacheHostGeneric<Type>>(obj: Type, cache: Cache): Cache {\n  cache.save(obj);\n  return cache;\n}\n\n</pre></code>\n// Eso escaló bastante rápido en términos de sintaxis. Sin\n embargo provee más seguridad. Estas son decisiones que\n ahora tienes más conocimiento para hacer. Al proporcionar\n APIs para terceros, la genericidad ofrece una forma flexible\n de permitir a otros utilizar sus propios tipos con total capacidad\n de inferencia de código.\n\n Para más ejemplos de genericidad con clases e interfaces:\n\n example:advanced-classes\n example:typescript-with-react\n https://www.typescriptlang.org/docs/handbook/generics.html\n","redirectHref":"es/play/?#example/generic-functions"}},"staticQueryHashes":[]}