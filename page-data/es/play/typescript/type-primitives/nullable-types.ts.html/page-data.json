{"componentChunkName":"component---src-templates-play-example-tsx","path":"/es/play/typescript/type-primitives/nullable-types.ts.html","result":{"pageContext":{"name":"Nullable Types","title":"Tipos Anulables","lang":"es","html":"\n JavaScript tiene dos formas de declarar valores que no\n existen, y TypeScript agrega sintaxis adicional lo que\n permite aun más formas de declarar algo como opcional o\n anulable.\n\n Primero, la diferencia entre ambas primitivas de\n JavaScript: undefined y null.\n\n La primitiva indefinida `undefined` es cuando algo no\n puede ser encontrado o modificado.\n\n<code><pre>\nconst emptyObj = {};\nconst anUndefinedProperty: undefined = emptyObj[\"anything\"];\n\n</pre></code>\n// La primitiva nula `null` está destinada a ser usada\n cuando hay una falta consciente de un valor.\n\n<code><pre>\nconst searchResults = {\n  video: { name: \"LEGO Movie\" },\n  text: null,\n  audio: { name: \"LEGO Movie Soundtrack\" },\n};\n\n</pre></code>\n// ¿Por qué no usar undefined? Principalmente, porque ahora\n puedes verificar que la propiedad text se haya incluido\n correctamente. Si la propiedad text se devuelve como\n undefined, el resultado es el mismo que si no estuviera\n allí.\n\n Esto puede parecer un poco superficial, pero cuando se\n hace la conversión a una cadena JSON, si la propiedad\n text era undefined, esta no podria ser incluida en la\n cadena de texto equivalente.\n\n Tipos Anulables Estrictos\n\n Antes de TypeScript 2.0, las primitivas undefined y null\n eran ignoradas en el sistema de tipado. Esto permitió que\n TypeScript proporcionará un entorno de codificación más\n cercano a JavaScript sin tipado.\n\n La versión 2.0 agregó una opción de compilador llamada\n \"strictNullChecks\" y esta opción requería que los\n usuarios tratasen undefined y null como tipos que deben\n ser manejados por medio de análisis de flujo de código\n ( Ver más en example:code-flow )\n\n Para ver un ejemplo de la diferencia en activar la opción\n de verificación estricta de tipos nulos en TypeScript,\n desplaza el cursor sobre \"PotentialString\" a\n continuación:\n\n<code><pre>\ntype PotentialString = string | undefined | null;\n\n</pre></code>\n// La variable PotentialString descarta el valor undefined y\n null. Si vas al panel de configuración, y activas el modo\n estricto, al regresar al código, verás que al pasar por\n PotentialString ahora se muestra la unión completa de\n tipos.\n\n<code><pre>\ndeclare function getID(): PotentialString;\n\nconst userID = getID();\nconsole.log(\"User Logged in: \", userID.toUpperCase());\n\n// Lo anterior fallará solamente en modo estricto ^\n\n</pre></code>\n// Existen maneras de decirle a TypeScript que sabes lo que\n haces, como por ejemplo una aserción de tipo o mediante\n un operador de aserción no nulo (!)\n\n<code><pre>\nconst definitelyString1 = getID() as string;\nconst definitelyString2 = getID()!;\n\n</pre></code>\n// O puedes verificar de manera segura por la existencia del\n valor utilizando un condicional if:\n\n<code><pre>\nif (userID) {\n  console.log(userID);\n}\n\n// Propiedades Opcionales\n\n// Void\n\n</pre></code>\n// Void es el tipo que retorna una función que no devuelve\n un valor.\n\n<code><pre>\nconst voidFunction = () => {};\nconst resultOfVoidFunction = voidFunction();\n\n</pre></code>\n// Esto es usualmente un accidente, y TypeScript mantiene el\n tipo vacío para permitirle obtener errores del compilador,\n aunque en tiempo de ejecución sería undefined.\n","redirectHref":"es/play/?strictNullChecks=false#example/nullable-types"}},"staticQueryHashes":[]}