{"componentChunkName":"component---src-templates-play-example-tsx","path":"/es/play/typescript/type-primitives/tuples.ts.html","result":{"pageContext":{"name":"Tuples","title":"Tuples","lang":"es","html":" Típicamente un arreglo contiene de cero a muchos objetos\n de un solo tipo. TypeScript tiene un análisis especial en\n torno a los arreglos que contengan múltiples tipos, y\n donde es importante el orden en que se indexan.\n\n Estos se llaman tuplas (en inglés **tuples**). Piensa en\n ellas como una forma de conectar algunos datos pero con\n menos sintaxis que un objeto ordenado por llaves.\n\n Puedes crear una tupla utilizando la sintaxis de arreglos\n en JavaScript:\n\n<code><pre>\nconst failingResponse = [\"Not Found\", 404];\n\n// pero necesitarás declarar su tipo como una tupla.\n\nconst passingResponse: [string, number] = [\"{}\", 200];\n\n</pre></code>\n// Al pasar el cursor sobre los nombres de ambas variables\n puedes ver la diferencia entre la variable de tipo arreglo\n ( (string | number)[] ) y la tupla ( [string, number] ).\n\n En un arreglo, el orden no es importante por lo que un\n elemento en cualquier indice puede ser una cadena de\n texto o un número. En la tupla, el orden y la longitud\n son garantizados.\n\n<code><pre>\nif (passingResponse[1] === 200) {\n  const localInfo = JSON.parse(passingResponse[0]);\n  console.log(localInfo);\n}\n\n</pre></code>\n// Esto significa que TypeScript proporcionará el tipo\n correcto en el índice adecuado e incluso generará un\n error si intenta acceder a un objeto en un índice no\n declarado.\n\n<code><pre>\npassingResponse[2];\n\n</pre></code>\n// Una tupla puede lucir como un buen patrón para pedazos\n cortos de datos entrelazados o como base de otras tareas.\n\n<code><pre>\ntype StaffAccount = [number, string, string, string?];\n\nconst staff: StaffAccount[] = [\n  [0, \"Adankwo\", \"adankwo.e@\"],\n  [1, \"Kanokwan\", \"kanokwan.s@\"],\n  [2, \"Aneurin\", \"aneurin.s@\", \"Supervisor\"],\n];\n\n</pre></code>\n// Cuando se tiene un conjunto conocido de tipos en el\n comienzo de la tupla y luego un tamaño desconocido, se\n puede hacer uso del operador de propagación para indicar\n que este puede tener cualquier longitud y los indices\n extras serán de un tipo de dato en particular:\n\n<code><pre>\ntype PayStubs = [StaffAccount, ...number[]];\n\nconst payStubs: PayStubs[] = [\n  [staff[0], 250],\n  [staff[1], 250, 260],\n  [staff[0], 300, 300, 300],\n];\n\nconst monthOnePayments = payStubs[0][1] + payStubs[1][1] + payStubs[2][1];\nconst monthTwoPayments = payStubs[1][2] + payStubs[2][2];\nconst monthThreePayments = payStubs[2][2];\n\n</pre></code>\n// Puedes utilizar tuplas para describir funciones las\n cuales toman un número indefinido de parámetros con un\n tipo determinado:\n\n<code><pre>\ndeclare function calculatePayForEmployee(id: number, ...args: [...number[]]): number;\n\ncalculatePayForEmployee(staff[0][0], payStubs[0][1]);\ncalculatePayForEmployee(staff[1][0], payStubs[1][1], payStubs[1][2]);\n\n</pre></code>\n//\n https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#tuples-in-rest-parameters-and-spread-expressions\n https://auth0.com/blog/typescript-3-exploring-tuples-the-unknown-type/\n","redirectHref":"es/play/?#example/tuples"}},"staticQueryHashes":[]}