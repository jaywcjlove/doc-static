{"componentChunkName":"component---src-templates-play-example-tsx","path":"/es/play/typescript/meta-types/discriminate-types.ts.html","result":{"pageContext":{"name":"Discriminate Types","title":"Discriminate Types","lang":"es","html":" Una unión de tipo discriminado es cuando se utiliza el\n análisis de flujo de código para reducir un conjunto de\n objetos potenciales a un objeto específico.\n\n Este patrón funciona muy bien para conjuntos de objetos\n similares con una cadena o constante numérica diferente,\n por ejemplo: una lista de eventos con nombre, o conjuntos\n de objetos versionados.\n\n<code><pre>\ntype TimingEvent = { name: \"start\"; userStarted: boolean } | { name: \"closed\"; duration: number };\n\n</pre></code>\n// Cuando el evento entra en esta función, podría ser\n cualquiera de los dos tipos potenciales.\n\n<code><pre>\nconst handleEvent = (event: TimingEvent) => {\n  // Mediante el uso de un interruptor en event.name el\n  // análisis de flujo de código de TypeScript puede\n  // determinar que un objeto sólo puede ser representado\n  // por un tipo en la unión.\n\n  switch (event.name) {\n    case \"start\":\n      // Esto significa que puedes acceder con seguridad a\n      // userStarted porque es el único tipo dentro de\n      // TimingEvent donde el nombre es \"start\".\n      const initiatedByUser = event.userStarted;\n      break;\n\n    case \"closed\":\n      const timespan = event.duration;\n      break;\n  }\n};\n\n</pre></code>\n// Este patrón es el mismo con los números que podemos usar\n como el discriminador.\n\n En este ejemplo, tenemos una unión discriminante y un\n estado de error adicional que manejar.\n\n<code><pre>\ntype APIResponses = { version: 0; msg: string } | { version: 1; message: string; status: number } | { error: string };\n\nconst handleResponse = (response: APIResponses) => {\n  // Maneja el caso de error, y luego retorna\n  if (\"error\" in response) {\n    console.error(response.error);\n    return;\n  }\n\n  // TypeScript ahora sabe que APIResponse no puede ser el\n  // tipo de error. Si fuera el error, la función habría\n  // retornado. Puede verificar esto pasando el cursor sobre\n  // response a continuación.\n\n  if (response.version === 0) {\n    console.log(response.msg);\n  } else if (response.version === 1) {\n    console.log(response.status, response.message);\n  }\n};\n\n</pre></code>\n// Es mejor usar una declaración switch en lugar de\n declaraciones if, porque puedes asegurarte de que todas\n las partes de la unión son revisadas. Hay un buen patrón\n para esto usando el tipo `never` en el manual:\n\n https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions\n","redirectHref":"es/play/?#example/discriminate-types"}},"staticQueryHashes":[]}