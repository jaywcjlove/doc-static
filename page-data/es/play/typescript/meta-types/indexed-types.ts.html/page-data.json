{"componentChunkName":"component---src-templates-play-example-tsx","path":"/es/play/typescript/meta-types/indexed-types.ts.html","result":{"pageContext":{"name":"Indexed Types","title":"Indexed Types","lang":"es","html":" Hay veces que te encuentras duplicando tipos. Un ejemplo\n común es el de los recursos anidados en una respuesta API\n autogenerada.\n\n<code><pre>\ninterface ArtworkSearchResponse {\n  artists: {\n    name: string;\n    artworks: {\n      name: string;\n      deathdate: string | null;\n      bio: string;\n    }[];\n  }[];\n}\n\n</pre></code>\n// Si esta interfaz fuera hecha a mano, es bastante fácil\n imaginar que se saca el tipo de artworks en una interfaz\n como:\n\n<code><pre>\ninterface Artwork {\n  name: string;\n  deathdate: string | null;\n  bio: string;\n}\n\n</pre></code>\n// Sin embargo, en este caso no controlamos la API, y si\n creamos la interfaz a mano, es posible que la parte de\n ArtworkSearchResponse y Artwork se desincronicen cuando\n la respuesta cambie.\n\n La solución para esto son los tipos indexados, que\n replican la manera en que JavaScript permite el acceso a\n las propiedades a través de cadenas.\n\n<code><pre>\ntype InferredArtwork = ArtworkSearchResponse[\"artists\"][0][\"artworks\"][0];\n\n</pre></code>\n// El InferredArtwork se genera mirando las propiedades del\n tipo y dando un nuevo nombre al subconjunto que has\n indexado.\n","redirectHref":"es/play/?#example/indexed-types"}},"staticQueryHashes":[]}