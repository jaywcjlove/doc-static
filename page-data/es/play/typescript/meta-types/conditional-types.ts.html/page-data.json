{"componentChunkName":"component---src-templates-play-example-tsx","path":"/es/play/typescript/meta-types/conditional-types.ts.html","result":{"pageContext":{"name":"Conditional Types","title":"Conditional Types","lang":"es","html":" Los tipos condicionales proporcionan una forma de hacer\n lógica simple en el sistema de tipos de TypeScript. Esta\n es definitivamente una característica avanzada, y es\n bastante factible que no necesites usar esto en tu código\n del día a día.\n\n Un tipo condicional se parece a:\n\n   A extends B ? C : D\n\n Donde la condición es si un tipo extiende una expresión\n y, en caso afirmativo, qué tipo debe devolverse.\n\n Veamos algunos ejemplos, para ser breves vamos a usar\n letras simples para los genéricos. Esto es opcional, pero\n al restringirnos a 60 caracteres es difícil que quepa en\n la pantalla.\n\n<code><pre>\ntype Cat = { meows: true };\ntype Dog = { barks: true };\ntype Cheetah = { meows: true; fast: true };\ntype Wolf = { barks: true; howls: true };\n\n</pre></code>\n// Podemos crear un tipo condicional que permita extraer\n tipos que sólo se ajusten a un animal que ladra.\n\n<code><pre>\ntype ExtractDogish<A> = A extends { barks: true } ? A : never;\n\n// Entonces podemos crear tipos soportados por ExtractDogish:\n\n// Un gato no ladra, por lo que retorna `never`\ntype NeverCat = ExtractDogish<Cat>;\n</pre></code>\n// Un lobo puede ladrar, por lo que retorna la forma del\n objeto `Wolf`\n<code><pre>\ntype Wolfish = ExtractDogish<Wolf>;\n\n</pre></code>\n// Esto resulta útil cuando se quiere trabajar con un unión\n de muchos tipos y reducir el número de opciones\n potenciales en una unión:\n\n<code><pre>\ntype Animals = Cat | Dog | Cheetah | Wolf;\n\n</pre></code>\n// Cuando aplicas ExtractDogish a una unión de tipos, es\n igual a ejecutar los condicionales en cada uno de los\n miembros del tipo:\n\n<code><pre>\ntype Dogish = ExtractDogish<Animals>;\n\n</pre></code>\n// = ExtractDogish<Cat> | ExtractDogish<Dog> |\n   ExtractDogish<Cheetah> | ExtractDogish<Wolf>\n\n = never | Dog | never | Wolf\n\n = Dog | Wolf (Veasé example:unknown-and-never)\n\n Se denomina tipo condicional distributivo porque el tipo\n se distribuye sobre cada miembro de la unión.\n\n Tipos Condicionales Diferidos\n\n Los tipos condicionales pueden utilizarse para reforzar\n sus APIs, que pueden devolver diferentes tipos en función\n de las entradas.\n\n Por ejemplo, esta función que puede devolver una cadena o\n un número dependiendo del booleano pasado.\n\n<code><pre>\ndeclare function getID<T extends boolean>(fancy: T): T extends true ? string : number;\n\n</pre></code>\n// Entonces, dependiendo de cuánto sepa el sistema de tipos\n sobre el booleano, obtendrá diferentes tipos de retorno:\n\n<code><pre>\nlet stringReturnValue = getID(true);\nlet numberReturnValue = getID(false);\nlet stringOrNumber = getID(Math.random() < 0.5);\n\n</pre></code>\n// En este caso, TypeScript puede saber el valor de retorno\n al instante. Sin embargo, puede usar tipos condicionales\n en funciones donde el tipo no se conoce todavía. Esto se\n denomina tipo condicional diferido.\n\n Igual que nuestro \"Dogish\" anterior, pero como función\n<code><pre>\ndeclare function isCatish<T>(x: T): T extends { meows: true } ? T : undefined;\n\n</pre></code>\n// Hay una herramienta extra útil dentro de los tipos\n condicionales, que es capaz de decirle específicamente a\n TypeScript que debe inferir el tipo al diferir. Esa es la\n palabra clave \"infer\".\n\n \"infer\" se usa típicamente para crear meta-tipos que\n inspeccionan los tipos existentes en tu código, piensa en\n ello como crear una nueva variable dentro del tipo.\n\n<code><pre>\ntype GetReturnValue<T> = T extends (...args: any[]) => infer R ? R : T;\n\n</pre></code>\n// Básicamente:\n\n  - Este es un tipo genérico condicional llamado\n    GetReturnValue el cual acepta un tipo como su primer\n    parámetro.\n\n  - El condicional revisa si el tipo es una función, y si\n    es así crea un nuevo tipo llamado R basado en el valor\n    retornado por esa función.\n\n  - Si la revisión pasa, el valor del tipo es el valor de\n    retorno inferido, sino es el tipo original.\n\n\n<code><pre>\ntype getIDReturn = GetReturnValue<typeof getID>;\n\n</pre></code>\n// Esto falla en la comprobación de ser una función, y sólo\n devolvería el tipo pasado a ella.\n<code><pre>\ntype getCat = GetReturnValue<Cat>;\n","redirectHref":"es/play/?#example/conditional-types"}},"staticQueryHashes":[]}