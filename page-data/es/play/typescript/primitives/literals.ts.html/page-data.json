{"componentChunkName":"component---src-templates-play-example-tsx","path":"/es/play/typescript/primitives/literals.ts.html","result":{"pageContext":{"name":"Literals","title":"Literales","lang":"es","html":"\n TypeScript tambien cuenta con algunos casos especiales\n para los literales en el código fuente.\n\n De hecho, gran parte del soporte está cubierto por la expansión\n y redución de tipos ( example:type-widening-narrowing ) y vale\n la pena hablar de ello primero.\n\n Un literal es un subtipo más concreto de un tipo común.\n Lo que esto significa es que \"Hello World\" es una cadena,\n pero una cadena no es \"Hello World\" dentro del sistema de tipos.\n\n<code><pre>\nconst helloWorld = \"Hello World\";\nlet hiWorld = \"Hi World\"; // esto es una cadena porque se define con let\n\n// Esta función acepta todas las cadenas\ndeclare function allowsAnyString(arg: string);\nallowsAnyString(helloWorld);\nallowsAnyString(hiWorld);\n\n// Esta función solo acepta la cadena literal \"Hello World\"\ndeclare function allowsOnlyHello(arg: \"Hello World\");\nallowsOnlyHello(helloWorld);\nallowsOnlyHello(hiWorld);\n\n</pre></code>\n// Esto te permite declarar APIs que usan uniones para decir\n que solo acepta unos literales en particular.\n\n<code><pre>\ndeclare function allowsFirstFiveNumbers(arg: 1 | 2 | 3 | 4 | 5);\nallowsFirstFiveNumbers(1);\nallowsFirstFiveNumbers(10);\n\nlet potentiallyAnyNumber = 3;\nallowsFirstFiveNumbers(potentiallyAnyNumber);\n\n// A primera vista, esta regla no se aplica a los objetos complejos.\n\nconst myUser = {\n  name: \"Sabrina\",\n};\n\n</pre></code>\n// Notesé como transforma `name: \"Sabrina\"` a `name: string`\n aún cuando está definida como una constante. Esto se debe\n a que el nombre todavía puede cambiar en cualquier momento:\n\n<code><pre>\nmyUser.name = \"Cynthia\";\n\n</pre></code>\n// Debido a que la propiedad `name` de `myUser` puede cambiar,\n TypeScript no puede usar la versión literal en el sistema\n de tipos. Sin embargo, hay una característica que le permitirá\n hacer esto.\n\n<code><pre>\nconst myUnchangingUser = {\n  name: \"Fatma\",\n} as const;\n\n</pre></code>\n// Cuando se aplica \"as const\" al objeto, entonces se convierte\n en un objeto literal que no cambia a diferencia de un objeto\n mutable que sí puede.\n\n<code><pre>\nmyUnchangingUser.name = \"Raîssa\";\n\n</pre></code>\n// \"as const\" es una gran herramienta para datos fijos, y lugares\n donde se trata el código como literales en línea. \"as const\"\n también funciona con los arreglos:\n\n<code><pre>\nconst exampleUsers = [{ name: \"Brian\" }, { name: \"Fahrooq\" }] as const;\n","redirectHref":"es/play/?#example/literals"}},"staticQueryHashes":[]}