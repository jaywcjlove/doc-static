{"componentChunkName":"component---src-templates-play-example-tsx","path":"/es/play/typescript/primitives/union-and-intersection-types.ts.html","result":{"pageContext":{"name":"Union and Intersection Types","title":"Tipos Unión e Intersección","lang":"es","html":"\n Las uniones de tipo son una forma de declarar que un\n objeto podría ser de más de un tipo.\n\n<code><pre>\ntype StringOrNumber = string | number;\ntype ProcessStates = \"open\" | \"closed\";\ntype OddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;\ntype AMessyUnion = \"hello\" | 156 | { error: true };\n\n</pre></code>\n// Si el uso de \"open\" y \"closed\" frente a una cadena es\n nuevo para ti, miresé: example:literals\n\n Podemos mezclar diferentes tipos en una unión, y con ello\n decir que el valor es uno de esos tipos.\n\n TypeScript te dejará entonces averiguar cómo determinar\n qué valor podría ser en tiempo de ejecución.\n\n Las uniones pueden a veces ser socavadas por el\n ensanchamiento del tipo, por ejemplo:\n\n<code><pre>\ntype WindowStates = \"open\" | \"closed\" | \"minimized\" | string;\n\n</pre></code>\n// Si inspecciona arriba, podrá ver que WindowStates\n se convierte en una cadena - no en la unión. Esto es\n explicado en example:type-widening-and-narrowing\n\n Si una unión es una operación OR, entonces una intersección\n es una operación AND. Las intersecciones de tipo son cuando\n dos tipos se cruzan para crear un nuevo tipo. Esto permite\n la composición del tipo.\n\n<code><pre>\ninterface ErrorHandling {\n  success: boolean;\n  error?: { message: string };\n}\n\ninterface ArtworksData {\n  artworks: { title: string }[];\n}\n\ninterface ArtistsData {\n  artists: { name: string }[];\n}\n\n</pre></code>\n// Estas interfaces pueden estar compuestas por respuestas\n que tienen tanto un manejo consistente de errores como\n sus propios datos.\n\n<code><pre>\ntype ArtworksResponse = ArtworksData & ErrorHandling;\ntype ArtistsResponse = ArtistsData & ErrorHandling;\n\n// Por ejemplo:\n\nconst handleArtistsResponse = (response: ArtistsResponse) => {\n  if (response.error) {\n    console.error(response.error.message);\n    return;\n  }\n\n  console.log(response.artists);\n};\n\n</pre></code>\n// Una mezcla de tipos de Intersección y Unión se vuelve\n realmente útil cuando tienes casos en los que un objeto\n tiene que incluir uno de dos valores:\n\n<code><pre>\ninterface CreateArtistBioBase {\n  artistID: string;\n  thirdParty?: boolean;\n}\n\ntype CreateArtistBioRequest = (CreateArtistBioBase & { html: string }) | { markdown: string };\n\n</pre></code>\n// Ahora sólo puedes crear una petición cuando incluyes\n artistID y los campos html o markdown\n\n<code><pre>\nconst workingRequest: CreateArtistBioRequest = {\n  artistID: \"banksy\",\n  markdown: \"Banksy is an anonymous England-based graffiti artist...\",\n};\n\nconst badRequest: CreateArtistBioRequest = {\n  artistID: \"banksy\",\n};\n","redirectHref":"es/play/?#example/union-and-intersection-types"}},"staticQueryHashes":[]}