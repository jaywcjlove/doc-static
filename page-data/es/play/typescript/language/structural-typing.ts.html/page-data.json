{"componentChunkName":"component---src-templates-play-example-tsx","path":"/es/play/typescript/language/structural-typing.ts.html","result":{"pageContext":{"name":"Structural Typing","title":"Structural Typing","lang":"es","html":" TypeScript es un sistema de tipo estructural. Un sistema\n de tipo estructural significa que cuando se comparan los\n tipos, TypeScript sólo tiene en cuenta los miembros en el\n tipo.\n\n Esto es en contraste con los sistemas de tipo nominal,\n donde se pueden crear dos tipos pero no se pueden asignar\n uno al otro. Véase example:nominal-typing\n\n Por ejemplo, estas dos interfaces son completamente\n transferibles en un sistema de tipo estructural:\n\n<code><pre>\ninterface Ball {\n  diameter: number;\n}\ninterface Sphere {\n  diameter: number;\n}\n\nlet ball: Ball = { diameter: 10 };\nlet sphere: Sphere = { diameter: 20 };\n\nsphere = ball;\nball = sphere;\n\n</pre></code>\n// Si añadimos un tipo que estructuralmente contiene todos\n los miembros de Ball (Bola) y Sphere (Esfera), entonces\n también puede ser configurado para ser una bola o esfera.\n\n<code><pre>\ninterface Tube {\n  diameter: number;\n  length: number;\n}\n\nlet tube: Tube = { diameter: 12, length: 3 };\n\ntube = ball;\nball = tube;\n\n</pre></code>\n// Debido a que una bola no tiene una longitud, no puede ser\n asignada a la variable `tube`. Sin embargo, todos los\n miembros de Ball están dentro de Tube, y por lo\n tanto puede ser asignada.\n\n TypeScript está comparando cada miembro del tipo con los\n demás para verificar su igualdad.\n\n Una función es un objeto en JavaScript y se compara de\n manera similar. Con un útil truco extra alrededor de los\n parámetros:\n\n<code><pre>\nlet createBall = (diameter: number) => ({ diameter });\nlet createSphere = (diameter: number, useInches: boolean) => {\n  return { diameter: useInches ? diameter * 0.39 : diameter };\n};\n\ncreateSphere = createBall;\ncreateBall = createSphere;\n\n</pre></code>\n// TypeScript permitirá que (number) sea igual a (number, boolean)\n en los parámetros, pero no (number, boolean) -> (number)\n\n TypeScript descartará el booleano en la primera\n asignación porque es muy común que el código JavaScript\n salte los parámetros de paso cuando no se necesitan.\n\n Por ejemplo, el método forEach del arreglo tiene tres\n parámetros, value, index y el arreglo entero - si\n TypeScript no soportará el descarte de parámetros,\n entonces tendrías que incluir todas las opciones para\n hacer que las funciones coincidieran:\n\n<code><pre>\n[createBall(1), createBall(2)].forEach((ball, _index, _balls) => {\n  console.log(ball);\n});\n\n// Nadie necesita eso.\n\n</pre></code>\n// Los tipos de retorno se tratan como objetos, y cualquier\n diferencia se compara con las mismas reglas de igualdad\n de objetos de arriba.\n\n<code><pre>\nlet createRedBall = (diameter: number) => ({ diameter, color: \"red\" });\n\ncreateBall = createRedBall;\ncreateRedBall = createBall;\n\n</pre></code>\n// Donde la primera asignación funciona (ambos tienen\n diámetro) pero la segunda no (la bola no tiene color).\n","redirectHref":"es/play/?#example/structural-typing"}},"staticQueryHashes":[]}