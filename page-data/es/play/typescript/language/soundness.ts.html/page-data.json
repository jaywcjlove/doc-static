{"componentChunkName":"component---src-templates-play-example-tsx","path":"/es/play/typescript/language/soundness.ts.html","result":{"pageContext":{"name":"Soundness","title":"Soundness","lang":"es","html":"\n Sin antecedentes en la teoría de tipos, es poco probable que esté\n familiarizado con la idea de que un sistema de tipos sea \"sólido\".\n\n La Solidez es la idea de que el compilador puede dar garantías sobre el tipo\n de valor que tiene un valor en tiempo de ejecución, y no sólo durante la\n compilación. Esto es normal para la mayoría de los lenguajes de programación\n que se construyen con tipos desde el primer día.\n\n Sin embargo, la construcción de un sistema de tipos que modela un lenguaje el\n cual ha existido por algunas décadas se torna en la toma de decisiones para\n compensar tres cualidades: Simplicidad, Usabilidad y Solidez.\n\n Siendo el objetivo de TypeScript de ser capaz de soportar todo el código\n JavaScript, el lenguaje tiende a la simplicidad y la usabilidad cuando se\n presenta con formas de añadir tipos a JavaScript.\n\n Veamos algunos casos en los cuales TypeScript probablemente no es sólido,\n para entender cómo se verían esas compensaciones de otra manera.\n\n Aserciones de Tipo\n\n<code><pre>\nconst usersAge = (\"23\" as any) as number;\n\n</pre></code>\n// TypeScript le permitirá usar aserciones de tipo para anular la inferencia de\n algo que está mal. El uso de aserciones de tipo es una manera de decirle a\n TypeScript que usted sabe lo que hace, y TypeScript tratará de dejarle\n continuar con ello.\n\n Los lenguajes que son sólidos ocasionalmente usarían comprobaciones de tiempo\n de ejecución para asegurarse de que los datos coinciden con lo que dicen sus\n tipos - pero TypeScript tiene como objetivo no tener un impacto en tiempo de\n ejecución de los tipos en su código transpilado.\n\n Parámetro de función Bi-variante\n\n Los parámetros de una función soportan la redefinición del parámetro para que\n sea un subtipo de la declaración original.\n\n<code><pre>\ninterface InputEvent {\n  timestamp: number;\n}\ninterface MouseInputEvent extends InputEvent {\n  x: number;\n  y: number;\n}\ninterface KeyboardInputEvent extends InputEvent {\n  keyCode: number;\n}\n\nfunction listenForEvent(eventType: \"keyboard\" | \"mouse\", handler: (event: InputEvent) => void) {}\n\n</pre></code>\n// Puede volver a declarar el tipo de parámetro para que sea un subtipo de la\n declaración. En lo anterior, el parámetro `handler` esperaba un tipo\n InputEvent pero en los siguientes ejemplos - TypeScript acepta un tipo que\n tiene propiedades adicionales.\n\n<code><pre>\nlistenForEvent(\"keyboard\", (event: KeyboardInputEvent) => {});\nlistenForEvent(\"mouse\", (event: MouseInputEvent) => {});\n\n// Esto puede extenderse hasta el tipo común más pequeño:\n\nlistenForEvent(\"mouse\", (event: {}) => {});\n\n// Pero no más allá:\n\nlistenForEvent(\"mouse\", (event: string) => {});\n\n</pre></code>\n// Esto cubre el patrón del mundo real para escuchar eventos en JavaScript, a\n expensas de tener un código más sólido.\n\n TypeScript puede arrojar un error cuando esto sucede a través de la opción\n `strictFunctionTypes`. O, podrías trabajar alrededor de este caso particular\n con sobrecargas de funciones,\n Véase: example:typing-functions\n\n Caso especial para Void\n\n Descarte de parámetros\n\n Para conocer acerca de los casos especiales con parámetros de función\n Véase example:structural-typing\n\n Parámetros Rest\n\n Los parámetros rest se asumen todos como opcionales, esto significa que\n TypeScript no tiene manera de hacer cumplir el número de parámetros\n disponibles para una llamada de retorno.\n\n<code><pre>\nfunction getRandomNumbers(count: number, callback: (...args: number[]) => void) {}\n\ngetRandomNumbers(2, (first, second) => console.log([first, second]));\ngetRandomNumbers(400, first => console.log(first));\n\n// Las funciones declaradas `void` pueden coincidir con una función con un valor de retorno\n\n</pre></code>\n// Una función que retorna una función declarada `void` puede aceptar una\n función que acepta cualquier otro tipo.\n\n<code><pre>\nconst getPI = () => 3.14;\n\nfunction runFunction(func: () => void) {\n  func();\n}\n\nrunFunction(getPI);\n\n</pre></code>\n// Para más información sobre los lugares donde la solidez del sistema de tipos\n se ve comprometida, véase:\n\n https://github.com/Microsoft/TypeScript/wiki/FAQ#type-system-behavior\n https://github.com/Microsoft/TypeScript/issues/9825\n https://www.typescriptlang.org/docs/handbook/type-compatibility.html\n","redirectHref":"es/play/?strictFunctionTypes=false#example/soundness"}},"staticQueryHashes":[]}