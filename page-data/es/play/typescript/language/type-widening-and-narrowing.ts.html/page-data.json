{"componentChunkName":"component---src-templates-play-example-tsx","path":"/es/play/typescript/language/type-widening-and-narrowing.ts.html","result":{"pageContext":{"name":"Type Widening and Narrowing","title":"Type Widening and Narrowing","lang":"es","html":" Podría ser más fácil comenzar el debate sobre la ampliación y\n la reducción con un ejemplo:\n\n<code><pre>\nconst welcomeString = \"Hello There\";\nlet replyString = \"Hey\";\n\n</pre></code>\n// Aparte de las diferencias de texto en las cadenas, welcomeString\n es una const (lo que significa que el valor nunca cambiará)\n y replyString es un let (lo que significa que puede cambiar).\n\n Si pasas el cursor por encima de ambas variables, obtienes\n información de tipo muy diferente de TypeScript:\n\n   const welcomeString: \"Hello There\"\n\n   let replyString: string\n\n TypeScript ha inferido el tipo de welcomeString como la cadena\n literal \"Hello There\", mientras que replyString es una cadena\n general.\n\n Esto se debe a que let necesita un tipo mas amplio, podrias\n establecer replyString como cualquier otra cadena, lo que\n significa que tiene un conjunto más amplio de posibilidades.\n\n<code><pre>\nreplyString = \"Hi :wave:\";\n\n</pre></code>\n// Si replyString tiene como tipo la cadena literal \"Hey\" -\n entonces nunca podrías cambiar el valor porque sólo podría\n cambiar a \"Hey\" de nuevo.\n\n La ampliación y reducción de tipos se basa en aumentar o\n reducir las posibilidades que un tipo puede representar.\n\n Un ejemplo de reducción de tipo es trabajar con uniones, el\n ejemplo del análisis de flujo de código se basa casi\n enteramente en la reducción: example:code-flow\n\n La reducción de tipo es lo que impulsa el modo estricto de\n TypeScript a través de las verificaciones de nulidad. Con el\n modo estricto desactivado, los marcadores de nulidad como\n indefinido y nulo son ignorados en una unión.\n\n<code><pre>\ndeclare const quantumString: string | undefined;\n// Esto fallará sólo en modo estricto\nquantumString.length;\n\n</pre></code>\n// En el modo estricto la responsabilidad es del autor del código\n para asegurar que el tipo se ha reducido al tipo no nulo.\n Normalmente esto es tan simple como una comprobación de tipo if:\n\n<code><pre>\nif (quantumString) {\n  quantumString.length;\n}\n\n</pre></code>\n// En el modo estricto, el tipo quantumString tiene dos representaciones.\n Dentro del condicional if, el tipo fue reducido a solo una cadena.\n\n Puede ver más ejemplos de reducción en:\n\n example:union-and-intersection-types\n example:discriminate-types\n\n Y aún más recursos en la web:\n\n https://mariusschulz.com/blog/literal-type-widening-in-typescript\n https://sandersn.github.io/manual/Widening-and-Narrowing-in-Typescript.html\n","redirectHref":"es/play/?#example/type-widening-and-narrowing"}},"staticQueryHashes":[]}