{"componentChunkName":"component---src-templates-play-example-tsx","path":"/id/play/javascript/external-apis/typescript-with-webgl.js.html","result":{"pageContext":{"name":"TypeScript with WebGL","title":"TypeScript with WebGL","lang":"id","html":"\n Di bawah ini merupakan contoh pembuata sebuah kanvas HTML\n yang menggunakan WebGL untuk menghasilkan _confetti_ yang\n berputar menggunakan JavaScript. Kita akan menelusuri kode\n program untuk mengerti bagaimana program bekerja, dan melihat\n bagaimana perkakas TypeScript menyediakan fitur yang berguna.\n\n Contoh ini dibangun berdasarkan: example:working-with-the-dom\n\n Pertama, kita harus membuat sebuah elemen `canvas`, yang\n kita buat menggunakan API DOM dan menetapkan beberapa\n _inline styles_:\n\n<code><pre>\nconst canvas = document.createElement(\"canvas\")\ncanvas.id = \"spinning-canvas\"\ncanvas.style.backgroundColor = \"#0078D4\"\ncanvas.style.position = \"fixed\"\ncanvas.style.bottom = \"10px\"\ncanvas.style.right = \"20px\"\ncanvas.style.width = \"500px\"\ncanvas.style.height = \"400px\"\n\n</pre></code>\n// Selanjutnya, untuk mempermudah perubahan, kita akan menghapus\n kanvas versi lama dengan ketika menekan tombol \"Run\"  - sekarang\n Anda dapat membuat perubahan dan melihat perubahan tersebut\n ketika Anda menekan tombol \"Run\" atau (`cmd + enter`):\n\n<code><pre>\nconst kanvasYangSudahAda = document.getElementById(canvas.id)\nif (kanvasYangSudahAda && kanvasYangSudahAda.parentElement) {\n  kanvasYangSudahAda.parentElement.removeChild(kanvasYangSudahAda)\n}\n\n</pre></code>\n// Perintahkan elemen kanvas untuk menggunakan WebGL ketika akan\n menggambar dalam elemen (dan jangan gunakan mesin _raster_ anggapan):\n\n<code><pre>\nconst gl = canvas.getContext(\"webgl\")\n\n</pre></code>\n// Selanjutnya, kita perlu untuk membuat _vertex shaders_ - sederhananya,\n _vertex shaders_ adalah program kecil yang menerapkan fungsi matematika\n pada sekumpulan titik (bilangan).\n\n Anda dapat melihat banyak atribut di atas _shader_, atribut-atribut\n tersebut akan diteruskan pada _shader_ hasil kompilasi pada \n bagian bawah contoh.\n\n Anda dapat melihat gambaran umum tentang bagaimana WebGL bekerja\n melalui:\n https://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html\n\n<code><pre>\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)\ngl.shaderSource(\n  vertexShader,\n  `\nprecision lowp float;\n\nattribute vec2 a_position; // Flat square on XY plane\nattribute float a_startAngle;\nattribute float a_angularVelocity;\nattribute float a_rotationAxisAngle;\nattribute float a_particleDistance;\nattribute float a_particleAngle;\nattribute float a_particleY;\nuniform float u_time; // Global state\n\nvarying vec2 v_position;\nvarying vec3 v_color;\nvarying float v_overlight;\n\nvoid main() {\n  float angle = a_startAngle + a_angularVelocity * u_time;\n  float vertPosition = 1.1 - mod(u_time * .25 + a_particleY, 2.2);\n  float viewAngle = a_particleAngle + mod(u_time * .25, 6.28);\n\n  mat4 vMatrix = mat4(\n    1.3, 0.0, 0.0, 0.0,\n    0.0, 1.3, 0.0, 0.0,\n    0.0, 0.0, 1.0, 1.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  mat4 shiftMatrix = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    a_particleDistance * sin(viewAngle), vertPosition, a_particleDistance * cos(viewAngle), 1.0\n  );\n\n  mat4 pMatrix = mat4(\n    cos(a_rotationAxisAngle), sin(a_rotationAxisAngle), 0.0, 0.0,\n    -sin(a_rotationAxisAngle), cos(a_rotationAxisAngle), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  ) * mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(angle), sin(angle), 0.0,\n    0.0, -sin(angle), cos(angle), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  gl_Position = vMatrix * shiftMatrix * pMatrix * vec4(a_position * 0.03, 0.0, 1.0);\n  vec4 normal = vec4(0.0, 0.0, 1.0, 0.0);\n  vec4 transformedNormal = normalize(pMatrix * normal);\n\n  float dotNormal = abs(dot(normal.xyz, transformedNormal.xyz));\n  float regularLighting = dotNormal / 2.0 + 0.5;\n  float glanceLighting = smoothstep(0.92, 0.98, dotNormal);\n  v_color = vec3(\n    mix((0.5 - transformedNormal.z / 2.0) * regularLighting, 1.0, glanceLighting),\n    mix(0.5 * regularLighting, 1.0, glanceLighting),\n    mix((0.5 + transformedNormal.z / 2.0) * regularLighting, 1.0, glanceLighting)\n  );\n\n  v_position = a_position;\n  v_overlight = 0.9 + glanceLighting * 0.1;\n}\n`\n)\ngl.compileShader(vertexShader)\n\n</pre></code>\n// Contoh ini juga menggunakan _fragment shader_ - sebuah \n _fragment shader_ adalah program kecil yang berjalan\n di seluruh piksel dalam kanvas dan menetapkan warna bagi\n piksel.\n\n Dalam kasus ini, apabila Anda mencoba masukan lain, Anda dapat\n melihat bahwa masukan tersebut mempengaruhi pencahayaan pada\n layar, dan juga _border radius_ dari _confetti_:\n\n<code><pre>\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)\ngl.shaderSource(\n  fragmentShader,\n  `\nprecision lowp float;\nvarying vec2 v_position;\nvarying vec3 v_color;\nvarying float v_overlight;\n\nvoid main() {\n  gl_FragColor = vec4(v_color, 1.0 - smoothstep(0.8, v_overlight, length(v_position)));\n}\n`\n)\ngl.compileShader(fragmentShader)\n\n</pre></code>\n// Ambil _shader-shader_ yang telah dikompilasi dan\n tambahkan _shader-shader_ tersebut ke dalam konteks\n kanvas WebGL sehingga dapat digunakan:\n\n<code><pre>\nconst shaderProgram = gl.createProgram()\ngl.attachShader(shaderProgram, vertexShader)\ngl.attachShader(shaderProgram, fragmentShader)\ngl.linkProgram(shaderProgram)\ngl.useProgram(shaderProgram)\n\ngl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())\n\n</pre></code>\n// Kita butuh kemampuan untuk menetapkan atau memperoleh\n variabel masukan pada _shader_ dengan cara yang aman\n secara memori, sehingga urutan dan panjang dari nilai-nilai\n harus disimpan.\n<code><pre>\nconst attrs = [\n  { name: \"a_position\", length: 2, offset: 0 }, // contoh: x dan y membutuhkan dua tempat di memori\n  { name: \"a_startAngle\", length: 1, offset: 2 }, // namun, _angle_ hanya membutuhkan satu tempat di memori\n  { name: \"a_angularVelocity\", length: 1, offset: 3 },\n  { name: \"a_rotationAxisAngle\", length: 1, offset: 4 },\n  { name: \"a_particleDistance\", length: 1, offset: 5 },\n  { name: \"a_particleAngle\", length: 1, offset: 6 },\n  { name: \"a_particleY\", length: 1, offset: 7 }\n]\n\nconst STRIDE = Object.keys(attrs).length + 1\n\n</pre></code>\n// Lakukan _looping_ pada seluruh atribut yang diketahui dan buat _pointer_\n di memori supaya JavaScript dapat mengisi atribut-atribut\n tersebut pada _shader_.\n\n Berikut merupakan sedikit penjelasan mengenai API ini:\n WebGL merupakan teknologi yang berbasis pada OpenGL yang\n merupakan sebuah API dengan gaya _state-machine_. Anda\n dapat meneruskan perintah dalam urutan tertentu untuk\n mengeluarkan sesuatu pada layar.\n\n Sehingga, WebGL biasanya tidak bekerja dengan cara meneruskan\n seluruh objek pada setiap pemanggilan API WebGL, namun meneruskan\n satu objek pada sebuah fungsi, kemudian meneruskan objek lain\n pada fungsi selanjutnya. Sehingga, di sini kita memerintahkan WebGL\n untuk membuat sebuah _array vertex pointer_:\n\n<code><pre>\nfor (var i = 0; i < attrs.length; i++) {\n  const name = attrs[i].name\n  const length = attrs[i].length\n  const offset = attrs[i].offset\n  const attribLocation = gl.getAttribLocation(shaderProgram, name)\n  gl.vertexAttribPointer(attribLocation, length, gl.FLOAT, false, STRIDE * 4, offset * 4)\n  gl.enableVertexAttribArray(attribLocation)\n}\n\n</pre></code>\n// Kemudian pada baris ini, kumpulan _vertex pointer_ tersebut\n terikat pada sebuah _array_ dalam memori: \n\n<code><pre>\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer())\n\n// Tetapkan beberapa konstanta yang akan digunakan pada proses _rendering_:\n\nconst NUM_PARTICLES = 200\nconst NUM_VERTICES = 4\n\n</pre></code>\n// Coba kurangi nilai ini dan jalankan program kembali,\n nilai ini menentukan banyaknya titik yang ada\n pada setiap _confetti_ dan nilai ganjil akan\n mengacaukan _confetti_ yang ditampilkan.\n\n<code><pre>\nconst NUM_INDICES = 6\n\n// Buat _array_ masukan untuk kumpulan _vertex shader_\nconst vertices = new Float32Array(NUM_PARTICLES * STRIDE * NUM_VERTICES)\nconst indices = new Uint16Array(NUM_PARTICLES * NUM_INDICES)\n\nfor (let i = 0; i < NUM_PARTICLES; i++) {\n  const axisAngle = Math.random() * Math.PI * 2\n  const startAngle = Math.random() * Math.PI * 2\n  const groupPtr = i * STRIDE * NUM_VERTICES\n\n  const particleDistance = Math.sqrt(Math.random())\n  const particleAngle = Math.random() * Math.PI * 2\n  const particleY = Math.random() * 2.2\n  const angularVelocity = Math.random() * 2 + 1\n\n  for (let j = 0; j < 4; j++) {\n    const vertexPtr = groupPtr + j * STRIDE\n    vertices[vertexPtr + 2] = startAngle       // Sudut awal\n    vertices[vertexPtr + 3] = angularVelocity  // Kecepatan sudut\n    vertices[vertexPtr + 4] = axisAngle        // Perbedaan arah\n    vertices[vertexPtr + 5] = particleDistance // Jarak partikel yang dihitung dari titik (0, 0, 0)\n    vertices[vertexPtr + 6] = particleAngle    // Arah berdasarkan sumbu Y\n    vertices[vertexPtr + 7] = particleY        // Arah berdasarkan sumbu Y\n  }\n\n  // Koordinat\n  vertices[groupPtr] = vertices[groupPtr + STRIDE * 2] = -1\n  vertices[groupPtr + STRIDE] = vertices[groupPtr + STRIDE * 3] = +1\n  vertices[groupPtr + 1] = vertices[groupPtr + STRIDE + 1] = -1\n  vertices[groupPtr + STRIDE * 2 + 1] = vertices[groupPtr + STRIDE * 3 + 1] = +1\n\n  const indicesPtr = i * NUM_INDICES\n  const vertexPtr = i * NUM_VERTICES\n  indices[indicesPtr] = vertexPtr\n  indices[indicesPtr + 4] = indices[indicesPtr + 1] = vertexPtr + 1\n  indices[indicesPtr + 3] = indices[indicesPtr + 2] = vertexPtr + 2\n  indices[indicesPtr + 5] = vertexPtr + 3\n}\n\n// Teruskan data pada konteks WebGL\ngl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW)\n\n\nconst timeUniformLocation = gl.getUniformLocation(shaderProgram, \"u_time\")\nconst startTime = (window.performance || Date).now()\n\n// Awali warna latar dengan warna hitam\ngl.clearColor(0, 0, 0, 1)\n\n// Nyalakan _alpha channel_ pada _vertex shader_\ngl.enable(gl.BLEND)\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE)\n\n// Tetapkan ukuran konteks WebGL sebesar ukuran kanvas\ngl.viewport(0, 0, canvas.width, canvas.height)\n\n  // Buat sebuah _run-loop_ untuk menggambar seluruh _confetti_ \n  ; (function frame() {\n    gl.uniform1f(timeUniformLocation, ((window.performance || Date).now() - startTime) / 1000)\n\n    gl.clear(gl.COLOR_BUFFER_BIT)\n    gl.drawElements(\n      gl.TRIANGLES,\n      NUM_INDICES * NUM_PARTICLES,\n      gl.UNSIGNED_SHORT,\n      0\n    )\n    requestAnimationFrame(frame)\n  })()\n\n</pre></code>\n// Tambahkan elemen kanvas yang baru pada bagian\n kiri bawah dari arena bermain\n<code><pre>\ndocument.body.appendChild(canvas)\n\n</pre></code>\n// Dibuat berdasarkan JSFiddle biatan Subzey\n https://jsfiddle.net/subzey/52sowezj/\n","redirectHref":"id/play/?#example/typescript-with-webgl"}},"staticQueryHashes":[]}