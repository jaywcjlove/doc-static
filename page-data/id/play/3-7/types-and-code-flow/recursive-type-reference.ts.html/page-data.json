{"componentChunkName":"component---src-templates-play-example-tsx","path":"/id/play/3-7/types-and-code-flow/recursive-type-reference.ts.html","result":{"pageContext":{"name":"Recursive Type Reference","title":"Recursive Type Reference","lang":"id","html":"\n Memilih antara menggunakan tipe dan antarmuka adalah\n tentang memilih batasan dari fitur yang ditawarkan keduanya.\n Dengan TypeScript 3.7, salah satu batasan yang dimiliki\n oleh tipe namun tidak dimiliki antarmuka telah dihapus.\n\n Anda dapat mengetahui lebih lanjut tentang hal ini pada\n example:types-vs-interfaces\n\n Dulunya, Anda tidak dapat mengacu pada tipe yang Anda\n definiskan di dalam tipe itu sendiri. Hal ini adalah sebuah\n batasan yang tidak terdapat dalam sebuah antarmuka, dan dapat\n diatasi dengan sebuah cara tertentu.\n\n Contohnya, ekspresi di bawah ini tidak valid pada TypeScript versi 3.6:\n<code><pre>\ntype NilaiAtauArray<T> = T | Array<NilaiAtauArray<T>>;\n\n</pre></code>\n// Di bawah ini merupakan cara untuk mengatasi masalah tersebut, dengan\n menggabungkan tipe dengan sebuah antarmuka\n<code><pre>\ntype NilaiAtauArray2<T> = T | ArrayOfNilaiAtauArray<T>;\ninterface ArrayOfNilaiAtauArray<T> extends Array<NilaiAtauArray2<T>> { }\n\n</pre></code>\n// Hal tersebut memungkinkan sebuah definisi JSON yang komprehensif,\n yang dinyatakan dengan mengacu pada dirinya sendiri.\n\n<code><pre>\ntype Json = string | number | boolean | null | Json[] | { [key: string]: Json };\n\nconst contohStatusJSON: Json = {\n    tersedia: true,\n    namaPengguna: \"Jean-loup\",\n    ruangan: {\n        nama: \"Highcrest\",\n        // Tidak dapat menambahkan fungsi pada tipe Json\n        // perbarui: () => {}\n    },\n};\n\n</pre></code>\n// Ada hal lain yang dapat dipelajari dari catatan rilis TypeScript versi\n 3.7 _beta_ dan _pull request_nya.\n\n https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/\n https://github.com/microsoft/TypeScript/pull/33050\n","redirectHref":"id/play/?#example/recursive-type-reference"}},"staticQueryHashes":[]}