{"componentChunkName":"component---src-templates-blog-js","path":"/blog/2015/12/18/react-components-elements-and-instances.html","result":{"data":{"markdownRemark":{"html":"<p>许多 React 初学者对<strong>组件、其实例以及元素</strong>之间的区别感到困惑。为什么有三个不同的术语来指代屏幕上绘制的内容？</p>\n<h2 id=\"managing-the-instances\"><a href=\"#managing-the-instances\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>管理实例 </h2>\n<p>如果你不熟悉 React，那么此前你可能仅仅工作用到过组件类和实例。例如，你可能通过新建一个 class 来声明 <code class=\"gatsby-code-text\">Button</code> <em>组件</em>。当 app 运行起来以后，你可能会有若干个拥有自己属性和本地 state 的<em>实例</em>运行在屏幕上。这是传统的面向对象 UI 编程。那为什么要引入<em>元素</em>？</p>\n<p>在这些传统的 UI 模型中，需要由你来关心创建及销毁子组件们的实例。如果一个 <code class=\"gatsby-code-text\">Form</code> 组件要渲染一个 <code class=\"gatsby-code-text\">Button</code> 组件，那么它需要创建其实例并手动根据最新的信息使其保持同步。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Form</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">TraditionalObjectOrientedView</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 读取一些数据到当前视图</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> isSubmitted<span class=\"token punctuation\">,</span> buttonText <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>attrs<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isSubmitted <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>button<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 表单还未提交。创建按钮！</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>button <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Button</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        children<span class=\"token operator\">:</span> buttonText<span class=\"token punctuation\">,</span>\n        color<span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>el<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>button<span class=\"token punctuation\">.</span>el<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>button<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 按钮可见。更新其文本！</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>button<span class=\"token punctuation\">.</span>attrs<span class=\"token punctuation\">.</span>children <span class=\"token operator\">=</span> buttonText<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>button<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isSubmitted <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>button<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 表单已提交。销毁按钮！</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>el<span class=\"token punctuation\">.</span><span class=\"token function\">removeChild</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>button<span class=\"token punctuation\">.</span>el<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>button<span class=\"token punctuation\">.</span><span class=\"token function\">destroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isSubmitted <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 表达已经提交。显示成功信息！</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>message <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> text<span class=\"token operator\">:</span> <span class=\"token string\">'Success!'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>el<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">.</span>el<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>虽然这是一段伪代码，但只要你在使用一个库（比如 Backbone）编写复合界面代码的同时，恪守面向对象的思想，最终代码多少都会变成这个样子。</p>\n<p>每个组件实例都必须保持对 DOM 节点和子组件实例的引用，同时在正确的时机新建、更新、销毁它们。随着组件可能状态的平方式增长，代码行数也将增长。与此同时，父组件直接访问子组件实例也使得将来它们彼此之间更难解耦。</p>\n<p>所以 React 有何不同呢？</p>\n<h2 id=\"elements-describe-the-tree\"><a href=\"#elements-describe-the-tree\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>元素描述了树 </h2>\n<p>这正是 React 希望<em>元素</em>施展拳脚之处。<strong>元素是一个用来<em>描述</em>组件实例或 DOM 节点及其需要属性的普通对象</strong>。它只包含组件类型（比如 <code class=\"gatsby-code-text\">Button</code>），其属性（比如<code class=\"gatsby-code-text\">color</code>）以及所有其下子元素的相关信息。</p>\n<p>一个元素不是一个确切的实例。他是一种告诉 React 你<em>想要</em>在屏幕上看到什么的方法。你不能在元素上调用任何方法。它只是一个携有 <code class=\"gatsby-code-text\">type: (string | ReactClass)</code> 和 <code class=\"gatsby-code-text\">props: Object</code><sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> 字段的不可变描述对象。</p>\n<h3 id=\"dom-elements\"><a href=\"#dom-elements\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DOM 元素 </h3>\n<p>当一个元素的 <code class=\"gatsby-code-text\">type</code> 是字符串时，它代表了一个具有该标签名称的 DOM 节点。<code class=\"gatsby-code-text\">props</code> \b对应于它的属性。React 这就是 React 将呈现的内容。举个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    className<span class=\"token operator\">:</span> <span class=\"token string\">'button button-blue'</span><span class=\"token punctuation\">,</span>\n    children<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        children<span class=\"token operator\">:</span> <span class=\"token string\">'OK!'</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这个元素只不过是一种将下面这段 HTML 表示成一个普通对象的方法。</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"gatsby-code-html\"><code class=\"gatsby-code-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">'</span>button button-blue<span class=\"token punctuation\">'</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>b</span><span class=\"token punctuation\">></span></span>\n    OK!\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>b</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>注意元素是如何嵌套的。按照惯例，当我们要创建一棵 element tree 时，我们指定一或多个子元素作为其 <code class=\"gatsby-code-text\">children</code> 成员。</p>\n<p>重要的是子元素和父元素<em>仅仅作为描述而不是真正的实例</em>。当你创建了它们，它们并不代表任何屏幕上的东西。你可以创建、丢弃它们，不必担心什么。</p>\n<p>React 元素易于遍历，无需解析。此外它们比起真实的 DOM 元素更轻——它们只是对象！</p>\n<h3 id=\"component-elements\"><a href=\"#component-elements\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>组件元素 </h3>\n<p>然而，元素的 <code class=\"gatsby-code-text\">type</code> 究竟是一个函数还是一个类则视 React 组件而定：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> Button<span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    color<span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span><span class=\"token punctuation\">,</span>\n    children<span class=\"token operator\">:</span> <span class=\"token string\">'OK!'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这是 React 的核心思想。</p>\n<p><strong>一个用于描述组件的元素也是一个元素，就像一个用于描述 DOM 节点的元素一样。它们可以彼此嵌套，互相混合。</strong></p>\n<p>该特性让你可以将 <code class=\"gatsby-code-text\">DangerButton</code> 组件定义为一个被指定 <code class=\"gatsby-code-text\">color</code> 值的 <code class=\"gatsby-code-text\">Button</code>，而你完全不必关心 <code class=\"gatsby-code-text\">Button</code> 是渲染成一个 DOM <code class=\"gatsby-code-text\">&lt;button></code>、<code class=\"gatsby-code-text\">&lt;div></code> 或其他东西。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">DangerButton</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> children <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> Button<span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    color<span class=\"token operator\">:</span> <span class=\"token string\">'red'</span><span class=\"token punctuation\">,</span>\n    children<span class=\"token operator\">:</span> children\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>你可以混合和匹配 DOM 及组件元素在一个单独的 element tree 中：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">DeleteAccount</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'div'</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    children<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'p'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        children<span class=\"token operator\">:</span> <span class=\"token string\">'Are you sure?'</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> DangerButton<span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        children<span class=\"token operator\">:</span> <span class=\"token string\">'Yep'</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> Button<span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        color<span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span><span class=\"token punctuation\">,</span>\n        children<span class=\"token operator\">:</span> <span class=\"token string\">'Cancel'</span>\n      <span class=\"token punctuation\">}</span>\n   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>或者，如果你喜欢 JSX：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">DeleteAccount</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Are you sure?</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">DangerButton</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Yep</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">DangerButton</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Button</span></span> <span class=\"token attr-name\">color</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">'</span>blue<span class=\"token punctuation\">'</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Cancel</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Button</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这种混合和匹配有助于组件彼此分离，因为它们可以仅仅通过组合来表示 <em>is-a</em> 和 <em>has-a</em> 的关系:</p>\n<ul>\n<li><code class=\"gatsby-code-text\">Button</code> 是一个被指定部分属性的 DOM <code class=\"gatsby-code-text\">&lt;button></code>。</li>\n<li><code class=\"gatsby-code-text\">DangerButton</code> 是一个被指定部分属性的 <code class=\"gatsby-code-text\">Button</code>。</li>\n<li><code class=\"gatsby-code-text\">DeleteAccount</code> 在一个 <code class=\"gatsby-code-text\">&lt;div></code>中包含一个 <code class=\"gatsby-code-text\">Button</code> 和一个 <code class=\"gatsby-code-text\">DangerButton</code> 。</li>\n</ul>\n<h3 id=\"components-encapsulate-element-trees\"><a href=\"#components-encapsulate-element-trees\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>组件封装 Element Trees </h3>\n<p>当 React 遇到一个带有函数或类 <code class=\"gatsby-code-text\">type</code> 的元素时，它知道要问<em>那个</em>组件它要呈现什么元素，并给出相应的 <code class=\"gatsby-code-text\">props</code>。</p>\n<p>当它遇到这个元素:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> Button<span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    color<span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span><span class=\"token punctuation\">,</span>\n    children<span class=\"token operator\">:</span> <span class=\"token string\">'OK!'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>React 将问 <code class=\"gatsby-code-text\">Button</code> 它将渲染成什么。<code class=\"gatsby-code-text\">Button</code> 将会返回这个元素：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    className<span class=\"token operator\">:</span> <span class=\"token string\">'button button-blue'</span><span class=\"token punctuation\">,</span>\n    children<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        children<span class=\"token operator\">:</span> <span class=\"token string\">'OK!'</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>React 将重复这个过程直到它知道了页面上每一个组件之下的 DOM 标签元素。</p>\n<p>React 就像一个孩子。在搞清楚这个世界的每一件小事之前，它都要向每一个你所解释的 ”X是Y“ 询问 ”Y是什么“。</p>\n<p>还记得之前 <code class=\"gatsby-code-text\">Form</code> 的例子吗？它可以用 React 编写如下<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Form</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> isSubmitted<span class=\"token punctuation\">,</span> buttonText <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isSubmitted<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Form 提交了！返回一个 message 元素。</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> Message<span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        text<span class=\"token operator\">:</span> <span class=\"token string\">'Success!'</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// Form 还在继续显示！返回一个 button 元素。</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    type<span class=\"token operator\">:</span> Button<span class=\"token punctuation\">,</span>\n    props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      children<span class=\"token operator\">:</span> buttonText<span class=\"token punctuation\">,</span>\n      color<span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这就是它！对于一个 React 组件，props 就是输入，element tree 就是输出。</p>\n<p><strong>返回的 element tree 可以包含描述 DOM 节点的元素，描述其他组件的元素。这使你可以组成 UI 的独立部分，而无需依赖其内部 DOM 结构。</strong></p>\n<p>我们让 React 创建，更新，销毁实例。我们通过组件返回的元素<em>描述</em>它们，而 React 负责管理这些实例。</p>\n<h3 id=\"components-can-be-classes-or-functions\"><a href=\"#components-can-be-classes-or-functions\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>组件可以是类或函数 </h3>\n<p>在之前的代码中，<code class=\"gatsby-code-text\">Form</code>, <code class=\"gatsby-code-text\">Message</code> 和 <code class=\"gatsby-code-text\">Button</code> 是 React 组件。它们既可以像此前那样被写作函数，也可以通过<code class=\"gatsby-code-text\">React.Component</code>写作类。这三种声明组件的方式几乎是等效的：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// 1) 作为一个带 props 的函数</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Button</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> children<span class=\"token punctuation\">,</span> color <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    className<span class=\"token operator\">:</span> <span class=\"token string\">'button button-'</span> <span class=\"token operator\">+</span> color<span class=\"token punctuation\">,</span>\n    children<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        children<span class=\"token operator\">:</span> children\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 2) 使用 React.createClass() 工厂</span>\n<span class=\"token keyword\">const</span> Button <span class=\"token operator\">=</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">createClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> children<span class=\"token punctuation\">,</span> color <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        className<span class=\"token operator\">:</span> <span class=\"token string\">'button button-'</span> <span class=\"token operator\">+</span> color<span class=\"token punctuation\">,</span>\n        children<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          type<span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span>\n          props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            children<span class=\"token operator\">:</span> children\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 3) 作为从 React.Component 继承的ES6类</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Button</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> children<span class=\"token punctuation\">,</span> color <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        className<span class=\"token operator\">:</span> <span class=\"token string\">'button button-'</span> <span class=\"token operator\">+</span> color<span class=\"token punctuation\">,</span>\n        children<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n          type<span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span>\n          props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n            children<span class=\"token operator\">:</span> children\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>当一个组件用类定义时，它会比一个函数组件要强大一点。当创建或销毁相应的 DOM 节点时，它能存储一些本地状态并执行自定义逻辑。</p>\n<p>函数组件功能更弱，但它更简单。它就像一个只有 <code class=\"gatsby-code-text\">render()</code> 方法的 class 组件。除非你需要只有从类组件那才能得到的功能，否则我们建议你用函数组件。</p>\n<p><strong>然而，不论函数或类，根本上来说它们都是 React 组件。它们将 props 作为输入，返回元素作为输出。</strong></p>\n<h3 id=\"top-down-reconciliation\"><a href=\"#top-down-reconciliation\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>自上而下的的协调 </h3>\n<p>当你调用：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\">ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> Form<span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    isSubmitted<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    buttonText<span class=\"token operator\">:</span> <span class=\"token string\">'OK!'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>React 先将那些 <code class=\"gatsby-code-text\">props</code> 传入 <code class=\"gatsby-code-text\">Form</code> 组件，随后等待返回 element tree。它将通过更简单的”基元“逐步完善对组件树的理解：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// React: 你告诉了我这...</span>\n<span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> Form<span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    isSubmitted<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    buttonText<span class=\"token operator\">:</span> <span class=\"token string\">'OK!'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// React: ...然后 Form 告诉了我这...</span>\n<span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> Button<span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    children<span class=\"token operator\">:</span> <span class=\"token string\">'OK!'</span><span class=\"token punctuation\">,</span>\n    color<span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// React: ...然后 Button 告诉了我这！我觉得我做完了。</span>\n<span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    className<span class=\"token operator\">:</span> <span class=\"token string\">'button button-blue'</span><span class=\"token punctuation\">,</span>\n    children<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        children<span class=\"token operator\">:</span> <span class=\"token string\">'OK!'</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这是 React 称之为<a href=\"/docs/reconciliation.html\">协调</a>过程的一部分。它开始于你调用 <a href=\"/docs/top-level-api.html#reactdom.render\"><code class=\"gatsby-code-text\">ReactDOM.render()</code></a> 或 <a href=\"/docs/component-api.html#setstate\"><code class=\"gatsby-code-text\">setState()</code></a>。在协调结束的时候，React 知道了结果的 DOM 树，然后一个渲染器像 <code class=\"gatsby-code-text\">react-dom</code> 或 <code class=\"gatsby-code-text\">react-native</code> 尽可能使用最少的变化来更新 DOM 节点（或在 React Native 中的特定平台视图）。</p>\n<p>这种逐步改善过程也是为什么 React 应用易于优化的原因。如果你组件树的一部分因为变得太大导致 React 无法高效的访问，你可以告诉它<a href=\"/docs/advanced-performance.html\">如果相关props没有变化，跳过这个”改善“并且只比对树的某些部分</a>。如果 props 是不可变的，那么计算其是否发生变化是非常快的，因此 React 和不可变性可以很好地协同工作，并且可以以最小的努力提供出色的优化。</p>\n<p>你可能已经注意到，此博客文章讨论了很多组件和元素的内容，没有提到太多实例。事实上，与绝大多数面向对象 UI 框架相比，实例在 React 中的重要性要小很多。</p>\n<p>只有使用类声明的组件有实例，而且你永远不会直接创建它们：React 为你做了那些。尽管存在<a href=\"/docs/more-about-refs.html\">父组件实例访问子组件实例的机制</a>，但只要不是万不得已（譬如为某个字段设置聚焦），我么通常都应该避免这种操作。</p>\n<p>React 负责为每个类组件创建一个实例，所以你可以用面向对象的方法写一个带有方法和本地状态的组件。但除此之外，在 React 的编程模型中实例并不十分重要，而且这些都由它自己管理。</p>\n<h2 id=\"summary\"><a href=\"#summary\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结 </h2>\n<h2 id=\"summary\"><a href=\"#summary\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary </h2>\n<p>一个<em>元素</em>是一个普通的对象。它被用来描述什么需要在屏幕上显示，根据 DOM 节点还是其他组件。元素可以在它们的 props 里包含其他元素。创建一个 React 元素很廉价。一旦一个元素被创建了，它就不再改变。</p>\n<p>一个<em>组件</em>可以通过多种不同的方式声明。它可以是一个带有 <code class=\"gatsby-code-text\">render()</code> 方法的类。或者，更简单些，它可以被定义成一个函数。不论何种方式，它都需要 props 作为输入，返回一个 element tree 作为输出。</p>\n<p>当一个组件收到一些 props 作为输入，其必是因为某个父组件返回了一个带有它 <code class=\"gatsby-code-text\">type</code> 和这些 props 的元素。这就是为什么在 React 中人们说 props 是单向流：从父级到子级。</p>\n<p><em>实例</em>是你在编写组件类中称为<code class=\"gatsby-code-text\">this</code>的东西。它在<a href=\"/docs/component-api.html\">保存本地状态和响应生命周期事件</a>上很有用。</p>\n<p>函数组件根本没有实例。类组件才有实例，但你永远不需要去直接创建组件实例——React 会负责这些。</p>\n<p>最后，要新建一个元素，使用<a href=\"/docs/top-level-api.html#react.createelement\"><code class=\"gatsby-code-text\">React.createElement()</code></a>， <a href=\"/docs/jsx-in-depth.html\">JSX</a>, 或 <a href=\"/docs/top-level-api.html#react.createfactory\">element factory helper</a>。不要在真实代码中将元素写作普通对象——知道它们是处于底层的普通对象足矣。</p>\n<h2 id=\"further-reading\"><a href=\"#further-reading\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>拓展阅读 </h2>\n<ul>\n<li><a href=\"/blog/2014/10/14/introducing-react-elements.html\">Introducing React Elements</a></li>\n<li><a href=\"/blog/2015/02/24/streamlining-react-elements.html\">Streamlining React Elements</a></li>\n<li><a href=\"/docs/glossary.html\">React (Virtual) DOM Terminology</a></li>\n</ul>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>出于<a href=\"https://github.com/facebook/react/pull/4832\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">安全原因</a>，所有 React 元素都需要在对象上声明一个额外的 <code class=\"gatsby-code-text\">$$typeof: Symbol.for('react.element')</code> 字段。在上文的示例中将其省略了。为了使你理解底层发生了什么，这篇博客为元素使用了内联对象，但无论是为元素添加 <code class=\"gatsby-code-text\">$$typeof</code> 还是更改代码使用 <code class=\"gatsby-code-text\">React.createElement()</code> 或 JSX，代码都不会如预期运行。</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","excerpt":"许多 React 初学者对组件、其实例以及元素之间的区别感到困惑。为什么有三个不同的术语来指代屏幕上绘制的内容？ 管理实例  如果你不熟悉 React，那么此前你可能仅仅工作用到过组件类和实例。例如，你可能通过新建一个 class 来声明  组件。当 app 运行起来以后，你可能会有若干个拥有自己属性和本地 state 的实例运行在屏幕上。这是传统的面向对象 UI 编程。那为什么要引入元素？ 在这些传统的 UI 模型中，需要由你来关心创建及销毁子组件们的实例。如果一个  组件要渲染一个  组件，那么它需要创建其实例并手动根据最新的信息使其保持同步。 虽然这是一段伪代码，但只要你在使用一个库（比如 Backbone）编写复合界面代码的同时，恪守面向对象的思想，最终代码多少都会变成这个样子。 每个组件实例都必须保持对 DOM 节点和子组件实例的引用，同时在正确的时机新建、更新、销毁它们。随着组件可能状态的平方式增长，代码行数也将增长。与此同时，父组件直接访问子组件实例也使得将来它们彼此之间更难解耦。 所以 React 有何不同呢？ 元素描述了树  这正是 React…","frontmatter":{"title":"React 组件，元素和实例","next":null,"prev":null,"author":[{"frontmatter":{"name":"Dan Abramov","url":"https://twitter.com/dan_abramov"}}]},"fields":{"date":"December 18, 2015","path":"content/blog/2015-12-18-react-components-elements-and-instances.md","slug":"/blog/2015/12/18/react-components-elements-and-instances.html"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"title":"React 18 发布计划"},"fields":{"slug":"/blog/2021/06/08/the-plan-for-react-18.html"}}},{"node":{"frontmatter":{"title":"介绍 Zero-Bundle-Size 的 React 服务端组件"},"fields":{"slug":"/blog/2020/12/21/data-fetching-with-react-server-components.html"}}},{"node":{"frontmatter":{"title":"React v17.0"},"fields":{"slug":"/blog/2020/10/20/react-v17.html"}}},{"node":{"frontmatter":{"title":"介绍全新的 JSX 转换"},"fields":{"slug":"/blog/2020/09/22/introducing-the-new-jsx-transform.html"}}},{"node":{"frontmatter":{"title":"React v17.0 RC 版本发布：没有新特性"},"fields":{"slug":"/blog/2020/08/10/react-v17-rc.html"}}},{"node":{"frontmatter":{"title":"React v16.13.0"},"fields":{"slug":"/blog/2020/02/26/react-v16.13.0.html"}}},{"node":{"frontmatter":{"title":"Building Great User Experiences with Concurrent Mode and Suspense"},"fields":{"slug":"/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html"}}},{"node":{"frontmatter":{"title":"使用 React 预发布版为新功能打基础"},"fields":{"slug":"/blog/2019/10/22/react-release-channels.html"}}},{"node":{"frontmatter":{"title":"全新的 React DevTools 简介"},"fields":{"slug":"/blog/2019/08/15/new-react-devtools.html"}}},{"node":{"frontmatter":{"title":"React v16.9.0 发布及 Roadmap 最新进展"},"fields":{"slug":"/blog/2019/08/08/react-v16.9.0.html"}}}]}},"pageContext":{"slug":"/blog/2015/12/18/react-components-elements-and-instances.html"}},"staticQueryHashes":[]}