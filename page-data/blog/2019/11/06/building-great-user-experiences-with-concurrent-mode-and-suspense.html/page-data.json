{"componentChunkName":"component---src-templates-blog-js","path":"/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html","result":{"data":{"markdownRemark":{"html":"<p>At React Conf 2019 we announced an <a href=\"/docs/concurrent-mode-adoption.html#installation\">experimental release</a> of React that supports Concurrent Mode and Suspense. In this post we’ll introduce best practices for using them that we’ve identified through the process of building <a href=\"https://twitter.com/facebook/status/1123322299418124289\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the new facebook.com</a>.</p>\n<blockquote>\n<p>This post will be most relevant to people working on <em>data fetching libraries</em> for React. </p>\n<p>It shows how to best integrate them with Concurrent Mode and Suspense. The patterns introduced here are based on <a href=\"https://relay.dev/docs/en/experimental/step-by-step\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Relay</a> — our library for building data-driven UIs with GraphQL. However, the ideas in this post <strong>apply to other GraphQL clients as well as libraries using REST</strong> or other approaches.</p>\n</blockquote>\n<p>This post is <strong>aimed at library authors</strong>. If you’re primarily an application developer, you might still find some interesting ideas here, but don’t feel like you have to read it in its entirety.</p>\n<h2 id=\"talk-videos\"><a href=\"#talk-videos\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Talk Videos </h2>\n<p>If you prefer to watch videos, some of the ideas from this blog post have been referenced in several React Conf 2019 presentations:</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=Tl0S7QkxFE4&#x26;list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh&#x26;index=15&#x26;t=0s\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Data Fetching with Suspense in Relay</a> by <a href=\"https://twitter.com/en_JS\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Joe Savona</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=KT3XKDBZW7M&#x26;list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh&#x26;index=4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Building the New Facebook with React and Relay</a> by <a href=\"https://twitter.com/catchingash\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Ashley Watkins</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=uXEEL9mrkAQ&#x26;list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh&#x26;index=2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">React Conf Keynote</a> by <a href=\"https://twitter.com/yuzhiz\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Yuzhi Zheng</a></li>\n</ul>\n<p>This post presents a deeper dive on implementing a data fetching library with Suspense.</p>\n<h2 id=\"putting-user-experience-first\"><a href=\"#putting-user-experience-first\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Putting User Experience First </h2>\n<p>The React team and community has long placed a deserved emphasis on developer experience: ensuring that React has good error messages, focusing on components as a way to reason locally about app behavior, crafting APIs that are predictable and encourage correct usage by design, etc. But we haven’t provided enough guidance on the best ways to achieve a great <em>user</em> experience in large apps.</p>\n<p>For example, the React team has focused on <em>framework</em> performance and providing tools for developers to debug and tune application performance (e.g. <code class=\"gatsby-code-text\">React.memo</code>). But we haven’t been as opinionated about the <em>high-level patterns</em> that make the difference between fast, fluid apps and slow, janky ones. We always want to ensure that React remains approachable to new users and supports a variety of use-cases — not every app has to be “blazing” fast. But as a community we can and should aim high. <strong>We should make it as easy as possible to build apps that start fast and stay fast,</strong> even as they grow in complexity, for users on varying devices and networks around the world. </p>\n<p><a href=\"/docs/concurrent-mode-intro.html\">Concurrent Mode</a> and <a href=\"/docs/concurrent-mode-suspense.html\">Suspense</a> are experimental features that can help developers achieve this goal. We first introduced them at <a href=\"/blog/2018/03/01/sneak-peek-beyond-react-16.html\">JSConf Iceland in 2018</a>, intentionally sharing details very early to give the community time to digest the new concepts and to set the stage for subsequent changes. Since then we’ve completed related work, such as the new Context API and the introduction of Hooks, which are designed in part to help developers naturally write code that is more compatible with Concurrent Mode. But we didn’t want to implement these features and release them without validating that they work. So over the past year, the React, Relay, web infrastructure, and product teams at Facebook have all collaborated closely to build a new version of facebook.com that deeply integrates Concurrent Mode and Suspense to create an experience with a more fluid and app-like feel. </p>\n<p>Thanks to this project, we’re more confident than ever that Concurrent Mode and Suspense can make it easier to deliver great, <em>fast</em> user experiences. But doing so requires rethinking how we approach loading code and data for our apps. Effectively all of the data-fetching on the new facebook.com is powered by <a href=\"https://relay.dev/docs/en/experimental/step-by-step\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Relay Hooks</a> — new Hooks-based Relay APIs that integrate with Concurrent Mode and Suspense out of the box.</p>\n<p>Relay Hooks — and GraphQL — won’t be for everyone, and that’s ok! Through our work on these APIs we’ve identified a set of more general patterns for using Suspense. <strong>Even if Relay isn’t the right fit for you, we think the key patterns we’ve introduced with Relay Hooks can be adapted to other frameworks.</strong></p>\n<h2 id=\"best-practices-for-suspense\"><a href=\"#best-practices-for-suspense\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Best Practices for Suspense </h2>\n<p>It’s tempting to focus only on the total startup time for an app — but it turns out that users’ perception of performance is determined by more than the absolute loading time. For example, when comparing two apps with the same absolute startup time, our research shows that users will generally perceive the one with fewer intermediate loading states and fewer layout changes as having loaded faster. Suspense is a powerful tool for carefully orchestrating an elegant loading sequence with a few, well-defined states that progressively reveal content. But improving perceived performance only goes so far — our apps still shouldn’t take forever to fetch all of their code, data, images, and other assets.</p>\n<p>The traditional approach to loading data in React apps involves what we refer to as <a href=\"/docs/concurrent-mode-suspense.html#approach-1-fetch-on-render-not-using-suspense\">“fetch-on-render”</a>. First we render a component with a spinner, then fetch data on mount (<code class=\"gatsby-code-text\">componentDidMount</code> or <code class=\"gatsby-code-text\">useEffect</code>), and finally update to render the resulting data. It’s certainly <em>possible</em> to use this pattern with Suspense: instead of initially rendering a placeholder itself, a component can “suspend” — indicate to React that it isn’t ready yet. This will tell React to find the nearest ancestor <code class=\"gatsby-code-text\">&lt;Suspense fallback={&lt;Placeholder/>}></code>, and render its fallback instead. If you watched earlier Suspense demos this example may feel familiar — it’s how we originally imagined using Suspense for data-fetching. </p>\n<p>It turns out that this approach has some limitations. Consider a page that shows a social media post by a user, along with comments on that post. That might be structured as a <code class=\"gatsby-code-text\">&lt;Post></code> component that renders both the post body and a <code class=\"gatsby-code-text\">&lt;CommentList></code> to show the comments. Using the fetch-on-render approach described above to implement this could cause sequential round trips (sometimes referred to as a “waterfall”). First the data for the <code class=\"gatsby-code-text\">&lt;Post></code> component would be fetched and then the data for <code class=\"gatsby-code-text\">&lt;CommentList></code> would be fetched, increasing the time it takes to show the full page.</p>\n<p>There’s also another often-overlooked downside to this approach. If <code class=\"gatsby-code-text\">&lt;Post></code> eagerly requires (or imports) the <code class=\"gatsby-code-text\">&lt;CommentList></code> component, our app will have to wait to show the post <em>body</em> while the code for the <em>comments</em> is downloading. We could lazily load <code class=\"gatsby-code-text\">&lt;CommentList></code>, but then that would delay fetching comments data and increase the time to show the full page. How do we resolve this problem without compromising on the user experience?</p>\n<h2 id=\"render-as-you-fetch\"><a href=\"#render-as-you-fetch\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Render As You Fetch </h2>\n<p>The fetch-on-render approach is widely used by React apps today and can certainly be used to create great apps. But can we do even better? Let’s step back and consider our goal.</p>\n<p>In the above <code class=\"gatsby-code-text\">&lt;Post></code> example, we’d ideally show the more important content — the post body — as early as possible, <em>without</em> negatively impacting the time to show the full page (including comments). Let’s consider the key constraints on any solution and look at how we can achieve them:</p>\n<ul>\n<li>Showing the more important content (the post body) as early as possible means that we need to load the code and data for the view incrementally. We <em>don’t want to block showing the post body</em> on the code for <code class=\"gatsby-code-text\">&lt;CommentList></code> being downloaded, for example.</li>\n<li>At the same time we don’t want to increase the time to show the full page including comments. So we need to <em>start loading the code and data for the comments</em> as soon as possible, ideally <em>in parallel</em> with loading the post body.</li>\n</ul>\n<p>This might sound difficult to achieve — but these constraints are actually incredibly helpful. They rule out a large number of approaches and spell out a solution for us. This brings us to the key patterns we’ve implemented in Relay Hooks, and that can be adapted to other data-fetching libraries. We’ll look at each one in turn and then see how they add up to achieve our goal of fast, delightful loading experiences:</p>\n<ol>\n<li>Parallel data and view trees</li>\n<li>Fetch in event handlers</li>\n<li>Load data incrementally</li>\n<li>Treat code like data</li>\n</ol>\n<h3 id=\"parallel-data-and-view-trees\"><a href=\"#parallel-data-and-view-trees\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parallel Data and View Trees </h3>\n<p>One of the most appealing things about the fetch-on-render pattern is that it colocates <em>what</em> data a component needs with <em>how</em> to render that data. This colocation is great — an example of how it makes sense to group code by concerns and not by technologies. All the issues we saw above were due to <em>when</em> we fetch data in this approach: upon rendering. We need to be able to fetch data <em>before</em> we’ve rendered the component. The only way to achieve that is by extracting the data dependencies into parallel data and view trees. </p>\n<p>Here’s how that works in Relay Hooks. Continuing our example of a social media post with body and comments, here’s how we might define it with Relay Hooks:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// Post.js</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Post</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Given a reference to some post - `props.post` - *what* data</span>\n  <span class=\"token comment\">// do we need about that post?</span>\n  <span class=\"token keyword\">const</span> postData <span class=\"token operator\">=</span> <span class=\"token function\">useFragment</span><span class=\"token punctuation\">(</span>graphql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n    fragment PostData on Post @refetchable(queryName: \"PostQuery\") {\n      author\n      title\n      # ...  more fields ...\n    }\n  </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> props<span class=\"token punctuation\">.</span>post<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// Now that we have the data, how do we render it?</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>postData<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">by </span><span class=\"token punctuation\">{</span>postData<span class=\"token punctuation\">.</span>author<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span><span class=\"token comment\">/* more fields  */</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Although the GraphQL is written within the component, Relay has a build step (Relay Compiler) that extracts these data-dependencies into separate files and aggregates the GraphQL for each view into a single query. So we get the benefit of colocating concerns, while at runtime having parallel data and view trees. Other frameworks could achieve a similar effect by allowing developers to define data-fetching logic in a sibling file (maybe <code class=\"gatsby-code-text\">Post.data.js</code>), or perhaps integrate with a bundler to allow defining data dependencies with UI code and automatically extracting it, similar to Relay Compiler.</p>\n<p>The key is that regardless of the technology we’re using to load our data — GraphQL, REST, etc — we can separate <em>what</em> data to load from how and when to actually load it. But once we do that, how and when <em>do</em> we fetch our data?</p>\n<h3 id=\"fetch-in-event-handlers\"><a href=\"#fetch-in-event-handlers\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fetch in Event Handlers </h3>\n<p>Imagine that we’re about to navigate from a list of a user’s posts to the page for a specific post. We’ll need to download the code for that page — <code class=\"gatsby-code-text\">Post.js</code> — and also fetch its data.</p>\n<p>Waiting until we render the component has problems as we saw above. The key is to start fetching code and data for a new view <em>in the same event handler that triggers showing that view</em>. We can either fetch the data within our router — if our router supports preloading data for routes — or in the click event on the link that triggered the navigation. It turns out that the React Router folks are already hard at work on building APIs to support preloading data for routes. But other routing frameworks can implement this idea too. </p>\n<p>Conceptually, we want every route definition to include two things: what component to render and what data to preload, as a function of the route/url params. Here’s what such a route definition <em>might</em> look like. This example is loosely inspired by React Router’s route definitions and is <em>primarily intended to demonstrate the concept, not a specific API</em>:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// PostRoute.js (GraphQL version)</span>\n\n<span class=\"token comment\">// Relay generated query for loading Post data</span>\n<span class=\"token keyword\">import</span> PostQuery <span class=\"token keyword\">from</span> <span class=\"token string\">'./__generated__/PostQuery.graphql'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> PostRoute <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// a matching expression for which paths to handle</span>\n  path<span class=\"token operator\">:</span> <span class=\"token string\">'/post/:id'</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// what component to render for this route</span>\n  component<span class=\"token operator\">:</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">lazy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./Post'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// data to load for this route, as function of the route</span>\n  <span class=\"token comment\">// parameters</span>\n  <span class=\"token function-variable function\">prepare</span><span class=\"token operator\">:</span> <span class=\"token parameter\">routeParams</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Relay extracts queries from components, allowing us to reference</span>\n    <span class=\"token comment\">// the data dependencies -- data tree -- from outside.</span>\n    <span class=\"token keyword\">const</span> postData <span class=\"token operator\">=</span> <span class=\"token function\">preloadQuery</span><span class=\"token punctuation\">(</span>PostQuery<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      postId<span class=\"token operator\">:</span> routeParams<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> postData <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> PostRoute<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Given such a definition, a router can:</p>\n<ul>\n<li>Match a URL to a route definition.</li>\n<li>Call the <code class=\"gatsby-code-text\">prepare()</code> function to start loading that route’s data. Note that <code class=\"gatsby-code-text\">prepare()</code> is synchronous — <em>we don’t wait for the data to be ready</em>, since we want to start rendering more important parts of the view (like the post body) as quickly as possible.</li>\n<li>Pass the preloaded data to the component. If the component is ready — the <code class=\"gatsby-code-text\">React.lazy</code> dynamic import has completed — the component will render and try to access its data. If not, <code class=\"gatsby-code-text\">React.lazy</code> will suspend until the code is ready.</li>\n</ul>\n<p>This approach can be generalized to other data-fetching solutions. An app that uses REST might define a route like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// PostRoute.js (REST version)</span>\n\n<span class=\"token comment\">// Manually written logic for loading the data for the component</span>\n<span class=\"token keyword\">import</span> PostData <span class=\"token keyword\">from</span> <span class=\"token string\">'./Post.data'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> PostRoute <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// a matching expression for which paths to handle</span>\n  path<span class=\"token operator\">:</span> <span class=\"token string\">'/post/:id'</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// what component to render for this route</span>\n  component<span class=\"token operator\">:</span> React<span class=\"token punctuation\">.</span><span class=\"token function\">lazy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./Post'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// data to load for this route, as function of the route</span>\n  <span class=\"token comment\">// parameters</span>\n  <span class=\"token function-variable function\">prepare</span><span class=\"token operator\">:</span> <span class=\"token parameter\">routeParams</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> postData <span class=\"token operator\">=</span> <span class=\"token function\">preloadRestEndpoint</span><span class=\"token punctuation\">(</span>\n      PostData<span class=\"token punctuation\">.</span>endpointUrl<span class=\"token punctuation\">,</span> \n      <span class=\"token punctuation\">{</span>\n        postId<span class=\"token operator\">:</span> routeParams<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span> postData <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> PostRoute<span class=\"token punctuation\">;</span></code></pre></div>\n<p>This same approach can be employed not just for routing, but in other places where we show content lazily or based on user interaction. For example, a tab component could eagerly load the first tab’s code and data, and then use the same pattern as above to load the code and data for other tabs in the tab-change event handler. A component that displays a modal could preload the code and data for the modal in the click handler that triggers opening the modal, and so on. </p>\n<p>Once we’ve implemented the ability to start loading code and data for a view independently, we have the option to go one step further. Consider a <code class=\"gatsby-code-text\">&lt;Link to={path} /></code> component that links to a route. If the user hovers over that link, there’s a reasonable chance they’ll click it. And if they press the mouse down, there’s an even better chance that they’ll complete the click. If we can load code and data for a view <em>after</em> the user clicks, we can also start that work <em>before</em> they click, getting a head start on preparing the view.</p>\n<p>Best of all, we can centralize that logic in a few key places — a router or core UI components — and get any performance benefits automatically throughout our app. Of course preloading isn’t always beneficial. It’s something an application would tune based on the user’s device or network speed to avoid eating up user’s data plans. But the pattern here makes it easier to centralize the implementation of preloading and the decision of whether to enable it or not.</p>\n<h3 id=\"load-data-incrementally\"><a href=\"#load-data-incrementally\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Load Data Incrementally </h3>\n<p>The above patterns — parallel data/view trees and fetching in event handlers — let us start loading all the data for a view earlier. But we still want to be able to show more important parts of the view without waiting for <em>all</em> of our data. At Facebook we’ve implemented support for this in GraphQL and Relay in the form of some new GraphQL directives (annotations that affect how/when data is delivered, but not what data). These new directives, called <code class=\"gatsby-code-text\">@defer</code> and <code class=\"gatsby-code-text\">@stream</code>, allow us to retrieve data incrementally. For example, consider our <code class=\"gatsby-code-text\">&lt;Post></code> component from above. We want to show the body without waiting for the comments to be ready. We can achieve this with <code class=\"gatsby-code-text\">@defer</code> and <code class=\"gatsby-code-text\">&lt;Suspense></code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// Post.js</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Post</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> postData <span class=\"token operator\">=</span> <span class=\"token function\">useFragment</span><span class=\"token punctuation\">(</span>graphql<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n    fragment PostData on Post {\n      author\n      title\n\n      # fetch data for the comments, but don't block on it being ready\n      ...CommentList @defer\n    }\n  </span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span> props<span class=\"token punctuation\">.</span>post<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>postData<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">by </span><span class=\"token punctuation\">{</span>postData<span class=\"token punctuation\">.</span>author<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span><span class=\"token comment\">/* @defer pairs naturally with &lt;Suspense> to make the UI non-blocking too */</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Suspense</span></span> <span class=\"token attr-name\">fallback</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Spinner</span></span><span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">CommentList</span></span> <span class=\"token attr-name\">post</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>postData<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Suspense</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Here, our GraphQL server will stream back the results, first returning the <code class=\"gatsby-code-text\">author</code> and <code class=\"gatsby-code-text\">title</code> fields and then returning the comment data when it’s ready. We wrap <code class=\"gatsby-code-text\">&lt;CommentList></code> in a <code class=\"gatsby-code-text\">&lt;Suspense></code> boundary so that we can render the post body before <code class=\"gatsby-code-text\">&lt;CommentList></code> and its data are ready. This same pattern can be applied to other frameworks as well. For example, apps that call a REST API might make parallel requests to fetch the body and comments data for a post to avoid blocking on all the data being ready.</p>\n<h3 id=\"treat-code-like-data\"><a href=\"#treat-code-like-data\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Treat Code Like Data </h3>\n<p>But there’s one thing that’s still missing. We’ve shown how to preload <em>data</em> for a route — but what about code? The example above cheated a bit and used <code class=\"gatsby-code-text\">React.lazy</code>. However, <code class=\"gatsby-code-text\">React.lazy</code> is, as the name implies, <em>lazy</em>. It won’t start downloading code until the lazy component is actually rendered — it’s “fetch-on-render” for code!</p>\n<p>To solve this, the React team is considering APIs that would allow bundle splitting and eager preloading for code as well. That would allow a user to pass some form of lazy component to a router, and for the router to trigger loading the code alongside its data as early as possible.</p>\n<h2 id=\"putting-it-all-together\"><a href=\"#putting-it-all-together\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Putting It All Together </h2>\n<p>To recap, achieving a great loading experience means that we need to <strong>start loading code and data as early as possible, but without waiting for all of it to be ready</strong>. Parallel data and view trees allow us to load the data for a view in parallel with loading the view (code) itself. Fetching in an event handler means we can start loading data as early as possible, and even optimistically preload a view when we have enough confidence that a user will navigate to it. Loading data incrementally allows us to load important data earlier without delaying the fetching of less important data. And treating code as data — and preloading it with similar APIs — allows us to load it earlier too.</p>\n<h2 id=\"using-these-patterns\"><a href=\"#using-these-patterns\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using These Patterns </h2>\n<p>These patterns aren’t just ideas — we’ve implemented them in Relay Hooks and are using them in production throughout the new facebook.com (which is currently in beta testing). If you’re interested in using or learning more about these patterns, here are some resources:</p>\n<ul>\n<li>The <a href=\"/docs/concurrent-mode-intro.html\">React Concurrent docs</a> explore how to use Concurrent Mode and Suspense and go into more detail about many of these patterns. It’s a great resource to learn more about the APIs and use-cases they support.</li>\n<li>The <a href=\"https://relay.dev/docs/en/experimental/step-by-step\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">experimental release of Relay Hooks</a> implements the patterns described here. </li>\n<li>\n<p>We’ve implemented two similar example apps that demonstrate these concepts:</p>\n<ul>\n<li>The <a href=\"https://github.com/relayjs/relay-examples/tree/main/issue-tracker\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Relay Hooks example app</a> uses GitHub’s public GraphQL API to implement a simple issue tracker app. It includes nested route support with code and data preloading. The code is fully commented — we encourage cloning the repo, running the app locally, and exploring how it works.</li>\n<li>We also have a <a href=\"https://github.com/gaearon/suspense-experimental-github-demo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">non-GraphQL version of the app</a> that demonstrates how these concepts can be applied to other data-fetching libraries.</li>\n</ul>\n</li>\n</ul>\n<p>While the APIs around Concurrent Mode and Suspense are <a href=\"/docs/concurrent-mode-adoption.html#who-is-this-experimental-release-for\">still experimental</a>, we’re confident that the ideas in this post are proven by practice. However, we understand that Relay and GraphQL aren’t the right fit for everyone. That’s ok! <strong>We’re actively exploring how to generalize these patterns to approaches such as REST,</strong> and are exploring ideas for a more generic (ie non-GraphQL) API for composing a tree of data dependencies. In the meantime, we’re excited to see what new libraries will emerge that implement the patterns described in this post to make it easier to build great, <em>fast</em> user experiences.</p>","excerpt":"At React Conf 2019 we announced an experimental release of React that supports Concurrent Mode and Suspense. In this post we’ll introduce best practices for using them that we’ve identified through the process of building the new facebook.com. This post will be most relevant to people working on data fetching libraries for React.  It shows how to best integrate them with Concurrent Mode and Suspense. The patterns introduced here are based on Relay — our library for building data-driven UIs with…","frontmatter":{"title":"Building Great User Experiences with Concurrent Mode and Suspense","next":null,"prev":null,"author":[{"frontmatter":{"name":"Joseph Savona","url":"https://twitter.com/en_JS"}}]},"fields":{"date":"November 06, 2019","path":"content/blog/2019-11-06-building-great-user-experiences-with-concurrent-mode-and-suspense.md","slug":"/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"title":"React 18 发布计划"},"fields":{"slug":"/blog/2021/06/08/the-plan-for-react-18.html"}}},{"node":{"frontmatter":{"title":"介绍 Zero-Bundle-Size 的 React 服务端组件"},"fields":{"slug":"/blog/2020/12/21/data-fetching-with-react-server-components.html"}}},{"node":{"frontmatter":{"title":"React v17.0"},"fields":{"slug":"/blog/2020/10/20/react-v17.html"}}},{"node":{"frontmatter":{"title":"介绍全新的 JSX 转换"},"fields":{"slug":"/blog/2020/09/22/introducing-the-new-jsx-transform.html"}}},{"node":{"frontmatter":{"title":"React v17.0 RC 版本发布：没有新特性"},"fields":{"slug":"/blog/2020/08/10/react-v17-rc.html"}}},{"node":{"frontmatter":{"title":"React v16.13.0"},"fields":{"slug":"/blog/2020/02/26/react-v16.13.0.html"}}},{"node":{"frontmatter":{"title":"Building Great User Experiences with Concurrent Mode and Suspense"},"fields":{"slug":"/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html"}}},{"node":{"frontmatter":{"title":"使用 React 预发布版为新功能打基础"},"fields":{"slug":"/blog/2019/10/22/react-release-channels.html"}}},{"node":{"frontmatter":{"title":"全新的 React DevTools 简介"},"fields":{"slug":"/blog/2019/08/15/new-react-devtools.html"}}},{"node":{"frontmatter":{"title":"React v16.9.0 发布及 Roadmap 最新进展"},"fields":{"slug":"/blog/2019/08/08/react-v16.9.0.html"}}}]}},"pageContext":{"slug":"/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html"}},"staticQueryHashes":[]}