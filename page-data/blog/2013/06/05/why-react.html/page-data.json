{"componentChunkName":"component---src-templates-blog-js","path":"/blog/2013/06/05/why-react.html","result":{"data":{"markdownRemark":{"html":"<p>现在有很多 JavaScript MVC 框架。我们为什么还要构建 React，\n你又为什么会使用它？</p>\n<h2 id=\"react-isnt-an-mvc-framework\"><a href=\"#react-isnt-an-mvc-framework\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 不是一个 MVC 框架。 </h2>\n<p>React 是一个用于构建可组合用户界面的库。\n它鼓励创建那些用于呈现随时间变化数据的、可复用的\nUI 组件。</p>\n<h2 id=\"react-doesnt-use-templates\"><a href=\"#react-doesnt-use-templates\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 不使用模板。 </h2>\n<p>在以往，web 应用程序的 UI 都是使用模板或者 HTML 指令构建的。\n这些模板决定了你可以用来构建\nUI 的全套抽象。</p>\n<p>而 React 用了不同的方式构建 UI，把它们拆成<strong>组件</strong>。\n这意味着 React 使用了一种真实的、具有各种特性的编程语言来渲染视图，\n我们认为它相较于模板而言是一种优势的理由如下:</p>\n<ul>\n<li><strong>JavaScript 是一种灵活、强大的编程语言</strong>，具有构建抽象的能力，\n这在大型应用中非常重要。</li>\n<li>通过将你的标记和其相对应的视图逻辑统一起来，\nReact 实际上可以让视图变得<strong>更容易扩展和维护</strong>。</li>\n<li>通过把一种对标记和内容的理解融入 JavaScript，\n<strong>不用手动连接字符串</strong>，因此 XSS\n漏洞的表面积也更小。</li>\n</ul>\n<p>相比原生 JavaScript，如果你更喜欢 HTML 的高可读性，\n我们创造了 <a href=\"/docs/jsx-in-depth.html\">JSX</a>，一种可选的语法扩展。</p>\n<h2 id=\"reactive-updates-are-dead-simple\"><a href=\"#reactive-updates-are-dead-simple\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>响应式更新非常简单。 </h2>\n<p>当你的数据随时间变化的时候，React 表现得真的很出色。</p>\n<p>在一个传统的 JavaScript 应用中，你需要观察数据发生了什么变化，\n并且为了让 DOM 保持最新的状态还必须对它进行更改。\nAngularJS 甚至通过指令和数据绑定的提供声明式接口，\n还<a href=\"https://code.angularjs.org/1.0.8/docs/guide/directive#reasonsbehindthecompilelinkseparation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">需要一个链接函数来手动更新 DOM 节点</a> 。</p>\n<p>但 React 采用了不同的方式。</p>\n<p>当你的组件首次初始化，组件的 <code class=\"gatsby-code-text\">render</code> 方法会被调用，\n对你的视图生成一个轻量化的表示。从那个表示生成一串标记，\n并注入到文档中。当你的数据发生了变化，\n<code class=\"gatsby-code-text\">render</code> 方法会再次被调用。为了尽可能高效地执行更新，\n我们会对前一次调用 <code class=\"gatsby-code-text\">render</code> 方法返回的结果和新的调用结果进行区分，\n并生成一个要应用于 DOM\n的最小更改集合。</p>\n<blockquote>\n<p><code class=\"gatsby-code-text\">render</code> 返回的数据既不是一串字符串也不是一个 DOM 节点 —— 而是一种表示\nDOM 应该是什么样子的轻量化描述。</p>\n</blockquote>\n<p>我们把这个过程称为<strong>协调</strong>。 查看\n<a href=\"http://jsfiddle.net/2h6th4ju/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这个 jsFiddle</a>\n可以看到实际的协调示例。</p>\n<p>因为这样的重渲染实在太快了（对于 TodoMVC 而言大概就 1ms），\n所以开发者不需要显式地指定数据绑定。\n我们发现这种方式可以更轻松地构建应用程序。</p>\n<h2 id=\"html-is-just-the-beginning\"><a href=\"#html-is-just-the-beginning\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTML 只是开始。 </h2>\n<p>因为 React 有它自己对于文档的轻量化表示，\n所以我们可以用它做一些非常酷的事情：</p>\n<ul>\n<li>Facebook 有些动态的图表会渲染成 <code class=\"gatsby-code-text\">&lt;canvas></code> 而不是 HTML。</li>\n<li>Instagram 是一个完全用 React 和 <code class=\"gatsby-code-text\">Backbone.Router</code> 构建的“单页”web 应用程序。\n设计师经常使用 JSX 来提供 React 代码。</li>\n<li>我们已经构建了在 web worker 中运行 React 应用程序的内部原型，并且用\nReact 通过一个 Objective-C 桥接器来驱动 <strong>原生 iOS 视图</strong>。</li>\n<li>你可以\n<a href=\"https://github.com/petehunt/react-server-rendering-example\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">在服务器上</a>\n运行 React 以获得 SEO、性能、代码共享和整体的灵活性。</li>\n<li>事件在所有浏览器（包括 IE8）中以一致的、符合标准的方式运行，\n并且自动使用了\n<a href=\"http://davidwalsh.name/event-delegate\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">事件委托</a> 。</li>\n</ul>\n<p>前往 <a href=\"https://reactjs.org\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://reactjs.org</a> 可以查看我们已经构建的内容。\n我们的文档旨在用框架构建应用程序，\n但是如果你对具体细节感兴趣，\n请与我们<a href=\"/support.html\">联系</a>！</p>\n<p>感谢阅读！</p>","excerpt":"现在有很多 JavaScript MVC 框架。我们为什么还要构建 React，\n你又为什么会使用它？ React 不是一个 MVC 框架。  React 是一个用于构建可组合用户界面的库。\n它鼓励创建那些用于呈现随时间变化数据的、可复用的\nUI 组件。 React 不使用模板。  在以往，web 应用程序的 UI 都是使用模板或者 HTML 指令构建的。\n这些模板决定了你可以用来构建\nUI 的全套抽象。 而 React 用了不同的方式构建 UI，把它们拆成组件。\n这意味着 React 使用了一种真实的、具有各种特性的编程语言来渲染视图，\n我们认为它相较于模板而言是一种优势的理由如下: JavaScript 是一种灵活、强大的编程语言，具有构建抽象的能力，\n这在大型应用中非常重要。 通过将你的标记和其相对应的视图逻辑统一起来，\nReact 实际上可以让视图变得更容易扩展和维护。 通过把一种对标记和内容的理解融入 JavaScript，\n不用手动连接字符串，因此 XSS\n漏洞的表面积也更小。 相比原生 JavaScript，如果你更喜欢 HTML 的高可读性，\n我们创造了 JSX…","frontmatter":{"title":"我们为什么要构建 React?","next":null,"prev":null,"author":[{"frontmatter":{"name":"Pete Hunt","url":"https://twitter.com/floydophone"}}]},"fields":{"date":"June 05, 2013","path":"content/blog/2013-06-05-why-react.md","slug":"/blog/2013/06/05/why-react.html"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"title":"React 18 发布计划"},"fields":{"slug":"/blog/2021/06/08/the-plan-for-react-18.html"}}},{"node":{"frontmatter":{"title":"介绍 Zero-Bundle-Size 的 React 服务端组件"},"fields":{"slug":"/blog/2020/12/21/data-fetching-with-react-server-components.html"}}},{"node":{"frontmatter":{"title":"React v17.0"},"fields":{"slug":"/blog/2020/10/20/react-v17.html"}}},{"node":{"frontmatter":{"title":"介绍全新的 JSX 转换"},"fields":{"slug":"/blog/2020/09/22/introducing-the-new-jsx-transform.html"}}},{"node":{"frontmatter":{"title":"React v17.0 RC 版本发布：没有新特性"},"fields":{"slug":"/blog/2020/08/10/react-v17-rc.html"}}},{"node":{"frontmatter":{"title":"React v16.13.0"},"fields":{"slug":"/blog/2020/02/26/react-v16.13.0.html"}}},{"node":{"frontmatter":{"title":"Building Great User Experiences with Concurrent Mode and Suspense"},"fields":{"slug":"/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html"}}},{"node":{"frontmatter":{"title":"使用 React 预发布版为新功能打基础"},"fields":{"slug":"/blog/2019/10/22/react-release-channels.html"}}},{"node":{"frontmatter":{"title":"全新的 React DevTools 简介"},"fields":{"slug":"/blog/2019/08/15/new-react-devtools.html"}}},{"node":{"frontmatter":{"title":"React v16.9.0 发布及 Roadmap 最新进展"},"fields":{"slug":"/blog/2019/08/08/react-v16.9.0.html"}}}]}},"pageContext":{"slug":"/blog/2013/06/05/why-react.html"}},"staticQueryHashes":[]}