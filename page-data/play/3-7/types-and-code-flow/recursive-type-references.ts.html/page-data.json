{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/3-7/types-and-code-flow/recursive-type-references.ts.html","result":{"pageContext":{"name":"Recursive Type References","title":"Recursive Type References","lang":"en","html":"\n Choosing between using type vs interface is about the\n constraints in the features for each. With 3.7, one of\n the constrains on type but not in interface was removed.\n\n You can find out more about this in example:types-vs-interfaces\n\n It used to be that you could not refer to the type you\n are defining inside the type itself. This was a limit\n which didn't exist inside an interface, and could be worked\n around with a little work.\n\n For example, this is not feasible in 3.6:\n<code><pre>\ntype ValueOrArray<T> = T | Array<ValueOrArray<T>>;\n\n</pre></code>\n// An implementation would have looked like this, by mixing\n the type with an interface.\n<code><pre>\ntype ValueOrArray2<T> = T | ArrayOfValueOrArray<T>;\ninterface ArrayOfValueOrArray<T> extends Array<ValueOrArray2<T>> {}\n\n</pre></code>\n// This allows for a comprehensive definition of JSON,\n which works by referring to itself.\n\n<code><pre>\ntype Json = string | number | boolean | null | Json[] | { [key: string]: Json };\n\nconst exampleStatusJSON: Json = {\n  available: true,\n  username: \"Jean-loup\",\n  room: {\n    name: \"Highcrest\",\n    // Cannot add functions into the Json type\n    // update: () => {}\n  },\n};\n\n</pre></code>\n// There's more to learn from the 3.7 beta release notes and its PR:\n\n https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/\n https://github.com/microsoft/TypeScript/pull/33050\n","redirectHref":"/play/?#example/recursive-type-references"}},"staticQueryHashes":[]}