{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts.html","result":{"pageContext":{"name":"Checking Unions with Index Signatures","title":"Checking Unions with Index Signatures","lang":"en","html":" In previous versions of TypeScript, the checker would not\n verify that undeclared fields in a union conform to any indexed\n types in the union.\n\n You can learn about indexed types here: example:indexed-types\n\n For example, the IdentifierCache below indicates that any\n key on the object will be a number:\n\n<code><pre>\ntype IdentifierCache = { [key: string]: number };\n\n</pre></code>\n// Meaning this will fail, because 'file_a' has a\n string value\n\n<code><pre>\nconst cacheWithString: IdentifierCache = { file_a: \"12343\" };\n\n</pre></code>\n// However, when you put that into a union, then the\n validation check would not happen:\n\n<code><pre>\nlet userCache: IdentifierCache | { index: number };\nuserCache = { file_one: 5, file_two: \"abc\" };\n\n</pre></code>\n// This is fixed, and there would be an error about\n 'file_two' from the compiler.\n\n This also takes into account when the key is a different\n type, for example: ([key: string] and [key: number])\n\n<code><pre>\ntype IdentifierResponseCache = { [key: number]: number };\n\nlet resultCache: IdentifierCache | IdentifierResponseCache;\nresultCache = { file_one: \"abc\" };\n","redirectHref":"/play/?ts=3.8.3#example/checking-unions-with-index-signatures"}},"staticQueryHashes":[]}