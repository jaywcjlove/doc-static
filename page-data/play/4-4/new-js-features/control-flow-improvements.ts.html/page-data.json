{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/4-4/new-js-features/control-flow-improvements.ts.html","result":{"pageContext":{"name":"Control Flow Improvements","title":"Control Flow Improvements","lang":"en","html":" Control Flow Analysis is the name for the system which\n narrows the potential types an identifier can be based\n on the code someone has wrote, you can get an overview\n in example:type-widening-and-narrowing\n\n Roughly, Control Flow Analysis lets you write code like\n the following:\n\n<code><pre>\ndeclare const userInput: string | number;\nif (typeof userInput === \"string\") {\n  userInput; // string\n} else {\n  userInput; // number\n}\n\n</pre></code>\n// In this case, prior to TypeScript 4.4, code flow analysis\n would only be applied to the code inside the if statement.\n This meant that a very simple refactor like the following:\n\n<code><pre>\nconst isString = typeof userInput === \"string\";\n\n// Would have _not_ had control flow analysis applied:\n\nif (isString) {\n  userInput; // string | number in 4.3\n} else {\n  userInput; // string | number in 4.3\n}\n\n</pre></code>\n// In TypeScript 4.4 - the version you're currently on, the control flow\n analysis can handle this sort of code. This works when TypeScript\n can make reasonable assumptions that the variable hasn't changed since\n it was created. For example, a `let` would not be able to be used\n in analysis:\n\n<code><pre>\nlet isString2 = typeof userInput === \"string\";\nif (isString2) {\n  userInput; // string | number in 4.4\n} else {\n  userInput; // string | number in 4.4\n}\n\n</pre></code>\n// For full details see:\n https://github.com/microsoft/TypeScript/pull/44730\n","redirectHref":"/play/?ts=4.4.2#example/control-flow-improvements"}},"staticQueryHashes":[]}