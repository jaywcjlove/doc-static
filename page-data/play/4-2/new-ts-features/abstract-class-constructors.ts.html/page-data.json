{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/4-2/new-ts-features/abstract-class-constructors.ts.html","result":{"pageContext":{"name":"Abstract Class Constructors","title":"Abstract Class Constructors","lang":"en","html":" TypeScript has supported abstract classes since 2015, which\n provides compiler errors if you try to instantiate that class.\n\n TypeScript 4.2 adds support for declaring that the constructor\n function is abstract. This is mostly used by people who use\n the mixin pattern ( example:mixins )\n\n The mixin pattern involves having classes dynamically wrapping\n each other to \"mixing in\" certain features to the end result.\n\n This pattern is represented in TypeScript via a chain of constructor\n functions of the classes, and by declaring one as abstract you can use\n abstract classes inside your mixins.\n\n All mixins start with a generic constructor to pass the T through, now\n these can be abstract.\n<code><pre>\ntype AbstractConstructor<T> = abstract new (...args: any[]) => T\n\n</pre></code>\n// We'll create an abstract class \"Animal\" where\n the subclasses must override 'walk' \n<code><pre>\nabstract class Animal {\n  abstract walk(): void;\n  breath() { }\n}\n\n// A mixin which adds a new function (in this case, animate)\nfunction animatableAnimal<T extends AbstractConstructor<object>>(Ctor: T) {\n  abstract class StopWalking extends Ctor {\n    animate() { }\n  }\n  return StopWalking;\n}\n\n</pre></code>\n// A subclass of the Animal, through the mixins, must still\n handle the abstract contract for Animal. Which means it\n needs to implement 'walk' below. Try deleting the function\n to see what happens.\n\n<code><pre>\nclass Dog extends animatableAnimal(Animal) {\n  walk() { }\n}\n\n\nconst dog = new Dog()\ndog.breath()\ndog.walk()\ndog.animate()\n","redirectHref":"/play/?ts=4.2.0-beta#example/abstract-class-constructors"}},"staticQueryHashes":[]}