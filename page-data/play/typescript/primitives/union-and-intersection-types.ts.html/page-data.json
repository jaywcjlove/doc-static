{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/typescript/primitives/union-and-intersection-types.ts.html","result":{"pageContext":{"name":"Union and Intersection Types","title":"Union and Intersection Types","lang":"en","html":" Type unions are a way of declaring that an object\n could be more than one type.\n\n<code><pre>\ntype StringOrNumber = string | number;\ntype ProcessStates = \"open\" | \"closed\";\ntype OddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;\ntype AMessyUnion = \"hello\" | 156 | { error: true };\n\n</pre></code>\n// If the use of \"open\" and \"closed\" vs string is\n new to you, check out: example:literals\n\n We can mix different types into a union, and\n what we're saying is that the value is one of those types.\n\n TypeScript will then leave you to figure out how to\n determine which value it could be at runtime.\n\n Unions can sometimes be undermined by type widening,\n for example:\n\n<code><pre>\ntype WindowStates = \"open\" | \"closed\" | \"minimized\" | string;\n\n</pre></code>\n// If you hover above, you can see that WindowStates\n becomes a string - not the union. This is covered in\n example:type-widening-and-narrowing\n\n If a union is an OR, then an intersection is an AND.\n Intersection types are when two types intersect to create\n a new type. This allows for type composition.\n\n<code><pre>\ninterface ErrorHandling {\n  success: boolean;\n  error?: { message: string };\n}\n\ninterface ArtworksData {\n  artworks: { title: string }[];\n}\n\ninterface ArtistsData {\n  artists: { name: string }[];\n}\n\n</pre></code>\n// These interfaces can be composed in responses which have\n both consistent error handling, and their own data.\n\n<code><pre>\ntype ArtworksResponse = ArtworksData & ErrorHandling;\ntype ArtistsResponse = ArtistsData & ErrorHandling;\n\n// For example:\n\nconst handleArtistsResponse = (response: ArtistsResponse) => {\n  if (response.error) {\n    console.error(response.error.message);\n    return;\n  }\n\n  console.log(response.artists);\n};\n\n</pre></code>\n// A mix of Intersection and Union types becomes really\n useful when you have cases where an object has to\n include one of two values:\n\n<code><pre>\ninterface CreateArtistBioBase {\n  artistID: string;\n  thirdParty?: boolean;\n}\n\ntype CreateArtistBioRequest = CreateArtistBioBase & ({ html: string } | { markdown: string });\n\n</pre></code>\n// Now you can only create a request when you include\n artistID and either html or markdown\n\n<code><pre>\nconst workingRequest: CreateArtistBioRequest = {\n  artistID: \"banksy\",\n  markdown: \"Banksy is an anonymous England-based graffiti artist...\",\n};\n\nconst badRequest: CreateArtistBioRequest = {\n  artistID: \"banksy\",\n};\n","redirectHref":"/play/?#example/union-and-intersection-types"}},"staticQueryHashes":[]}