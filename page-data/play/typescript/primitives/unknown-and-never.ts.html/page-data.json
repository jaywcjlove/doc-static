{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/typescript/primitives/unknown-and-never.ts.html","result":{"pageContext":{"name":"Unknown and Never","title":"Unknown and Never","lang":"en","html":" Unknown\n\n Unknown is one of those types that once it clicks, you\n can find quite a lot of uses for it. It acts like a sibling\n to the any type. Where any allows for ambiguity - unknown\n requires specifics.\n\n A good example would be in wrapping a JSON parser. JSON\n data can come in many different forms and the creator\n of the json parsing function won't know the shape of the\n data - the person calling that function should.\n\n<code><pre>\nconst jsonParser = (jsonString: string) => JSON.parse(jsonString);\n\nconst myAccount = jsonParser(`{ \"name\": \"Dorothea\" }`);\n\nmyAccount.name;\nmyAccount.email;\n\n</pre></code>\n// If you hover on jsonParser, you can see that it has the\n return type of any, so then does myAccount. It's possible\n to fix this with generics - but it's also possible to fix\n this with unknown.\n\n<code><pre>\nconst jsonParserUnknown = (jsonString: string): unknown => JSON.parse(jsonString);\n\nconst myOtherAccount = jsonParserUnknown(`{ \"name\": \"Samuel\" }`);\n\nmyOtherAccount.name;\n\n</pre></code>\n// The object myOtherAccount cannot be used until the type has\n been declared to TypeScript. This can be used to ensure\n that API consumers think about their typing up-front:\n\n<code><pre>\ntype User = { name: string };\nconst myUserAccount = jsonParserUnknown(`{ \"name\": \"Samuel\" }`) as User;\nmyUserAccount.name;\n\n</pre></code>\n// Unknown is a great tool, to understand it more read these:\n https://mariusschulz.com/blog/the-unknown-type-in-typescript\n https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type\n\n Never\n\n Because TypeScript supports code flow analysis, the language\n needs to be able to represent when code logically cannot\n happen. For example, this function cannot return:\n\n<code><pre>\nconst neverReturns = () => {\n  // If it throws on the first line\n  throw new Error(\"Always throws, never returns\");\n};\n\n</pre></code>\n// If you hover on the type, you see it is a () => never\n which means it should never happen. These can still be\n passed around like other values:\n\n<code><pre>\nconst myValue = neverReturns();\n\n</pre></code>\n// Having a function never return can be useful when dealing\n with the unpredictability of the JavaScript runtime and\n API consumers that might not be using types:\n\n<code><pre>\nconst validateUser = (user: User) => {\n  if (user) {\n    return user.name !== \"NaN\";\n  }\n\n  // According to the type system, this code path can never\n  // happen, which matches the return type of neverReturns.\n\n  return neverReturns();\n};\n\n</pre></code>\n// The type definitions state that a user has to be passed in\n but there are enough escape valves in JavaScript whereby\n you can't guarantee that.\n\n Using a function which returns never allows you to add\n additional code in places which should not be possible.\n This is useful for presenting better error messages,\n or closing resources like files or loops.\n\n A very popular use for never, is to ensure that a\n switch is exhaustive. E.g., that every path is covered.\n\n Here's an enum and an exhaustive switch, try adding\n a new option to the enum (maybe Tulip?)\n\n<code><pre>\nenum Flower {\n  Rose,\n  Rhododendron,\n  Violet,\n  Daisy,\n}\n\nconst flowerLatinName = (flower: Flower) => {\n  switch (flower) {\n    case Flower.Rose:\n      return \"Rosa rubiginosa\";\n    case Flower.Rhododendron:\n      return \"Rhododendron ferrugineum\";\n    case Flower.Violet:\n      return \"Viola reichenbachiana\";\n    case Flower.Daisy:\n      return \"Bellis perennis\";\n\n    default:\n      const _exhaustiveCheck: never = flower;\n      return _exhaustiveCheck;\n  }\n};\n\n</pre></code>\n// You will get a compiler error saying that your new\n flower type cannot be converted into never.\n\n Never in Unions\n\n A never is something which is automatically removed from\n a type union.\n\n<code><pre>\ntype NeverIsRemoved = string | never | number;\n\n</pre></code>\n// If you look at the type for NeverIsRemoved, you see that\n it is string | number. This is because it should never\n happen at runtime because you cannot assign to it.\n\n This feature is used a lot in example:conditional-types\n","redirectHref":"/play/?#example/unknown-and-never"}},"staticQueryHashes":[]}