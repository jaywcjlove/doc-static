{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/typescript/type-primitives/nullable-types.ts.html","result":{"pageContext":{"name":"Nullable Types","title":"Nullable Types","lang":"en","html":"\n JavaScript has two ways to declare values which don't\n exist, and TypeScript adds extra syntax which allows even\n more ways to declare something as optional or nullable.\n\n First up, the difference between the two JavaScript\n primitives: undefined and null\n\n Undefined is when something cannot be found or set\n\n<code><pre>\nconst emptyObj = {};\nconst anUndefinedProperty: undefined = emptyObj[\"anything\"];\n\n</pre></code>\n// Null is meant to be used when there is a conscious lack\n of a value.\n\n<code><pre>\nconst searchResults = {\n  video: { name: \"LEGO Movie\" },\n  text: null,\n  audio: { name: \"LEGO Movie Soundtrack\" },\n};\n\n</pre></code>\n// Why not use undefined? Mainly, because now you can verify\n that text was correctly included. If text returned as\n undefined then the result is the same as though it was\n not there.\n\n This might feel a bit superficial, but when converted into\n a JSON string, if text was an undefined, it would not be\n included in the string equivalent.\n\n Strict Null Types\n\n Before TypeScript 2.0 undefined and null were effectively\n ignored in the type system. This let TypeScript provide a\n coding environment closer to un-typed JavaScript.\n\n Version 2.0 added a compiler flag called \"strictNullChecks\"\n and this flag required people to treat undefined and null\n as types which needs to be handled via code-flow analysis\n ( see more at example:code-flow )\n\n For an example of the difference in turning on strict null\n checks to TypeScript, hover over \"Potential String\" below:\n\n<code><pre>\ntype PotentialString = string | undefined | null;\n\n</pre></code>\n// The PotentialString discards the undefined and null. If\n you go up to the settings and turn on strict mode and come\n back, you'll see that hovering on PotentialString now shows\n the full union.\n\n<code><pre>\ndeclare function getID(): PotentialString;\n\nconst userID = getID();\nconsole.log(\"User Logged in: \", userID.toUpperCase());\n\n// Only in strict mode the above will fail ^\n\n</pre></code>\n// There are ways to tell TypeScript you know more, such as\n a type assertion or via a non-null assertion operator (!)\n\n<code><pre>\nconst definitelyString1 = getID() as string;\nconst definitelyString2 = getID()!;\n\n// Or you safely can check for the existence via an if:\n\nif (userID) {\n  console.log(userID);\n}\n\n// Optional Properties\n\n// Void\n\n</pre></code>\n// Void is the return type of a function which does not\n return a value.\n\n<code><pre>\nconst voidFunction = () => { };\nconst resultOfVoidFunction = voidFunction();\n\n</pre></code>\n// This is usually an accident, and TypeScript keeps the void\n type around to let you get compiler errors - even though at\n runtime it would be an undefined.\n","redirectHref":"/play/?strictNullChecks=false#example/nullable-types"}},"staticQueryHashes":[]}