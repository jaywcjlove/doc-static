{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/typescript/meta-types/indexed-types.ts.html","result":{"pageContext":{"name":"Indexed Types","title":"Indexed Types","lang":"en","html":" There are times when you find yourself duplicating types.\n A common example is nested resources in an auto-generated\n API response.\n\n<code><pre>\ninterface ArtworkSearchResponse {\n  artists: {\n    name: string;\n    artworks: {\n      name: string;\n      deathdate: string | null;\n      bio: string;\n    }[];\n  }[];\n}\n\n</pre></code>\n// If this interface were hand-crafted, it's pretty easy to\n imagine pulling out the artworks into an interface like:\n\n<code><pre>\ninterface Artwork {\n  name: string;\n  deathdate: string | null;\n  bio: string;\n}\n\n</pre></code>\n// However, in this case we don't control the API, and if\n we hand-created the interface then it's possible that\n the artworks part of ArtworkSearchResponse and\n Artwork could get out of sync when the response changes.\n\n The fix for this is indexed types, which replicate how\n JavaScript allows accessing properties via strings.\n\n<code><pre>\ntype InferredArtwork = ArtworkSearchResponse[\"artists\"][0][\"artworks\"][0];\n\n</pre></code>\n// The InferredArtwork is generated by looking through the\n type's properties and giving a new name to the subset which\n you have indexed.\n","redirectHref":"/play/?#example/indexed-types"}},"staticQueryHashes":[]}