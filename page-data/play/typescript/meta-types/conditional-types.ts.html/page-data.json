{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/typescript/meta-types/conditional-types.ts.html","result":{"pageContext":{"name":"Conditional Types","title":"Conditional Types","lang":"en","html":" Conditional Types provide a way to do simple logic in the\n TypeScript type system. This is definitely an advanced\n feature, and it's quite feasible that you won't need to\n use this in your normal day to day code.\n\n A conditional type looks like:\n\n   A extends B ? C : D\n\n Where the condition is whether a type extends an\n expression, and if so what type should be returned.\n\n Let's go through some examples, for brevity we're\n going to use single letters for generics. This is optional\n but restricting ourselves to 60 characters makes it\n hard to fit on screen.\n\n<code><pre>\ntype Cat = { meows: true };\ntype Dog = { barks: true };\ntype Cheetah = { meows: true; fast: true };\ntype Wolf = { barks: true; howls: true };\n\n</pre></code>\n// We can create a conditional type which lets extract\n types which only conform to something which barks.\n\n<code><pre>\ntype ExtractDogish<A> = A extends { barks: true } ? A : never;\n\n// Then we can create types which ExtractDogish wraps:\n\n// A cat doesn't bark, so it will return never\ntype NeverCat = ExtractDogish<Cat>;\n// A wolf will bark, so it returns the wolf shape\ntype Wolfish = ExtractDogish<Wolf>;\n\n</pre></code>\n// This becomes useful when you want to work with a\n union of many types and reduce the number of potential\n options in a union:\n\n<code><pre>\ntype Animals = Cat | Dog | Cheetah | Wolf;\n\n</pre></code>\n// When you apply ExtractDogish to a union type, it is the\n same as running the conditional against each member of\n the type:\n\n<code><pre>\ntype Dogish = ExtractDogish<Animals>;\n\n</pre></code>\n// = ExtractDogish<Cat> | ExtractDogish<Dog> |\n   ExtractDogish<Cheetah> | ExtractDogish<Wolf>\n\n = never | Dog | never | Wolf\n\n = Dog | Wolf (see example:unknown-and-never)\n\n This is called a distributive conditional type because\n the type distributes over each member of the union.\n\n Deferred Conditional Types\n\n Conditional types can be used to tighten your APIs which\n can return different types depending on the inputs.\n\n For example this function which could return either a\n string or number depending on the boolean passed in.\n\n<code><pre>\ndeclare function getID<T extends boolean>(fancy: T): T extends true ? string : number;\n\n</pre></code>\n// Then depending on how much the type-system knows about\n the boolean, you will get different return types:\n\n<code><pre>\nlet stringReturnValue = getID(true);\nlet numberReturnValue = getID(false);\nlet stringOrNumber = getID(Math.random() < 0.5);\n\n</pre></code>\n// In this case above TypeScript can know the return value\n instantly. However, you can use conditional types in functions\n where the type isn't known yet. This is called a deferred\n conditional type.\n\n Same as our Dogish above, but as a function instead\n<code><pre>\ndeclare function isCatish<T>(x: T): T extends { meows: true } ? T : undefined;\n\n</pre></code>\n// There is an extra useful tool within conditional types, which\n is being able to specifically tell TypeScript that it should\n infer the type when deferring. That is the 'infer' keyword.\n\n infer is typically used to create meta-types which inspect\n the existing types in your code, think of it as creating\n a new variable inside the type.\n\n<code><pre>\ntype GetReturnValue<T> = T extends (...args: any[]) => infer R ? R : T;\n\n</pre></code>\n// Roughly:\n\n  - this is a conditional generic type called GetReturnValue\n    which takes a type in its first parameter\n\n  - the conditional checks if the type is a function, and\n    if so create a new type called R based on the return\n    value for that function\n\n  - If the check passes, the type value is the inferred\n    return value, otherwise it is the original type\n\n\n<code><pre>\ntype getIDReturn = GetReturnValue<typeof getID>;\n\n</pre></code>\n// This fails the check for being a function, and would\n just return the type passed into it.\n<code><pre>\ntype getCat = GetReturnValue<Cat>;\n","redirectHref":"/play/?#example/conditional-types"}},"staticQueryHashes":[]}