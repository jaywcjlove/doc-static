{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/typescript/language/soundness.ts.html","result":{"pageContext":{"name":"Soundness","title":"Soundness","lang":"en","html":"\n Without a background in type theory, you're unlikely\n to be familiar with the idea of a type system being \"sound\".\n\n Soundness is the idea that the compiler can make guarantees\n about the type a value has at runtime, and not just\n during compilation. This is normal for most programming\n languages that are built with types from day one.\n\n Building a type system which models a language which has\n existed for a few decades however becomes about making\n decisions with trade-offs on three qualities: Simplicity,\n Usability and Soundness.\n\n With TypeScript's goal of being able to support all JavaScript\n code, the language tends towards simplicity and usability\n when presented with ways to add types to JavaScript.\n\n Let's look at a few cases where TypeScript is provably\n not sound, to understand what those trade-offs would look\n like otherwise.\n\n Type Assertions\n\n<code><pre>\nconst usersAge = (\"23\" as any) as number;\n\n</pre></code>\n// TypeScript will let you use type assertions to override\n the inference to something which is quite wrong. Using\n type assertions is a way of telling TypeScript you know\n best, and TypeScript will try to let you get on with it.\n\n Languages which are sound would occasionally use runtime checks\n to ensure that the data matches what your types say - but\n TypeScript aims to have no type-aware runtime impact on\n your transpiled code.\n\n Function Parameter Bi-variance\n\n Params for a function support redefining the parameter\n to be a subtype of the original declaration.\n\n<code><pre>\ninterface InputEvent {\n  timestamp: number;\n}\ninterface MouseInputEvent extends InputEvent {\n  x: number;\n  y: number;\n}\ninterface KeyboardInputEvent extends InputEvent {\n  keyCode: number;\n}\n\nfunction listenForEvent(eventType: \"keyboard\" | \"mouse\", handler: (event: InputEvent) => void) { }\n\n</pre></code>\n// You can re-declare the parameter type to be a subtype of\n the declaration. Above, handler expected a type InputEvent\n but in the below usage examples - TypeScript accepts\n a type which has additional properties.\n\n<code><pre>\nlistenForEvent(\"keyboard\", (event: KeyboardInputEvent) => { });\nlistenForEvent(\"mouse\", (event: MouseInputEvent) => { });\n\n// This can go all the way back to the smallest common type:\n\nlistenForEvent(\"mouse\", (event: {}) => { });\n\n// But no further:\n\nlistenForEvent(\"mouse\", (event: string) => { });\n\n</pre></code>\n// This covers the real-world pattern of event listener\n in JavaScript, at the expense of having being sound.\n\n TypeScript can raise an error when this happens via\n `strictFunctionTypes`. Or, you could work around this\n particular case with function overloads,\n see: example:typing-functions\n\n Void special casing\n\n Parameter Discarding\n\n To learn about special cases with function parameters\n see example:structural-typing\n\n Rest Parameters\n\n Rest parameters are assumed to all be optional, this means\n TypeScript will not have a way to enforce the number of\n parameters available to a callback.\n\n<code><pre>\nfunction getRandomNumbers(count: number, callback: (...args: number[]) => void) { }\n\ngetRandomNumbers(2, (first, second) => console.log([first, second]));\ngetRandomNumbers(400, (first) => console.log(first));\n\n// Void Functions Can Match to a Function With a Return Value\n\n</pre></code>\n// A function which returns a void function, can accept a\n function which takes any other type.\n\n<code><pre>\nconst getPI = () => 3.14;\n\nfunction runFunction(func: () => void) {\n  func();\n}\n\nrunFunction(getPI);\n\n</pre></code>\n// For more information on the places where soundness of the\n type system is compromised, see:\n\n https://github.com/Microsoft/TypeScript/wiki/FAQ#type-system-behavior\n https://github.com/Microsoft/TypeScript/issues/9825\n https://www.typescriptlang.org/docs/handbook/type-compatibility.html\n","redirectHref":"/play/?strictFunctionTypes=false#example/soundness"}},"staticQueryHashes":[]}