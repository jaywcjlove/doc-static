{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/typescript/language/structural-typing.ts.html","result":{"pageContext":{"name":"Structural Typing","title":"Structural Typing","lang":"en","html":" TypeScript is a Structural Type System. A structural type\n system means that when comparing types, TypeScript only\n takes into account the members on the type.\n\n This is in contrast to nominal type systems, where you\n could create two types but could not assign them to each\n other. See example:nominal-typing\n\n For example, these two interfaces are completely\n transferrable in a structural type system:\n\n<code><pre>\ninterface Ball {\n  diameter: number;\n}\ninterface Sphere {\n  diameter: number;\n}\n\nlet ball: Ball = { diameter: 10 };\nlet sphere: Sphere = { diameter: 20 };\n\nsphere = ball;\nball = sphere;\n\n</pre></code>\n// If we add in a type which structurally contains all of\n the members of Ball and Sphere, then it also can be\n set to be a ball or sphere.\n\n<code><pre>\ninterface Tube {\n  diameter: number;\n  length: number;\n}\n\nlet tube: Tube = { diameter: 12, length: 3 };\n\ntube = ball;\nball = tube;\n\n</pre></code>\n// Because a ball does not have a length, then it cannot be\n assigned to the tube variable. However, all of the members\n of Ball are inside tube, and so it can be assigned.\n\n TypeScript is comparing each member in the type against\n each other to verify their equality.\n\n A function is an object in JavaScript and it is compared\n in a similar fashion. With one useful extra trick around\n the params:\n\n<code><pre>\nlet createBall = (diameter: number) => ({ diameter });\nlet createSphere = (diameter: number, useInches: boolean) => {\n  return { diameter: useInches ? diameter * 0.39 : diameter };\n};\n\ncreateSphere = createBall;\ncreateBall = createSphere;\n\n</pre></code>\n// TypeScript will allow (number) to equal (number, boolean)\n in the parameters, but not (number, boolean) -> (number)\n\n TypeScript will discard the boolean in the first assignment\n because it's very common for JavaScript code to skip passing\n params when they're not needed.\n\n For example the array's forEach's callback has three params,\n value, index and the full array - if TypeScript didn't\n support discarding parameters, then you would have to\n include every option to make the functions match up:\n\n<code><pre>\n[createBall(1), createBall(2)].forEach((ball, _index, _balls) => {\n  console.log(ball);\n});\n\n// No one needs that.\n\n</pre></code>\n// Return types are treated like objects, and any differences\n are compared with the same object equality rules above.\n\n<code><pre>\nlet createRedBall = (diameter: number) => ({ diameter, color: \"red\" });\n\ncreateBall = createRedBall;\ncreateRedBall = createBall;\n\n</pre></code>\n// Where the first assignment works (they both have diameter)\n but the second doesn't (the ball doesn't have a color).\n","redirectHref":"/play/?#example/structural-typing"}},"staticQueryHashes":[]}