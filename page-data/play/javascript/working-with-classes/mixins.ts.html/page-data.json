{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/javascript/working-with-classes/mixins.ts.html","result":{"pageContext":{"name":"Mixins","title":"Mixins","lang":"en","html":"\n Mixins are a faux-multiple inheritance pattern for classes\n in JavaScript which TypeScript has support for. The pattern\n allows you to create a class which is a merge of many\n classes.\n\n To get started, we need a type which we'll use to extend\n other classes from. The main responsibility is to declare\n that the type being passed in is a class.\n\n<code><pre>\ntype Constructor = new (...args: any[]) => {};\n\n</pre></code>\n// Then we can create a series of classes which extend\n the final class by wrapping it. This pattern works well\n when similar objects have different capabilities.\n\n This mixin adds a scale property, with getters and setters\n for changing it with an encapsulated private property:\n\n<code><pre>\nfunction Scale<TBase extends Constructor>(Base: TBase) {\n  return class extends Base {\n    // Mixins may not declare private/protected properties\n    // however, you can use ES2020 private fields\n    _scale = 1;\n\n    setScale(scale: number) {\n      this._scale = scale;\n    }\n\n    get scale(): number {\n      return this._scale;\n    }\n  };\n}\n\n</pre></code>\n// This mixin adds extra methods around alpha composition\n something which modern computers use to create depth:\n\n<code><pre>\nfunction Alpha<TBase extends Constructor>(Base: TBase) {\n  return class extends Base {\n    alpha = 1;\n\n    setHidden() {\n      this.alpha = 0;\n    }\n\n    setVisible() {\n      this.alpha = 1;\n    }\n\n    setAlpha(alpha: number) {\n      this.alpha = alpha;\n    }\n  };\n}\n\n// A simple sprite base class which will then be extended:\n\nclass Sprite {\n  name = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n</pre></code>\n// Here we create two different types of sprites\n which have different capabilities:\n\n<code><pre>\nconst ModernDisplaySprite = Alpha(Scale(Sprite));\nconst EightBitSprite = Scale(Sprite);\n\n</pre></code>\n// Creating instances of these classes shows that\n the objects have different sets of properties\n and methods due to their mixins:\n\n<code><pre>\nconst flappySprite = new ModernDisplaySprite(\"Bird\");\nflappySprite.x = 10;\nflappySprite.y = 20;\nflappySprite.setVisible();\nflappySprite.setScale(0.8);\nconsole.log(flappySprite.scale);\n\nconst gameBoySprite = new EightBitSprite(\"L block\");\ngameBoySprite.setScale(0.3);\n\n</pre></code>\n// Fails because an EightBitSprite does not have\n the mixin for changing alphas:\n<code><pre>\ngameBoySprite.setAlpha(0.5);\n\n</pre></code>\n// If you want to make more guarantees over the classes\n which you wrap, you can use a constructor with generics.\n\n<code><pre>\ntype GConstructor<T = {}> = new (...args: any[]) => T;\n\n</pre></code>\n// Now you can declare that this mixin can only be\n applied when the base class is a certain shape.\n\n<code><pre>\ntype Moveable = GConstructor<{ setXYAcceleration: (x: number, y: number) => void }>;\n\n</pre></code>\n// We can then create a mixin which relies on the function\n present in the parameter to the GConstructor above.\n\n<code><pre>\nfunction Jumpable<TBase extends Moveable>(Base: TBase) {\n  return class extends Base {\n    jump() {\n      // This mixin knows about setXYAcceleration now\n      this.setXYAcceleration(0, 20);\n    }\n  };\n}\n\n</pre></code>\n// We cannot create this sprite until there is a class\n in the mixin hierarchy which adds setXYAcceleration:\n<code><pre>\nconst UserSprite = new Jumpable(ModernDisplaySprite);\n","redirectHref":"/play/?#example/mixins"}},"staticQueryHashes":[]}