{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/javascript/working-with-classes/this.ts.html","result":{"pageContext":{"name":"This","title":"This","lang":"en","html":"\n When calling a method of a class, you generally expect it\n to refer to the current instance of the class.\n\n<code><pre>\nclass Safe {\n  contents: string;\n\n  constructor(contents: string) {\n    this.contents = contents;\n  }\n\n  printContents() {\n    console.log(this.contents);\n  }\n}\n\nconst safe = new Safe(\"Crown Jewels\");\nsafe.printContents();\n\n</pre></code>\n// If you come from an objected oriented language where the\n this/self variable is easily predictable, then you may\n find you need to read up on how confusing 'this' can be:\n\n https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/\n https://aka.ms/AA5ugm2\n\n TLDR: this can change. The reference to which this refers\n to can be different depending on how you call the function.\n\n For example, if you use a reference to the func in another\n object, and then call it through that - the this variable\n has moved to refer to the hosting object:\n\n<code><pre>\nconst customObjectCapturingThis = { contents: \"http://gph.is/VxeHsW\", print: safe.printContents };\ncustomObjectCapturingThis.print(); // Prints \"http://gph.is/VxeHsW\" - not \"Crown Jewels\"\n\n</pre></code>\n// This is tricky, because when dealing with callback APIs -\n it can be very tempting to pass the function reference\n directly. This can be worked around by creating a new\n function at the call site.\n\n<code><pre>\nconst objectNotCapturingThis = { contents: \"N/A\", print: () => safe.printContents() };\nobjectNotCapturingThis.print();\n\n</pre></code>\n// There are a few ways to work around this problem. One\n route is to force the binding of this to be the object\n you originally intended via bind.\n\n<code><pre>\nconst customObjectCapturingThisAgain = { contents: \"N/A\", print: safe.printContents.bind(safe) };\ncustomObjectCapturingThisAgain.print();\n\n</pre></code>\n// To work around an unexpected this context, you can also\n change how you create functions in your class. By\n creating a property which uses an arrow function, the\n binding of this is done at a different time. Which makes\n it more predictable for those less experienced with the\n JavaScript runtime.\n\n<code><pre>\nclass SafelyBoundSafe {\n  contents: string;\n\n  constructor(contents: string) {\n    this.contents = contents;\n  }\n\n  printContents = () => {\n    console.log(this.contents);\n  };\n}\n\n</pre></code>\n// Now passing the function to another object\n to run does not accidentally change this.\n\n<code><pre>\nconst saferSafe = new SafelyBoundSafe(\"Golden Skull\");\nsaferSafe.printContents();\n\nconst customObjectTryingToChangeThis = {\n  contents: \"http://gph.is/XLof62\",\n  print: saferSafe.printContents,\n};\n\ncustomObjectTryingToChangeThis.print();\n\n</pre></code>\n// If you have a TypeScript project, you can use the compiler\n flag noImplicitThis to highlight cases where TypeScript\n cannot determine what type \"this\" is for a function.\n\n You can learn more about that in the handbook:\n\n https://www.typescriptlang.org/docs/handbook/utility-types.html#thistypet\n","redirectHref":"/play/?#example/this"}},"staticQueryHashes":[]}