{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/javascript/external-apis/typescript-with-webgl.js.html","result":{"pageContext":{"name":"TypeScript with WebGL","title":"TypeScript with WebGL","lang":"en","html":"\n This example creates an HTML canvas which uses WebGL to\n render spinning confetti using JavaScript. We're going\n to walk through the code to understand how it works, and\n see how TypeScript's tooling provides useful insight.\n\n This example builds off: example:working-with-the-dom\n\n First up, we need to create an HTML canvas element, which\n we do via the DOM API and set some inline style attributes:\n\n<code><pre>\nconst canvas = document.createElement(\"canvas\")\ncanvas.id = \"spinning-canvas\"\ncanvas.style.backgroundColor = \"#0078D4\"\ncanvas.style.position = \"fixed\"\ncanvas.style.bottom = \"10px\"\ncanvas.style.right = \"20px\"\ncanvas.style.width = \"500px\"\ncanvas.style.height = \"400px\"\n\n</pre></code>\n// Next, to make it easy to make changes, we remove any older\n versions of the canvas when hitting \"Run\" - now you can\n make changes and see them reflected when you press \"Run\"\n or (cmd + enter):\n\n<code><pre>\nconst existingCanvas = document.getElementById(canvas.id)\nif (existingCanvas && existingCanvas.parentElement) {\n  existingCanvas.parentElement.removeChild(existingCanvas)\n}\n\n</pre></code>\n// Tell the canvas element that we will use WebGL to draw\n inside the element (and not the default raster engine):\n\n<code><pre>\nconst gl = canvas.getContext(\"webgl\")\n\n</pre></code>\n// Next we need to create vertex shaders - these roughly are\n small programs that apply maths to a set of incoming\n array of vertices (numbers).\n\n You can see the large set of attributes at the top of the shader,\n these are passed into the compiled shader further down the example.\n\n There's a great overview on how they work here:\n https://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html\n\n<code><pre>\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER)\ngl.shaderSource(\n  vertexShader,\n  `\nprecision lowp float;\n\nattribute vec2 a_position; // Flat square on XY plane\nattribute float a_startAngle;\nattribute float a_angularVelocity;\nattribute float a_rotationAxisAngle;\nattribute float a_particleDistance;\nattribute float a_particleAngle;\nattribute float a_particleY;\nuniform float u_time; // Global state\n\nvarying vec2 v_position;\nvarying vec3 v_color;\nvarying float v_overlight;\n\nvoid main() {\n  float angle = a_startAngle + a_angularVelocity * u_time;\n  float vertPosition = 1.1 - mod(u_time * .25 + a_particleY, 2.2);\n  float viewAngle = a_particleAngle + mod(u_time * .25, 6.28);\n\n  mat4 vMatrix = mat4(\n    1.3, 0.0, 0.0, 0.0,\n    0.0, 1.3, 0.0, 0.0,\n    0.0, 0.0, 1.0, 1.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  mat4 shiftMatrix = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    a_particleDistance * sin(viewAngle), vertPosition, a_particleDistance * cos(viewAngle), 1.0\n  );\n\n  mat4 pMatrix = mat4(\n    cos(a_rotationAxisAngle), sin(a_rotationAxisAngle), 0.0, 0.0,\n    -sin(a_rotationAxisAngle), cos(a_rotationAxisAngle), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  ) * mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(angle), sin(angle), 0.0,\n    0.0, -sin(angle), cos(angle), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  gl_Position = vMatrix * shiftMatrix * pMatrix * vec4(a_position * 0.03, 0.0, 1.0);\n  vec4 normal = vec4(0.0, 0.0, 1.0, 0.0);\n  vec4 transformedNormal = normalize(pMatrix * normal);\n\n  float dotNormal = abs(dot(normal.xyz, transformedNormal.xyz));\n  float regularLighting = dotNormal / 2.0 + 0.5;\n  float glanceLighting = smoothstep(0.92, 0.98, dotNormal);\n  v_color = vec3(\n    mix((0.5 - transformedNormal.z / 2.0) * regularLighting, 1.0, glanceLighting),\n    mix(0.5 * regularLighting, 1.0, glanceLighting),\n    mix((0.5 + transformedNormal.z / 2.0) * regularLighting, 1.0, glanceLighting)\n  );\n\n  v_position = a_position;\n  v_overlight = 0.9 + glanceLighting * 0.1;\n}\n`\n)\ngl.compileShader(vertexShader)\n\n</pre></code>\n// This example also uses fragment shaders - a fragment\n shader is another small program that runs through every\n pixel in the canvas and sets its color.\n\n In this case, if you play around with the numbers you can see how\n this affects the lighting in the scene, as well as the border\n radius on the confetti:\n\n<code><pre>\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)\ngl.shaderSource(\n  fragmentShader,\n  `\nprecision lowp float;\nvarying vec2 v_position;\nvarying vec3 v_color;\nvarying float v_overlight;\n\nvoid main() {\n  gl_FragColor = vec4(v_color, 1.0 - smoothstep(0.8, v_overlight, length(v_position)));\n}\n`\n)\ngl.compileShader(fragmentShader)\n\n</pre></code>\n// Takes the compiled shaders and adds them to the canvas'\n WebGL context so that can be used:\n\n<code><pre>\nconst shaderProgram = gl.createProgram()\ngl.attachShader(shaderProgram, vertexShader)\ngl.attachShader(shaderProgram, fragmentShader)\ngl.linkProgram(shaderProgram)\ngl.useProgram(shaderProgram)\n\ngl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())\n\n</pre></code>\n// We need to get/set the input variables into the shader in a\n memory-safe way, so the order and the length of their\n values needs to be stored.\n\n<code><pre>\nconst attrs = [\n  { name: \"a_position\", length: 2, offset: 0 }, // e.g. x and y represent 2 spaces in memory\n  { name: \"a_startAngle\", length: 1, offset: 2 }, // but angle is just 1 value\n  { name: \"a_angularVelocity\", length: 1, offset: 3 },\n  { name: \"a_rotationAxisAngle\", length: 1, offset: 4 },\n  { name: \"a_particleDistance\", length: 1, offset: 5 },\n  { name: \"a_particleAngle\", length: 1, offset: 6 },\n  { name: \"a_particleY\", length: 1, offset: 7 }\n]\n\nconst STRIDE = Object.keys(attrs).length + 1\n\n</pre></code>\n// Loop through our known attributes and create pointers in memory for the JS side\n to be able to fill into the shader.\n\n To understand this API a little bit: WebGL is based on OpenGL\n which is a state-machine styled API. You pass in commands in a\n particular order to render things to the screen.\n\n So, the intended usage is often not passing objects to every WebGL\n API call, but instead passing one thing to one function, then passing\n another to the next. So, here we prime WebGL to create an array of\n vertex pointers:\n\n<code><pre>\nfor (var i = 0; i < attrs.length; i++) {\n  const name = attrs[i].name\n  const length = attrs[i].length\n  const offset = attrs[i].offset\n  const attribLocation = gl.getAttribLocation(shaderProgram, name)\n  gl.vertexAttribPointer(attribLocation, length, gl.FLOAT, false, STRIDE * 4, offset * 4)\n  gl.enableVertexAttribArray(attribLocation)\n}\n\n// Then on this line they are bound to an array in memory:\n\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer())\n\n// Set up some constants for rendering:\n\nconst NUM_PARTICLES = 200\nconst NUM_VERTICES = 4\n\n</pre></code>\n// Try reducing this one and hitting \"Run\" again,\n it represents how many points should exist on\n each confetti and having an odd number sends\n it way out of whack.\n\n<code><pre>\nconst NUM_INDICES = 6\n\n// Create the arrays of inputs for the vertex shaders\nconst vertices = new Float32Array(NUM_PARTICLES * STRIDE * NUM_VERTICES)\nconst indices = new Uint16Array(NUM_PARTICLES * NUM_INDICES)\n\nfor (let i = 0; i < NUM_PARTICLES; i++) {\n  const axisAngle = Math.random() * Math.PI * 2\n  const startAngle = Math.random() * Math.PI * 2\n  const groupPtr = i * STRIDE * NUM_VERTICES\n\n  const particleDistance = Math.sqrt(Math.random())\n  const particleAngle = Math.random() * Math.PI * 2\n  const particleY = Math.random() * 2.2\n  const angularVelocity = Math.random() * 2 + 1\n\n  for (let j = 0; j < 4; j++) {\n    const vertexPtr = groupPtr + j * STRIDE\n    vertices[vertexPtr + 2] = startAngle       // Start angle\n    vertices[vertexPtr + 3] = angularVelocity  // Angular velocity\n    vertices[vertexPtr + 4] = axisAngle        // Angle diff\n    vertices[vertexPtr + 5] = particleDistance // Distance of the particle from the (0,0,0)\n    vertices[vertexPtr + 6] = particleAngle    // Angle around Y axis\n    vertices[vertexPtr + 7] = particleY        // Angle around Y axis\n  }\n\n  // Coordinates\n  vertices[groupPtr] = vertices[groupPtr + STRIDE * 2] = -1\n  vertices[groupPtr + STRIDE] = vertices[groupPtr + STRIDE * 3] = +1\n  vertices[groupPtr + 1] = vertices[groupPtr + STRIDE + 1] = -1\n  vertices[groupPtr + STRIDE * 2 + 1] = vertices[groupPtr + STRIDE * 3 + 1] = +1\n\n  const indicesPtr = i * NUM_INDICES\n  const vertexPtr = i * NUM_VERTICES\n  indices[indicesPtr] = vertexPtr\n  indices[indicesPtr + 4] = indices[indicesPtr + 1] = vertexPtr + 1\n  indices[indicesPtr + 3] = indices[indicesPtr + 2] = vertexPtr + 2\n  indices[indicesPtr + 5] = vertexPtr + 3\n}\n\n// Pass in the data to the WebGL context\ngl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW)\n\n\nconst timeUniformLocation = gl.getUniformLocation(shaderProgram, \"u_time\")\nconst startTime = (window.performance || Date).now()\n\n// Start the background colour as black\ngl.clearColor(0, 0, 0, 1)\n\n// Allow alpha channels on in the vertex shader\ngl.enable(gl.BLEND)\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE)\n\n// Set the WebGL context to be the full size of the canvas\ngl.viewport(0, 0, canvas.width, canvas.height)\n\n// Create a run-loop to draw all of the confetti\n;(function frame() {\n  gl.uniform1f(timeUniformLocation, ((window.performance || Date).now() - startTime) / 1000)\n\n  gl.clear(gl.COLOR_BUFFER_BIT)\n  gl.drawElements(\n    gl.TRIANGLES,\n    NUM_INDICES * NUM_PARTICLES,\n    gl.UNSIGNED_SHORT,\n    0\n  )\n  requestAnimationFrame(frame)\n})()\n\n</pre></code>\n// Add the new canvas element into the bottom left\n of the playground\n<code><pre>\ndocument.body.appendChild(canvas)\n\n</pre></code>\n// Credit: based on this JSFiddle by Subzey\n https://jsfiddle.net/subzey/52sowezj/\n","redirectHref":"/play/?#example/typescript-with-webgl"}},"staticQueryHashes":[]}