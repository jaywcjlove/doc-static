{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/javascript/functions-with-javascript/typing-functions.ts.html","result":{"pageContext":{"name":"Typing Functions","title":"Typing Functions","lang":"en","html":" TypeScript's inference can get you very far, but there\n are lots of extra ways to provide a richer way to document\n the shape of your functions.\n\n A good first place is to look at optional params, which\n is a way of letting others know you can skip params.\n\n<code><pre>\nlet i = 0;\nconst incrementIndex = (value?: number) => {\n  i += value === undefined ? 1 : value;\n};\n\n// This function can be called like:\n\nincrementIndex();\nincrementIndex(0);\nincrementIndex(3);\n\n</pre></code>\n// You can type parameters as functions, which provides\n type inference when you write the functions.\n\n<code><pre>\nconst callbackWithIndex = (callback: (i: number) => void) => {\n  callback(i);\n};\n\n</pre></code>\n// Embedding function interfaces can get a bit hard to read\n with all the arrows. Using a type alias will let you name\n the function param.\n\n<code><pre>\ntype NumberCallback = (i: number) => void;\nconst callbackWithIndex2 = (callback: NumberCallback) => {\n  callback(i);\n};\n\n// These can be called like:\n\ncallbackWithIndex(index => {\n  console.log(index);\n});\n\n</pre></code>\n// By hovering on index above, you can see how TypeScript\n has inferred the index to be a number correctly.\n\n TypeScript inference can work when passing a function\n as an instance reference too. To show this, we'll use\n a function which changed a number into string:\n\n<code><pre>\nconst numberToString = (n: number) => {\n  return n.toString();\n};\n\n</pre></code>\n// This can be used in a function like map on an array\n to convert all numbers into a string, if you hover\n on stringedNumbers below you can see the expected types.\n<code><pre>\nconst stringedNumbers = [1, 4, 6, 10].map(i => numberToString(i));\n\n</pre></code>\n// We can use shorthand to have the function passed directly\n and get the same results with more focused code:\n<code><pre>\nconst stringedNumbersTerse = [1, 4, 6, 10].map(numberToString);\n\n</pre></code>\n// You may have functions which could accept a lot of types\n but you are only interested in a few properties. This is\n a useful case for indexed signatures in types. The\n following type declares that this function is OK to use\n any object so long as it includes the property name:\n\n<code><pre>\ninterface AnyObjectButMustHaveName {\n  name: string;\n  [key: string]: any;\n}\n\nconst printFormattedName = (input: AnyObjectButMustHaveName) => {};\n\nprintFormattedName({ name: \"joey\" });\nprintFormattedName({ name: \"joey\", age: 23 });\n\n</pre></code>\n// If you'd like to learn more about index-signatures\n we recommend:\n\n https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks\n https://basarat.gitbooks.io/typescript/docs/types/index-signatures.html\n\n You can also allow this kind of behavior everywhere\n via the tsconfig flag suppressExcessPropertyErrors -\n however, you can't know if others using your API have\n this set to off.\n\n Functions in JavaScript can accept different sets of params.\n There are two common patterns for describing these: union\n types for parameters/return, and function overloads.\n\n Using union types in your parameters makes sense if there\n are only one or two changes and documentation does not need\n to change between functions.\n\n<code><pre>\nconst boolOrNumberFunction = (input: boolean | number) => {};\n\nboolOrNumberFunction(true);\nboolOrNumberFunction(23);\n\n</pre></code>\n// Function overloads on the other hand offer a much richer\n syntax for the parameters and return types.\n\n<code><pre>\ninterface BoolOrNumberOrStringFunction {\n  /** Takes a bool, returns a bool */\n  (input: boolean): boolean;\n  /** Takes a number, returns a number */\n  (input: number): number;\n  /** Takes a string, returns a bool */\n  (input: string): boolean;\n}\n\n</pre></code>\n// If this is your first time seeing declare, it allows you\n to tell TypeScript something exists even if it doesn't\n exist in the runtime in this file. Useful for mapping\n code with side-effects but extremely useful for demos\n where making the implementation would be a lot of code.\n\n<code><pre>\ndeclare const boolOrNumberOrStringFunction: BoolOrNumberOrStringFunction;\n\nconst boolValue = boolOrNumberOrStringFunction(true);\nconst numberValue = boolOrNumberOrStringFunction(12);\nconst boolValue2 = boolOrNumberOrStringFunction(\"string\");\n\n</pre></code>\n// If you hover over the above values and functions you\n can see the right documentation and return values.\n\n Using function overloads can get you very far, however\n there's another tool for dealing with different types of\n inputs and return values and that is generics.\n\n These provide a way for you to have types as placeholder\n variables in type definitions.\n\n example:generic-functions\n example:function-chaining\n","redirectHref":"/play/?#example/typing-functions"}},"staticQueryHashes":[]}