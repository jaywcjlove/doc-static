{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/javascript/functions-with-javascript/generic-functions.ts.html","result":{"pageContext":{"name":"Generic Functions","title":"Generic Functions","lang":"en","html":" Generics provide a way to use Types as variables in other\n types. Meta.\n\n We'll be trying to keep this example light, you can do\n a lot with generics and it's likely you will see some very\n complicated code using generics at some point - but that\n does not mean that generics are complicated.\n\n Let's start with an example where we wrap an input object\n in an array. We will only care about one variable in this\n case, the type which was passed in:\n\n<code><pre>\nfunction wrapInArray<Type>(input: Type): Type[] {\n  return [input];\n}\n\n</pre></code>\n// Note: it's common to see Type referred to as T. This is\n culturally similar to how people use i in a for loop to\n represent index. T normally represents Type, so we'll\n be using the full name for clarity.\n\n Our function will use inference to always keep the type\n passed in the same as the type passed out (though\n it will be wrapped in an array).\n\n<code><pre>\nconst stringArray = wrapInArray(\"hello generics\");\nconst numberArray = wrapInArray(123);\n\n</pre></code>\n// We can verify this works as expected by checking\n if we can assign a string array to a function which\n should be an object array:\n<code><pre>\nconst notStringArray: string[] = wrapInArray({});\n\n</pre></code>\n// You can also skip the generic inference by adding the\n type yourself also:\n<code><pre>\nconst stringArray2 = wrapInArray<string>(\"\");\n\n</pre></code>\n// wrapInArray allows any type to be used, however there\n are cases when you need to only allow a subset of types.\n In these cases you can say the type has to extend a\n particular type.\n\n<code><pre>\ninterface Drawable {\n  draw: () => void;\n}\n\n</pre></code>\n// This function takes a set of objects which have a function\n for drawing to the screen\n<code><pre>\nfunction renderToScreen<Type extends Drawable>(input: Type[]) {\n  input.forEach((i) => i.draw());\n}\n\nconst objectsWithDraw = [{ draw: () => {} }, { draw: () => {} }];\nrenderToScreen(objectsWithDraw);\n\n// It will fail if draw is missing:\n\nrenderToScreen([{}, { draw: () => {} }]);\n\n</pre></code>\n// Generics can start to look complicated when you have\n multiple variables. Here is an example of a caching\n function that lets you have different sets of input types\n and caches.\n\n<code><pre>\ninterface CacheHost {\n  save: (a: any) => void;\n}\n\nfunction addObjectToCache<Type, Cache extends CacheHost>(obj: Type, cache: Cache): Cache {\n  cache.save(obj);\n  return cache;\n}\n\n</pre></code>\n// This is the same as above, but with an extra parameter.\n Note: to make this work though, we had to use an any. This\n can be worked out by using a generic interface.\n\n<code><pre>\ninterface CacheHostGeneric<ContentType> {\n  save: (a: ContentType) => void;\n}\n\n</pre></code>\n// Now when the CacheHostGeneric is used, you need to tell\n it what ContentType is.\n\n<code><pre>\nfunction addTypedObjectToCache<Type, Cache extends CacheHostGeneric<Type>>(obj: Type, cache: Cache): Cache {\n  cache.save(obj);\n  return cache;\n}\n\n</pre></code>\n// That escalated pretty quickly in terms of syntax. However,\n this provides more safety. These are trade-offs, that you\n have more knowledge to make now. When providing APIs for\n others, generics offer a flexible way to let others use\n their own types with full code inference.\n\n For more examples of generics with classes and interfaces:\n\n example:advanced-classes\n example:typescript-with-react\n https://www.typescriptlang.org/docs/handbook/generics.html\n","redirectHref":"/play/?#example/generic-functions"}},"staticQueryHashes":[]}