{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/javascript/javascript-essentials/objects-and-arrays.ts.html","result":{"pageContext":{"name":"Objects and Arrays","title":"Objects and Arrays","lang":"en","html":"\n JavaScript objects are collections of values wrapped up\n with named keys.\n\n<code><pre>\nconst userAccount = {\n  name: \"Kieron\",\n  id: 0,\n};\n\n</pre></code>\n// You can combine these to make larger, more complex\n data-models.\n\n<code><pre>\nconst pie = {\n  type: \"Apple\",\n};\n\nconst purchaseOrder = {\n  owner: userAccount,\n  item: pie,\n};\n\n</pre></code>\n// If you use your mouse to hover over some of these words\n (try purchaseOrder above) you can see how TypeScript is\n interpreting your JavaScript into labeled types.\n\n Values can be accessed via the \".\", so to get a\n username for a purchase order:\n<code><pre>\nconsole.log(purchaseOrder.item.type);\n\n</pre></code>\n// If you hover your mouse over each part of the code\n between the ()s, you can see TypeScript offering more\n information about each part. Try re-writing this below:\n\n Copy this in the next line, character by character:\n\n   purchaseOrder.item.type\n\n TypeScript provides feedback to the playground\n about what JavaScript objects are available in this\n file and lets you avoid typos and see additional\n information without having to look it up in another place.\n\n TypeScript also offers these same features to arrays.\n Here's an array with just our purchase order above in it.\n\n<code><pre>\nconst allOrders = [purchaseOrder];\n\n</pre></code>\n// If you hover on allOrders, you can tell it's an array\n because the hover info ends with []. You can access the\n first order by using square brackets with an index\n (starting from zero).\n\n<code><pre>\nconst firstOrder = allOrders[0];\nconsole.log(firstOrder.item.type);\n\n</pre></code>\n// An alternative way to get an object is via pop-ing the\n array to remove objects. Doing this removes the object\n from the array, and returns the object. This is called\n mutating the array, because it changes the underlying\n data inside it.\n\n<code><pre>\nconst poppedFirstOrder = allOrders.pop();\n\n</pre></code>\n// Now allOrders is empty. Mutating data can be useful for\n many things, but one way to reduce the complexity in your\n codebases is to avoid mutation. TypeScript offers a way\n to declare an array readonly instead:\n\n Creates a type based on the shape of a purchase order:\n<code><pre>\ntype PurchaseOrder = typeof purchaseOrder;\n\n// Creates a readonly array of purchase orders\nconst readonlyOrders: readonly PurchaseOrder[] = [purchaseOrder];\n\n</pre></code>\n// Yep! That's a bit more code for sure. There's four\n new things here:\n\n  type PurchaseOrder - Declares a new type to TypeScript.\n\n  typeof - Use the type inference system to set the type\n           based on the const which is passed in next.\n\n  purchaseOrder - Get the variable purchaseOrder and tell\n                  TypeScript this is the shape of all\n                  objects in the orders array.\n\n  readonly - This object does not support mutation, once\n             it is created then the contents of the array\n             will always stay the same.\n\n Now if you try to pop from the readonlyOrders, TypeScript\n will raise an error.\n\n<code><pre>\nreadonlyOrders.pop();\n\n</pre></code>\n// You can use readonly in all sorts of places, it's a\n little bit of extra syntax here and there, but it\n provides a lot of extra safety.\n\n You can find out more about readonly:\n  - https://www.typescriptlang.org/docs/handbook/interfaces.html#readonly-properties\n  - https://basarat.gitbooks.io/typescript/content/docs/types/readonly.html\n\n And you can carry on learning about JavaScript and\n TypeScript in the example on functions:\n example:functions\n\n Or if you want to know more about immutability:\n example:immutability\n","redirectHref":"/play/?strict=false#example/objects-and-arrays"}},"staticQueryHashes":[]}