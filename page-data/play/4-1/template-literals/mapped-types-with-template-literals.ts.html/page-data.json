{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/4-1/template-literals/mapped-types-with-template-literals.ts.html","result":{"pageContext":{"name":"Mapped Types with Template Literals","title":"Mapped Types with Template Literals","lang":"en","html":"\n TypeScript 4.1 added support for template literals, you can\n understand some of the basics in example:intro-to-template-literals\n\n 4.1 introduces new syntax inside a mapped types declaration,\n you can now use \"as `templated string`\" which can be used to transform\n strings inside a union.\n\n For example, this type will transform all of the properties of an existing\n type into four functions which correspond to traditional REST calls.\n\n Template strings literals to describe each API endpoint:\n<code><pre>\ntype GET<T extends string> = `get${Capitalize<T>}`\ntype POST<T extends string> = `post${Capitalize<T>}`\ntype PUT<T extends string> = `put${Capitalize<T>}`\ntype DELETE<T extends string> = `delete${Capitalize<T>}`\n\n// A union of the above literal types\ntype REST<T extends string> = GET<T> | POST<T> | PUT<T> | DELETE<T>\n\n</pre></code>\n// Takes a type, then for each string property in the type, map\n that key to REST above, which would create the four functions.\n\n<code><pre>\ntype RESTify<Type> = {\n  [Key in keyof Type as REST<Key extends string ? Key : never>]: () => Type[Key]\n};\n\n</pre></code>\n// The `Key extends string ? Key : never` is needed because an object\n can contain strings, numbers and symbols as keys. We can only handle\n the string cases here.\n\n Now we have a list of objects available through the API:\n\n<code><pre>\ninterface APIs {\n  artwork: { id: string, title: string };\n  artist: { id: string, name: string };\n  location: { id: string, address: string, country: string }\n}\n\n// Then when we have an object which uses these types\ndeclare const api: RESTify<APIs>\n\n// Then all these functions are automatically created \napi.getArtist()\napi.postArtist()\napi.putLocation()\n\n</pre></code>\n// Continue learning more about template literals in:\n example:string-manipulation-with-template-literals\n\n Or read the announcement blog post:\n https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#template-literal-types\n\n","redirectHref":"/play/?ts=4.1.0-dev.20201028#example/mapped-types-with-template-literals"}},"staticQueryHashes":[]}