{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/4-1/template-literals/string-manipulation-with-template-literals.ts.html","result":{"pageContext":{"name":"String Manipulation with Template Literals","title":"String Manipulation with Template Literals","lang":"en","html":"\n Template literals can be used to extract and manipulate string literal types.\n These string literal types, in turn, can be used as properties, and can describe\n possible transformations from a string to an object in an API.\n\n ## String Splitting To An Object\n\n Template literals can use patterns as \"split-points\" to infer the\n substrings in between. For example...\n\n This type is a string literal which conforms to a SemVer-like string.\n<code><pre>\ntype TSVersion = \"4.1.2\"\n\n</pre></code>\n// We can create a type to extract the components of that string.\n We'll split across two '.' characters.\n<code><pre>\ntype ExtractSemver<SemverString extends string> = \n   SemverString extends `${infer Major}.${infer Minor}.${infer Patch}` ? \n        { major: Major, minor: Minor, patch: Patch } : { error: \"Cannot parse semver string\" }\n\n</pre></code>\n// Line 1 should be familiar if you've looked at the preceding examples:\n example:intro-to-template-literals / example:mapped-types-with-template-literals\n\n Line 2 is a conditional type, TypeScript validates that the infer pattern matches\n against SemverString parameter.\n\n Line 3 is the result of the conditional, if true then provide an object\n with the substrings passed into different positions in an object. If the string\n does not match, then return the type with an error shape.\n\n<code><pre>\ntype TS = ExtractSemver<TSVersion>\n\n// This won't handle SemVer 100%, because it is an example:\ntype BadSemverButOKString = ExtractSemver<\"4.0.Four.4444\">\n\n</pre></code>\n// However, ExtractSemver will fail on strings which don't fit the format. This case\n will only match when a string has the format \"X.Y.Z\", which the next line does not:\n<code><pre>\ntype SemverError = ExtractSemver<\"Four point Zero point Five\">\n\n// ## Recursive String Splitting\n\n</pre></code>\n// The previous example will only work when you have an exact string to match,\n for more nuanced cases you want work with the TypeScript 4.0 feature: example:variadic-tuples.\n\n To split a string into re-usable components, Tuples are a good way to keep\n track of the results. Here's a split type:\n\n<code><pre>\ntype Split<S extends string, D extends string> =\n    string extends S ? string[] :\n        S extends '' ? [] :\n            S extends `${infer T}${D}${infer U}` ?  [T, ...Split<U, D>] :  [S];\n\n</pre></code>\n// Line 1 declares two params, we'll use single characters for brevity\n S represents the string to split, and D is the deliminator. This\n line ensures they are both strings.\n\n Line 2 checks if string is a literal, by checking if a general string\n can be extended from the input string. If so, return a string array. We\n can't work with non-literal string.\n\n E.g. this case:\n<code><pre>\ntype S1 = Split<string, \".\">\n\n// Line 3 checks if the string is empty, if so return an empty tuple\ntype S2 = Split<\"\", \".\">\n\n</pre></code>\n// Line 4 has a similar check to our ExtractSemver. If the string matches\n `[Prefix as T][Deliminator][Suffix as U]` then extract the prefix (T) into the\n first parameter of a tuple, then re-run Split on the suffix (U) to ensure\n that more than one match can be found.\n\n If the string does not include the deliminator, then return a tuple of 1 \n length which contains the string passed in as an argument (S).\n\n Simple case\n<code><pre>\ntype S3 = Split<\"1.2\", \".\">\n\n// Will recurse once to get all the .'s splitted\ntype S4 = Split<\"1.2.3\", \".\">\n\n// The \n\n</pre></code>\n// With this knowledge, you should be able to read and understand quite a\n few of the community examples of template literals, for example:\n\n - An express route extractor by Dan Vanderkam\n https://twitter.com/danvdk/status/1301707026507198464\n\n - A definition for document.querySelector by Mike Ryan\n https://twitter.com/mikeryandev/status/1308472279010025477\n\n People have also experimented with quite complicated string parsers \n using template string literals, which are fun - but not recommended for\n production codebases.\n\n https://github.com/ghoullier/awesome-template-literal-types\n \n Or read the announcement blog post:\n https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#template-literal-types\n","redirectHref":"/play/?ts=4.1.0-dev.20201028#example/string-manipulation-with-template-literals"}},"staticQueryHashes":[]}