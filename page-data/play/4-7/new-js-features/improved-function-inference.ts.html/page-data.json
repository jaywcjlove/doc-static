{"componentChunkName":"component---src-templates-play-example-tsx","path":"/play/4-7/new-js-features/improved-function-inference.ts.html","result":{"pageContext":{"name":"Improved Function Inference","title":"Improved Function Inference","lang":"en","html":" With TypeScript 4.7, there are improvements in how types\n are inferred from typed function calls.\n\n Take this function 'cache', it takes one type parameter, 'Type'\n and one function argument, which contains two functions.\n\n<code><pre>\ndeclare function cache<Type>(arg: { add: (n: string) => Type; process: (x: Type) => void }): void;\n\n</pre></code>\n// When TypeScript is trying to infer the type of 'Type', it\n has two potential places to look:\n\n - the return of 'add'\n - the first parameter of 'remove'\n\n TypeScript's code inference now takes more these cases into\n account with more code styles, and also handle cases where the\n types depend on each other.\n\n<code><pre>\ncache({\n  add: n => n,\n  process: x => x.toLowerCase(),\n});\n\n</pre></code>\n// Here Type = string because `add` returns a string\n which is the parameter type. However, prior versions of\n TypeScript would infer Type = any/unknown because both\n add and process would be evaluated at the same time.\n\n<code><pre>\ncache({\n  add: function (str) {\n    return { value: str + \"!\" };\n  },\n  process: x => x.value.toLowerCase(),\n});\n\n// Here Type = { value: string }\n\ncache({\n  add() {\n    return 23;\n  },\n  process: x => x + 1,\n});\n\n// Here Type = number\n\n</pre></code>\n// This helps JavaScript and TypeScript users experience\n less accidental anys when working across different\n code styles.\n","redirectHref":"/play/?ts=4.7.3#example/improved-function-inference"}},"staticQueryHashes":[]}