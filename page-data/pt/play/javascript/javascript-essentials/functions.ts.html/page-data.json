{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/javascript/javascript-essentials/functions.ts.html","result":{"pageContext":{"name":"Functions","title":"Functions","lang":"pt","html":"\nExistem várias maneiras de declarar uma função em JavaScript.\nVejamos uma função que adiciona dois números:\n\nCrie uma função de escopo global chamado addOldSchool\n<code><pre>\nfunction addOldSchool(x, y) {\n  return x + y;\n}\n\n//Você pode mover o nome da função para uma variável também\nconst anonymousOldSchoolFunction = function (x, y) {\n  return x + y;\n};\n\n//Você pode também usar a forma abreviada de uma Arrow Function\nconst addFunction = (x, y) => {\n  return x + y;\n};\n\n</pre></code>\n//Nós iremos focar na última forma, porém tudo se aplica para\nos três formatos\n\nTypeScript fornece uma sintaxe adicional para a \ndefinição da função e dá dicas de quais tipagens são\nesperadas por essa função\n\nA seguir temos uma versão simples da função de adicionar,\na qual recebe dois parametros de qualquer tipagem (any): \npoderiam ser passadas strings, números ou objetos.\n\n<code><pre>\nconst add1 = (x: any, y: any) => {\n  return x + y;\n};\nadd1(\"Hello\", 23);\n\n</pre></code>\n//Isso é legítimo em JavaScript (strings podem ser \nadicionados como esse exemplo), porém não é o ideal para \nnossa função, que sabemos que é para números, portanto\niremos converter os parametros x e y para receberem somente números.\n\n<code><pre>\nconst add2 = (x: number, y: number) => {\n  return x + y;\n};\nadd2(16, 23);\nadd2(\"Hello\", 23);\n\n</pre></code>\n//Ótimo. Nós receberemos um erro quando algo que não seja um número\nfor passado. Se você passar o mouse sbre a palavra add2 acima, verá\nque o TypeScript os descreve como:\n\n   const add2: (x: number, y: number) => number\n\nOnde foi deduzido que, quando os dois parametros são números,\no único tipo de retorno possível é um número.\nIsso é ótimo, você não precisa escrever sintaxe extra.\nVejamos o que é preciso para fazer isso:\n\n<code><pre>\nconst add3 = (x: number, y: number): string => {\n  return x + y;\n};\n\n</pre></code>\n//Essa função falha porque informamos ao TypeScript \nque ela deveria retornar uma string, mas a função \nnão cumpriu com o esperado.\n\n<code><pre>\nconst add4 = (x: number, y: number): number => {\n  return x + y;\n};\n\n</pre></code>\n//Isso é uma versão mais explícita de add2 - Existem casos\nem que você talvez queira usar uma sintaxe explícita do tipo \nde retorno para dar espaço para trabalhar antes de começar.\nUm pouco como o desenvolvimento orientado a testes (TDD) recomenda\ncomeçar com um teste com falha, mas nesse caso, é com o formato\nde uma função com falha.\n\nEste exemplo é apenas uma introdução, você pode aprender muito mais\ncomo as funções funcionam no TypeScript no manual e na\nseção de exemplos de JavaScript Funcional:\n\n https://www.typescriptlang.org/docs/handbook/functions.html\n example:function-chaining\n\nE para continuar nosso tour pelos fundamentos do JavaScript,\nveremos como o fluxo de código afeta a tipagem do TypeScript:\nexample:code-flow\n","redirectHref":"pt/play/?noImplicitAny=false#example/functions"}},"staticQueryHashes":[]}