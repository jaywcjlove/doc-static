{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/javascript/working-with-classes/mixins.ts.html","result":{"pageContext":{"name":"Mixins","title":"Mixins","lang":"pt","html":"\n Mixins são um falso padrão de herança múltipla para classes\n em JavaScript para o qual o TypeScript tem suporte. O padrão\n permite que você crie uma classe que é uma fusão de múltiplas\n classes.\n\n Para começar, precisamos de um tipo que usaremos para estender\n de outras classes. A principal responsabilidade é declarar\n que o tipo que está sendo passado é uma classe.\n\n<code><pre>\ntype Constructor = new (...args: any[]) => {};\n\n</pre></code>\n// Então podemos criar uma série de classes que estendem\n a classe final envolvendo-a. Este padrão funciona bem\n quando objetos semelhantes têm recursos diferentes.\n\n Este mixin adiciona uma propriedade de escala, com getters e setters\n para alterá-lo com uma propriedade privada encapsulada:\n\n<code><pre>\nfunction Scale<TBase extends Constructor>(Base: TBase) {\n  return class extends Base {\n    // Mixins não podem declarar propriedades privadas / protegidas\n    // entretanto, você pode usar campos privados ES2020\n    _scale = 1;\n\n    setScale(scale: number) {\n      this._scale = scale;\n    }\n\n    get scale(): number {\n      return this._scale;\n    }\n  };\n}\n\n</pre></code>\n// Este mixin adiciona métodos extras em torno da composição alpha\n algo que os computadores modernos usam para criar profundidade:\n\n<code><pre>\nfunction Alpha<TBase extends Constructor>(Base: TBase) {\n  return class extends Base {\n    alpha = 1;\n\n    setHidden() {\n      this.alpha = 0;\n    }\n\n    setVisible() {\n      this.alpha = 1;\n    }\n\n    setAlpha(alpha: number) {\n      this.alpha = alpha;\n    }\n  };\n}\n\n// Uma classe base de sprite simples que será estendida:\n\nclass Sprite {\n  name = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n</pre></code>\n// Aqui nós criamos dois tipos diferentes de sprites\n que têm recursos diferentes:\n\n<code><pre>\nconst ModernDisplaySprite = Alpha(Scale(Sprite));\nconst EightBitSprite = Scale(Sprite);\n\n</pre></code>\n// A criação de instâncias dessas classes mostra que\n os objetos têm diferentes conjuntos de propriedades\n e métodos devido aos seus mixins:\n\n<code><pre>\nconst flappySprite = new ModernDisplaySprite(\"Bird\");\nflappySprite.x = 10;\nflappySprite.y = 20;\nflappySprite.setVisible();\nflappySprite.setScale(0.8);\nconsole.log(flappySprite.scale);\n\nconst gameBoySprite = new EightBitSprite(\"L block\");\ngameBoySprite.setScale(0.3);\n\n</pre></code>\n// Falha porque um EightBitSprite não tem\n o mixin para mudar alphas:\n<code><pre>\ngameBoySprite.setAlpha(0.5);\n\n</pre></code>\n// Se você quiser dar mais garantias sobre as classes\n que você embrulha, você pode usar um construtor com genéricos.\n\n<code><pre>\ntype GConstructor<T = {}> = new (...args: any[]) => T;\n\n</pre></code>\n// Agora você pode declarar que este mixin só pode ser\n aplicado quando a classe base tem uma determinada forma.\n\n<code><pre>\ntype Moveable = GConstructor<{ setXYAcceleration: (x: number, y: number) => void }>;\n\n</pre></code>\n// Podemos então criar um mixin que depende da função\n presente no parâmetro para o GConstructor acima.\n\n<code><pre>\nfunction Jumpable<TBase extends Moveable>(Base: TBase) {\n  return class extends Base {\n    jump() {\n      // Este mixin conhece setXYAcceleration agora\n      this.setXYAcceleration(0, 20);\n    }\n  };\n}\n\n</pre></code>\n// Não podemos criar este sprite até que haja uma classe\n na hierarquia mixin que adiciona setXYAcceleration:\n\n<code><pre>\nconst UserSprite = new Jumpable(ModernDisplaySprite);\n","redirectHref":"pt/play/?#example/mixins"}},"staticQueryHashes":[]}