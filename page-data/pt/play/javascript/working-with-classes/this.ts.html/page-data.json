{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/javascript/working-with-classes/this.ts.html","result":{"pageContext":{"name":"This","title":"This","lang":"pt","html":"\n Quando um método de uma classe é chamado, você geralmente espera\n que ele se refira a atual instância dessa classe.\n\n<code><pre>\nclass Cofre {\n  conteudo: string;\n  \n  constructor(conteudo: string) {\n    this.conteudo = conteudo;\n  }\n  \n  imprimeConteudo() {\n    console.log(this.conteudo);\n  }\n}\n\nconst cofre = new Cofre(\"Jóias da Coroa\");\ncofre.imprimeConteudo();\n\n</pre></code>\n// Se você veio de uma linguagem orientada a objetos onde\n a variável this/self é facilmente previsível, então você\n talvez precise ler sobre como o \"this\" pode ser confuso:\n\n https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/\n https://aka.ms/AA5ugm2\n\n Obs: isso pode mudar. A referência que o this se refere\n pode ser diferente dependendo de como você chama a função.\n\n Por exemplo, se você usa uma referência para uma função em\n outro objeto, e então chama ela através dele - a variável this\n vai passar a ter de referência o objeto que recebe:\n\n<code><pre>\nconst objetoCapturandoThis = { conteudo: \"http://gph.is/VxeHsW\", imprime: cofre.imprimeConteudo };\nobjetoCapturandoThis.imprime(); // Imprime \"http://gph.is/VxeHsW\", e não \"Jóias da Coroa\"\n\n</pre></code>\n// Isso é complicado, porque quando lidamos com callback de APIs\n pode ser bastante tentador passar a referência direto para\n a função. Isso pode ser resolvido criando uma nova função\n no lugar de chamada.\n\n<code><pre>\nconst objetoQueNaoCapturaThis = { conteudo: \"N/A\", imprime: () => cofre.imprimeConteudo() };\nobjetoQueNaoCapturaThis.imprime();\n\n</pre></code>\n// Existem algumas outras formas de resolver esse problema. Uma delas\n é forçar a ligação do this com o objeto que você originalmente\n pretendia ligar.\n\n<code><pre>\nconst objetoCapturandoOThisDeNovo = { conteudo: \"N/A\", imprime: cofre.imprimeConteudo.bind(cofre) };\nobjetoCapturandoOThisDeNovo.imprime();\n\n</pre></code>\n// Para lidar com um contexto inesperado, você também pode\n mudar a forma com que criou a função na sua classe.\n Ao criar uma função que use uma arrow function, o momento\n que a vinculação acontece vai ser diferente. O que faz com\n que seja mais previsível para os que têm menos experiência\n com o tempo de execução do JavaScript.\n\n<code><pre>\nclass CofreComSegurança {\n  conteudo: string;\n  \n  constructor(conteudo: string) {\n    this.conteudo = conteudo;\n  }\n  \n  imprimeConteudo = () => {\n    console.log(this.conteudo);\n  };\n}\n\n</pre></code>\n// Agora ao passar a função para outro objeto\n ele não vai acidentalmente mudar o this.\n\n<code><pre>\nconst cofreASegurado = new CofreComSegurança(\"Caveira de Cristal\");\ncofreASegurado.imprimeConteudo();\n\nconst objetoTentandoMudarOThis = {\n  conteudo: \"http://gph.is/XLof62\",\n  imprime: cofreASegurado.imprimeConteudo,\n};\n\nobjetoTentandoMudarOThis.imprime();\n\n</pre></code>\n// Se você tem um projeto em TypeScript, você pode usar a flag\n do compilador noImplicitThis para marcar casos onde o TypeScript\n não pode determinar que tipo de \"this\" é para a função.\n\n Você pode ler mais sobre no manual:\n\n https://www.typescriptlang.org/docs/handbook/utility-types.html#thistypet\n","redirectHref":"pt/play/?#example/this"}},"staticQueryHashes":[]}