{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/javascript/modern-javascript/import-export.ts.html","result":{"pageContext":{"name":"Import Export","title":"Import Export","lang":"pt","html":"\n O JavaScript adicionou import/export à linguagem em 2016\n e TypeScript tem suporte completo para esse estilo de\n conexão entre arquivos e entre modulos externos.\n O TypeScript expande essa sintaxe ao permitir que tipos\n sejam importados e exportados junto com o código.\n\n Vamos ver o import de código de um módulo.\n\n<code><pre>\nimport { danger, message, warn, DangerDSLType } from \"danger\";\n\n</pre></code>\n// Aqui importamos um conjunto de import nomeados\n (\"named imports\") de um módulo do Node chamado danger.\n Apesar de haver mais do que quatro imports,\n esses são os únicos que nós escolhemos importar.\n\n Nomeando especificamente quais imports você precisa,\n permite que ferramentas tenham a habilidade de remover\n código não utilizado em seu applicativo, e ajuda você a\n entender o que está sendo utilizado nessa arquivo em particular.\n\n Nesse caso: danger, message e warn são imports de JavaScript\n enquanto que DangerDSLType é uma interface.\n\n O TypeScript permite que engenheiros documentem seus códigos usando\n JSDoc, e a documentação é importada também. Por exemplo, se você\n passar o mouse sobre diferentes partes abaixo, você verá\n explicações sobre o que elas são.\n\n<code><pre>\ndanger.git.modified_files;\n\n</pre></code>\n// Se você quiser saber como criar essas anotações de documentação\n leia o exemplo:jsdoc-support\n\n Outro modo de importar código é através do export\n padrão de um módulo. Um exemplo disso é o módulo debug, o qual\n expõe uma função que cria uma função de log.\n\n<code><pre>\nimport debug from \"debug\";\nconst log = debug(\"playground\");\nlog(\"Código começou a rodar\");\n\n</pre></code>\n// Por conta das exports padrões (\"default exports\") não terem um nome,\n elas podem ser delicadas de se trabalhar junto com ferramentas de análise estática\n como o suporte a refactoração em TypeScript, mas elas têm o seu próprio uso.\n\n Por haver uma longa história sobre import/export de código\n em JavaScript, existe uma parte confusa sobre o export padrão:\n alguns módulos exportados tem documentação que sugere que você possa\n escrever um import como este:\n\n<code><pre>\nimport req from \"request\";\n\n</pre></code>\n// Entretanto, isto apresenta uma erro. E então você encontra no\n Stack Overflow uma recomendação de import como esta:\n\n<code><pre>\nimport * as req from \"request\";\n\n</pre></code>\n// E este funciona. Por que? Nós vamos voltar a isso no final\n da nossa sessão sobre export.\n\n Para realizar um import, você precisa fazer um export.\n O modo moderno de escrever exports é através da palavra-chave export\n\n<code><pre>\n/** O número atual de adesivos que sobraram no rolo  */\nexport const numeroDeAdesivos = 11;\n\n</pre></code>\n// Isso poderia ter sido importado em outro arquivo usando:\n\n import { numeroDeAdesivos } from \"./caminho/para/o/arquivo\"\n\n Vocé pode ter tantas importações em um arquivo quantas forem necessárias.\n Já um export padrão é bem parecido com isso.\n\n<code><pre>\n/** Cria um adesivo para você */\nconst geradorDeAdesivos = () => {};\nexport default geradorDeAdesivos;\n\n</pre></code>\n// Isto poderia ser importado em outro arquivo usando:\n\n import pegueAdesivos from \"./caminho/para/o/arquivo\"\n\n O nome é decidido pelo módulo que está realizando o import.\n\n Estes não são os únicos tipos de import, apenas os\n mais comuns em código moderno. Há um tópico bem abrangente\n sobre todos os modos que um código pode cruzar as fronteiras\n de um módulo no manual:\n\n https://www.typescriptlang.org/docs/handbook/modules.html\n\n Entretanto, para tentar responder a última questão. Se você\n observar o código JavaScript desse exemplo, você verá isto:\n\n var geradorDeAdesivos = function () { };\n exports.default = geradorDeAdesivos;\n\n Isso define a propriedade padrão (\"default\") no objeto exports como\n geradorDeAdesivos. Existe código que define o exports como uma\n função ao invés de um objeto.\n\n O TypeScript optou por utilizar a especificação ECMAScript\n sobre como lidar com esses casos, que é criar um erro.\n Entretanto, existe uma configuração do compilador que lida\n automaticamente com esses casos para você, que é a esModuleInterop.\n\n Se você ativar ela nesse exemplo, você verá que o erro desaparece.\n","redirectHref":"pt/play/?#example/import-export"}},"staticQueryHashes":[]}