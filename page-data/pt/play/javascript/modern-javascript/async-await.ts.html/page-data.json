{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/javascript/modern-javascript/async-await.ts.html","result":{"pageContext":{"name":"Async Await","title":"Async Await","lang":"pt","html":"\n O JavaScript moderno adicionou um modo de lidar com callbacks\n de uma maneira elegante adicionando uma API baseada em Promises\n a qual tem uma sintaxe especial que te permite tratar\n código assíncrono como se fosse síncrono.\n\n Assim como todos os recursos da linguagem, isso é uma troca em\n complexidade: fazer uma função assíncrona significa que o valor de\n retorno está envolvido em Promises. O que costumava retornar uma\n string, agora retorn uma Promise<string>.\n\n<code><pre>\nconst funcao = () => \":onda:\";\nconst funcaoAsync = async () => \":onda:\";\n\nconst minhaString = funcao();\nconst minhaPromiseString = funcaoAsync();\n\nminhaString.length;\n\n// minhaPromiseString é uma Promise, não uma string:\n\nminhaPromiseString.length;\n\n</pre></code>\n// Você pode usar a palavra chave await para converter uma promise\n ao seu valor. Atualmente, isso funciona apenas dentro de uma\n função assíncrona.\n\n<code><pre>\nconst minhaFuncao = async () => {\n  const minhaString = funcao();\n  const minhaPromiseResolvidaEmString = await funcaoAsync();\n\n  // Com a palavra chave await, agora minha minhaPromiseResolvidaEmString\n  // é uma string\n  minhaString.length;\n  minhaPromiseResolvidaEmString.length;\n};\n\n</pre></code>\n// Códigos rodando em await podem lançar erros,\n e é importante pegar esses erros em algum lugar.\n\n<code><pre>\nconst minhaFuncaoLancando = async () => {\n  throw new Error(\"Não chame isso\");\n};\n\n</pre></code>\n// Podemos envolver a chamada de uma função assíncrona em um try catch\n para lidar com casos onde a função age inexperadamente.\n\n<code><pre>\nconst funcaoAssincronaPegando = async () => {\n  const meuValorDeRetorno = \"Olá mundo\";\n  try {\n    await minhaFuncaoLancando();\n  } catch (erro) {\n    console.error(\"minhaFuncaoLancando falhou\", erro);\n  }\n  return meuValorDeRetorno;\n};\n\n</pre></code>\n// Devido à ergonomia dessa API estar retornando um\n único valor, ou lançando, você deve considerar\n oferecer informação sobre o resultado dentro do valor\n retornado e usar o throw apenas quando algo\n realmente excepcional ocorreu.\n\n<code><pre>\nconst funcaoExemploRaizQuadrada = async (input: any) => {\n  if (isNaN(input)) {\n    throw new Error(\"Apenas números são aceitos\");\n  }\n\n  if (input < 0) {\n    return { sucesso: false, mensagem: \"Não existe raiz quadrada de número negativo\" };\n  } else {\n    return { sucesso: true, valor: Math.sqrt(input) };\n  }\n};\n\n</pre></code>\n// Então a função consumidora pode checar a resposta e\n descobrir o que fazer com o valor retornado. Por enquanto\n este é um exemplo trivial, assim que você começar a trabalhar\n com códigos de rede, essa sintaxe extra valerá a pena.\n\n<code><pre>\nconst checarRaizQuadrada = async (valor: number) => {\n  const resposta = await funcaoExemploRaizQuadrada(valor);\n  if (resposta.sucesso) {\n    resposta.valor;\n  }\n};\n\n// Async/Await pega um código parecido com esse:\n\n</pre></code>\n// pegarResposta(url, resposta => {\n   pegarResposta(resposta.url, (segundaResposta) => {\n     const dadosDaResposta = segundaResposta.data\n     pegarResposta(dadosDaResposta.url, (terceiraResposta) => {\n       ...\n     })\n   })\n })\n\n E deixa se tornar linear como:\n\n const resposta = await pegarResposta(url)\n const segundaResposta = await pegarResposta(reposta.url)\n const dadosDaResposta = segundaResposta.data\n const terceiraResposta = await pegarResposta(dadosDaResposta.url)\n ...\n\n O qual pode fazer o código ficar mais perto do canto esquerdo\n e ser lido com um ritmo consistente.\n","redirectHref":"pt/play/?#example/async-await"}},"staticQueryHashes":[]}