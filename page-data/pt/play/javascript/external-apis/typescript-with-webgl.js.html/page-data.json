{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/javascript/external-apis/typescript-with-webgl.js.html","result":{"pageContext":{"name":"TypeScript with WebGL","title":"TypeScript with WebGL","lang":"pt","html":"\n Esse exemplo cria um HTML canvas que faz uso do WebGL para\n renderizar confetes giratórios usando JavaScript. Iremos \n caminhar pelo código para entender como ele funciona, e \n ver como o ferramental do TypeScript fornece dicas úteis.\n\n Esse exemplo compõe: example:working-with-the-dom\n\n Primeiro, precisamos criar um elemento HTML canvas, feito\n pela API do DOM e definir alguns atributos de estilo em linha. \n\n<code><pre>\nconst canvas = document.createElement(\"canvas\")\ncanvas.id = \"canvas-giratorio\"\ncanvas.style.backgroundColor = \"#0078D4\"\ncanvas.style.position = \"fixed\"\ncanvas.style.bottom = \"10px\"\ncanvas.style.right = \"20px\"\ncanvas.style.width = \"500px\"\ncanvas.style.height = \"400px\"\n\n</pre></code>\n// Em seguida, para tornar mais fácil fazer alterações, nós removemos \n quaisquer versões antigas do canvas quando clicamos \"Run\" - e agora você pode\n fazer alterações e vê-las refletidas quando apertar \"Run\"\n ou (cmd + enter):\n\n<code><pre>\nconst canvasExistente = document.getElementById(canvas.id)\nif (canvasExistente && canvasExistente.parentElement) {\n  canvasExistente.parentElement.removeChild(canvasExistente)\n}\n\n</pre></code>\n// Diga ao elemento canvas que iremos usar o WebGL para desenhar\n dentro do elemento (e não a ferramenta padrão de raster):\n\n<code><pre>\nconst gl = canvas.getContext(\"webgl\")\n\n</pre></code>\n// Em seguida precisamos criar sombreadores de vértices - eles são,\n a grosso modo, programas que aplicam matemática a um grupo de \n de arrays ou vértices de entrada (números).\n\n Você pode ver o grande grupo de atributos no topo do sombreador,\n esses são passados para ao sombreador compilado no exemplo mais abaixo. \n\n Existe uma visão geral boa de como eles funcionam aqui:\n https://webglfundamentals.org/webgl/lessons/webgl-how-it-works.html\n\n<code><pre>\nconst sombreadorVertice = gl.createShader(gl.VERTEX_SHADER)\ngl.shaderSource(\n  sombreadorVertice,\n  `\nprecision lowp float;\n\nattribute vec2 a_position; // Flat square on XY plane\nattribute float a_startAngle;\nattribute float a_angularVelocity;\nattribute float a_rotationAxisAngle;\nattribute float a_particleDistance;\nattribute float a_particleAngle;\nattribute float a_particleY;\nuniform float u_time; // Global state\n\nvarying vec2 v_position;\nvarying vec3 v_color;\nvarying float v_overlight;\n\nvoid main() {\n  float angle = a_startAngle + a_angularVelocity * u_time;\n  float vertPosition = 1.1 - mod(u_time * .25 + a_particleY, 2.2);\n  float viewAngle = a_particleAngle + mod(u_time * .25, 6.28);\n\n  mat4 vMatrix = mat4(\n    1.3, 0.0, 0.0, 0.0,\n    0.0, 1.3, 0.0, 0.0,\n    0.0, 0.0, 1.0, 1.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  mat4 shiftMatrix = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    a_particleDistance * sin(viewAngle), vertPosition, a_particleDistance * cos(viewAngle), 1.0\n  );\n\n  mat4 pMatrix = mat4(\n    cos(a_rotationAxisAngle), sin(a_rotationAxisAngle), 0.0, 0.0,\n    -sin(a_rotationAxisAngle), cos(a_rotationAxisAngle), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  ) * mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(angle), sin(angle), 0.0,\n    0.0, -sin(angle), cos(angle), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n\n  gl_Position = vMatrix * shiftMatrix * pMatrix * vec4(a_position * 0.03, 0.0, 1.0);\n  vec4 normal = vec4(0.0, 0.0, 1.0, 0.0);\n  vec4 transformedNormal = normalize(pMatrix * normal);\n\n  float dotNormal = abs(dot(normal.xyz, transformedNormal.xyz));\n  float regularLighting = dotNormal / 2.0 + 0.5;\n  float glanceLighting = smoothstep(0.92, 0.98, dotNormal);\n  v_color = vec3(\n    mix((0.5 - transformedNormal.z / 2.0) * regularLighting, 1.0, glanceLighting),\n    mix(0.5 * regularLighting, 1.0, glanceLighting),\n    mix((0.5 + transformedNormal.z / 2.0) * regularLighting, 1.0, glanceLighting)\n  );\n\n  v_position = a_position;\n  v_overlight = 0.9 + glanceLighting * 0.1;\n}\n`\n)\ngl.compileShader(sombreadorVertice)\n\n</pre></code>\n// Esse exemplo também faz uso sombreadores em fragmento - um sombreador\n em fragmento é outro pequeno programa que passa por todo\n pixel presente no canvas e define sua cor.\n\n Nesse caso, se brincar com os números você pode ver como\n isso afeta a iluminação na cena, tal como a espessura da \n da borda no confete:\n\n<code><pre>\nconst sombreadorFragmentos = gl.createShader(gl.FRAGMENT_SHADER)\ngl.shaderSource(\n  sombreadorFragmentos,\n  `\nprecision lowp float;\nvarying vec2 v_position;\nvarying vec3 v_color;\nvarying float v_overlight;\n\nvoid main() {\n  gl_FragColor = vec4(v_color, 1.0 - smoothstep(0.8, v_overlight, length(v_position)));\n}\n`\n)\ngl.compileShader(sombreadorFragmentos)\n\n</pre></code>\n// Recebe o sombreador compilado e o adiciona ao contexto\n WebGL do canvas para que possa ser usado:\n\n<code><pre>\nconst sombreador = gl.createProgram()\ngl.attachShader(sombreador, sombreadorVertice)\ngl.attachShader(sombreador, sombreadorFragmentos)\ngl.linkProgram(sombreador)\ngl.useProgram(sombreador)\n\ngl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())\n\n</pre></code>\n// Precisamos obter/definir as variáveis de entrada para o sombreador de \n uma maneira segura para memória, para que a ordem e o comprimento de seus \n valores precisam ser armazenados.\n\n<code><pre>\nconst attrs = [\n  { name: \"a_position\", length: 2, offset: 0 }, // ex: x e y representam 2 espaços na memória\n  { name: \"a_startAngle\", length: 1, offset: 2 }, // mas o ângulo, apenas 1 valor\n  { name: \"a_angularVelocity\", length: 1, offset: 3 },\n  { name: \"a_rotationAxisAngle\", length: 1, offset: 4 },\n  { name: \"a_particleDistance\", length: 1, offset: 5 },\n  { name: \"a_particleAngle\", length: 1, offset: 6 },\n  { name: \"a_particleY\", length: 1, offset: 7 }\n]\n\nconst STRIDE = Object.keys(attrs).length + 1\n\n</pre></code>\n// Itere sobre nossos atributos conhecidos e crie ponteiros na memória para que o lado JS\n possa ser capaz de preencher o sombreador. \n\n Para compreender essa API um pouco: WebGL é baseada no OpenGL\n que é uma 'API baseada em uma máquina de estados'. Você passa comandos em uma \n ordem em particular para renderizar coisas na tela.\n\n Então, o uso desejado é geralmente não passar objetos para cada chamada\n API WebGL, mas passar uma coisa para uma função, então passar outra\n para a próxima. Então, aqui otimizamos o WebGL para criar um array de \n vértices ponteiro.\n\n<code><pre>\nfor (var i = 0; i < attrs.length; i++) {\n  const name = attrs[i].name\n  const length = attrs[i].length\n  const offset = attrs[i].offset\n  const attribLocation = gl.getAttribLocation(shaderProgram, name)\n  gl.vertexAttribPointer(attribLocation, length, gl.FLOAT, false, STRIDE * 4, offset * 4)\n  gl.enableVertexAttribArray(attribLocation)\n}\n\n// Então nessa linha eles são ligados a um array em memória:\n\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer())\n\n// Define algumas constantes para renderização:\n\nconst NUM_PARTICLES = 200\nconst NUM_VERTICES = 4\n\n</pre></code>\n// Tente reduzi-las e clicar em \"Run\" de novo, \n elas representam quantos pontos deveriam existir em\n cada confete e ter um número ímpar \n tira tudo dos eixos.\n\n<code><pre>\nconst NUM_INDICES = 6\n\n// Cria os arrays de entradas para os sombreadores de vértices.\nconst vertices = new Float32Array(NUM_PARTICLES * STRIDE * NUM_VERTICES)\nconst indices = new Uint16Array(NUM_PARTICLES * NUM_INDICES)\n\nfor (let i = 0; i < NUM_PARTICLES; i++) {\n  const axisAngle = Math.random() * Math.PI * 2\n  const startAngle = Math.random() * Math.PI * 2\n  const groupPtr = i * STRIDE * NUM_VERTICES\n\n  const particleDistance = Math.sqrt(Math.random())\n  const particleAngle = Math.random() * Math.PI * 2\n  const particleY = Math.random() * 2.2\n  const angularVelocity = Math.random() * 2 + 1\n\n  for (let j = 0; j < 4; j++) {\n    const vertexPtr = groupPtr + j * STRIDE\n    vertices[vertexPtr + 2] = startAngle       // Angulo inicial\n    vertices[vertexPtr + 3] = angularVelocity  // Velocidade angular\n    vertices[vertexPtr + 4] = axisAngle        // Diferença de ângulo\n    vertices[vertexPtr + 5] = particleDistance // Distancia de partículas indo de (0,0,0)\n    vertices[vertexPtr + 6] = particleAngle    // Angulo em volta do eixo Y\n    vertices[vertexPtr + 7] = particleY        // Angulo em volta do eixo y\n  }\n\n  // Coordenadas\n  vertices[groupPtr] = vertices[groupPtr + STRIDE * 2] = -1\n  vertices[groupPtr + STRIDE] = vertices[groupPtr + STRIDE * 3] = +1\n  vertices[groupPtr + 1] = vertices[groupPtr + STRIDE + 1] = -1\n  vertices[groupPtr + STRIDE * 2 + 1] = vertices[groupPtr + STRIDE * 3 + 1] = +1\n\n  const indicesPtr = i * NUM_INDICES\n  const vertexPtr = i * NUM_VERTICES\n  indices[indicesPtr] = vertexPtr\n  indices[indicesPtr + 4] = indices[indicesPtr + 1] = vertexPtr + 1\n  indices[indicesPtr + 3] = indices[indicesPtr + 2] = vertexPtr + 2\n  indices[indicesPtr + 5] = vertexPtr + 3\n}\n\n// Passando o conteúdo para o contexto do WebGL\ngl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW)\n\n\nconst timeUniformLocation = gl.getUniformLocation(shaderProgram, \"u_time\")\nconst startTime = (window.performance || Date).now()\n\n// Inicia a cor do fundo como preto.\ngl.clearColor(0, 0, 0, 1)\n\n// Permite canais alfa no sombreador de vértices.\ngl.enable(gl.BLEND)\ngl.blendFunc(gl.SRC_ALPHA, gl.ONE)\n\n// Define o contexto do WebGL para ter o tamanho total do canvas\ngl.viewport(0, 0, canvas.width, canvas.height)\n\n  // Cria um loop de execução para desenhar todos os confetes\n  ; (function frame() {\n    gl.uniform1f(timeUniformLocation, ((window.performance || Date).now() - startTime) / 1000)\n\n    gl.clear(gl.COLOR_BUFFER_BIT)\n    gl.drawElements(\n      gl.TRIANGLES,\n      NUM_INDICES * NUM_PARTICLES,\n      gl.UNSIGNED_SHORT,\n      0\n    )\n    requestAnimationFrame(frame)\n  })()\n\n</pre></code>\n// Adiciona o novo elemento canvas no canto inferior esquerdo\n do playground\n<code><pre>\ndocument.body.appendChild(canvas)\n\n</pre></code>\n// Creditos: baseado nesse JSFiddle por Subzey\n https://jsfiddle.net/subzey/52sowezj/\n","redirectHref":"pt/play/?#example/typescript-with-webgl"}},"staticQueryHashes":[]}