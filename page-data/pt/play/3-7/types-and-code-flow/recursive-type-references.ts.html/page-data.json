{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/3-7/types-and-code-flow/recursive-type-references.ts.html","result":{"pageContext":{"name":"Recursive Type References","title":"Recursive Type References","lang":"pt","html":"\n A escolha entre o uso de tipo x interface envolve as\n restrições nos recursos de cada um. Com o 3.7, uma das\n restrições no tipo, mas não na interface, foi removida.\n\n Você pode descobrir mais sobre isso em example:types-vs-interfaces\n\n Antes, você não podia se referir ao tipo que está definindo dentro\n do próprio tipo. Este era um limite que não existia dentro de uma\n interface e poderia ser contornado com um pouco de trabalho.\n\n Por exemplo, isso não é possível em 3.6:\n<code><pre>\ntype ValueOrArray<T> = T | Array<ValueOrArray<T>>;\n\n</pre></code>\n// Uma implementação teria esta aparência, misturando o tipo\n com uma interface.\n<code><pre>\ntype ValueOrArray2<T> = T | ArrayOfValueOrArray<T>;\ninterface ArrayOfValueOrArray<T> extends Array<ValueOrArray2<T>> {}\n\n</pre></code>\n// Isso permite uma definição abrangente de JSON, que\n funciona referindo-se a si mesmo.\n\n<code><pre>\ntype Json = string | number | boolean | null | Json[] | { [key: string]: Json };\n\nconst exampleStatusJSON: Json = {\n  available: true,\n  username: \"Jean-loup\",\n  room: {\n    name: \"Highcrest\",\n    // Não é possível adicionar funções ao tipo Json\n    // update: () => {}\n  },\n};\n\n</pre></code>\n// Há mais para aprender com as notas de lançamento da versão 3.7 beta e seu PR:\n\n https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/\n https://github.com/microsoft/TypeScript/pull/33050\n","redirectHref":"pt/play/?#example/recursive-type-references"}},"staticQueryHashes":[]}