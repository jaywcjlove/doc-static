{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/3-7/types-and-code-flow/uncalled-function-checks.ts.html","result":{"pageContext":{"name":"Uncalled Function Checks","title":"Uncalled Function Checks","lang":"pt","html":"\n Nova na versão 3.7, é uma verificação dentro de blocos 'if'\n para quando você acidentalmente usa uma função ao invés do valor\n de retorno da função.\n\n Isto só é aplicado quando a função é conhecida para existir\n fazendo com que o bloco 'if' sempre seja verdadeiro.\n\n Aqui está um exemplo de uma 'interface' onde existem\n 'callbacks' opcionais e não-opcionais.\n\n<code><pre>\ninterface PluginSettings {\n  pluginShouldLoad?: () => void;\n  pluginIsActivated: () => void;\n}\n\ndeclare const plugin: PluginSettings;\n\n</pre></code>\n// Por 'pluginShouldLoad' poder não existir, então\n é uma verificação legítima.\n\n<code><pre>\nif (plugin.pluginShouldLoad) {\n  // Faça alguma coisa quando 'pluginShouldLoad' existir.\n}\n\n// Na versão 3.6 e anteriores, isto não era um erro.\n\nif (plugin.pluginIsActivated) {\n  // Quer fazer alguma coisa quando o plugin está ativado,\n  // mas ao invés de chamar o método, nós usamos isso como uma\n  // propriedade.\n}\n\n</pre></code>\n// 'pluginIsActivated' sempre deve existir, mas o TypeScript\n ainda permite a verificação, porque o método é chamado\n dentro do bloco 'if'.\n\n<code><pre>\nif (plugin.pluginIsActivated) {\n  plugin.pluginIsActivated();\n}\n","redirectHref":"pt/play/?#example/uncalled-function-checks"}},"staticQueryHashes":[]}