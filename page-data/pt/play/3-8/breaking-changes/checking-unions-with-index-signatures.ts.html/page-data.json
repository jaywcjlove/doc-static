{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts.html","result":{"pageContext":{"name":"Checking Unions with Index Signatures","title":"Checking Unions with Index Signatures","lang":"pt","html":" Nas versões anteriores do TypeScript, o verificador não valida\n se os campos não declarados em uma união de tipos estavam em \n conformidade com qualquer tipo indexado na união.\n\n Você pode aprender mais sobre tipagens indexadas aqui: example:indexed-types\n\n Por exemplo, o IdentifierCache abaixo indica que qualquer\n 'key' no objeto, será um número:\n\n<code><pre>\ntype IdentifierCache = { [key: string]: number };\n\n// Significa que isso irá falhar, porque 'file_a' é uma string.\n\nconst cacheWithString: IdentifierCache = { file_a: \"12343\" };\n\n</pre></code>\n// No entanto, quando você coloca isso em uma união,\n a verificação de validação não aconteceria\n\n<code><pre>\nlet userCache: IdentifierCache | { index: number };\nuserCache = { file_one: 5, file_two: \"abc\" };\n\n// Isso foi corrigido e haveria um erro do compilador no 'file_two' \n\n</pre></code>\n// Isso também leva em consideração quando a key é de um tipo\n diferente, por exemplo: ([key: string] and [key: number])\n\n<code><pre>\ntype IdentifierResponseCache = { [key: number]: number };\n\nlet resultCache: IdentifierCache | IdentifierResponseCache;\nresultCache = { file_one: \"abc\" };\n","redirectHref":"pt/play/?ts=3.8.3#example/checking-unions-with-index-signatures"}},"staticQueryHashes":[]}