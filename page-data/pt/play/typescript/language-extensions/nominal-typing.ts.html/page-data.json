{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/typescript/language-extensions/nominal-typing.ts.html","result":{"pageContext":{"name":"Nominal Typing","title":"Nominal Typing","lang":"pt","html":" Um sistema de tipos nominal significa que cada tipo é\r\n único e, mesmo se os tipos possuam os mesmos dados, eles\r\n não podem ser atribuídos entre tipos.\r\n\n O sistema de tipos do TypeScript é estrutural, o que\r\n significa que se um tipo tem a forma de um pato, ele é\r\n um pato. Se um ganso tem todos os atributos de um pato,\r\n então ele também é um pato. Você pode aprender mais em:\r\n example:structural-typing\r\n\n Isso pode trazer desvantagens, por exemplo, existem casos\r\n em que uma string ou número podem ter um contexto especial\r\n e você não quer que esses valores sejam transferíveis.\r\n Por exemplo:\r\n\n - Strings com entradas de usuários (inseguro)\r\n - Strings de tradução\r\n - Números de identificação de usuário\r\n - Tokens de acesso\r\n\n É possível implementar a maior parte das funções de um \r\n sistema de tipos nominal com um pouco de código adicional.\r\n\n Utilizando um tipo de interseção, com uma restrição na\r\n forma de uma propriedade chamada __brand (isso é uma\r\n convenção), tornamos impossível atribuir uma string comum\r\n a um tipo StringDeEntradaValidada.\r\n\n<code><pre>\ntype StringDeEntradaValidada = string & { __brand: \"Entrada de Usuário Após Validação\" };\r\n\r\n</pre></code>\n// Agora utilizaremos uma função para transformar uma string\r\n em uma StringDeEntradaValidada - mas algo a se notar é que\r\n nós estamos apenas dizendo ao TypeScript que isso é verdade.\r\n\n<code><pre>\nconst validarEntradaDeUsuario = (entrada: string) => {\r\n  const validacaoSimplesDeEntrada = entrada.replace(/\\</g, \"≤\");\r\n  return validacaoSimplesDeEntrada as StringDeEntradaValidada;\r\n};\r\n\r\n</pre></code>\n// Assim, podemos criar funções que aceitam somente o nosso\r\n novo tipo nominal, e não o tipo string mais genérico.\r\n\n<code><pre>\nconst imprimirNome = (nome: StringDeEntradaValidada) => {\r\n  console.log(nome);\r\n};\r\n\r\n</pre></code>\n// Por exemplo, aqui temos uma entrada insegura de um usuário\r\n que, após passar pelo validador, é impressa sem problemas:\r\n\n<code><pre>\nconst entrada = \"\\n<script>alert('bobby tables')</script>\";\r\nconst validatedInput = validarEntradaDeUsuario(entrada);\r\nimprimirNome(validatedInput);\r\n\r\n</pre></code>\n// Por outro lado, passar uma string não-validada para a função\r\n imprimirNome causará um erro no compilador:\r\n\n<code><pre>\nimprimirNome(entrada);\r\n\r\n</pre></code>\n// Você pode consultar uma visão geral das diferentes maneiras\r\n de criar tipos nominais, com suas vantagens e desvantagens,\r\n nesse issue do GitHub (em inglês):\r\n\n https://github.com/Microsoft/TypeScript/issues/202\r\n\n Também pode acessar um ótimo sumário neste post (em inglês):\r\n https://michalzalecki.com/nominal-typing-in-typescript/\r\n","redirectHref":"pt/play/?#example/nominal-typing"}},"staticQueryHashes":[]}