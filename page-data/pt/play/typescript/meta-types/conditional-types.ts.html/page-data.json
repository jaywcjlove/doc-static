{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/typescript/meta-types/conditional-types.ts.html","result":{"pageContext":{"name":"Conditional Types","title":"Conditional Types","lang":"pt","html":" Tipos Condicionais fornecem uma maneira simples de adicionar\n lógica no sistema de tipos do Typescript. Esse é um recurso\n avançado, e é muito possível que você não precise utilizá-lo\n no seu código do dia a dia.\n\n Um tipo condicional se parece com:\n\n   A extends B ? C : D\n\n Onde a condição é: se um tipo se extende a uma expressão,\n e que tipo deveria ser retornado.\n\n Vamos passar por alguns exemplos, por questões de brevidade\n usaremos apenas uma letra para tipos genéricos. Isso é opcional,\n mas nos restringimos à 60 caracteres para caber na tela.\n\n<code><pre>\ntype Gato = { miau: true };\ntype Cachorro = { latido: true };\ntype Guepardo = { miau: true; rapido: true };\ntype Lobo = { latido: true; uivos: true };\n\n</pre></code>\n// Podemos criar um tipo condicional onde é possível extrair\n tipos que se aplicam apenas com algo que late.\n\n<code><pre>\ntype ExtrairLatidos<A> = A extends { latido: true } ? A : never;\n\n// Assim podemos criar tipos envolvidos pelo ExtrairLatidos:\n\n// Um gato não late, então iremos retornar never\ntype GatoNever = ExtrairLatidos<Gato>;\n// Um lobo late, então retornaremos a forma de lobo\ntype TipoLobo = ExtrairLatidos<Lobo>;\n\n</pre></code>\n// Isso se torna útil quando você quer trabalhar com uma união\n de vários tipos e reduzir o número de potenciais opções:\n\n<code><pre>\ntype Animais = Gato | Cachorro | Guepardo | Lobo;\n\n</pre></code>\n// Quando você aplica ExtrairLatidos para um tipo de união,\n é o mesmo que testar a condição com todos os membros do tipo:\n\n<code><pre>\ntype Latido = ExtrairLatidos<Animais>;\n\n</pre></code>\n// = ExtrairLatidos<Gato> | ExtrairLatidos<Cachorro> |\n   ExtrairLatidos<Guepardo> | ExtrairLatidos<Lobo>\n\n = never | Cachorro | never | Lobo\n\n = Cachorro | Lobo (veja example:unknown-and-never)\n\n Isso é chamado de tipo condicional distributivo porque\n o tipo distribui para cada membro da união.\n\n Tipos condicionais diferidos\n\n Tipos condicionais podem ser usados para diminuir suas APIs\n que podem retornar diferentes tipos dependendo dos inputs.\n\n Por exemplo, essa função pode retornar tanto uma string\n quanto um number dependendo do boolean passado.\n\n<code><pre>\ndeclare function pegarID<T extends boolean>(legal: T): T extends true ? string : number;\n\n</pre></code>\n// Então dependendo do quanto o sistema de tipos sabe sobre o boolean\n você irá receber um tipo de retorno diferente:\n<code><pre>\nlet retornoDeString = pegarID(true);\nlet retornoDeNumber = pegarID(false);\nlet stringOuNumber = pegarID(Math.random() < 0.5);\n\n</pre></code>\n// Nesse caso acima o TypeScript sabe o tipo de retorno imediatamente.\n Contudo, você pode usar tipos condicionais em funções\n onde o tipo não é conhecido. Isso é chamado tipo condicional diferido.\n\n O mesmo que o nosso ExtrairLatidos acima, mas como uma função\n<code><pre>\ndeclare function extrairMiado<T>(x: T): T extends { miau: true } ? T : undefined;\n\n</pre></code>\n// Existe uma ferramenta muito útil dentro dos tipos condicionais, na qual\n é possível especificamente dizer ao TypeScript que ele deve inferir o tipo\n quando diferido. Essa é a palavra chave 'infer'.\n\n 'infer' é normalmente usado para criar metatipos que inspecionam\n os tipos existentes no seu código, pense nisso como a criação de uma\n nova variável dentro do tipo.\n\n<code><pre>\ntype PegarOTipoDoRetorno<T> = T extends (...args: any[]) => infer R ? R : T;\n\n</pre></code>\n// Brevemente:\n\n  - esse é um tipo genérico condicional chamado PegarOTipoDoRetorno\n    que recebe um tipo como primeiro parâmetro\n\n  - a condição checa se o tipo é uma função, e se for cria um novo tipo\n    chamado R baseado no retorno do valor da função\n\n  - se a checagem passar, o valor do tipo é inferido como o valor do\n    retorno da função, caso contrario é o tipo original\n\n\n<code><pre>\ntype retornoDoPegarID = PegarOTipoDoRetorno<typeof pegarID>;\n\n</pre></code>\n// Isso falha na verifição de ser uma função, e iria apenas retornar o tipo\n passado a ele.\n<code><pre>\ntype pegarGato = PegarOTipoDoRetorno<Gato>;\n","redirectHref":"pt/play/?#example/conditional-types"}},"staticQueryHashes":[]}