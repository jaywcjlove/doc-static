{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/typescript/meta-types/discriminate-types.ts.html","result":{"pageContext":{"name":"Discriminate Types","title":"Discriminate Types","lang":"pt","html":" Uma união de tipos discriminados é quando você usa análise\r\n de fluxo de código para reduzir um conjunto de objetos\r\n para um objeto específico.\r\n\n Esse padrão funciona muito bem para conjuntos de objetos\r\n semelhantes com propriedades em comum, por exemplo: uma\r\n lista de eventos nomeados, ou um conjunto de objetos\r\n versionados.\r\n\n<code><pre>\ntype EventoCronometrado = { nome: \"inicio\"; usuarioIniciou: boolean } | { nome: \"encerrado\"; duracao: number };\r\n\r\n</pre></code>\n// Quando o evento chega na função abaixo, ele pode ser\r\n qualquer um dos dois tipos possíveis.\r\n\n<code><pre>\nconst tratarEvento = (evento: EventoCronometrado) => {\r\n  // Usando um switch com evento.nome, a análise de fluxo de\r\n  // código do TypeScript consegue determinar que um objeto\r\n  // pode ser representado somente por um tipo da união.\r\n\r\n  switch (evento.nome) {\r\n    case \"inicio\":\r\n      // Isso significa que você pode acessar usuarioIniciou\r\n      // com segurança, porque esse é o único tipo dentro de\r\n      // EventoCronometrado onde nome é \"inicio\".\r\n      const usuarioIniciou = evento.usuarioIniciou;\r\n      break;\r\n\r\n    case \"encerrado\":\r\n      const intervaloDeTempo = evento.duracao;\r\n      break;\r\n  }\r\n};\r\n\r\n</pre></code>\n// Também podemos usar números como o discriminador, seguindo\r\n o mesmo padrão.\r\n\n Nesse exemplo, temos uma união discriminada e um estado\r\n de erro adicional para tratar.\r\n\n<code><pre>\ntype RespostasAPI = { versao: 0; mensagem: string } | { versao: 1; mensagem: string; status: number } | { erro: string };\r\n\r\nconst tratarResposta = (resposta: RespostasAPI) => {\r\n  // Tratar o caso de erro, e então retornar.\r\n  if (\"erro\" in resposta) {\r\n    console.error(resposta.erro);\r\n    return;\r\n  }\r\n\r\n  // O TypeScript agora sabe que respostas não pode ser do\r\n  // tipo erro. Caso fosse, a função teria retornado. Você\r\n  // pode verificar isso passando o mouse sobre resposta no\r\n  // trecho abaixo.\r\n\r\n  if (resposta.versao === 0) {\r\n    console.log(resposta.mensagem);\r\n  } else if (resposta.versao === 1) {\r\n    console.log(resposta.status, resposta.mensagem);\r\n  }\r\n};\r\n\r\n</pre></code>\n// É recomendado utilizar um bloco switch no lugar de um\r\n bloco if porque assim você pode garantir que todas as\r\n partes da união são checadas. Existe um bom padrão para\r\n isso usando o tipo never no manual (em inglês):\r\n\r\n https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions\r\n","redirectHref":"pt/play/?#example/discriminate-types"}},"staticQueryHashes":[]}