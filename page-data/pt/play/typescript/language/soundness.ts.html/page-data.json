{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/typescript/language/soundness.ts.html","result":{"pageContext":{"name":"Soundness","title":"Soundness","lang":"pt","html":"\n Sem um histórico na teoria de tipos, é improvável que você\n esteja familiarizado com a ideia de um sistema de tipos ser \"sólido\" (_sound_).\n\n Solidez (_Soundness_) é a ideia de que o compilador pode dar garantias sobre o tipo\n de um valor em tempo de execução, e não apenas durante a compilação.\n Isso é normal para a maioria das linguagens de programação\n que são construídas com tipos desde a sua criação.\n\n Construir um sistema de tipo que modela uma linguagem que existe\n há algumas décadas, no entanto, torna-se sobre tomar\n decisões que podem ter efeitos em três propriedades: Simplicidade,\n Usabilidade e Solidez.\n\n Com o objetivo do TypeScript de ser capaz de suportar todo o código\n JavaScript, a linguagem tende à simplicidade e usabilidade quando\n apresentada com maneiras de adicionar tipos ao JavaScript.\n\n Vejamos alguns casos em que o TypeScript provavelmente\n não é adequado para entender como seriam\n essas compensações de outra forma.\n\n Asserções de tipo\n\n<code><pre>\nconst idadeDoUsuario = (\"23\" as any) as number;\n\n</pre></code>\n// O TypeScript permitirá que você use asserções de tipo para  substituir\n a inferência de algo que está totalmente errado. Usar asserções de tipo\n é uma maneira de dizer ao TypeScript que você o conhece melhor,\n e o TypeScript tentará permitir que você prossiga com isso.\n\n Linguagens que são sólidas ocasionalmente usariam verificações\n de tempo de execução para garantir que os dados correspondam ao que\n seus tipos dizem - mas o TypeScript visa não ter impacto no tempo\n de execução com reconhecimento de tipo no seu código transpilado.\n\n Função Parâmetro Bi-variância\n\n Parâmetros para uma função que suportam a redefinição do\n parâmetro para ser um subtipo da declaração original.\n\n<code><pre>\ninterface InputEvent {\n  timestamp: number;\n}\ninterface MouseInputEvent extends InputEvent {\n  x: number;\n  y: number;\n}\ninterface KeyboardInputEvent extends InputEvent {\n  keyCode: number;\n}\n\nfunction escuteOEvento(eventType: \"keyboard\" | \"mouse\", handler: (event: InputEvent) => void) {}\n\n</pre></code>\n// Você pode declarar novamente o tipo de parâmetro como um subtipo\n da declaração. Acima, o manipulador esperava um tipo InputEvent,\n mas nos exemplos de uso abaixo - o TypeScript aceita um tipo\n que possui propriedades adicionais.\n\n<code><pre>\nescuteOEvento(\"keyboard\", (event: KeyboardInputEvent) => {});\nescuteOEvento(\"mouse\", (event: MouseInputEvent) => {});\n\n// Isso pode voltar ao menor tipo comum:\n\nescuteOEvento(\"mouse\", (event: {}) => {});\n\n// Mas não mais:\n\nescuteOEvento(\"mouse\", (event: string) => {});\n\n</pre></code>\n// Isso cobre o padrão real do event listener em JavaScript,\n às custas de ser sólido.\n\n O TypeScript pode gerar um erro quando isso acontecer por meio\n de `strictFunctionTypes`. Ou você pode contornar este caso\n específico com sobrecargas de função, consulte:\n exemplo: typing-functions\n\n Casing especial para Void\n\n Descarte de parâmetros\n\n Para aprender sobre casos especiais com parâmetros de função,\n consulte o exemplo: structural-typing\n\n Parâmetros rest\n\n Os parâmetros rest são considerados opcionais, isso significa\n que o TypeScript não terá uma maneira de impor o número de\n parâmetros disponíveis para um retorno de chamada.\n\n<code><pre>\nfunction obterNumerosAleatorios(count: number, callback: (...args: number[]) => void) {}\n\nobterNumerosAleatorios(2, (first, second) => console.log([first, second]));\nobterNumerosAleatorios(400, first => console.log(first));\n\n// Funções nulas podem corresponder a uma função com um valor de retorno\n\n</pre></code>\n// Uma função que retorna uma função void pode\n aceitar uma função que assume qualquer outro tipo.\n\n<code><pre>\nconst obterPI = () => 3.14;\n\nfunction executarFuncao(func: () => void) {\n  func();\n}\n\nexecutarFuncao(obterPI);\n\n</pre></code>\n// Para obter mais informações sobre os locais onde\n a solidez do sistema de tipo está comprometida, consulte:\n\n https://github.com/Microsoft/TypeScript/wiki/FAQ#type-system-behavior\n https://github.com/Microsoft/TypeScript/issues/9825\n https://www.typescriptlang.org/docs/handbook/type-compatibility.html\n","redirectHref":"pt/play/?strictFunctionTypes=false#example/soundness"}},"staticQueryHashes":[]}