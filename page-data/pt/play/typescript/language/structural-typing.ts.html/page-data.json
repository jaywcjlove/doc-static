{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/typescript/language/structural-typing.ts.html","result":{"pageContext":{"name":"Structural Typing","title":"Structural Typing","lang":"pt","html":" TypeScript é um Sistema de Tipagem Estrutural, isso significa\n que comparando tipos, o Typescript leva em consideração apenas\n as propriedades do tipo.\n\n Isso em contraste a sistemas de tipagem nominais, onde você\n pode criar dois tipos mas não pode atribuir um ao outro.\n Veja o example:nominal-typing\n\n Por exemplo, essas duas interfaces são\n transferíveis em um sistema de tipo estrutural\n\n<code><pre>\ninterface Bola {\n  diametro: number;\n}\ninterface Esfera {\n  diametro: number;\n}\n\nlet bola: Bola = { diametro: 10 };\nlet esfera: Esfera = { diametro: 20 };\n\nesfera = bola;\nbola = esfera;\n\n</pre></code>\n// Se nós adicionarmos um tipo que possui estruturalmente todas\n as propriedades de Bola e Esfera, esse tipo também poderá ser\n atribuído a um Bola ou Esfera.\n\n<code><pre>\ninterface Tubo {\n  diametro: number;\n  tamanho: number;\n}\n\nlet tubo: Tubo = { diametro: 12, tamanho: 3 };\n\ntubo = bola;\nbola = tubo;\n\n</pre></code>\n// Porque a variável bola não tem a propriedade tamanho, ela não pode\n ser atribuída a tubo. No entanto, já que todas as propriedades\n de Bola estão dentro de tubo, ela pode ser atribuída a variável bola.\n\n TypeScript é a comparação entre propriedades de um tipo contra\n as de outro para verificar a igualdade.\n\n Uma função é um objeto em Javascript e isso é comparado de forma\n semelhante. Com um truque extra em volta dos parâmetros:\n\n<code><pre>\nlet criaBola = (diametro: number) => ({ diametro });\nlet criaEsfera = (diametro: number, emPolegadas: boolean) => {\n  return { diametro: emPolegadas ? diametro * 0.39 : diametro };\n};\n\ncriaEsfera = criaBola;\ncriaBola = criaEsfera;\n\n</pre></code>\n// TypeScript vai permitir (number) ser igual (number, boolean)\n nos parâmetros, mas não (number, boolean) -> (number)\n\n TypeScript vai descartar o boolean na primeira atribuição\n porque é bastante comum para o código Javascript pular a\n passagem de parâmetros quando não são necessários.\n\n Por exemplo o callback do método forEach de Arrays possui\n três parâmetros, valor, index e o array completo - se o Typescript\n não suportasse o descarte de parâmetros, ele teria que incluir\n todas as opções para fazer as funções combinarem:\n\n<code><pre>\n[criaBola(1), criaBola(2)].forEach((bola, _index, _bolas) => {\n  console.log(bola);\n});\n\n// Ninguém precisa disso.\n\n</pre></code>\n// Tipos de retorno são tratados como objetos, e qualquer diferença\n é comparada usando a mesma regra de igualdade a cima.\n\n<code><pre>\nlet criaBolaVermelha = (diametro: number) => ({ diametro, color: \"red\" });\n\ncriaBola = criaBolaVermelha;\ncriaBolaVermelha = criaBola;\n\n</pre></code>\n// Aqui o primeiro argumento funciona (os dois possuem diâmetro)\n mas o segundo não (a variável bola não possui cor).\n","redirectHref":"pt/play/?#example/structural-typing"}},"staticQueryHashes":[]}