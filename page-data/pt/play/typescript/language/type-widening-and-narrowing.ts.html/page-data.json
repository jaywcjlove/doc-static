{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/typescript/language/type-widening-and-narrowing.ts.html","result":{"pageContext":{"name":"Type Widening and Narrowing","title":"Type Widening and Narrowing","lang":"pt","html":" Pode ser mais fácil começar a discussão do\n alargamento e estreitamento com um exemplo:\n\n<code><pre>\nconst welcomeString = \"Olá! Estranho\";\nlet replyString = \"Hey\";\n\n</pre></code>\n// Além das diferenças de texto das strings, welcomeString\n é um const (o que significa que o valor nunca mudará)\n e replyString é um let (que significa que o valor pode mudar).\n\n Se você passar o mouse sobre as duas variáveis, \n obterá informações de tipo muito diferentes do TypeScript:\n\n   const welcomeString: \"Hello There\"\n\n   let replyString: string\n\n TypeScript inferiu que o tipo do welcomeString é\n a string literal \"Hello There\", enquanto replyString\n é uma string genérica.\n\n Isso ocorre porque um let precisa ter um tipo mais amplo, você\n pode determinar replyString para ser qualquer outra string - no qual significa\n ter uma grande conjunto de possibilidades.\n\n<code><pre>\nreplyString = \"Hi :wave:\";\n\n</pre></code>\n// Se replyString tiver uma string literal \"Hey\" - então\n você nunca poderia mudar o valor pois ele poderia mudar\n para apenas \"Hey\" de novo.\n\n Os alargamento e estreitamento de tipos são sobre expandir e reduzir\n as possibilidades no qual um tipo pode representar.\n\n Um exemplo de estreitamento de tipos é trabalhando com uniões, o\n exemplo do fluxo de análise do código é quase inteiramente baseado no\n estreitamento: example:code-flow\n\n O estreitamento de tipos é o que dá poder ao modo estrito do TypeScript\n por meio das verificações de nulidade. Com o modo estrito desligado,\n marcadores de nulidade como undefined e null são ignorados\n em uma união.\n\n<code><pre>\ndeclare const quantumString: string | undefined;\n// Isso irá falhar no modo strict apenas\nquantumString.length;\n\n</pre></code>\n// No modo estrito a responsabilidade recai sobre o autor do código para garantir\n que o tipo foi limitado ao tipo não nulo.\n Normalmente, isso é tão simples quanto uma verificação if:\n\n<code><pre>\nif (quantumString) {\n  quantumString.length;\n}\n\n</pre></code>\n// No modo estrito o tipo quantumString tem duas representações.\n Dentro do if, o tipo foi limitado para apenas string.\n\n Você pode ver mais exemplos de estreitamento aqui:\n\n example:union-and-intersection-types\n example:discriminate-types\n\n E ainda mais materiais na web:\n\n https://mariusschulz.com/blog/literal-type-widening-in-typescript\n https://sandersn.github.io/manual/Widening-and-Narrowing-in-Typescript.html\n","redirectHref":"pt/play/?#example/type-widening-and-narrowing"}},"staticQueryHashes":[]}