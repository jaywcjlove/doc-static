{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/typescript/primitives/unknown-and-never.ts.html","result":{"pageContext":{"name":"Unknown and Never","title":"Unknown and Never","lang":"pt","html":" Unknown\n\n Unknown é um daqueles tipos que, assim que você entende,\n acha muitos casos de uso. Ele age como um irmão para o tipo any.\n any permite ambiguidade - unknown requer especificidades.\n\n Um bom exemplo poderia envolver um JSON parser. Dados JSON podem vir\n de diferentes formas e o criador da função que analisa o JSON não\n saberá a forma do dado - a pessoa chamando a função deve.\n\n<code><pre>\nconst transformadorJson = (stringJson: string) => JSON.parse(stringJson);\n\nconst minhaConta = transformadorJson(`{ \"nome\": \"Dorothea\" }`);\n\nminhaConta.nome;\nminhaConta.email;\n\n</pre></code>\n// Se você passar o mouse em transformadorJson, poderá ver que ele tem\n o tipo de retorno any, assim como o minhaConta. É possível ajustar isso\n com tipos Genéricos - mas também é possível ajustar isso com o unkown.\n\n<code><pre>\nconst transformadorJsonUnkown = (stringJson: string): unknown => JSON.parse(stringJson);\n\nconst minhaOutraConta = transformadorJsonUnkown(`{ \"nome\": \"Samuel\" }`);\n\nminhaOutraConta.nome;\n\n</pre></code>\n// O objeto minhaOutraConta não pode ser usado até o tipo ser declarado\n para o TypeScript. Isso pode ser usado para garantir que\n quem consumir a API pense em sua tipagem com antecedência:\n\n<code><pre>\ntype Usuario = { nome: string };\nconst minhaContaDeUsuario = transformadorJsonUnkown(`{ \"nome\": \"Samuel\" }`) as Usuario;\nminhaContaDeUsuario.nome;\n\n</pre></code>\n// Unknown é uma boa ferramenta, para entendê-lo ainda mais leia:\n https://mariusschulz.com/blog/the-unknown-type-in-typescript\n https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type\n\n Never\n\n Como o Typescript suporta análise de fluxo do código, a linguagem\n precisa ser capaz de representar quando lógicamente o código não pode\n acontecer. Por exemplo, essa função não pode retornar:\n\n<code><pre>\nconst nuncaRetorna = () => {\n  // Se for lançado um erro na primeira linha\n  throw new Error(\"Sempre lança um erro, nunca retorna\");\n};\n\n</pre></code>\n// Se você passar o mouse em cima da função, verá () => never\n que significa que isso nunca deverá acontecer. Estes ainda\n podem ser passados como outros valores:\n\n<code><pre>\nconst meuValor = nuncaRetorna();\n\n</pre></code>\n// Tendo uma função que retorna never pode ser útil quando lidamos com\n a imprevisiblidade do runtime JavaScript e os\n consumidores da API que podem não estar usando tipos:\n\n<code><pre>\nconst validarUsuario = (usuario: Usuario) => {\n  if (usuario) {\n    return usuario.nome !== \"NaN\";\n  }\n\n  // De acordo com o sistema de tipos, esse caminho do código\n  // nunca deveria acontecer, que combina com o tipo de\n  // retorno do nuncaRetorna.\n\n  return nuncaRetorna();\n};\n\n</pre></code>\n// O estado da definição de tipos indica que um usuário deve ser\n passado, mas existem muitas válvulas de escape no JavaScript\n por meio das quais você não pode garantir isso.\n\n Usar uma função que retorna never te permite adicionar\n código em partes que não deveriam ser possíveis.\n Isso é útil para mostrar uma mensagem de erro melhor,\n ou fechar recursos como arquivos ou loops.\n\n Um tipo de uso bem popular para o never é garantir que um\n switch é exaustivo. Por exemplo, todos os caminhos são cobertos.\n\n Aqui tem um enum e um switch exaustivo, tente adicionar\n uma nova opção para o enum (talvez Tulipa?)\n\n<code><pre>\nenum Flor {\n  Rosa,\n  Rododendro,\n  Violeta,\n  Margarida,\n}\n\nconst nomeDaFlorEmLatim = (flor: Flor) => {\n  switch (flor) {\n    case Flor.Rosa:\n      return \"Rosa rubiginosa\";\n    case Flor.Rododendro:\n      return \"Rhododendron ferrugineum\";\n    case Flor.Violeta:\n      return \"Viola reichenbachiana\";\n    case Flor.Margarida:\n      return \"Bellis perennis\";\n\n    default:\n      const _checagemExaustiva: never = flor;\n      return _checagemExaustiva;\n  }\n};\n\n</pre></code>\n// Você vai ter um erro de compilação falando que seu\n novo tipo de flor não pode ser convertido em never.\n\n Never em Unions\n\n O never é removido automaticamente do tipo union.\n\n<code><pre>\ntype NeverERemovido = string | never | number;\n\n</pre></code>\n// Se você olhar no tipo para NeverERemovido, verá que\n é string | number. Isso é porque never nunca deve acontecer em\n tempo de execução, já que você não pode atribuir a ele.\n\n Esse recurso é muito utilizado em example:conditional-types\n","redirectHref":"pt/play/?#example/unknown-and-never"}},"staticQueryHashes":[]}