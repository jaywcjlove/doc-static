{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/typescript/primitives/union-and-intersection-types.ts.html","result":{"pageContext":{"name":"Union and Intersection Types","title":"Union and Intersection Types","lang":"pt","html":" União de tipos (type unions) é uma forma de declarar que um objeto\n pode ser mais de um tipo.\n\n<code><pre>\ntype StringOrNumber = string | number;\ntype ProcessStates = \"open\" | \"closed\";\ntype OddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;\ntype AMessyUnion = \"hello\" | 156 | { error: true };\n\n</pre></code>\n// Se o uso de \"open\" e \"closed\" vs string é\n novo para você, verifique: example:literals\n\n Podemos misturar diferentes tipos em um union, dizendo que o valor é \n de um destes tipos.\n\n TypeScript irá então deixar para você o trabalho de \n determinar qual valor deve ser em tempo de execução.\n\n Unions podem ser prejudicados pelo 'type-widening', \n por exemplo:\n\n<code><pre>\ntype WindowStates = \"open\" | \"closed\" | \"minimized\" | string;\n\n</pre></code>\n// Se você passar o mouse por cima, você poderá ver que o WindowStates\n se transforma em uma string - não em um union. Isto é explicado em\n example:type-widening-and-narrowing\n\n Se um union é um 'OU', então um intersection é um 'E'.\n Interseção de tipos (type intersection) consiste de dois tipos que\n se cruzam para criar um novo tipo. Ele permite a composição de tipos.\n\n<code><pre>\ninterface ErrorHandling {\n  success: boolean;\n  error?: { message: string };\n}\n\ninterface ArtworksData {\n  artworks: { title: string }[];\n}\n\ninterface ArtistsData {\n  artists: { name: string }[];\n}\n\n</pre></code>\n// Essas interfaces podem ser compostas em respostas que possuem\n ambos manipulação de erros e dados.\n\n<code><pre>\ntype ArtworksResponse = ArtworksData & ErrorHandling;\ntype ArtistsResponse = ArtistsData & ErrorHandling;\n\n// Por exemplo:\n\nconst handleArtistsResponse = (response: ArtistsResponse) => {\n  if (response.error) {\n    console.error(response.error.message);\n    return;\n  }\n\n  console.log(response.artists);\n};\n\n</pre></code>\n// Uma mistura dos tipos Intersection e Union se torna realmente\n útil quando você tem um caso em que um objeto precisa \n incluir um de dois valores:\n\n<code><pre>\ninterface CreateArtistBioBase {\n  artistID: string;\n  thirdParty?: boolean;\n}\n\ntype CreateArtistBioRequest = (CreateArtistBioBase & { html: string }) | { markdown: string };\n\n</pre></code>\n// Agora você pode apenas criar uma requisição quando você incluir\n artistsID e html ou markdown.\n\n<code><pre>\nconst workingRequest: CreateArtistBioRequest = {\n  artistID: \"banksy\",\n  markdown: \"Banksy é um artista anonimo de grafite que mora na Inglaterra\",\n};\n\nconst badRequest: CreateArtistBioRequest = {\n  artistID: \"banksy\",\n};\n","redirectHref":"pt/play/?#example/union-and-intersection-types"}},"staticQueryHashes":[]}