{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/typescript/type-primitives/nullable-types.ts.html","result":{"pageContext":{"name":"Nullable Types","title":"Nullable Types","lang":"pt","html":"\n No JavaScript existem duas maneiras de declarar valores que não\n existem, o TypeScript adiciona sintaxe extra que nos proporciona\n mais maneiras de declarar algo como opcional ou nulo.\n\n Primeiramente a diferença entre os dois primitivos\n no JavaScript: undefined e null.\n\n Undefined é quando algo não foi encontrado ou definido.\n\n<code><pre>\nconst emptyObj = {};\nconst anUndefinedProperty: undefined = emptyObj[\"anything\"];\n\n</pre></code>\n// Null é usado quando se quer intencionalmente mostrar que\n o valor não existe.\n\n<code><pre>\nconst searchResults = {\n  video: { name: \"LEGO Movie\" },\n  text: null,\n  audio: { name: \"LEGO Movie Soundtrack\" },\n};\n\n</pre></code>\n// Por que não usar undefined? Pricipalmente, porque agora podemos\n verificar que text foi incluido corretamente. Se text retornasse\n undefined então o resultado seria o mesmo que dizer que não\n foi declarado.\n\n Isso pode parecer superficial, mas quando convertido\n em uma string JSON, se o text fosse undefined, nāo seria\n incluido na conversão para string.\n\n Strict Null Types\n\n Antes do TypeScript 2.0, undefined e null eram efetivamente\n ignorados no sistema de tipagem. Isso fazia com que TypeScript\n pudesse prover um ambiente de desenvolvimento mais próximo de\n um JavaScript sem tipagem.\n\n A versāo 2.0 adiciona uma configuração de compilação (flag),\n chamada \"strictNullChecks\". Essa flag requer que undefined e null\n sejam tratados como tipos, o que significa que devem ser manipulados\n via análise de fluxo de código (code-flow).\n ( veja mais em example:code-flow )\n\n Para um exemplo da diferença quando se usa o strict null\n checks no TypeScript, passe o mouse por cima de \"Potential String\" abaixo:\n\n<code><pre>\ntype PotentialString = string | undefined | null;\n\n</pre></code>\n// O PotentialString discarta o undefined e null. Se você ir\n até as configurações, ligar o strict mode e voltar\n você pode ver que ao passar o mouse por cima de PotencialString\n agora pode ver a união completa.\n\n<code><pre>\ndeclare function getID(): PotentialString;\n\nconst userID = getID();\nconsole.log(\"User Logged in: \", userID.toUpperCase());\n\n// Somente em strict mode a linha acima vai falhar^\n\n</pre></code>\n// Existem maneiras de dizer ao TypeScript que você sabe mais\n sobre a tipagem, como type assertion ou através do\n non-null assertion operator (!)\n\n<code><pre>\nconst definitelyString1 = getID() as string;\nconst definitelyString2 = getID()!;\n\n// Ou pode com segurança checar a existência do valor usando if:\n\nif (userID) {\n  console.log(userID);\n}\n\n// Optional Properties\n\n// Void\n\n</pre></code>\n// Void é a tipagem de retorno quando uma função não\n tem um valor de retorno.\n\n<code><pre>\nconst voidFunction = () => {};\nconst resultOfVoidFunction = voidFunction();\n\n</pre></code>\n// Isso geralmente é um acidente, e o TypeScript mantém o tipo void\n para que você tenha erros de compilação - mesmo que em\n tempo de execução ele seria um valor undefined.\n","redirectHref":"pt/play/?strictNullChecks=false#example/nullable-types"}},"staticQueryHashes":[]}