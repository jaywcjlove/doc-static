{"componentChunkName":"component---src-templates-documentation-tsx","path":"/pt/docs/handbook/type-compatibility.html","result":{"data":{"markdownRemark":{"id":"d3d92e3e-b152-50dd-b37c-bf13442706be","excerpt":"Compatibilidade de tipos no Typescript é baseado em subtipagem estrutural.\nTipagem estrutural é um forma de relacionar tipos baseado exclusivamente em seus…","html":"<p>Compatibilidade de tipos no Typescript é baseado em subtipagem estrutural.\nTipagem estrutural é um forma de relacionar tipos baseado exclusivamente em seus membros.\nIsso vai de encontro com a tipagem nominal.\nConsidere o código a seguir:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Nomeado {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">nome</span><span style=\"color: #000000\">: string;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> Pessoa {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">nome</span><span style=\"color: #000000\">: string;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">p</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> Nomeado</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #008000\">// OK, por causa da tipagem estrutural</span>\n<span style=\"color: #1A1A1A\">p</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> Pessoa();</span></code></div></pre>\n<p>Em linguagens nominalmente tipadas como C# ou Java, o código equivalente seria um erro porque a classe <code>Pessoa</code> não se descreve explícitamente como sendo um implementador da interface <code>Nomeado</code>.</p>\n<p>O sistema de tipagem estrutural TypeScript foi projetado baseado em como o código Javascript é tipicamente escrito.\nPor que o Javascript faz uso amplo de objetos anônimos como funções de expressões e literais de objetos, é muito mais natural representar os tipos de relacionamentos encontrados em bibliotecas JavaScript com um sistema de tipo estrutural do que um tipo nominal.</p>\n<h2 id=\"uma-nota-sobre-solidez\" style=\"position:relative;\"><a href=\"#uma-nota-sobre-solidez\" aria-label=\"uma nota sobre solidez permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Uma nota sobre Solidez</h2>\n<p>O sistema de tipos TypeScript permite certas operações, que não poderiam ser conhecidas em tempo de compilação, a serem seguras.\nQuando um sistema de tipos tem essa propriedade, fica dito não ser “sólido” (<em>sound</em>). Os locais onde Typescript permite comportamento não sólido foram considerados cuidadosamente, e ao decorrer desse documento iremos explicar onde eles ocorrem e os cenários motivadores por trás deles. </p>\n<h2 id=\"começando\" style=\"position:relative;\"><a href=\"#come%C3%A7ando\" aria-label=\"começando permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Começando</h2>\n<p>A regra básica para tipagem estrutural do TypeScript é que <code>x</code> é compatível com <code>y</code> se <code>y</code> tem ao menos o mesmo numero de membros de <code>x</code>. Por exemplo:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Nomeado {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">nome</span><span style=\"color: #000000\">: string;  </span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> Nomeado</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #008000\">// o tipo inferido de y é { nome: string; localizacao: string; }</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">y </span><span style=\"color: #000000\">= { nome: </span><span style=\"color: #A31515\">\"Alice\"</span><span style=\"color: #000000\">, localizacao: </span><span style=\"color: #A31515\">\"Acre\"</span><span style=\"color: #000000\"> };</span>\n<span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">;</span></code></div></pre>\n<p>Para verificar quando <code>y</code> pode ser atribuído a <code>x</code>, o compilador checa cada propriedade de <code>x</code> para encontrar uma propriedade compatível em  <code>y</code>.\nNesse caso, <code>y</code> precisa ter um membro chamado <code>nome</code> que é uma string. Tendo feito, então a atribuição é permitida.</p>\n<p>A mesma regra para atribuição é usada ao verificar chamadas dos argumentos da função:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> cumprimenta(</span><span style=\"color: #1A1A1A\">n</span><span style=\"color: #000000\">: Nomeado) {</span>\n<span style=\"color: #000000\">  console.log(</span><span style=\"color: #A31515\">\"Olá, \"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">n</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">nome</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #000000\">cumprimenta(</span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// OK</span></code></div></pre>\n<p>Perceba que <code>y</code> tem uma propriedade <code>localizacao</code> extra, mas isso não cria um erro.\nApenas membros do tipo alvo (<code>Nomeado</code> nesse caso) são considerados ao checar por compatibilidade.</p>\n<p>Esse processo de comparação ocorre recursivamente, explorando o tipo de cada membro e sub-membro.</p>\n<h2 id=\"comparando-duas-funções\" style=\"position:relative;\"><a href=\"#comparando-duas-fun%C3%A7%C3%B5es\" aria-label=\"comparando duas funções permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Comparando duas funções</h2>\n<p>Enquanto comparar tipos primitivos é relativamente simples, a questão de quais tipos de funções deveriam ser consideradas compatíveis é um pouco mais difícil. Vamos começar com um exemplo básico de duas funções que diferem apenas em sua lista de parâmetros:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">x </span><span style=\"color: #000000\">= (</span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">: number) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> </span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">y </span><span style=\"color: #000000\">= (</span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">: number, </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">: string) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> </span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">;</span>\n\n<span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// OK</span>\n<span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Erro</span></code></div></pre>\n<p>Para verificar se <code>x</code> é atribuível a <code>y</code>, primeiro olhamos a lista de parâmetros.\nCada parâmetro em <code>x</code> precisa ter um parâmetro correspondente em <code>y</code>com um tipo compatível.\nPerceba que o nome dos parâmetros não são considerados, apenas seus tipos.\nNesse caso, cada parâmetro de <code>x</code> tem um parâmetro correspondente compatível em <code>y</code>, então a atribuição é permitida.</p>\n<p>A segunda atribuição é um erro, porque <code>y</code> tem um segundo parâmetro requerido que <code>x</code> não tem, então a atribuição não é permitida.</p>\n<p>Você pode estar se perguntando por quê permitimos parâmetros ‘descartáveis’ como no exemplo <code>y = x</code>.\nO motivo para essa atribuição ser permitida é que, ignorar parâmetros extras de funções, na verdade, é bem comum no JavaScript.\nPor exemplo, <code>Array#forEach</code> provém tres parâmetros para a função de callback: os elementos do array, seus index e o array.\nMesmo assim, é muito útil prover um callback que usa apenas o primeiro parâmetro:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">itens </span><span style=\"color: #000000\">= [</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">];</span>\n\n<span style=\"color: #008000\">// Não força esses parâmetros extras</span>\n<span style=\"color: #1A1A1A\">itens</span><span style=\"color: #000000\">.forEach((</span><span style=\"color: #1A1A1A\">item</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">index</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">array</span><span style=\"color: #000000\">) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> console.log(</span><span style=\"color: #1A1A1A\">item</span><span style=\"color: #000000\">));</span>\n\n<span style=\"color: #008000\">// Deveria ser OK!</span>\n<span style=\"color: #1A1A1A\">itens</span><span style=\"color: #000000\">.forEach((</span><span style=\"color: #1A1A1A\">item</span><span style=\"color: #000000\">) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> console.log(</span><span style=\"color: #1A1A1A\">item</span><span style=\"color: #000000\">));</span></code></div></pre>\n<p>Agora vamos olhar como os tipos retornados são tratados usando duas funções que diferem apenas em seu tipo retornado:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">x </span><span style=\"color: #000000\">= () </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> ({ nome: </span><span style=\"color: #A31515\">\"Alice\"</span><span style=\"color: #000000\"> });</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">y </span><span style=\"color: #000000\">= () </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> ({ nome: </span><span style=\"color: #A31515\">\"Alice\"</span><span style=\"color: #000000\">, localizacao: </span><span style=\"color: #A31515\">\"Acre\"</span><span style=\"color: #000000\"> });</span>\n\n<span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// OK</span>\n<span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Erro, porque falta a propriedade localizacao em x()</span></code></div></pre>\n<p>O sistema de tipos força que o retorno da função fonte seja um subtipo do tipo retornado da função alvo.</p>\n<h2 id=\"parâmetro-de-função-bivariado\" style=\"position:relative;\"><a href=\"#par%C3%A2metro-de-fun%C3%A7%C3%A3o-bivariado\" aria-label=\"parâmetro de função bivariado permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parâmetro de Função Bivariado</h2>\n<p>Ao comparar os tipos de parâmetros de funções, a atribuição tem sucesso se o parâmetro fonte é atribuível ao parâmetro alvo, ou vice versa.\nIsso é não sólido pois pode ser dada a uma função chamadora uma função que retorna um tipo mais especializado, mas invoca a função com um tipo menos especializado.\nNa pratica, esse tipo de erro é raro, e permitir esse comportamento viabiliza muitos padrões comuns do JavaScript. Um exemplo breve:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">enum</span><span style=\"color: #000000\"> EventType {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">Mouse</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">Keyboard</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Event {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">timestamp</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> MouseEvent </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> Event {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> KeyEvent </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> Event {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">keyCode</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> listenEvent(</span><span style=\"color: #1A1A1A\">eventType</span><span style=\"color: #000000\">: EventType, handler: (</span><span style=\"color: #1A1A1A\">n</span><span style=\"color: #000000\">: Event) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">/* ... */</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #008000\">// Não sólido, mas útil e comum</span>\n<span style=\"color: #000000\">listenEvent(</span><span style=\"color: #1A1A1A\">EventType</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">Mouse</span><span style=\"color: #000000\">, (</span><span style=\"color: #1A1A1A\">e</span><span style=\"color: #000000\">: MouseEvent) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> console.log(</span><span style=\"color: #1A1A1A\">e</span><span style=\"color: #000000\">.x + </span><span style=\"color: #A31515\">\",\"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">e</span><span style=\"color: #000000\">.y));</span>\n\n<span style=\"color: #008000\">// Alternativas indesejáveis na presença de solidez</span>\n<span style=\"color: #000000\">listenEvent(</span><span style=\"color: #1A1A1A\">EventType</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">Mouse</span><span style=\"color: #000000\">, (</span><span style=\"color: #1A1A1A\">e</span><span style=\"color: #000000\">: Event) </span><span style=\"color: #0000FF\">=&gt;</span>\n<span style=\"color: #000000\">  console.log((</span><span style=\"color: #1A1A1A\">e</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> MouseEvent).x + </span><span style=\"color: #A31515\">\",\"</span><span style=\"color: #000000\"> + (</span><span style=\"color: #1A1A1A\">e</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> MouseEvent).y)</span>\n<span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">listenEvent(</span><span style=\"color: #1A1A1A\">EventType</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">Mouse</span><span style=\"color: #000000\">, ((</span><span style=\"color: #1A1A1A\">e</span><span style=\"color: #000000\">: MouseEvent) </span><span style=\"color: #0000FF\">=&gt;</span>\n<span style=\"color: #000000\">  console.log(</span><span style=\"color: #1A1A1A\">e</span><span style=\"color: #000000\">.x + </span><span style=\"color: #A31515\">\",\"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">e</span><span style=\"color: #000000\">.y)) </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">e</span><span style=\"color: #000000\">: Event) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void);</span>\n\n<span style=\"color: #008000\">// Ainda não permitido (erro claro). Segurança de tipos forçada para tipos completamente incompatíveis</span>\n<span style=\"color: #000000\">listenEvent(</span><span style=\"color: #1A1A1A\">EventType</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">Mouse</span><span style=\"color: #000000\">, (</span><span style=\"color: #1A1A1A\">e</span><span style=\"color: #000000\">: number) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> console.log(</span><span style=\"color: #1A1A1A\">e</span><span style=\"color: #000000\">));</span></code></div></pre>\n<p>Você pode ter o TypeScript lançando erros quando isso acontece pela marcação do compilador <code>strictFunctionTypes</code>.</p>\n<h2 id=\"parâmetros-opcionais-e-parâmetros-rest\" style=\"position:relative;\"><a href=\"#par%C3%A2metros-opcionais-e-par%C3%A2metros-rest\" aria-label=\"parâmetros opcionais e parâmetros rest permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parâmetros Opcionais e Parâmetros Rest</h2>\n<p>Ao comparar funções para compatibilidade, parâmetros opcionais e requeridos são intercambiáveis.\nParâmetros opcionais extras do tipo fonte não são um erro e parâmetros opcionais do tipo alvo, sem parâmetros correspondentes no tipo fonte, não são um erro.</p>\n<p>Quando uma função tem um parâmetro do tipo rest, ela é tratada como se tivesse uma série infinita de parâmetros opcionais.</p>\n<p>Isso não sólido pela perspectiva do sistema de tipos, mas pelo ponto de vista do tempo de execução a ideia de um parâmetro opcional é geralmente reforçada, uma vez que é o equivalente a passar <code>undefined</code> naquela posição para a maioria das funções.</p>\n<p>O exemplo motivacional é o padrão comum de uma função que recebe um callback e a chama com alguma previsibilidade (para o programador) mas com numero desconhecido (para o sistema de tipos) de argumentos:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> chamaDepois(</span><span style=\"color: #1A1A1A\">args</span><span style=\"color: #000000\">: any[], callback: (...</span><span style=\"color: #1A1A1A\">args</span><span style=\"color: #000000\">: any[]) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">/* ... Chama callback com 'args' ... */</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #008000\">// Não sólido - chamaDepois \"poderia\" prover qualquer numero de argumentos</span>\n<span style=\"color: #000000\">chamaDepois([</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">], (</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> console.log(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> + </span><span style=\"color: #A31515\">\", \"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">));</span>\n\n<span style=\"color: #008000\">// Confuso (x e y, na verdade, são requeridos ) e indetectáveis</span>\n<span style=\"color: #000000\">chamaDepois([</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">], (</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">?, </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">?) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> console.log(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> + </span><span style=\"color: #A31515\">\", \"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">));</span></code></div></pre>\n<h2 id=\"funções-com-sobrecarga\" style=\"position:relative;\"><a href=\"#fun%C3%A7%C3%B5es-com-sobrecarga\" aria-label=\"funções com sobrecarga permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Funções com sobrecarga</h2>\n<p>Quando uma função tem sobrecarga, cada sobrecarga no tipo fonte deve combinar com uma assinatura compatível no tipo alvo.\nIsso assegura que a função alvo pode ser chamada nas mesmas situações da função fonte.</p>\n<h2 id=\"enums\" style=\"position:relative;\"><a href=\"#enums\" aria-label=\"enums permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Enums</h2>\n<p>Enums são compatíveis com números e números são compatíveis com enums. Valores de Enum de tipos de enum diferentes são considerados incompatíveis. Por Exemplo,</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">enum</span><span style=\"color: #000000\"> Status {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">Pronto</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">Esperando</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">enum</span><span style=\"color: #000000\"> Cor {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">Vermelho</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">Azul</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">Verde</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">status </span><span style=\"color: #000000\">= </span><span style=\"color: #1A1A1A\">Status</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">Pronto</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #1A1A1A\">status</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">Cor</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">Verde</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Erro</span></code></div></pre>\n<h2 id=\"classes\" style=\"position:relative;\"><a href=\"#classes\" aria-label=\"classes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Classes</h2>\n<p>Classes funcionam de forma similar a tipos literais de objetos e interfaces, com uma exceção: Ambos tem um tipo estático e de instancia.\nAo comparar dois objetos de um tipo de classe, apenas membros da instancia são comparados.\nMembros estáticos e construtores não afetam a compatibilidade.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> Animal {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">patas</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">(</span><span style=\"color: #1A1A1A\">nome</span><span style=\"color: #000000\">: string, </span><span style=\"color: #1A1A1A\">numPatas</span><span style=\"color: #000000\">: number) {}</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> Tamanho {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">patas</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">(</span><span style=\"color: #1A1A1A\">numPatas</span><span style=\"color: #000000\">: number) {}</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> Animal</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> Tamanho</span><span style=\"color: #000000\">;</span>\n\n<span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// OK</span>\n<span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// OK</span></code></div></pre>\n<h2 id=\"membros-privados-e-protegidos-em-classes\" style=\"position:relative;\"><a href=\"#membros-privados-e-protegidos-em-classes\" aria-label=\"membros privados e protegidos em classes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Membros privados e protegidos em classes</h2>\n<p>Membros privados e protegidos em uma classe afetam sua compatibilidade.\nQuando a compatibilidade de uma instancia de classe é verificada, se o tipo alvo contem um membro privado, então o tipo fonte também precisa conter um membro privado que se originou da mesma classe.\nDe forma semelhante, o mesmo se aplica para uma instancia com um membro protegido.\nIsso permite manter a compatibilidade de atribuição com a sua classe super, mas <em>não</em> com classes de hierarquias de heranças diferentes que, de outra forma, possuem a mesma estrutura.</p>\n<h2 id=\"generics\" style=\"position:relative;\"><a href=\"#generics\" aria-label=\"generics permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generics</h2>\n<p>Porquê TypeScript é um sistema de tipo estrutural, tipo dos parâmetros apenas afetam o tipo resultante quando consumidos como parte do tipo de um membro. Por Exemplo,</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Empty&lt;T&gt; {}</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> Empty&lt;number&gt;</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> Empty&lt;string&gt;</span><span style=\"color: #000000\">;</span>\n\n<span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// OK, porque y combina com a estrutura de x</span></code></div></pre>\n<p>No exemplo acima, <code>x</code> e <code>y</code> são compatíveis porque suas estruturas não usam o argumento de tipo de forma diferenciativa.\nModificando esse exemplo adicionando um membro a <code>Empty&#x3C;T></code> mostra como isso funciona: </p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> NaoVazio&lt;T&gt; {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">data</span><span style=\"color: #000000\">: T;</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> NaoVazio&lt;number&gt;</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> NaoVazio&lt;string&gt;</span><span style=\"color: #000000\">;</span>\n\n<span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Erro, porque x e y não são compatíveis</span></code></div></pre>\n<p>Dessa forma, um tipo genérico que tem os seus tipos de argumentos especificados age como um tipo não genérico.</p>\n<p>Para tipos genéricos que nao tem seus tipos de argumentos especificados, a compatibilidade é verificada especificando <code>any</code> no lugar de todos os tipos de argumentos não especificados.\nA compatibilidade dos tipos resultantes é então verificada, assim como no caso dos tipos não genéricos.</p>\n<p>Por exemplo,</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">identidade </span><span style=\"color: #000000\">= </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> &lt;T&gt;(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: T): T {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">};</span>\n\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">reverter </span><span style=\"color: #000000\">= </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> &lt;U&gt;(</span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">: U): U {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">};</span>\n\n<span style=\"color: #1A1A1A\">identidade</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">reverter</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// OK, porque (x: any) =&gt; any bate com (y: any) =&gt; any</span></code></div></pre>\n<h2 id=\"tópicos-avançados\" style=\"position:relative;\"><a href=\"#t%C3%B3picos-avan%C3%A7ados\" aria-label=\"tópicos avançados permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tópicos avançados</h2>\n<h2 id=\"subtipos-vs-atribuições\" style=\"position:relative;\"><a href=\"#subtipos-vs-atribui%C3%A7%C3%B5es\" aria-label=\"subtipos vs atribuições permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Subtipos vs Atribuições</h2>\n<p>Até aqui, temos usado “compatível”, que não é um termo definido nas especificações da linguagem.\nEm TypeScript, existem dois tipos de compatibilidade: subtipos e atribuições.\nEles diferem apenas no fato de que a atribuição estende a compatibilidade do subtipo com regras para permitir a atribuição de e para <code>enum</code> com valores numéricos correspondentes. </p>\n<p>Diferentes locais na linguagem usam um dos dois tipos de mecanismos de compatibilidade, dependendo da situação.\nPara fins práticos, compatibilidade de tipos é ditada pela compatibilidade de atribuição, mesmo no casos das clausulas <code>implements</code> e <code>extends</code>.</p>","headings":[{"value":"Uma nota sobre Solidez","depth":2},{"value":"Começando","depth":2},{"value":"Comparando duas funções","depth":2},{"value":"Parâmetro de Função Bivariado","depth":2},{"value":"Parâmetros Opcionais e Parâmetros Rest","depth":2},{"value":"Funções com sobrecarga","depth":2},{"value":"Enums","depth":2},{"value":"Classes","depth":2},{"value":"Membros privados e protegidos em classes","depth":2},{"value":"Generics","depth":2},{"value":"Tópicos avançados","depth":2},{"value":"Subtipos vs Atribuições","depth":2}],"frontmatter":{"permalink":"/pt/docs/handbook/type-compatibility.html","title":"Compatibilidade de Tipos","disable_toc":null,"handbook":null,"oneline":"Como checagem de tipos funciona em TypeScript","beta":null}},"prev":null,"next":null},"pageContext":{"id":"2compatibilidade-de-tipos","slug":"/pt/docs/handbook/type-compatibility.html","repoPath":"/packages/documentation/copy/pt/reference/Type Compatibility.md","lang":"pt","modifiedTime":"2020-11-23T10:39:15.627Z"}},"staticQueryHashes":[]}