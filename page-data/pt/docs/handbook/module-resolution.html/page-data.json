{"componentChunkName":"component---src-templates-documentation-tsx","path":"/pt/docs/handbook/module-resolution.html","result":{"data":{"markdownRemark":{"id":"e6a54fda-1cb5-5391-a0fa-d84c7981a17b","excerpt":"Esta seção assume alguns conhecimentos básicos sobre módulos.\nPor favor veja a documentação de Modulos para mais informações. Resolução de Módulos (ou Module…","html":"<blockquote>\n<p>Esta seção assume alguns conhecimentos básicos sobre módulos.\nPor favor veja a documentação de <a href=\"/docs/handbook/modules.html\">Modulos</a> para mais informações.</p>\n</blockquote>\n<p><em>Resolução de Módulos</em> (ou <em>Module Resolution</em>) é o processo que o compilador usa para descobrir a que se refere uma importação.\nConsidere uma declaração de importação como <code>import { a } from \"moduleA\"</code>;\na fim de verificar qualquer uso de <code>a</code>, o compilador precisa saber exatamente o que ele representa, e será necessário verificar sua definição <code>moduleA</code>.</p>\n<p>Neste ponto, o compilador perguntará “qual é a forma do módulo <code>moduleA</code>?”\nEmbora isso pareça simples, <code>moduleA</code> poderia ser definido em um de seus próprios arquivos <code>.ts</code>/<code>.tsx</code>, ou em um arquivo <code>.d.ts</code> que seu código depende.</p>\n<p>Primeiro, o compilador tentará localizar um arquivo que representa o módulo importado.\nPara fazer isso, o compilador segue uma das duas estratégias diferentes: <a href=\"#classico\">Clássico</a> ou <a href=\"#node\">Node</a>.\nEssas estratégias dizem ao compilador <em>onde</em> procurar por <code>moduleA</code>.</p>\n<p>Se isso não funcionar e se o nome do módulo não for relativo (e no caso de <code>\"moduleA\"</code>, é relativo), então o compilador tentará localizar um <a href=\"/docs/handbook/modules.html#ambient-modules\">ambient module declaration</a>.\nVamos cobrir as importações não relativas a seguir.</p>\n<p>Finalmente, se o compilador não puder resolver o módulo, ele registrará um erro.\nNesse caso, o erro seria algo como <code>error TS2307: Cannot find module 'moduleA'.</code></p>\n<h2 id=\"importações-de-módulos-relativos-vs-não-relativos\" style=\"position:relative;\"><a href=\"#importa%C3%A7%C3%B5es-de-m%C3%B3dulos-relativos-vs-n%C3%A3o-relativos\" aria-label=\"importações de módulos relativos vs não relativos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Importações de módulos relativos vs. não relativos</h2>\n<p>As importações de módulo são resolvidas de forma diferente com base em se a referência do módulo é relativa ou não relativa.</p>\n<p>Uma <em>importação relativa</em> é aquela que começa com <code>/</code>, <code>./</code> ou <code>../</code>.\nAlguns exemplos incluem:</p>\n<ul>\n<li><code>import Entry from \"./components/Entry\";</code></li>\n<li><code>import { DefaultHeaders } from \"../constants/http\";</code></li>\n<li><code>import \"/mod\";</code></li>\n</ul>\n<p>Qualquer outra importação é considerada <strong>não relativa</strong>.\nAlguns exemplos incluem:</p>\n<ul>\n<li><code>import * as $ from \"jquery\";</code></li>\n<li><code>import { Component } from \"@angular/core\";</code></li>\n</ul>\n<p>Uma importação relativa é resolvida em relação ao arquivo de importação e <em>não pode</em> ser resolvida para uma declaração de módulo de ambiente.\nVocê deve usar importações relativas para seus próprios módulos, que garantem manter sua localização relativa no tempo de execução.</p>\n<p>Uma importação não relativa pode ser resolvida em relação ao <code>baseUrl</code>, ou por meio de mapeamento de caminho, que abordaremos a seguir.\nEles também podem resolver para <a href=\"/docs/handbook/modules.html#ambient-modules\">declarações do módulo ambiente</a>.\nUse caminhos não relativos ao importar qualquer uma de suas dependências externas.</p>\n<h2 id=\"estratégias-de-resolução-de-módulo\" style=\"position:relative;\"><a href=\"#estrat%C3%A9gias-de-resolu%C3%A7%C3%A3o-de-m%C3%B3dulo\" aria-label=\"estratégias de resolução de módulo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Estratégias de resolução de módulo</h2>\n<p>Existem duas estratégias de resolução de módulo possíveis: <a href=\"#node\">Node</a> e <a href=\"#classico\">Clássico</a>.\nVocê pode usar a flag <code>--moduleResolution</code> para especificar a estratégia de resolução do módulo.\nSe não for especificado, o padrão é <a href=\"#node\">Node</a> para <code>--module commonjs</code>, e <a href=\"#classico\">Clássico</a> para qualquer outra forma (incluso quando <code>--module</code> está configurado para <code>amd</code>, <code>system</code>, <code>umd</code>, <code>es2015</code>, <code>esnext</code>, etc.).</p>\n<blockquote>\n<p>Note: <code>node</code> A resolução do módulo é a mais comumente usada na comunidade TypeScript e é recomendada para a maioria dos projetos.\nSe você está tendo problemas de resolução com <code>import</code>s e <code>export</code>s em TypeScript, tente definir <code>moduleResolution: \"node\"</code> para ver se isso corrige o problema.</p>\n</blockquote>\n<h3 id=\"clássico\" style=\"position:relative;\"><a href=\"#cl%C3%A1ssico\" aria-label=\"clássico permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Clássico</h3>\n<p>Essa costumava ser a estratégia de resolução padrão do TypeScript.\nAtualmente, essa estratégia está presente principalmente para compatibilidade com versões anteriores.</p>\n<p>Uma importação relativa será resolvida em relação ao arquivo de importação.\nEntão <code>import { b } from \"./moduleB\"</code> no arquivo <code>/root/src/folder/A.ts</code> resultaria nas seguintes pesquisas:</p>\n<ol>\n<li><code>/root/src/folder/moduleB.ts</code></li>\n<li><code>/root/src/folder/moduleB.d.ts</code></li>\n</ol>\n<p>Para importações de módulos não relativos, entretanto, o compilador sobe na árvore de diretórios começando com o diretório que contém o arquivo de importação, tentando localizar um arquivo de definição correspondente.</p>\n<p>Por exemplo:</p>\n<p>Uma importação não relativa para <code>moduleB</code> como <code>import { b } from \"moduleB\"</code>, no arquivo <code>/root/src/folder/A.ts</code>, resultaria na tentativa dos seguintes locais para localizar <code>\"moduleB\"</code>:</p>\n<ol>\n<li><code>/root/src/folder/moduleB.ts</code></li>\n<li><code>/root/src/folder/moduleB.d.ts</code></li>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li><code>/root/moduleB.ts</code></li>\n<li><code>/root/moduleB.d.ts</code></li>\n<li><code>/moduleB.ts</code></li>\n<li><code>/moduleB.d.ts</code></li>\n</ol>\n<h3 id=\"node\" style=\"position:relative;\"><a href=\"#node\" aria-label=\"node permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node</h3>\n<p>Esta estratégia de resolução tenta imitar o mecanismo de resolução do módulo em tempo de execução do <a href=\"https://nodejs.org/\">Node.js</a>.\nO algoritmo de resolução Node.js completo é descrito na <a href=\"https://nodejs.org/api/modules.html#modules_all_together\">Documentação de módulos do Node.js </a>.</p>\n<h4 id=\"como-o-nodejs-resolve-os-módulos\" style=\"position:relative;\"><a href=\"#como-o-nodejs-resolve-os-m%C3%B3dulos\" aria-label=\"como o nodejs resolve os módulos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Como o Node.js resolve os módulos</h4>\n<p>Para entender quais etapas o compilador TS seguirá, é importante explicar como funciona os módulos Node.js.\nTradicionalmente, as importações em Node.js são realizadas chamando uma função chamada <code>require</code>.\nO comportamento do Node.js será diferente dependendo se <code>require</code> recebe um caminho relativo ou um caminho não relativo.</p>\n<p>Os caminhos relativos são bastante simples.\nComo exemplo, vamos considerar um arquivo localizado em <code>/root/src/moduleA.js</code>, que contém a importação <code>var x = require(\"./moduleB\");</code>\nNode.js resolve essa importação na seguinte ordem:</p>\n<ol>\n<li>Pergunte ao arquivo chamado <code>/root/src/moduleB.js</code>, se existe.</li>\n<li>Verifique se a pasta <code>/root/src/moduleB</code> contém um arquivo chamado <code>package.json</code> que especifica um módulo <code>\"main\"</code>.\nEm nosso exemplo, se o Node.js encontrar o arquivo <code>/root/src/moduleB/package.json</code> contendo <code>{ \"main\": \"lib/mainModule.js\" }</code>, então o Node.js vai referir-se a <code>/root/src/moduleB/lib/mainModule.js</code>.</li>\n<li>Verifique se a pasta <code>/root/src/moduleB</code> contém um arquivo chamado <code>index.js</code>.\nEsse arquivo é implicitamente considerado o módulo “principal” dessa pasta.</li>\n</ol>\n<p>Você pode ler mais sobre isso na documentação do Node.js disponível em <a href=\"https://nodejs.org/api/modules.html#modules_file_modules\">módulos de arquivo</a> e <a href=\"https://nodejs.org/api/modules.html#modules_folders_as_modules\">módulos de pasta</a>.</p>\n<p>No entanto, a resolução para um <a href=\"#importacoes-de-modulos-relativos-vs.-nao-relativos\">nome do módulo não relativa</a> é realizada de forma diferente.\nO Node irá procurar seus módulos em pastas especiais chamadas <code>node_modules</code>.\nUma pasta <code>node_modules</code> pode estar no mesmo nível do arquivo atual, ou superior na cadeia de pastas.\nO Node irá percorrer a cadeia de diretórios, olhando através de cada <code>node_modules</code> até encontrar o módulo que você tentou carregar.</p>\n<p>Seguindo nosso exemplo acima, considere se <code>/root/src/moduleA.js</code> em vez disso usasse um caminho não relativo e tivesse a importação <code>var x = require(\"moduleB\");</code>.\nO Node tentaria resolver o <code>moduleB</code> para cada um dos locais até que um funcionasse.</p>\n<ol>\n<li><code>/root/src/node_modules/moduleB.js</code></li>\n<li><code>/root/src/node_modules/moduleB/package.json</code> (se especifica uma propriedade <code>\"main\"</code>)</li>\n<li><code>/root/src/node_modules/moduleB/index.js</code>\n<br /><br /></li>\n<li><code>/root/node_modules/moduleB.js</code></li>\n<li><code>/root/node_modules/moduleB/package.json</code> (se especifica uma propriedade <code>\"main\"</code>)</li>\n<li><code>/root/node_modules/moduleB/index.js</code>\n<br /><br /></li>\n<li><code>/node_modules/moduleB.js</code></li>\n<li><code>/node_modules/moduleB/package.json</code> (se especifica uma propriedade <code>\"main\"</code>)</li>\n<li><code>/node_modules/moduleB/index.js</code></li>\n</ol>\n<p>Observe que o Node.js saltou para um diretório nas etapas (4) e (7).</p>\n<p>Você pode ler mais sobre o processo na documentação do Node.js em <a href=\"https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders\">carregando módulos do <code>node_modules</code></a>.</p>\n<h4 id=\"como-o-typescript-resolve-os-módulos\" style=\"position:relative;\"><a href=\"#como-o-typescript-resolve-os-m%C3%B3dulos\" aria-label=\"como o typescript resolve os módulos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Como o TypeScript resolve os módulos</h4>\n<p>O TypeScript irá imitar a estratégia de resolução de tempo de execução do Node.js para localizar arquivos de definição para módulos em tempo de compilação.\nPara realizar isso, TypeScript sobrepõe as extensões de arquivo de origem do TypeScript (<code>.ts</code>, <code>.tsx</code>, and <code>.d.ts</code>) sobre a lógica de resolução do Node.\nTypeScript também usará um campo no <code>package.json</code> chamado <code>\"types\"</code> para espelhar o propósito de <code>\"main\"</code> - o compilador irá usá-lo para encontrar o arquivo de definição “principal” para consultar.</p>\n<p>Por exemplo, uma declaração de importação como <code>import { b } from \"./moduleB\"</code> em <code>/root/src/moduleA.ts</code> resultaria na tentativa dos seguintes locais para localizar <code>\"./moduleB\"</code>:</p>\n<ol>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.tsx</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li><code>/root/src/moduleB/package.json</code> (se especifica uma propriedade <code>\"types\"</code>)</li>\n<li><code>/root/src/moduleB/index.ts</code></li>\n<li><code>/root/src/moduleB/index.tsx</code></li>\n<li><code>/root/src/moduleB/index.d.ts</code></li>\n</ol>\n<p>Lembre-se de que o Node.js procurou um arquivo chamado <code>moduleB.js</code>, então um aplicável <code>package.json</code>, e então por um <code>index.js</code>.</p>\n<p>Da mesma forma, uma importação não relativa seguirá a lógica de resolução do Node.js, primeiro procurando um arquivo, depois procurando uma pasta aplicável.\nEntão <code>import { b } from \"moduleB\"</code> no arquivo <code>/root/src/moduleA.ts</code> resultaria nas seguintes pesquisas:</p>\n<ol>\n<li><code>/root/src/node_modules/moduleB.ts</code></li>\n<li><code>/root/src/node_modules/moduleB.tsx</code></li>\n<li><code>/root/src/node_modules/moduleB.d.ts</code></li>\n<li><code>/root/src/node_modules/moduleB/package.json</code> (se especifica uma propriedade <code>\"types\"</code>)</li>\n<li><code>/root/src/node_modules/@types/moduleB.d.ts</code></li>\n<li><code>/root/src/node_modules/moduleB/index.ts</code></li>\n<li><code>/root/src/node_modules/moduleB/index.tsx</code></li>\n<li><code>/root/src/node_modules/moduleB/index.d.ts</code>\n<br /><br /></li>\n<li><code>/root/node_modules/moduleB.ts</code></li>\n<li><code>/root/node_modules/moduleB.tsx</code></li>\n<li><code>/root/node_modules/moduleB.d.ts</code></li>\n<li><code>/root/node_modules/moduleB/package.json</code> (se especifica uma propriedade <code>\"types\"</code>)</li>\n<li><code>/root/node_modules/@types/moduleB.d.ts</code></li>\n<li><code>/root/node_modules/moduleB/index.ts</code></li>\n<li><code>/root/node_modules/moduleB/index.tsx</code></li>\n<li><code>/root/node_modules/moduleB/index.d.ts</code>\n<br /><br /></li>\n<li><code>/node_modules/moduleB.ts</code></li>\n<li><code>/node_modules/moduleB.tsx</code></li>\n<li><code>/node_modules/moduleB.d.ts</code></li>\n<li><code>/node_modules/moduleB/package.json</code> (se especifica uma propriedade <code>\"types\"</code>)</li>\n<li><code>/node_modules/@types/moduleB.d.ts</code></li>\n<li><code>/node_modules/moduleB/index.ts</code></li>\n<li><code>/node_modules/moduleB/index.tsx</code></li>\n<li><code>/node_modules/moduleB/index.d.ts</code></li>\n</ol>\n<p>Não se assuste com o número de etapas aqui - o TypeScript ainda só pula os diretórios duas vezes nas etapas (9) e (17).\nIsso realmente não é mais complexo do que o que o próprio Node.js está fazendo.</p>\n<h2 id=\"flags-de-resolução-de-módulo-adicional\" style=\"position:relative;\"><a href=\"#flags-de-resolu%C3%A7%C3%A3o-de-m%C3%B3dulo-adicional\" aria-label=\"flags de resolução de módulo adicional permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Flags de resolução de módulo adicional</h2>\n<p>Um layout de origem do projeto às vezes não corresponde ao da saída.\nNormalmente, um conjunto de etapas de construção resulta na geração da saída final.\nIsso inclui compilar arquivos <code>.ts</code> em <code>.js</code> e copiar dependências de diferentes locais de origem para um único local de saída.\nO resultado final é que os módulos em tempo de execução podem ter nomes diferentes dos arquivos de origem que contêm suas definições.\nOu os caminhos do módulo na saída final podem não corresponder aos caminhos do arquivo de origem correspondente no momento da compilação.</p>\n<p>O compilador TypeScript tem um conjunto de sinalizadores adicionais para <em>informar</em> o compilador de transformações que devem ocorrer nas fontes para gerar a saída final.</p>\n<p>É importante observar que o compilador <em>não</em> executará nenhuma dessas transformações;\nEle apenas usa essas informações para guiar o processo de resolução de uma importação de módulo para seu arquivo de definição.</p>\n<h3 id=\"url-base\" style=\"position:relative;\"><a href=\"#url-base\" aria-label=\"url base permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>URL base</h3>\n<p>Usar um <code>baseUrl</code> é uma prática comum em aplicativos que usam carregadores de módulo AMD onde os módulos são “deployados” em uma única pasta em tempo de execução.\nAs fontes desses módulos podem estar em diretórios diferentes, mas um script de construção irá colocá-los todos juntos.</p>\n<p>Definir <code>baseUrl</code> informa ao compilador onde encontrar os módulos.\nTodas as importações de módulos com nomes não relativos são consideradas relativas ao <code>baseUrl</code>.</p>\n<p>O valor de <em>baseUrl</em> é determinado como:</p>\n<ul>\n<li>valor do argumento da linha de comando <em>baseUrl</em> (se o caminho fornecido for relativo, é calculado com base no diretório atual)</li>\n<li>valor da propriedade <em>baseUrl</em> em ‘tsconfig.json’ (se o caminho fornecido for relativo, ele é calculado com base na localização de ‘tsconfig.json’)</li>\n</ul>\n<p>Observe que as importações de módulos relativos não são afetadas pela configuração de baseUrl, pois elas sempre são resolvidas em relação aos arquivos de importação.</p>\n<p>Você pode encontrar mais documentação sobre baseUrl em <a href=\"http://requirejs.org/docs/api.html#config-baseUrl\">RequireJS</a> e <a href=\"https://github.com/systemjs/systemjs/blob/master%20/docs/api.md#baseurl\">SystemJS</a>.</p>\n<h3 id=\"mapeamento-de-caminhos\" style=\"position:relative;\"><a href=\"#mapeamento-de-caminhos\" aria-label=\"mapeamento de caminhos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mapeamento de caminhos</h3>\n<p>Às vezes, os módulos não estão localizados diretamente em <em>baseUrl</em>.\nPor exemplo, uma importação para um módulo <code>\"jquery\"</code> seria traduzido em tempo de execução para <code>\"node_modules/jquery/dist/jquery.slim.min.js\"</code>.\nOs carregadores usam uma configuração de mapeamento para mapear nomes de módulos para arquivos em tempo de execução, consulte a <a href=\"http://requirejs.org/docs/api.html#config-paths\">documentação do RequireJs</a> e a <a href=\"https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths\">documentação do SystemJS</a>.</p>\n<p>O compilador TypeScript suporta a declaração de tais mapeamentos usando a propriedade <code>\"paths\"</code> nos arquivos <code>tsconfig.json</code>.\nAqui está um exemplo de como especificar a propriedade <code>\"paths\"</code> para <code>jquery</code>.</p>\n<pre class=\"shiki tsconfig lsp\"><div class='code-container'><code><span style=\"color: #000000\">{</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"<a aria-hidden=true href='https://www.typescriptlang.org/tsconfig#compilerOptions'><data-lsp lsp=\"The set of compiler options for your project\">compilerOptions</data-lsp></a>\"</span><span style=\"color: #000000\">: {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"<a aria-hidden=true href='https://www.typescriptlang.org/tsconfig#baseUrl'><data-lsp lsp=\"Specify the base directory to resolve non-relative module names.\">baseUrl</data-lsp></a>\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\".\"</span><span style=\"color: #000000\">, </span><span style=\"color: #008000\">// Deve ser especificado se \"caminhos\" for .</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"<a aria-hidden=true href='https://www.typescriptlang.org/tsconfig#paths'><data-lsp lsp=\"Specify a set of entries that re-map imports to additional lookup locations.\">paths</data-lsp></a>\"</span><span style=\"color: #000000\">: {</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0451A5\">\"jquery\"</span><span style=\"color: #000000\">: [</span><span style=\"color: #A31515\">\"node_modules/jquery/dist/jquery\"</span><span style=\"color: #000000\">] </span><span style=\"color: #008000\">// Este mapeamento é relativo a \"baseUrl\"</span>\n<span style=\"color: #000000\">    }</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Observe que <code>\"paths\"</code> são resolvidos relativamente a <code>\"baseUrl\"</code>.\nAo definir<code>\"baseUrl\"</code> para outro valor que não <code>\".\"</code>, ou seja, o diretório de <code>tsconfig.json</code>, os mapeamentos devem ser alterados de acordo.\nDigamos que, você define <code>\"baseUrl\": \"./src\"</code> no exemplo acima, então jquery deve ser mapeado para <code>\"../node_modules/jquery/dist/jquery\"</code>.</p>\n<p>Usando <code>\"paths\"</code> também permite mapeamentos mais sofisticados, incluindo vários locais de fallback.\nConsidere uma configuração de projeto em que apenas alguns módulos estão disponíveis em um local e o restante em outro.\nUma etapa de construção iria colocá-los todos juntos em um só lugar.\nO layout do projeto pode ser semelhante a:</p>\n<pre class=\"shiki\"><div class='code-container'><code>projectRoot\n├── folder1\n│   ├── file1.ts (imports 'folder1/file2' and 'folder2/file3')\n│   └── file2.ts\n├── generated\n│   ├── folder1\n│   └── folder2\n│       └── file3.ts\n└── tsconfig.json</code></div></pre>\n<p>O correspondente <code>tsconfig.json</code> pareceria com:</p>\n<pre class=\"shiki tsconfig lsp\"><div class='code-container'><code><span style=\"color: #000000\">{</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"<a aria-hidden=true href='https://www.typescriptlang.org/tsconfig#compilerOptions'><data-lsp lsp=\"The set of compiler options for your project\">compilerOptions</data-lsp></a>\"</span><span style=\"color: #000000\">: {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"<a aria-hidden=true href='https://www.typescriptlang.org/tsconfig#baseUrl'><data-lsp lsp=\"Specify the base directory to resolve non-relative module names.\">baseUrl</data-lsp></a>\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\".\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"<a aria-hidden=true href='https://www.typescriptlang.org/tsconfig#paths'><data-lsp lsp=\"Specify a set of entries that re-map imports to additional lookup locations.\">paths</data-lsp></a>\"</span><span style=\"color: #000000\">: {</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0451A5\">\"*\"</span><span style=\"color: #000000\">: [</span><span style=\"color: #A31515\">\"*\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"generated/*\"</span><span style=\"color: #000000\">]</span>\n<span style=\"color: #000000\">    }</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Isso diz ao compilador para qualquer importação de módulo que corresponda ao padrão <code>\"*\"</code> (ou seja, todos os valores), para olhar em dois locais:</p>\n<ol>\n<li><code>\"*\"</code>: significando o mesmo nome inalterado, então mapear <code>&#x3C;moduleName></code> => <code>&#x3C;baseUrl>/&#x3C;moduleName></code></li>\n<li><code>\"generated/*\"</code> significando o nome do módulo com um prefixo anexado “gerado”, então mapear <code>&#x3C;moduleName></code> => <code>&#x3C;baseUrl>/generated/&#x3C;moduleName></code></li>\n</ol>\n<p>Seguindo essa lógica, o compilador tentará resolver as duas importações como tais:</p>\n<p>import ‘folder1/file2’:</p>\n<ol>\n<li>o padrão ’*’ é correspondido e o curinga captura todo o nome do módulo</li>\n<li>tente a primeira substituição na lista: ’*’ -> <code>folder1/file2</code></li>\n<li>resultado da substituição é nome não relativo - combiná-lo com <em>baseUrl</em> -> <code>projectRoot/folder1/file2.ts</code>.</li>\n<li>O arquivo existe. Feito.</li>\n</ol>\n<p>import ‘folder2/file3’:</p>\n<ol>\n<li>pattern ’*’ is matched and wildcard captures the whole module name</li>\n<li>tente a primeira substituição na lista: ’*’ -> <code>folder2/file3</code></li>\n<li>resultado da substituição é nome não relativo - combiná-lo com <em>baseUrl</em> -> <code>projectRoot/folder2/file3.ts</code>.</li>\n<li>Arquivo não existe, passar para a segunda substituição</li>\n<li>segunda substituição ‘gerada/*’ -> <code>generated/folder2/file3</code></li>\n<li>resultado da substituição é nome não relativo - combiná-lo com <em>baseUrl</em> -> <code>projectRoot/generated/folder2/file3.ts</code>.</li>\n<li>O arquivo existe. Feito.</li>\n</ol>\n<h3 id=\"diretórios-virtuais-com-rootdirs\" style=\"position:relative;\"><a href=\"#diret%C3%B3rios-virtuais-com-rootdirs\" aria-label=\"diretórios virtuais com rootdirs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Diretórios virtuais com <code>rootDirs</code></h3>\n<p>Às vezes, os fontes do projeto de vários diretórios em tempo de compilação são todos combinados para gerar um único diretório de saída.\nIsso pode ser visto como um conjunto de diretórios de origem para criar um diretório “virtual”.</p>\n<p>Usando ‘rootDirs’, você pode informar ao compilador as <em>roots</em> que compõem este diretório “virtual”;\ne, portanto, o compilador pode resolver as importações de módulos relativos dentro desses diretórios “virtuais” <em>como se</em> fossem mesclados em um diretório.</p>\n<p>Por exemplo, considere esta estrutura de projeto:</p>\n<pre class=\"shiki\"><div class='code-container'><code> src\n └── views\n     └── view1.ts (imports './template1')\n     └── view2.ts\n\n generated\n └── templates\n         └── views\n             └── template1.ts (imports './view2')</code></div></pre>\n<p>Arquivos em <code>src/views</code> são códigos de usuário para alguns controles de interface de usuário.\nOs arquivos em <code>generated/templates</code> são códigos de vinculação de templates de interface de usuário gerado automaticamente por um gerador de template como parte da construção.\nUma etapa de compilação irá copiar os arquivos em <code>/src/views</code> e <code>/generated/templates/views</code> para o mesmo diretório na saída.\nEm tempo de execução, uma visão pode esperar que seu modelo exista próximo a ela e, portanto, deve importá-lo usando um nome relativo como <code>\"./template\"</code>.</p>\n<p>Para especificar essa relação com o compilador, use <code>\"rootDirs\"</code>.\n<code>\"rootDirs\"</code> especifique uma lista de <em>roots</em> cujo conteúdo deve se fundir em tempo de execução.\nEntão, seguindo nosso exemplo, o <code>tsconfig.json</code> arquivo deve ser parecido com:</p>\n<pre class=\"shiki tsconfig lsp\"><div class='code-container'><code><span style=\"color: #000000\">{</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"<a aria-hidden=true href='https://www.typescriptlang.org/tsconfig#compilerOptions'><data-lsp lsp=\"The set of compiler options for your project\">compilerOptions</data-lsp></a>\"</span><span style=\"color: #000000\">: {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"<a aria-hidden=true href='https://www.typescriptlang.org/tsconfig#rootDirs'><data-lsp lsp=\"Allow multiple folders to be treated as one when resolving modules.\">rootDirs</data-lsp></a>\"</span><span style=\"color: #000000\">: [</span><span style=\"color: #A31515\">\"src/views\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"generated/templates/views\"</span><span style=\"color: #000000\">]</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Cada vez que o compilador vê uma importação de módulo relativa em uma subpasta de um dos <code>rootDirs</code>, ele tentará procurar por essa importação em cada uma das entradas de <code>rootDirs</code>.</p>\n<p>A flexibilidade de <code>rootDirs</code> não se limita a especificar uma lista de diretórios de origem física que são mesclados logicamente. O array fornecido pode incluir qualquer número de nomes de diretório arbitrários ad hoc, independentemente de existirem ou não. Isso permite que o compilador capture pacotes sofisticados e recursos de tempo de execução, como inclusão condicional e plug-ins de carregador específicos do projeto de maneira segura.</p>\n<p>Considere um cenário de internacionalização onde uma ferramenta de construção gera automaticamente pacotes específicos de localidade interpolando um token de caminho especial, digamos <code>#{locale}</code>, como parte de um caminho de módulo relativo, como <code>./#{locale}/messages</code>. Nesta configuração hipotética, a ferramenta enumera localidades com suporte, mapeando o caminho abstrato em <code>./zh/messages</code>, <code>./de/messages</code>, e assim por diante.</p>\n<p>Suponha que cada um desses módulos exporte um array de strings. Por exemplo <code>./zh/messages</code> pode conter:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">default</span><span style=\"color: #000000\"> [</span><span style=\"color: #A31515\">\"您好吗\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"很高兴认识你\"</span><span style=\"color: #000000\">];</span></code></div></pre>\n<p>Aproveitando <code>rootDirs</code> podemos informar o compilador deste mapeamento e, assim, permitir que ele resolva com segurança <code>./#{locale}/messages</code>, mesmo que o diretório nunca exista. Por exemplo, com o seguinte <code>tsconfig.json</code>:</p>\n<pre class=\"shiki tsconfig lsp\"><div class='code-container'><code><span style=\"color: #000000\">{</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"<a aria-hidden=true href='https://www.typescriptlang.org/tsconfig#compilerOptions'><data-lsp lsp=\"The set of compiler options for your project\">compilerOptions</data-lsp></a>\"</span><span style=\"color: #000000\">: {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"<a aria-hidden=true href='https://www.typescriptlang.org/tsconfig#rootDirs'><data-lsp lsp=\"Allow multiple folders to be treated as one when resolving modules.\">rootDirs</data-lsp></a>\"</span><span style=\"color: #000000\">: [</span><span style=\"color: #A31515\">\"src/zh\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"src/de\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"src/#{locale}\"</span><span style=\"color: #000000\">]</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>O compilador agora resolverá <code>import messages from './#{locale}/messages'</code> para <code>import messages from './zh/messages'</code> para fins de ferramentas, permitindo o desenvolvimento de uma maneira agnóstica de localidade sem comprometer o suporte ao tempo de design.</p>\n<h2 id=\"resolução-do-módulo-de-rastreamento\" style=\"position:relative;\"><a href=\"#resolu%C3%A7%C3%A3o-do-m%C3%B3dulo-de-rastreamento\" aria-label=\"resolução do módulo de rastreamento permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Resolução do módulo de rastreamento</h2>\n<p>Conforme discutido anteriormente, o compilador pode visitar arquivos fora da pasta atual ao resolver um módulo.\nIsso pode ser difícil ao diagnosticar porque um módulo não foi resolvido ou foi resolvido para uma definição incorreta.\nHabilitar o rastreamento de resolução do módulo do compilador usando <code>--traceResolution</code> fornece uma visão do que aconteceu durante o processo de resolução do módulo.</p>\n<p>Digamos que temos um aplicativo de amostra que usa o módulo <code>typescript</code>.\n<code>app.ts</code> contém uma importação como <code>import * as ts from \"typescript\"</code>.</p>\n<pre class=\"shiki\"><div class='code-container'><code>│   tsconfig.json\n├───node_modules\n│   └───typescript\n│       └───lib\n│               typescript.d.ts\n└───src\n        app.ts</code></div></pre>\n<p>Invocar o compilador com <code>--traceResolution</code></p>\n<pre class=\"shiki\"><div class=\"language-id\">shell</div><div class='code-container'><code><span style=\"color: #000000\">tsc --traceResolution</span></code></div></pre>\n<p>Resulta em uma saída como:</p>\n<pre class=\"shiki\"><div class='code-container'><code>======== Resolving module 'typescript' from 'src/app.ts'. ========\nModule resolution kind is not specified, using 'NodeJs'.\nLoading module 'typescript' from 'node_modules' folder.\nFile 'src/node_modules/typescript.ts' does not exist.\nFile 'src/node_modules/typescript.tsx' does not exist.\nFile 'src/node_modules/typescript.d.ts' does not exist.\nFile 'src/node_modules/typescript/package.json' does not exist.\nFile 'node_modules/typescript.ts' does not exist.\nFile 'node_modules/typescript.tsx' does not exist.\nFile 'node_modules/typescript.d.ts' does not exist.\nFound 'package.json' at 'node_modules/typescript/package.json'.\n'package.json' has 'types' field './lib/typescript.d.ts' that references 'node_modules/typescript/lib/typescript.d.ts'.\nFile 'node_modules/typescript/lib/typescript.d.ts' exist - use it as a module resolution result.\n======== Module name 'typescript' was successfully resolved to 'node_modules/typescript/lib/typescript.d.ts'. ========</code></div></pre>\n<h4 id=\"coisas-para-procurar\" style=\"position:relative;\"><a href=\"#coisas-para-procurar\" aria-label=\"coisas para procurar permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Coisas para procurar</h4>\n<ul>\n<li>Nome e localização da importação</li>\n</ul>\n<blockquote>\n<p>======== Resolving module <strong>‘typescript’</strong> of <strong>‘src/app.ts’</strong>. ========</p>\n</blockquote>\n<ul>\n<li>A estratégia que o compilador está seguindo</li>\n</ul>\n<blockquote>\n<p>O tipo de resolução do módulo não é especificado, usando <strong>‘NodeJs’</strong>.</p>\n</blockquote>\n<ul>\n<li>Carregando tipos de pacotes npm</li>\n</ul>\n<blockquote>\n<p>‘package.json’ tem campos <strong>‘types’</strong> em ‘./lib/typescript.d.ts’ que referencia ‘node_modules/typescript/lib/typescript.d.ts’.</p>\n</blockquote>\n<ul>\n<li>Resultado final</li>\n</ul>\n<blockquote>\n<p>======== Module name ‘typescript’ was <strong>successfully resolved</strong> to ‘node_modules/typescript/lib/typescript.d.ts’. ========</p>\n</blockquote>\n<h2 id=\"utilizando---noresolve\" style=\"position:relative;\"><a href=\"#utilizando---noresolve\" aria-label=\"utilizando   noresolve permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Utilizando <code>--noResolve</code></h2>\n<p>Normalmente, o compilador tentará resolver todas as importações de módulo antes de iniciar o processo de compilação.\nCada vez que ele resolve com sucesso uma <code>importação</code> para um arquivo, o arquivo é adicionado ao conjunto de arquivos que o compilador irá processar mais tarde.</p>\n<p>A opção de compliação <code>--noResolve</code> instrui o compilador a não “adicionar” nenhum arquivo à compilação que não tenha sido passado na linha de comando.\nEle ainda tentará resolver o módulo em arquivos, mas se o arquivo não for especificado, ele não será incluído.</p>\n<p>Por exemplo:</p>\n<h4 id=\"appts\" style=\"position:relative;\"><a href=\"#appts\" aria-label=\"appts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>app.ts</h4>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">A</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"moduleA\"</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// OK, 'moduleA' passou na linha de comando</span>\n<span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">B</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"moduleB\"</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Error TS2307: Cannot find module 'moduleB'.</span></code></div></pre>\n<pre class=\"shiki\"><div class=\"language-id\">shell</div><div class='code-container'><code><span style=\"color: #000000\">tsc app.ts moduleA.ts --noResolve</span></code></div></pre>\n<p>Compilando <code>app.ts</code> usando <code>--noResolve</code> deve resultar em:</p>\n<ul>\n<li>Encontrando corretamente <code>moduleA</code> conforme foi passado na linha de comando.</li>\n<li>Erro por não encontrar <code>moduleB</code> como não foi passado.</li>\n</ul>\n<h2 id=\"perguntas-frequentes\" style=\"position:relative;\"><a href=\"#perguntas-frequentes\" aria-label=\"perguntas frequentes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Perguntas Frequentes</h2>\n<h3 id=\"por-que-um-módulo-na-lista-de-exclusão-ainda-é-selecionado-pelo-compilador\" style=\"position:relative;\"><a href=\"#por-que-um-m%C3%B3dulo-na-lista-de-exclus%C3%A3o-ainda-%C3%A9-selecionado-pelo-compilador\" aria-label=\"por que um módulo na lista de exclusão ainda é selecionado pelo compilador permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Por que um módulo na lista de exclusão ainda é selecionado pelo compilador?</h3>\n<p><code>tsconfig.json</code> transforma uma pasta em um “projeto”.\nSem especificar nenhuma entrada <code>“exclude”</code> ou <code>“files”</code>, todos os arquivos na pasta que contém o <code>tsconfig.json</code> e todos os seus subdiretórios estão incluídos em sua compilação.\nSe você deseja excluir alguns dos arquivos, use <code>“exclude”</code>, se você preferir especificar todos os arquivos em vez de permitir que o compilador os procure, use <code>“files”</code>.</p>\n<p>Essa foi a inclusão automática de <code>tsconfig.json</code>.\nIsso não incorpora a resolução do módulo conforme discutido acima.\nSe o compilador identificou um arquivo como destino de uma importação de módulo, ele será incluído na compilação, independentemente de ter sido excluído nas etapas anteriores.</p>\n<p>Portanto, para excluir um arquivo da compilação, você precisa excluí-lo em <strong>todos</strong> os arquivos que possuem uma diretiva <code>import</code> ou <code>/// &#x3C;reference path=\"...\" /></code>.</p>","headings":[{"value":"Importações de módulos relativos vs. não relativos","depth":2},{"value":"Estratégias de resolução de módulo","depth":2},{"value":"Clássico","depth":3},{"value":"Node","depth":3},{"value":"Como o Node.js resolve os módulos","depth":4},{"value":"Como o TypeScript resolve os módulos","depth":4},{"value":"Flags de resolução de módulo adicional","depth":2},{"value":"URL base","depth":3},{"value":"Mapeamento de caminhos","depth":3},{"value":"Diretórios virtuais com rootDirs","depth":3},{"value":"Resolução do módulo de rastreamento","depth":2},{"value":"Coisas para procurar","depth":4},{"value":"Utilizando --noResolve","depth":2},{"value":"app.ts","depth":4},{"value":"Perguntas Frequentes","depth":2},{"value":"Por que um módulo na lista de exclusão ainda é selecionado pelo compilador?","depth":3}],"frontmatter":{"permalink":"/pt/docs/handbook/module-resolution.html","title":"Resolução de módulos","disable_toc":null,"handbook":null,"oneline":"Como o TypeScript resolve módulos em JavaScript","beta":null}},"prev":null,"next":null},"pageContext":{"id":"2resolução-de-módulos","slug":"/pt/docs/handbook/module-resolution.html","repoPath":"/packages/documentation/copy/pt/reference/Module Resolution.md","lang":"pt","modifiedTime":"2020-11-23T10:39:15.627Z"}},"staticQueryHashes":[]}