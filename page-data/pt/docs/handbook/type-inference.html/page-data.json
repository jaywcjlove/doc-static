{"componentChunkName":"component---src-templates-documentation-tsx","path":"/pt/docs/handbook/type-inference.html","result":{"data":{"markdownRemark":{"id":"402b768b-5d66-56c5-97ab-52c6b8863f84","excerpt":"Em TypeScript, existem vários locais onde a inferência de tipos é usada para prover informação quando não se tem um tipo explícito de anotação. Por exemplo…","html":"<p>Em TypeScript, existem vários locais onde a inferência de tipos é usada para prover informação quando não se tem um tipo explícito de anotação. Por exemplo, nesse código</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let x: number'>x</data-lsp> </span><span style=\"color: #000000\">= </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\">;</span>\n<span class='query'>//  ^ = let x: number</span></code><a href='https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EGYDcAoA9GiEB6B+IA'>Try</a></div></pre>\n<p>O tipo da variável <code>x</code> é inferido como sendo <code>number</code>.\nEsse tipo de inferência ocorre ao inicializar variáveis e membros, definir valores padrão de parâmetros e ao determinar o tipo de valor retornado por funções. </p>\n<p>Na maioria dos casos, inferência de tipos é fácil de entender.\nNa próxima sessão, iremos explorar algumas das nuances em como tipos são inferidos.</p>\n<h2 id=\"melhor-tipo-comum\" style=\"position:relative;\"><a href=\"#melhor-tipo-comum\" aria-label=\"melhor tipo comum permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Melhor tipo comum</h2>\n<p>Quando uma inferência de tipo é composta por várias expressões, o tipo dessas expressões é usada para calcular o “melhor tipo comum”. Por exemplo:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let x: (number | null)[]'>x</data-lsp> </span><span style=\"color: #000000\">= [</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\">null</span><span style=\"color: #000000\">];</span>\n<span class='query'>//  ^ = let x: (number | null)[]</span></code><a href='https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EG0AMAaCBGNA7ArsYAugNwBQA9GRBAHoD8QA'>Try</a></div></pre>\n<p>Para inferir o tipo de <code>x</code> no exemplo acima, nós precisamos considerar o tipo de cada elemento do array.\nAqui nos foi dada duas escolhas para o tipo do array: <code>number</code> e <code>null</code>.\nO algoritmo do melhor tipo comum considera o tipo de cada candidato e escolhe o tipo que é compatível com todos os outros candidatos.</p>\n<p>Porquê o melhor tipo comum tem de ser escolhido a partir dos tipos candidatos providos, existem alguns casos onde tipos compartilham uma estrutura comum, mas nenhum tipo é o supertipo de todos os tipos candidatos. Por Exemplo:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let zoo: (Rinoceronte | Elefante | Cobra)[]'>zoo</data-lsp> </span><span style=\"color: #000000\">= [</span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> <data-lsp lsp='constructor Rinoceronte(): Rinoceronte'>Rinoceronte</data-lsp>(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> <data-lsp lsp='constructor Elefante(): Elefante'>Elefante</data-lsp>(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> <data-lsp lsp='constructor Cobra(): Cobra'>Cobra</data-lsp>()];</span>\n<span class='query'>//    ^ = let zoo: (Rinoceronte | Elefante | Cobra)[]</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAErxUD2ieWLyrQ8oPAA9RVACblqdBowKhQo2gGEAFvHSw8aOAFc8AbgKtipcgFFseLCLGTpcyjXrYmKtXloAVIVoAI0xDWBNzS3ZyDV5g2ExxKTxZeQ8lH3UABUEqUjQsXDMLAhBQAFoqxCNoKoqCe2hQAC9eXlAAXlAAbSo8AHcuHn5BYVEACgBKABpQfqG7B0wnabmF0DiEzGmAXXNy1VAAPQB+IA'>Try</a></div></pre>\n<p>De forma ideal, queremos que <code>zoo</code> seja inferido como um <code>Animal[]</code>, mas como não existe um objeto que seja estritamente do tipo <code>Animal</code> no array, nós não fazemos inferências sobre o tipo de elemento do array.\nPara corrigir isso, em troca forneça explicitamente o tipo quando nenhum outro tipo é um supertipo de todos os outros candidatos:</p>\n<pre class=\"shiki twoslash lsp\"><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\"><data-lsp lsp='let zoo: Animal[]'>zoo</data-lsp></span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> <data-lsp lsp='class Animal'>Animal</data-lsp>[] </span><span style=\"color: #000000\">= [</span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> <data-lsp lsp='constructor Rinoceronte(): Rinoceronte'>Rinoceronte</data-lsp>(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> <data-lsp lsp='constructor Elefante(): Elefante'>Elefante</data-lsp>(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> <data-lsp lsp='constructor Cobra(): Cobra'>Cobra</data-lsp>()];</span>\n<span class='query'>//    ^ = let zoo: Animal[]</span></code><a href='https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAErxUD2ieWLyrQ8oPAA9RVACblqdBowKhQo2gGEAFvHSw8aOAFc8AbgKtipcgFFseLCLGTpcyjXrYmKtXloAVIVoAI0xDWBNzS3ZyDV5g2ExxKTxZeQ8lH3UABUEqUjQsXDMLAhBQAFoqxCNoKoqCe2hQAC9eXjQFTwBtAF1QAF5Qbqo8AHcuHn5BYVEACgBKABpQUYm7B0wnRZW10DiEzEXe83LVUAA9AH4gA'>Try</a></div></pre>\n<p>Quando nenhum tipo comum é encontrado, a inferência resultante é a união dos tipos do array, <code>(Rinoceronte | Elefante | Cobra)[]</code>.</p>\n<h2 id=\"tipagem-contextual\" style=\"position:relative;\"><a href=\"#tipagem-contextual\" aria-label=\"tipagem contextual permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tipagem Contextual</h2>\n<p>Inferência de tipo também funciona “em direção oposta” em alguns casos no TypeScript.\nIsso é conhecido como “tipagem contextual”. Tipagem contextual ocorre quando o tipo de uma expressão é inferido por sua localização. Por exemplo:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #000000\">window.onmousedown = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">mouseEvent</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  console.log(</span><span style=\"color: #1A1A1A\">mouseEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">botao</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- OK</span>\n<span style=\"color: #000000\">  console.log(</span><span style=\"color: #1A1A1A\">mouseEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">canguru</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- Error!</span>\n<span style=\"color: #000000\">};</span></code></div></pre>\n<p>Aqui, o verificador de tipos do TypeScript usa o tipo da função <code>Window.onmousedown</code> para inferir o tipo da expressão função do lado direito da atribuição.\nAo fazer isso, ele foi capaz de inferir o <a href=\"https://developer.mozilla.org/docs/Web/API/MouseEvent\">tipo</a> do parâmetro <code>mouseEvent</code>, que de fato contém uma propriedade <code>botao</code>, mas não uma propriedade <code>canguru</code>.</p>\n<p>TypeScript é inteligente o suficiente para inferir tipos em outros contextos também:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #000000\">window.onscroll = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">uiEvent</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  console.log(</span><span style=\"color: #1A1A1A\">uiEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">botao</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- Erro!</span>\n<span style=\"color: #000000\">};</span></code></div></pre>\n<p>Baseado no fato que a função acima foi atribuida a <code>Window.onscroll</code>, TypeScript sabe que <code>uiEvent</code> é um <a href=\"https://developer.mozilla.org/docs/Web/API/UIEvent\">UIEvent</a>, e não um <a href=\"https://developer.mozilla.org/docs/Web/API/MouseEvent\">MouseEvent</a> como no exemplo anterior. Objetos <code>UIEvent</code> não contém a propriedade <code>botao</code>, dessa forma TypeScript irá lançar um erro.</p>\n<p>Se essa função não estivesse digitada em uma posição contextualizada, os argumentos da função teriam implicitamente o tipo <code>any</code>, e nenhum erro seria emitido (a não ser que você esteja usando a opção <code>--noImplicitAny</code>):</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">handler </span><span style=\"color: #000000\">= </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">uiEvent</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  console.log(</span><span style=\"color: #1A1A1A\">uiEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">botao</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- OK</span>\n<span style=\"color: #000000\">};</span></code></div></pre>\n<p>Nós também podemos fornecer explicitamente informação sobre o tipo para que os argumentos da função sobrescrevam qualquer tipo contextual:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #000000\">window.onscroll = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">uiEvent</span><span style=\"color: #000000\">: any) {</span>\n<span style=\"color: #000000\">  console.log(</span><span style=\"color: #1A1A1A\">uiEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">botao</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- Agora, nenhum erro é fornecido</span>\n<span style=\"color: #000000\">};</span></code></div></pre>\n<p>Entretanto, esse código será exibido no log como <code>undefined</code>, uma vez que <code>uiEvent</code> não tem nenhuma propriedade <code>botao</code>.</p>\n<p>Tipagem contextual se aplica em muitos casos.\nCasos comuns incluem argumentos para chamadas de funções, lado direito de atribuições, asserções de tipo, membros de objetos, arrays literais, e declarações de retorno.\nO tipo contextual também age como um tipo candidato no melhor tipo comum. Por exemplo: </p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> criaZologico(): Animal[] {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> [</span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> Rinoceronte(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> Elefante(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> Cobra()];</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Nesse exemplo, o melhor tipo comum tem um grupo de quatro candidatos: <code>Animal</code>, <code>Rinoceronte</code>, <code>Elefante</code>, e <code>Cobra</code>.\nDesses, <code>Animal</code> pode ser escolhido pelo algorítimo de melhor candidato comum.</p>","headings":[{"value":"Melhor tipo comum","depth":2},{"value":"Tipagem Contextual","depth":2}],"frontmatter":{"permalink":"/pt/docs/handbook/type-inference.html","title":"Inferência de Tipo","disable_toc":null,"handbook":null,"oneline":"Como a analise do fluxo de código funciona em TypeScript","beta":null}},"prev":null,"next":null},"pageContext":{"id":"2inferência-de-tipo","slug":"/pt/docs/handbook/type-inference.html","repoPath":"/packages/documentation/copy/pt/reference/Type Inference.md","lang":"pt","modifiedTime":"2020-11-23T10:39:15.627Z"}},"staticQueryHashes":[]}