{"componentChunkName":"component---src-templates-documentation-tsx","path":"/pt/docs/handbook/namespaces-and-modules.html","result":{"data":{"markdownRemark":{"id":"01828a73-24ac-51e5-b3ef-fd34c76d95c4","excerpt":"Este post descreve as várias formas de organizar seu código usando módulos e namespaces no TypeScript.\nAbordaremos também alguns tópicos avançados sobre como…","html":"<p>Este post descreve as várias formas de organizar seu código usando módulos e namespaces no TypeScript.\nAbordaremos também alguns tópicos avançados sobre como usar namespaces e módulos, e algumas armadilhas comuns ao usá-los no TypeScrypt.</p>\n<p>Veja a documentação de <a href=\"/docs/handbook/modules.html\">Módulos</a> para mais informações sobre os módulos do ES.\nVeja a documentação de <a href=\"/pt/docs/handbook/namespaces.html\">Namespaces</a> para mais informações sobre os namespaces do Typescript. </p>\n<p>Nota: Em versões <em>muito</em> antigas do TypeScript, namespaces eram chamados de ‘Módulos Internos’ (ou ‘Internal Modules’, em inglês).</p>\n<h2 id=\"usando-módulos\" style=\"position:relative;\"><a href=\"#usando-m%C3%B3dulos\" aria-label=\"usando módulos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Usando Módulos</h2>\n<p>Módulos podem conter código e declarações.</p>\n<p>Os módulos também dependem de um carregador de módulos (como CommonJs/Require.js) ou um ambiente que suporta módulos ES.\nMódulos fornecem melhor reutilização de código, isolamento mais forte e melhor suporte a ferramentas para empacotamento.</p>\n<p>Também é importante notar que, para aplicações Node.js, moódulos são o padrão e <strong>nós recomendamos módulos em vez de namespaces em códigos modernos</strong>.</p>\n<p>Começando pelo ECMAScript 2015, módulos são parte nativa da linguagem e devem ser suportados por todas as implementações de engine compatíveis.\nDessa forma, para novos projetos, módulos seriam o mecanismo recomendado para organização de código.</p>\n<h2 id=\"usando-namespaces\" style=\"position:relative;\"><a href=\"#usando-namespaces\" aria-label=\"usando namespaces permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Usando Namespaces</h2>\n<p>Os Namespaces são uma forma específica do TypeScript para organizar código.\nNamespaces são simplesmente objetos JavaScript nomeados no namespace global.\nIsso torna os namespaces uma construção muito simples de usar.\nAo contrário dos módulos, eles podem atingir múltiplos arquivos, e podem ser concatenados usando <code>--outFile</code>.\nNamespaces podem ser uma boa maneira de estruturar seu código em uma aplicação Web, com todas as dependências incluídas como tags <code>&#x3C;script></code> em sua página HTML.</p>\n<p>Assim como toda poluição do namespace global, pode ser difícil identificar dependências de componentes, especialmente em uma aplicação grande.</p>\n<h2 id=\"armadilhas-de-namespaces-e-módulos\" style=\"position:relative;\"><a href=\"#armadilhas-de-namespaces-e-m%C3%B3dulos\" aria-label=\"armadilhas de namespaces e módulos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Armadilhas de Namespaces e Módulos</h2>\n<p>Nesta seção descreveremos várias armadilhas comuns no uso de namespaces e módulos e como evitá-las.</p>\n<h2 id=\"-reference-ando-um-módulo\" style=\"position:relative;\"><a href=\"#-reference-ando-um-m%C3%B3dulo\" aria-label=\" reference ando um módulo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>/// &#x3C;reference></code>-ando um módulo</h2>\n<p>Um erro comum é tentar usar a sintaxe <code>/// &#x3C;reference ... /></code> para se referir a um de módulo, em vez de usar a instrução <code>import</code>.\nPara entender a distinção, primeiro precisamos entender como o compilador pode localizar as informações de tipo com base no caminho de um <code>import</code> (e.g. os <code>...</code> em <code>import x from \"...\";</code>, <code>import x = require(\"...\");</code>, etc.).</p>\n<p>O compilador tentará encontrar um <code>.ts</code>, <code>.tsx</code>, e depois um <code>.d.ts</code> com o caminho apropriado.\nSe o arquivo específico não puder ser encontrado, então o compilador procurará por uma <em>declaração de módulo de ambiente</em>.\nLembre-se de que eles precisam ser declarados em um arquivo <code>.d.ts</code>.</p>\n<ul>\n<li>\n<p><code>meusModulos.d.ts</code></p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #008000\">// Em um arquivo .d.ts ou arquivo .ts que não é um módulo:</span>\n<span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">module</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"AlgumModulo\"</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> fn(): string;</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n</li>\n<li>\n<p><code>meuOutroModulo.ts</code></p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #008000\">/// </span><span style=\"color: #800000\">&lt;reference</span><span style=\"color: #008000\"> </span><span style=\"color: #DC0000\">path</span><span style=\"color: #000000\">=</span><span style=\"color: #A31515\">\"meusModulos.d.ts\"</span><span style=\"color: #008000\"> </span><span style=\"color: #800000\">/&gt;</span>\n<span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">m</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"AlgumModulo\"</span><span style=\"color: #000000\">;</span></code></div></pre>\n</li>\n</ul>\n<p>A tag de referência aqui nos permite localizar o arquivo de declaração que contém a declaração para o módulo de ambiente.\nÉ assim que o arquivo <code>node.d.ts</code> que vários dos exemplos do TypeScript usam é consumido. </p>\n<h2 id=\"namespacing-desnecessário\" style=\"position:relative;\"><a href=\"#namespacing-desnecess%C3%A1rio\" aria-label=\"namespacing desnecessário permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Namespacing Desnecessário</h2>\n<p>Se você estiver convertendo um programa de namespaces para módulos, pode ser fácil acabar com um arquivo que se parece com este:</p>\n<ul>\n<li>\n<p><code>formas.ts</code></p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">namespace</span><span style=\"color: #000000\"> Formas {</span>\n<span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> Triangulo {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">/* ... */</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> Quadrado {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">/* ... */</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n</li>\n</ul>\n<p>O módulo de nível superior aqui <code>Formas</code> agrupa <code>Triangulo</code> e <code>Quadrado</code> sem motivo.\nIsso é confuso e irritante para os consumidores de seu módulo:</p>\n<ul>\n<li>\n<p><code>consumidorDeFormas.ts</code></p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">formas</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./formas\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">t </span><span style=\"color: #000000\">= </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> formas.Formas.Triangulo(); </span><span style=\"color: #008000\">// formas.Formas?</span></code></div></pre>\n</li>\n</ul>\n<p>Uma característica chave de módulos em TypeScript é que dois módulos diferentes nunca contribuirão com nomes para o mesmo escopo.\nComo o consumidor de um módulo decide qual nome atribuir a ele, não há a necessidade de proativamente agrupar os simbolos exportados em um namespace.</p>\n<p>Para reiterar por que você não deve tentar atribuir um namespace ao conteúdo do seu módulo, a ideia geral do namespacing é fornecer o agrupamento lógico de construções e evitar colisão de nomes.\nComo o arquivo de módulo em si já é um agrupamento lógico, e seu nome de nível superior é definido pelo código que o importa, é desnecessário usar uma camada adicional de módulo para objetos exportados.</p>\n<p>Aqui está um exemplo revisado:</p>\n<ul>\n<li>\n<p><code>formas.ts</code></p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> Triangulo {</span>\n<span style=\"color: #008000\">/* ... */</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> Quadrado {</span>\n<span style=\"color: #008000\">/* ... */</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n</li>\n<li>\n<p><code>consumidorDeFormas.ts</code></p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">formas</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./formas\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">t </span><span style=\"color: #000000\">= </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> formas.Triangulo();</span></code></div></pre>\n</li>\n</ul>\n<h2 id=\"trade-offs-de-módulos\" style=\"position:relative;\"><a href=\"#trade-offs-de-m%C3%B3dulos\" aria-label=\"trade offs de módulos permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Trade-offs de Módulos</h2>\n<p>Assim como existe uma correspondência de um-para-um entre arquivos JS e módulos, TypeScript tem uma correspondência de um-para-um entre arquivos fonte de módulos e seus arquivos JS emitidos.\nUm efeito disso é que não é possível concatenar múltiplos arquivos fonte de módulos dependendo do sistema de módulos que você deseja.\nPor exemplo, você não pode apenas usar a opção <code>outFile</code> ao direcionar <code>commonjs</code> ou <code>umd</code>, mas com TypeScript 1.8 e posterior, <a href=\"./release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile\">é possível</a> usar <code>outFile</code> ao direcionar <code>amd</code> ou <code>system</code>.</p>","headings":[{"value":"Usando Módulos","depth":2},{"value":"Usando Namespaces","depth":2},{"value":"Armadilhas de Namespaces e Módulos","depth":2},{"value":"/// <reference>-ando um módulo","depth":2},{"value":"Namespacing Desnecessário","depth":2},{"value":"Trade-offs de Módulos","depth":2}],"frontmatter":{"permalink":"/pt/docs/handbook/namespaces-and-modules.html","title":"Namespaces e Módulos","disable_toc":null,"handbook":null,"oneline":"Como organizar o código em TypeScript através de módulos ou namespaces","beta":null}},"prev":null,"next":null},"pageContext":{"id":"2namespaces-e-módulos","slug":"/pt/docs/handbook/namespaces-and-modules.html","repoPath":"/packages/documentation/copy/pt/reference/Namespaces and Modules.md","lang":"pt","modifiedTime":"2020-11-23T10:39:15.627Z"}},"staticQueryHashes":[]}