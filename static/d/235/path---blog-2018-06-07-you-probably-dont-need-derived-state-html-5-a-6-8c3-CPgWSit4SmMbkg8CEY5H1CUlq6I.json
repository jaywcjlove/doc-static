{"data":{"markdownRemark":{"html":"<p>React 16.4 版本修复了一个 <a href=\"/blog/2018/05/23/react-v-16-4.html#bugfix-for-getderivedstatefromprops\">getDerivedStateFromProps 的 bug</a>，这个 bug 会在 React components 复现一些已知的 bug。如果这个版本导致出现的问题，导致您在修复过之后还已知出现的话，我们非常抱歉。在这篇文章里，我们会展示一些常见的反面模式，和相对应的，我们推荐的模式。</p>\n<p>在很长一段时间内，生命周期函数 <code class=\"gatsby-code-text\">componentWillReceiveProps</code> 是响应 Props 变化之后进行更新的唯一方式。16.3 版本里, <a href=\"/blog/2018/03/29/react-v-16-3.html#component-lifecycle-changes\">我们介绍了一个替代版的生命周期函数： <code class=\"gatsby-code-text\">getDerivedStateFromProps</code></a>，尝试用一个更安全的方式达到同样的目的。与此同时，我们意识到人们对如何使用这两种方法存在许多误解，并且我们发现反模式会导致细微而混乱的错误。16.4 版本修复的这个 bug， <a href=\"https://github.com/facebook/react/issues/12898\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">让派生 state 更加可控</a>，会让滥用导致的 bug 更容易被发现。</p>\n<blockquote>\n<p>注意</p>\n<p>下面所有的反面模式中，<code class=\"gatsby-code-text\">componentWillReceiveProps</code> 和 <code class=\"gatsby-code-text\">getDerivedStateFromProps</code> 都是通用的。</p>\n</blockquote>\n<p> 这篇blog包含以下主题：</p>\n<ul>\n<li><a href=\"#when-to-use-derived-state\">什么时候使用派生 state </a></li>\n<li>\n<p><a href=\"#common-bugs-when-using-derived-state\">派生 state 的常见 bug</a></p>\n<ul>\n<li><a href=\"#anti-pattern-unconditionally-copying-props-to-state\">反面模式 <sup><a href=\"#note1\">[1]</a></sup>：直接复制 props 到 state 上</a></li>\n<li><a href=\"#anti-pattern-erasing-state-when-props-change\">反面模式：在 props 变化后修改 state </a></li>\n</ul>\n</li>\n<li><a href=\"#preferred-solutions\">建议的模式</a></li>\n<li><a href=\"#what-about-memoization\">尝试一下 memoization ？</a></li>\n</ul>\n<h2 id=\"when-to-use-derived-state\"><a href=\"#when-to-use-derived-state\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什么时候使用派生 state  </h2>\n<p><code class=\"gatsby-code-text\">getDerivedStateFromProps</code> 的存在只有一个目的：让组件在 <strong>props 变化</strong>时更新 state。上一个 blog 展示了一些示例，比如 <a href=\"/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props\">props 的 offset 变化时，修改当前的滚动方向</a>和<a href=\"/blog/2018/03/27/update-on-async-rendering.html#fetching-external-data-when-props-change\">根据 props 变化加载外部数据</a>。</p>\n<p>我们没有提供很多示例，因为有<strong>保守使用派生 state</strong> 这个规则。大部分使用派生 state 导致的问题，不外乎两个原因：1，直接复制 props 到 state 上；2，如果 props 和 state 不一致就更新 state。下面的示例包含了这两种情况。</p>\n<ul>\n<li>如果你只是为了缓存（memoize）基于当前 props 计算后的结果的话，你就没必要使用派生 state。<a href=\"#what-about-memoization\">尝试一下 memoization？</a>。</li>\n<li>如果只是用来保存 props 或者和当前 state 比较之后不一致后更新 state，那你的组件应该是太频繁的更新了 state。请继续阅读。</li>\n</ul>\n<h2 id=\"common-bugs-when-using-derived-state\"><a href=\"#common-bugs-when-using-derived-state\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>派生 state 的常见 bug </h2>\n<p>名词<a href=\"/docs/forms.html#controlled-components\">“受控”</a>和<a href=\"/docs/uncontrolled-components.html\">“非受控”</a>通常用来指代表单的 inputs，但是也可以用来描述数据频繁更新的组件。用 props 传入数据的话，组件可以被认为是<strong>受控</strong>（因为组件被父级传入的 props 控制）。数据只保存在组件内部的 state 的话，是<strong>非受控</strong>组件（因为外部没办法直接控制 state）。</p>\n<p>常见的错误就是把两者混为一谈。当一个派生 state 值也被 <code class=\"gatsby-code-text\">setState</code> 方法更新时，这个值就不是一个单一来源的值了。<a href=\"/blog/2018/03/27/update-on-async-rendering.html#fetching-external-data-when-props-change\">加载外部数据示例</a>描述的行为和这个类似，但是有很重要的区别。在加载外部数据示例中，数据 <code class=\"gatsby-code-text\">source</code> 和 <code class=\"gatsby-code-text\">loading</code> 都有非常清晰并且唯一的数据来源。当 prop 改变时，<code class=\"gatsby-code-text\">loading</code> 的状态<strong>一定</strong>会改变。相反，state 只有在 prop 改变时才会改变，除非组件内部还有其他行为改变这个状态。</p>\n<p>上述条件如果有一个不满足，就会导致问题，最常见的就是在两个表单里修改数据。</p>\n<h3 id=\"anti-pattern-unconditionally-copying-props-to-state\"><a href=\"#anti-pattern-unconditionally-copying-props-to-state\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>反面模式: 直接复制 prop 到 state </h3>\n<p>最常见的误解就是 <code class=\"gatsby-code-text\">getDerivedStateFromProps</code> 和 <code class=\"gatsby-code-text\">componentWillReceiveProps</code> 只会在 props “改变”时才会调用。实际上只要父级重新渲染时，这两个生命周期函数就会重新调用，不管 props 有没有“变化”。所以，在这两个方法内直接复制（<em>unconditionally</em>）props 到 state 是不安全的。<strong>这样做会导致 state 后没有正确渲染</strong>。</p>\n<p>重现一下这个问题。这个 <code class=\"gatsby-code-text\">EmailInput</code> 组件复制 props 到 state：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">EmailInput</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> email<span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>email <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleChange<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function-variable function\">handleChange</span> <span class=\"token operator\">=</span> event <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> email<span class=\"token punctuation\">:</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">componentWillReceiveProps</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 这会覆盖所有组件内的 state 更新！</span>\n    <span class=\"token comment\">// 不要这样做。</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> email<span class=\"token punctuation\">:</span> nextProps<span class=\"token punctuation\">.</span>email <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>乍看之下还可以。 state 的初始值是 props 传来的，当在 <code class=\"gatsby-code-text\">&lt;input&gt;</code> 里输入时，修改 state。但是如果父组件重新渲染，我们输入的所有东西都会丢失！(<a href=\"https://codesandbox.io/s/m3w9zn1z8x\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">查看这个示例</a>)，即使在重置 state 前比较 <code class=\"gatsby-code-text\">nextProps.email !== this.state.email</code> 仍然会导致更新。</p>\n<p>这个小例子中，使用 <code class=\"gatsby-code-text\">shouldComponentUpdate</code> ，比较 props 的 email 是不是修改再决定要不要重新渲染。但是在实践中，一个组件会接收多个 prop，任何一个 prop 的改变都会导致重新渲染和不正确的状态重置。加上行内函数和对象 prop，创建一个完全可靠的 <code class=\"gatsby-code-text\">shouldComponentUpdate</code> 会变得越来越难。<a href=\"https://codesandbox.io/s/jl0w6r9w59\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这个示例展示了这个情况</a>。而且 <code class=\"gatsby-code-text\">shouldComponentUpdate</code> 的最佳实践是用于性能提升，而不是改正不合适的派生 state。</p>\n<p>希望以上能解释清楚为什么<strong>直接复制 prop 到 state 是一个非常糟糕的想法</strong>。在寻找解决方案之前，让我们看看一个相关的问题：假如我们只使用 props 中的 email 属性更新组件呢？</p>\n<h3 id=\"anti-pattern-erasing-state-when-props-change\"><a href=\"#anti-pattern-erasing-state-when-props-change\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>反面模式: 在 props 变化后修改 state </h3>\n<p>继续上面的示例，我们可以只使用 <code class=\"gatsby-code-text\">props.email</code> 来更新组件，这样能防止修改 state 导致的 bug：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">EmailInput</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    email<span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>email\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">componentWillReceiveProps</span><span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 只要 props.email 改变，就改变 state</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextProps<span class=\"token punctuation\">.</span>email <span class=\"token operator\">!==</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        email<span class=\"token punctuation\">:</span> nextProps<span class=\"token punctuation\">.</span>email\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>注意</p>\n<p>示例中使用了 <code class=\"gatsby-code-text\">componentWillReceiveProps</code> ，使用 <code class=\"gatsby-code-text\">getDerivedStateFromProps</code> 也是一样。</p>\n</blockquote>\n<p>我们已经做了一个很大的改进。现在组件只会在 prop 改变时才会改变。</p>\n<p>但是仍然有个问题。想象一下，如果这是一个密码输入组件，拥有同样 email 的两个账户进行切换时，这个输入框不会重置（用来让用户重新登录）。因为父组件传来的 prop 值没有变化！这会让用户非常惊讶，因为这看起来像是帮助一个用户分享了另外一个用户的密码，(<a href=\"https://codesandbox.io/s/mz2lnkjkrx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">查看这个示例</a>)。</p>\n<p>虽然这个设计就有问题，但是这样的错误很常见，(<a href=\"https://twitter.com/brian_d_vaughn/status/959600888242307072\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">我就犯过这样的错误</a>)。幸运的是，有两个方案能解决这些问题。这两者的关键在于，<strong>任何数据，都要保证只有一个数据来源，而且避免直接复制它</strong>。我们来看看这两个方案。</p>\n<h2 id=\"preferred-solutions\"><a href=\"#preferred-solutions\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>建议的模式 </h2>\n<h3 id=\"recommendation-fully-controlled-component\"><a href=\"#recommendation-fully-controlled-component\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>建议：完全可控的组件 </h3>\n<p>阻止上述问题发生的一个方法是，从组件里删除 state。如果 prop 里包含了 email，我们就没必要担心它和 state 冲突。我们甚至可以把 <code class=\"gatsby-code-text\">EmailInput</code> 转换成一个轻量的函数组件：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">EmailInput</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>onChange<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>props<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样能用最简单的方式完成我们需要的组件。但是如果我们仍然想要保存临时的值，则需要父组件手动执行保存这个动作。(<a href=\"https://codesandbox.io/s/7154w1l551\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">点击查看这个模式的演示</a>)。</p>\n<h3 id=\"recommendation-fully-uncontrolled-component-with-a-key\"><a href=\"#recommendation-fully-uncontrolled-component-with-a-key\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>建议：有 key 的非可控组件 </h3>\n<p>另外一个选择是让组件自己存储临时的 email state。在这种情况下，组件仍然可以从 prop 接收“初始值”，但是更改之后的值就和 prop 没关系了：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">EmailInput</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> email<span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>defaultEmail <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function-variable function\">handleChange</span> <span class=\"token operator\">=</span> event <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> email<span class=\"token punctuation\">:</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleChange<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在这密码管理器的例子中，为了在不同的页面切换不同的值，我们可以使用 <code class=\"gatsby-code-text\">key</code> 这个特殊的 React 属性。当 <code class=\"gatsby-code-text\">key</code> 变化时， React 会<a href=\"/docs/reconciliation.html#keys\">创建一个新的而不是更新一个既有的组件</a>。 Keys 一般用来渲染动态列表，但是这里也可以使用。在这个示例里，当用户输入时，我们使用 user ID 当作 key 重新创建一个新的 email input 组件：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>EmailInput</span>\n  <span class=\"token attr-name\">defaultEmail</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">.</span>email<span class=\"token punctuation\">}</span></span>\n  <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>user<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span></span>\n<span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>每次 ID 更改，都会重新创建 <code class=\"gatsby-code-text\">EmailInput</code> ，并将其状态重置为最新的 <code class=\"gatsby-code-text\">defaultEmail</code> 值。(<a href=\"https://codesandbox.io/s/6v1znlxyxn\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">点击查看这个模式的演示</a>) 使用此方法，不用为每次输入都添加 <code class=\"gatsby-code-text\">key</code>，在整个表单上添加 <code class=\"gatsby-code-text\">key</code> 更有位合理。每次 key 变化，表单里的所有组件都会用新的初始值重新创建。</p>\n<p>大部分情况下，这是处理重置 state 的最好的办法。</p>\n<blockquote>\n<p>注意</p>\n<p>这听起来很慢，但是这点的性能是可以忽略的。如果在组件树的更新上有很重的逻辑，这样反而会更快，因为省略了子组件 diff。</p>\n</blockquote>\n<h4 id=\"alternative-1-reset-uncontrolled-component-with-an-id-prop\"><a href=\"#alternative-1-reset-uncontrolled-component-with-an-id-prop\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>选项一：用 prop 的 ID 重置非受控组件 </h4>\n<p>如果某些情况下 <code class=\"gatsby-code-text\">key</code> 不起作用（可能是组件初始化的开销太大），一个麻烦但是可行的方案是在 <code class=\"gatsby-code-text\">getDerivedStateFromProps</code> 观察 <code class=\"gatsby-code-text\">userID</code> 的变化：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">EmailInput</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    email<span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>defaultEmail<span class=\"token punctuation\">,</span>\n    prevPropsUserID<span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>userID\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromProps</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 只要当前 user 变化，</span>\n    <span class=\"token comment\">// 重置所有跟 user 相关的状态。</span>\n    <span class=\"token comment\">// 这个例子中，只有 email 和 user 相关。</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">.</span>userID <span class=\"token operator\">!==</span> state<span class=\"token punctuation\">.</span>prevPropsUserID<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        prevPropsUserID<span class=\"token punctuation\">:</span> props<span class=\"token punctuation\">.</span>userID<span class=\"token punctuation\">,</span>\n        email<span class=\"token punctuation\">:</span> props<span class=\"token punctuation\">.</span>defaultEmail\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>如果你乐意，你也可以只重置一小部分 state (<a href=\"https://codesandbox.io/s/rjyvp7l3rq\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">点击查看这个模式的演示</a>)。</p>\n<blockquote>\n<p>注意</p>\n<p>上面的示例使用了 <code class=\"gatsby-code-text\">getDerivedStateFromProps</code>，用 <code class=\"gatsby-code-text\">componentWillReceiveProps</code> 也一样。</p>\n</blockquote>\n<h4 id=\"alternative-2-reset-uncontrolled-component-with-an-instance-method\"><a href=\"#alternative-2-reset-uncontrolled-component-with-an-instance-method\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>选项二：使用实例方法重置非受控组件 </h4>\n<p>更少见的情况是，即使没有合适的 <code class=\"gatsby-code-text\">key</code>，我们也想重新创建组件。一种解决方案是给一个随机值或者递增的值当作 <code class=\"gatsby-code-text\">key</code>，另外一种是用示例方法强制重置内部状态：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">EmailInput</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    email<span class=\"token punctuation\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>defaultEmail\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">resetEmailForNewUser</span><span class=\"token punctuation\">(</span>newEmail<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> email<span class=\"token punctuation\">:</span> newEmail <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>然后父级组件可以<a href=\"/docs/glossary.html#refs\">使用 <code class=\"gatsby-code-text\">ref</code> 调用这个方法</a>。(<a href=\"https://codesandbox.io/s/l70krvpykl\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">点击查看这个模式的演示</a>)。</p>\n<p>refs 在某些情况下很有用，比如这个。但通常我们建议谨慎使用。即使是做一个演示，这个命令式的方法也是非理想的，因为这会导致两次而不是一次渲染。</p>\n<hr>\n<h3 id=\"recap\"><a href=\"#recap\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>概括 </h3>\n<p>回顾一下，设计组件时，重要的是确定组件是受控组件还是非受控组件。</p>\n<p>不要直接复制（mirror） props 的值到 state 中，而是去实现一个<strong>受控</strong>的组件，然后在父组件里合并两个值。比如，不要在子组件里被动的接受 <code class=\"gatsby-code-text\">props.value</code> 并跟踪一个临时的 <code class=\"gatsby-code-text\">state.value</code>，而要在父组件里管理 <code class=\"gatsby-code-text\">state.draftValue</code> 和 <code class=\"gatsby-code-text\">state.committedValue</code>，直接控制子组件里的值。这样数据才更加明确可预测。</p>\n<p>对于<strong>不受控</strong>的组件，当你想在 prop 变化（通常是 ID ）时重置 state 的话，可以选择一下几种方式：</p>\n<ul>\n<li><strong>建议: 重置内部所有的初始 state，使用 <code class=\"gatsby-code-text\">key</code> 属性</strong></li>\n<li>选项一：仅更改某些字段，观察特殊属性的变化（比如 <code class=\"gatsby-code-text\">props.userID</code>）。</li>\n<li>选项二：使用 ref 调用实例方法。</li>\n</ul>\n<h2 id=\"what-about-memoization\"><a href=\"#what-about-memoization\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>尝试一下 memoization？ </h2>\n<p>我们上面用到了————仅在输入变化时，重新计算 <code class=\"gatsby-code-text\">render</code> 需要使用的值————这个技术叫做 <a href=\"https://en.wikipedia.org/wiki/Memoization\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">memoization</a>。</p>\n<p>把派生 state 用作 memoization 并不是什么坏事情，但是这并不是好的方法。管理派生 state 本来就很复杂，而且这种复杂度是随着需要管理的属性变得越来越庞大。比如，如果我们想在组件 state 里添加第二个派生 state，那就需要写两份跟踪变化的逻辑。</p>\n<p>这里有个示例，组件使用一个 prop ————一个列表————并在用户输入查询条件时显示匹配的项，我们可以使用派生 state 存储过滤后的列表：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Example</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    filterText<span class=\"token punctuation\">:</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// *******************************************************</span>\n  <span class=\"token comment\">// 注意：这个例子不是建议的方法。</span>\n  <span class=\"token comment\">// 下面的例子才是建议的方法。</span>\n  <span class=\"token comment\">// *******************************************************</span>\n\n  <span class=\"token keyword\">static</span> <span class=\"token function\">getDerivedStateFromProps</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 列表变化或者过滤文本变化时都重新过滤。</span>\n    <span class=\"token comment\">// 注意我们要存储 prevFilterText 和 prevPropsList 来检测变化。</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n      props<span class=\"token punctuation\">.</span>list <span class=\"token operator\">!==</span> state<span class=\"token punctuation\">.</span>prevPropsList <span class=\"token operator\">||</span>\n      state<span class=\"token punctuation\">.</span>prevFilterText <span class=\"token operator\">!==</span> state<span class=\"token punctuation\">.</span>filterText\n    <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        prevPropsList<span class=\"token punctuation\">:</span> props<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">,</span>\n        prevFilterText<span class=\"token punctuation\">:</span> state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">,</span>\n        filteredList<span class=\"token punctuation\">:</span> props<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>item <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function-variable function\">handleChange</span> <span class=\"token operator\">=</span> event <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> filterText<span class=\"token punctuation\">:</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Fragment</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleChange<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>filteredList<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>item <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Fragment</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这个实现避免了重复计算 <code class=\"gatsby-code-text\">filteredList</code>，但是过于复杂。因为它必须单独追踪并检测 prop 和 state 的变化，在能及时的更新过滤后的 list。我们可以使用 <code class=\"gatsby-code-text\">PureComponent</code>，把过滤操作放到 render 方法里来简化这个组件：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token comment\">// PureComponents 只会在 state 或者 prop 的值修改时才会再次渲染。</span>\n<span class=\"token comment\">// 通过对 state 和 prop 的 key 做浅比较（ shallow comparison ）来确定有没有变化。</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Example</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">PureComponent</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// state 只需要保存 filter 的值：</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    filterText<span class=\"token punctuation\">:</span> <span class=\"token string\">\"\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function-variable function\">handleChange</span> <span class=\"token operator\">=</span> event <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> filterText<span class=\"token punctuation\">:</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// PureComponent 的 render 只有</span>\n    <span class=\"token comment\">// 在 props.list 或 state.filterText 变化时才会调用</span>\n    <span class=\"token keyword\">const</span> filteredList <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>\n      item <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Fragment</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleChange<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>filteredList<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>item <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Fragment</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面的方法比派生 state 版本更加清晰明了。只有在过滤很大的列表时，这样做的效率不是很好。当有 prop 改变时 <code class=\"gatsby-code-text\">PureComponent</code> 不会阻止再次渲染。为了解决这两个问题，我们可以添加 memoization 帮助函数来阻止非必要的过滤：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"gatsby-code-jsx\"><code class=\"gatsby-code-jsx\"><span class=\"token keyword\">import</span> memoize <span class=\"token keyword\">from</span> <span class=\"token string\">\"memoize-one\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Example</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// state 只需要保存当前的 filter 值：</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> filterText<span class=\"token punctuation\">:</span> <span class=\"token string\">\"\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 在 list 或者 filter 变化时，重新运行 filter：</span>\n  filter <span class=\"token operator\">=</span> <span class=\"token function\">memoize</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">,</span> filterText<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> list<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>item <span class=\"token operator\">=></span> item<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span>filterText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function-variable function\">handleChange</span> <span class=\"token operator\">=</span> event <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> filterText<span class=\"token punctuation\">:</span> event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 计算最新的过滤后的 list。</span>\n    <span class=\"token comment\">// 如果和上次 render 参数一样，`memoize-one` 会重复使用上一次的值。</span>\n    <span class=\"token keyword\">const</span> filteredList <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Fragment</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">onChange</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handleChange<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">value</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>filterText<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>filteredList<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>item <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Fragment</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这样更简单，而且和派生 state 版本一样好！</p>\n<p>在使用 memoization 时，请记住这些约束：</p>\n<ol>\n<li>大部分情况下， <strong>每个组件内部都要引入 memoized 方法</strong>，已免实例之间相互影响。</li>\n<li>一般情况下，我们会<strong>限制 memoization 帮助函数的缓存空间</strong>，以免内存泄漏。（上面的例子中，使用 <code class=\"gatsby-code-text\">memoize-one</code> 只缓存最后一次的参数和结果）。</li>\n<li>如果每次父组件都传入新的 <code class=\"gatsby-code-text\">props.list</code> ，那本文提到的问题都不会遇到。在大多数情况下，这种方式是可取的。</li>\n</ol>\n<h2 id=\"in-closing\"><a href=\"#in-closing\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>结束语 </h2>\n<p>在实际应用中，组件一般都会有受控组件和非受控组件。这是正常的！不过如果每个值都有明确的来源，就可以避免上面提到的反面模式。</p>\n<p><code class=\"gatsby-code-text\">getDerivedStateFromProps</code> （以及其他派生 state）是一个高级复杂的功能，应该保守使用，这个再怎么重申也不过分。如果你的用法不属于上述这些模式，请在 <a href=\"https://github.com/reactjs/reactjs.org/issues/new\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub</a> 或 <a href=\"https://twitter.com/reactjs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Twitter</a> 与我们分享！</p>\n<hr>\n<p><strong>译注：</strong></p>\n<p><a name=\"note1\"></a> [1] 反面模式是 anti-patterns 的翻译，参考<a href=\"https://zh.wikipedia.org/zh-cn/%E5%8F%8D%E9%9D%A2%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"> wiki 页面</a>。</p>","excerpt":"React 16.4 版本修复了一个  getDerivedStateFromProps 的 bug ，这个 bug 会在 React components 复现一些已知的 bug。如果这个版本导致出现的问题，导致您在修复过之后还已知出现的话，我们非常抱歉。在这篇文章里，我们会展示一些常见的反面模式，和相对应的，我们推荐的模式。 在很长一段时间内，生命周期函数   是响应 Props 变化之后进行更新的唯一方式。16.3 版本里,  我们介绍了一个替代版的生命周期函数：  ，尝试用一个更安全的方式达到同样的目的。与此同时，我们意识到人们对如何使用这两种方法存在许多误解，并且我们发现反模式会导致细微而混乱的错误。16.4 版本修复的这个 bug，  让派生 state 更加可控 ，会让滥用导致的 bug 更容易被发现。 注意 下面所有的反面模式中，  和   都是通用的。  这篇blog包含以下主题： 什么时候使用派生 state  派生 state 的常见 bug 反面模式  [1] ：直接复制 props 到 state 上 反面模式：在 props 变化后修改 state…","frontmatter":{"title":"你可能不需要使用派生 state","next":null,"prev":null,"author":[{"frontmatter":{"name":"Brian Vaughn","url":"https://github.com/bvaughn"}}]},"fields":{"date":"June 07, 2018","path":"content/blog/2018-06-07-you-probably-dont-need-derived-state.md","slug":"/blog/2018/06/07/you-probably-dont-need-derived-state.html"}},"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"title":"Building Great User Experiences with Concurrent Mode and Suspense"},"fields":{"slug":"/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html"}}},{"node":{"frontmatter":{"title":"使用 React 预发布版为新功能打基础"},"fields":{"slug":"/blog/2019/10/22/react-release-channels.html"}}},{"node":{"frontmatter":{"title":"全新的 React DevTools 简介"},"fields":{"slug":"/blog/2019/08/15/new-react-devtools.html"}}},{"node":{"frontmatter":{"title":"React v16.9.0 发布及 Roadmap 最新进展"},"fields":{"slug":"/blog/2019/08/08/react-v16.9.0.html"}}},{"node":{"frontmatter":{"title":"Is React Translated Yet? ¡Sí! Sim! はい！"},"fields":{"slug":"/blog/2019/02/23/is-react-translated-yet.html"}}},{"node":{"frontmatter":{"title":"React v16.8：Hook 发布"},"fields":{"slug":"/blog/2019/02/06/react-v16.8.0.html"}}},{"node":{"frontmatter":{"title":"React v16.7: No, This Is Not the One With Hooks"},"fields":{"slug":"/blog/2018/12/19/react-v-16-7.html"}}},{"node":{"frontmatter":{"title":"React 16.x Roadmap"},"fields":{"slug":"/blog/2018/11/27/react-16-roadmap.html"}}},{"node":{"frontmatter":{"title":"React Conf 会议纪要：Hook，Suspense 和 Concurrent Rendering"},"fields":{"slug":"/blog/2018/11/13/react-conf-recap.html"}}},{"node":{"frontmatter":{"title":"React v16.6.0: lazy, memo and contextType"},"fields":{"slug":"/blog/2018/10/23/react-v-16-6.html"}}}]}},"pageContext":{"slug":"/blog/2018/06/07/you-probably-dont-need-derived-state.html"}}